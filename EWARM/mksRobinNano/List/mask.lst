###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\mask.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\mask.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\mask.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\mask.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\mask.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Masking.
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * This library is free software; you can redistribute it and/or
      8           * modify it under the terms of the GNU Lesser General Public
      9           * License as published by the Free Software Foundation; either
     10           * version 2.1 of the License, or any later version.
     11           *
     12           * This library is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     15           * Lesser General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU Lesser General Public
     18           * License along with this library; if not, write to the Free Software
     19           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     20           */
     21          
     22          #if HAVE_CONFIG_H
     23          # include "config.h"
     24          #endif
     25          #include <stdlib.h>
     26          #include <string.h>
     27          #include <limits.h>
     28          #include <errno.h>
     29          
     30          #include "qrencode.h"
     31          #include "qrspec.h"
     32          #include "mask.h"
     33          

   \                                 In section .text, align 2, keep-with-next
     34          static int Mask_writeFormatInformation(int width, unsigned char *frame, int mask, QRecLevel level)
     35          {
   \                     Mask_writeFormatInformation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4610             MOV      R0,R2
   \   00000008   0x4619             MOV      R1,R3
     36          	unsigned int format;
     37          	unsigned char v;
     38          	int i;
     39          	int blacks = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
     40          
     41          	format = QRspec_getFormatInfo(mask, level);
   \   0000000C   0x.... 0x....      BL       QRspec_getFormatInfo
     42          
     43          	for(i=0; i<8; i++) {
   \   00000010   0x4632             MOV      R2,R6
   \   00000012   0xE004             B.N      ??Mask_writeFormatInformation_0
     44          		if(format & 1) {
     45          			blacks += 2;
     46          			v = 0x85;
     47          		} else {
     48          			v = 0x84;
     49          		}
     50          		frame[width * 8 + width - 1 - i] = v;
     51          		if(i < 6) {
     52          			frame[width * i + 8] = v;
     53          		} else {
     54          			frame[width * (i + 1) + 8] = v;
   \                     ??Mask_writeFormatInformation_1: (+1)
   \   00000014   0xFB03 0x5204      MLA      R2,R3,R4,R5
   \   00000018   0x7211             STRB     R1,[R2, #+8]
     55          		}
     56          		format= format >> 1;
   \                     ??Mask_writeFormatInformation_2: (+1)
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x461A             MOV      R2,R3
   \                     ??Mask_writeFormatInformation_0: (+1)
   \   0000001E   0x2A08             CMP      R2,#+8
   \   00000020   0xDA11             BGE.N    ??Mask_writeFormatInformation_3
   \   00000022   0x07C1             LSLS     R1,R0,#+31
   \   00000024   0xD502             BPL.N    ??Mask_writeFormatInformation_4
   \   00000026   0x1CB6             ADDS     R6,R6,#+2
   \   00000028   0x2185             MOVS     R1,#+133
   \   0000002A   0xE000             B.N      ??Mask_writeFormatInformation_5
   \                     ??Mask_writeFormatInformation_4: (+1)
   \   0000002C   0x2184             MOVS     R1,#+132
   \                     ??Mask_writeFormatInformation_5: (+1)
   \   0000002E   0xEB04 0x03C4      ADD      R3,R4,R4, LSL #+3
   \   00000032   0x1E5B             SUBS     R3,R3,#+1
   \   00000034   0x1A9B             SUBS     R3,R3,R2
   \   00000036   0x5559             STRB     R1,[R3, R5]
   \   00000038   0x1C53             ADDS     R3,R2,#+1
   \   0000003A   0x2A06             CMP      R2,#+6
   \   0000003C   0xDAEA             BGE.N    ??Mask_writeFormatInformation_1
   \   0000003E   0xFB02 0x5204      MLA      R2,R2,R4,R5
   \   00000042   0x7211             STRB     R1,[R2, #+8]
   \   00000044   0xE7E9             B.N      ??Mask_writeFormatInformation_2
     57          	}
     58          	for(i=0; i<7; i++) {
   \                     ??Mask_writeFormatInformation_3: (+1)
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0xE005             B.N      ??Mask_writeFormatInformation_6
     59          		if(format & 1) {
     60          			blacks += 2;
     61          			v = 0x85;
     62          		} else {
     63          			v = 0x84;
     64          		}
     65          		frame[width * (width - 7 + i) + 8] = v;
     66          		if(i == 0) {
     67          			frame[width * 8 + 7] = v;
     68          		} else {
     69          			frame[width * 8 + 6 - i] = v;
   \                     ??Mask_writeFormatInformation_7: (+1)
   \   0000004A   0x00E3             LSLS     R3,R4,#+3
   \   0000004C   0x1D9B             ADDS     R3,R3,#+6
   \   0000004E   0x1A9B             SUBS     R3,R3,R2
   \   00000050   0x5559             STRB     R1,[R3, R5]
     70          		}
     71          		format= format >> 1;
   \                     ??Mask_writeFormatInformation_8: (+1)
   \   00000052   0x0840             LSRS     R0,R0,#+1
   \   00000054   0x1C52             ADDS     R2,R2,#+1
   \                     ??Mask_writeFormatInformation_6: (+1)
   \   00000056   0x2A07             CMP      R2,#+7
   \   00000058   0xDA10             BGE.N    ??Mask_writeFormatInformation_9
   \   0000005A   0x07C1             LSLS     R1,R0,#+31
   \   0000005C   0xD502             BPL.N    ??Mask_writeFormatInformation_10
   \   0000005E   0x1CB6             ADDS     R6,R6,#+2
   \   00000060   0x2185             MOVS     R1,#+133
   \   00000062   0xE000             B.N      ??Mask_writeFormatInformation_11
   \                     ??Mask_writeFormatInformation_10: (+1)
   \   00000064   0x2184             MOVS     R1,#+132
   \                     ??Mask_writeFormatInformation_11: (+1)
   \   00000066   0x1913             ADDS     R3,R2,R4
   \   00000068   0x1FDB             SUBS     R3,R3,#+7
   \   0000006A   0xFB03 0x5304      MLA      R3,R3,R4,R5
   \   0000006E   0x7219             STRB     R1,[R3, #+8]
   \   00000070   0x2A00             CMP      R2,#+0
   \   00000072   0xD1EA             BNE.N    ??Mask_writeFormatInformation_7
   \   00000074   0xEB05 0x03C4      ADD      R3,R5,R4, LSL #+3
   \   00000078   0x71D9             STRB     R1,[R3, #+7]
   \   0000007A   0xE7EA             B.N      ??Mask_writeFormatInformation_8
     72          	}
     73          
     74          	return blacks;
   \                     ??Mask_writeFormatInformation_9: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
     75          }
     76          
     77          /**
     78           * Demerit coefficients.
     79           * See Section 8.8.2, pp.45, JIS X0510:2004.
     80           */
     81          #define N1 (3)
     82          #define N2 (3)
     83          #define N3 (40)
     84          #define N4 (10)
     85          
     86          #define MASKMAKER(__exp__) \
     87          	int x, y;\
     88          	int b = 0;\
     89          \
     90          	for(y=0; y<width; y++) {\
     91          		for(x=0; x<width; x++) {\
     92          			if(*s & 0x80) {\
     93          				*d = *s;\
     94          			} else {\
     95          				*d = *s ^ ((__exp__) == 0);\
     96          			}\
     97          			b += (int)(*d & 1);\
     98          			s++; d++;\
     99          		}\
    100          	}\
    101          	return b;
    102          

   \                                 In section .text, align 2, keep-with-next
    103          static int Mask_mask0(int width, const unsigned char *s, unsigned char *d)
    104          {
   \                     Mask_mask0: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x4603             MOV      R3,R0
    105          	MASKMAKER((x+y)&1)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xE000             B.N      ??Mask_mask0_0
   \                     ??Mask_mask0_1: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask0_0: (+1)
   \   0000000C   0x429C             CMP      R4,R3
   \   0000000E   0xDA16             BGE.N    ??Mask_mask0_2
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0xE00D             B.N      ??Mask_mask0_3
   \                     ??Mask_mask0_4: (+1)
   \   00000014   0x1967             ADDS     R7,R4,R5
   \   00000016   0xF007 0x0701      AND      R7,R7,#0x1
   \   0000001A   0xF087 0x0701      EOR      R7,R7,#0x1
   \   0000001E   0x407E             EORS     R6,R7,R6
   \   00000020   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask0_5: (+1)
   \   00000022   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000026   0xF006 0x0601      AND      R6,R6,#0x1
   \   0000002A   0x1830             ADDS     R0,R6,R0
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask0_3: (+1)
   \   00000030   0x429D             CMP      R5,R3
   \   00000032   0xDAEA             BGE.N    ??Mask_mask0_1
   \   00000034   0x780E             LDRB     R6,[R1, #+0]
   \   00000036   0x0637             LSLS     R7,R6,#+24
   \   00000038   0xD5EC             BPL.N    ??Mask_mask0_4
   \   0000003A   0x7016             STRB     R6,[R2, #+0]
   \   0000003C   0xE7F1             B.N      ??Mask_mask0_5
   \                     ??Mask_mask0_2: (+1)
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return
    106          }
    107          

   \                                 In section .text, align 2, keep-with-next
    108          static int Mask_mask1(int width, const unsigned char *s, unsigned char *d)
    109          {
   \                     Mask_mask1: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    110          	MASKMAKER(y&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xE000             B.N      ??Mask_mask1_0
   \                     ??Mask_mask1_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask1_0: (+1)
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xDA15             BGE.N    ??Mask_mask1_2
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE00C             B.N      ??Mask_mask1_3
   \                     ??Mask_mask1_4: (+1)
   \   00000012   0xF004 0x0701      AND      R7,R4,#0x1
   \   00000016   0xF087 0x0701      EOR      R7,R7,#0x1
   \   0000001A   0x407E             EORS     R6,R7,R6
   \   0000001C   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask1_5: (+1)
   \   0000001E   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000022   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000026   0x18F3             ADDS     R3,R6,R3
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask1_3: (+1)
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xDAEB             BGE.N    ??Mask_mask1_1
   \   00000030   0x780E             LDRB     R6,[R1, #+0]
   \   00000032   0x0637             LSLS     R7,R6,#+24
   \   00000034   0xD5ED             BPL.N    ??Mask_mask1_4
   \   00000036   0x7016             STRB     R6,[R2, #+0]
   \   00000038   0xE7F1             B.N      ??Mask_mask1_5
   \                     ??Mask_mask1_2: (+1)
   \   0000003A   0x4618             MOV      R0,R3
   \   0000003C   0xBCF0             POP      {R4-R7}
   \   0000003E   0x4770             BX       LR               ;; return
    111          }
    112          

   \                                 In section .text, align 2, keep-with-next
    113          static int Mask_mask2(int width, const unsigned char *s, unsigned char *d)
    114          {
   \                     Mask_mask2: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    115          	MASKMAKER(x%3)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xE000             B.N      ??Mask_mask2_0
   \                     ??Mask_mask2_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask2_0: (+1)
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xDA1A             BGE.N    ??Mask_mask2_2
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE011             B.N      ??Mask_mask2_3
   \                     ??Mask_mask2_4: (+1)
   \   00000012   0x2603             MOVS     R6,#+3
   \   00000014   0xFB95 0xF6F6      SDIV     R6,R5,R6
   \   00000018   0xEB06 0x0646      ADD      R6,R6,R6, LSL #+1
   \   0000001C   0x1BAE             SUBS     R6,R5,R6
   \   0000001E   0x1E76             SUBS     R6,R6,#+1
   \   00000020   0x41B6             SBCS     R6,R6,R6
   \   00000022   0xEA97 0x76D6      EORS     R6,R7,R6, LSR #+31
   \   00000026   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask2_5: (+1)
   \   00000028   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   0000002C   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000030   0x18F3             ADDS     R3,R6,R3
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask2_3: (+1)
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xDAE6             BGE.N    ??Mask_mask2_1
   \   0000003A   0x780F             LDRB     R7,[R1, #+0]
   \   0000003C   0x063E             LSLS     R6,R7,#+24
   \   0000003E   0xD5E8             BPL.N    ??Mask_mask2_4
   \   00000040   0x7017             STRB     R7,[R2, #+0]
   \   00000042   0xE7F1             B.N      ??Mask_mask2_5
   \                     ??Mask_mask2_2: (+1)
   \   00000044   0x4618             MOV      R0,R3
   \   00000046   0xBCF0             POP      {R4-R7}
   \   00000048   0x4770             BX       LR               ;; return
    116          }
    117          

   \                                 In section .text, align 2, keep-with-next
    118          static int Mask_mask3(int width, const unsigned char *s, unsigned char *d)
    119          {
   \                     Mask_mask3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    120          	MASKMAKER((x+y)%3)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xE000             B.N      ??Mask_mask3_0
   \                     ??Mask_mask3_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask3_0: (+1)
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xDA1D             BGE.N    ??Mask_mask3_2
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE014             B.N      ??Mask_mask3_3
   \                     ??Mask_mask3_4: (+1)
   \   00000012   0x1966             ADDS     R6,R4,R5
   \   00000014   0xF04F 0x0C03      MOV      R12,#+3
   \   00000018   0xFB96 0xFCFC      SDIV     R12,R6,R12
   \   0000001C   0xEB0C 0x0C4C      ADD      R12,R12,R12, LSL #+1
   \   00000020   0xEBA6 0x060C      SUB      R6,R6,R12
   \   00000024   0x1E76             SUBS     R6,R6,#+1
   \   00000026   0x41B6             SBCS     R6,R6,R6
   \   00000028   0xEA97 0x76D6      EORS     R6,R7,R6, LSR #+31
   \   0000002C   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask3_5: (+1)
   \   0000002E   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000032   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000036   0x18F3             ADDS     R3,R6,R3
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask3_3: (+1)
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xDAE3             BGE.N    ??Mask_mask3_1
   \   00000040   0x780F             LDRB     R7,[R1, #+0]
   \   00000042   0x063E             LSLS     R6,R7,#+24
   \   00000044   0xD5E5             BPL.N    ??Mask_mask3_4
   \   00000046   0x7017             STRB     R7,[R2, #+0]
   \   00000048   0xE7F1             B.N      ??Mask_mask3_5
   \                     ??Mask_mask3_2: (+1)
   \   0000004A   0x4618             MOV      R0,R3
   \   0000004C   0xBCF0             POP      {R4-R7}
   \   0000004E   0x4770             BX       LR               ;; return
    121          }
    122          

   \                                 In section .text, align 2, keep-with-next
    123          static int Mask_mask4(int width, const unsigned char *s, unsigned char *d)
    124          {
   \                     Mask_mask4: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    125          	MASKMAKER(((y/2)+(x/3))&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xE000             B.N      ??Mask_mask4_0
   \                     ??Mask_mask4_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask4_0: (+1)
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xDA1D             BGE.N    ??Mask_mask4_2
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE014             B.N      ??Mask_mask4_3
   \                     ??Mask_mask4_4: (+1)
   \   00000012   0xEB04 0x77D4      ADD      R7,R4,R4, LSR #+31
   \   00000016   0xF04F 0x0C03      MOV      R12,#+3
   \   0000001A   0xFB95 0xFCFC      SDIV     R12,R5,R12
   \   0000001E   0xEB0C 0x0767      ADD      R7,R12,R7, ASR #+1
   \   00000022   0xF007 0x0701      AND      R7,R7,#0x1
   \   00000026   0xF087 0x0701      EOR      R7,R7,#0x1
   \   0000002A   0x407E             EORS     R6,R7,R6
   \   0000002C   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask4_5: (+1)
   \   0000002E   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000032   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000036   0x18F3             ADDS     R3,R6,R3
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask4_3: (+1)
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xDAE3             BGE.N    ??Mask_mask4_1
   \   00000040   0x780E             LDRB     R6,[R1, #+0]
   \   00000042   0x0637             LSLS     R7,R6,#+24
   \   00000044   0xD5E5             BPL.N    ??Mask_mask4_4
   \   00000046   0x7016             STRB     R6,[R2, #+0]
   \   00000048   0xE7F1             B.N      ??Mask_mask4_5
   \                     ??Mask_mask4_2: (+1)
   \   0000004A   0x4618             MOV      R0,R3
   \   0000004C   0xBCF0             POP      {R4-R7}
   \   0000004E   0x4770             BX       LR               ;; return
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          static int Mask_mask5(int width, const unsigned char *s, unsigned char *d)
    129          {
   \                     Mask_mask5: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    130          	MASKMAKER(((x*y)&1)+(x*y)%3)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xE000             B.N      ??Mask_mask5_0
   \                     ??Mask_mask5_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask5_0: (+1)
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xDA21             BGE.N    ??Mask_mask5_2
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE018             B.N      ??Mask_mask5_3
   \                     ??Mask_mask5_4: (+1)
   \   00000012   0xFB04 0xF705      MUL      R7,R4,R5
   \   00000016   0xF007 0x0C01      AND      R12,R7,#0x1
   \   0000001A   0x44BC             ADD      R12,R7,R12
   \   0000001C   0xF04F 0x0E03      MOV      LR,#+3
   \   00000020   0xFB97 0xF7FE      SDIV     R7,R7,LR
   \   00000024   0xEB07 0x0747      ADD      R7,R7,R7, LSL #+1
   \   00000028   0xEBAC 0x0707      SUB      R7,R12,R7
   \   0000002C   0x1E7F             SUBS     R7,R7,#+1
   \   0000002E   0x41BF             SBCS     R7,R7,R7
   \   00000030   0xEA96 0x76D7      EORS     R6,R6,R7, LSR #+31
   \   00000034   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask5_5: (+1)
   \   00000036   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   0000003A   0xF006 0x0601      AND      R6,R6,#0x1
   \   0000003E   0x18F3             ADDS     R3,R6,R3
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask5_3: (+1)
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xDADF             BGE.N    ??Mask_mask5_1
   \   00000048   0x780E             LDRB     R6,[R1, #+0]
   \   0000004A   0x0637             LSLS     R7,R6,#+24
   \   0000004C   0xD5E1             BPL.N    ??Mask_mask5_4
   \   0000004E   0x7016             STRB     R6,[R2, #+0]
   \   00000050   0xE7F1             B.N      ??Mask_mask5_5
   \                     ??Mask_mask5_2: (+1)
   \   00000052   0x4618             MOV      R0,R3
   \   00000054   0xBDF0             POP      {R4-R7,PC}       ;; return
    131          }
    132          

   \                                 In section .text, align 2, keep-with-next
    133          static int Mask_mask6(int width, const unsigned char *s, unsigned char *d)
    134          {
   \                     Mask_mask6: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    135          	MASKMAKER((((x*y)&1)+(x*y)%3)&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xF06F 0x0C02      MVN      R12,#+2
   \   0000000A   0xE000             B.N      ??Mask_mask6_0
   \                     ??Mask_mask6_1: (+1)
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask6_0: (+1)
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xDA19             BGE.N    ??Mask_mask6_2
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0xE010             B.N      ??Mask_mask6_3
   \                     ??Mask_mask6_4: (+1)
   \   00000016   0xFB04 0xF705      MUL      R7,R4,R5
   \   0000001A   0xFB97 0xF7FC      SDIV     R7,R7,R12
   \   0000001E   0xF007 0x0701      AND      R7,R7,#0x1
   \   00000022   0xF087 0x0701      EOR      R7,R7,#0x1
   \   00000026   0x407E             EORS     R6,R7,R6
   \   00000028   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask6_5: (+1)
   \   0000002A   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   0000002E   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000032   0x18F3             ADDS     R3,R6,R3
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask6_3: (+1)
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xDAE7             BGE.N    ??Mask_mask6_1
   \   0000003C   0x780E             LDRB     R6,[R1, #+0]
   \   0000003E   0x0637             LSLS     R7,R6,#+24
   \   00000040   0xD5E9             BPL.N    ??Mask_mask6_4
   \   00000042   0x7016             STRB     R6,[R2, #+0]
   \   00000044   0xE7F1             B.N      ??Mask_mask6_5
   \                     ??Mask_mask6_2: (+1)
   \   00000046   0x4618             MOV      R0,R3
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          static int Mask_mask7(int width, const unsigned char *s, unsigned char *d)
    139          {
   \                     Mask_mask7: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    140          	MASKMAKER((((x*y)%3)+((x+y)&1))&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0xE000             B.N      ??Mask_mask7_0
   \                     ??Mask_mask7_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask7_0: (+1)
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xDA1F             BGE.N    ??Mask_mask7_2
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE016             B.N      ??Mask_mask7_3
   \                     ??Mask_mask7_4: (+1)
   \   00000012   0xFB04 0xF705      MUL      R7,R4,R5
   \   00000016   0xF04F 0x0C03      MOV      R12,#+3
   \   0000001A   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   0000001E   0xEBA7 0x070C      SUB      R7,R7,R12
   \   00000022   0x19EF             ADDS     R7,R5,R7
   \   00000024   0x19E7             ADDS     R7,R4,R7
   \   00000026   0xF007 0x0701      AND      R7,R7,#0x1
   \   0000002A   0xF087 0x0701      EOR      R7,R7,#0x1
   \   0000002E   0x407E             EORS     R6,R7,R6
   \   00000030   0x7016             STRB     R6,[R2, #+0]
   \                     ??Mask_mask7_5: (+1)
   \   00000032   0xF812 0x6B01      LDRB     R6,[R2], #+1
   \   00000036   0xF006 0x0601      AND      R6,R6,#0x1
   \   0000003A   0x18F3             ADDS     R3,R6,R3
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_mask7_3: (+1)
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xDAE1             BGE.N    ??Mask_mask7_1
   \   00000044   0x780E             LDRB     R6,[R1, #+0]
   \   00000046   0x0637             LSLS     R7,R6,#+24
   \   00000048   0xD5E3             BPL.N    ??Mask_mask7_4
   \   0000004A   0x7016             STRB     R6,[R2, #+0]
   \   0000004C   0xE7F1             B.N      ??Mask_mask7_5
   \                     ??Mask_mask7_2: (+1)
   \   0000004E   0x4618             MOV      R0,R3
   \   00000050   0xBCF0             POP      {R4-R7}
   \   00000052   0x4770             BX       LR               ;; return
    141          }
    142          
    143          #define maskNum (8)
    144          typedef int MaskMaker(int, const unsigned char *, unsigned char *);

   \                                 In section .data, align 4
    145          static MaskMaker *maskMakers[maskNum] = {
   \                     maskMakers:
   \   00000000   0x........         DC32 Mask_mask0, Mask_mask1, Mask_mask2, Mask_mask3, Mask_mask4
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 Mask_mask5, Mask_mask6, Mask_mask7
   \              0x........   
   \              0x........   
    146          	Mask_mask0, Mask_mask1, Mask_mask2, Mask_mask3,
    147          	Mask_mask4, Mask_mask5, Mask_mask6, Mask_mask7
    148          };
    149          
    150          #ifdef WITH_TESTS
    151          unsigned char *Mask_makeMaskedFrame(int width, unsigned char *frame, int mask)
    152          {
    153          	unsigned char *masked;
    154          
    155          	masked = (unsigned char *)malloc(width * width);
    156          	if(masked == NULL) return NULL;
    157          
    158          	maskMakers[mask](width, frame, masked);
    159          
    160          	return masked;
    161          }
    162          #endif
    163          

   \                                 In section .text, align 2, keep-with-next
    164          unsigned char *Mask_makeMask(int width, unsigned char *frame, int mask, QRecLevel level)
    165          {
   \                     Mask_makeMask: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    166          	unsigned char *masked;
    167          
    168          	if(mask < 0 || mask >= maskNum) {
   \   0000000C   0x2E08             CMP      R6,#+8
   \   0000000E   0xD306             BCC.N    ??Mask_makeMask_0
    169          		errno = EINVAL;
   \   00000010   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    170          		return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE017             B.N      ??Mask_makeMask_1
    171          	}
    172          
    173          	masked = (unsigned char *)malloc(width * width);
   \                     ??Mask_makeMask_0: (+1)
   \   0000001E   0xFB04 0xF004      MUL      R0,R4,R4
   \   00000022   0x.... 0x....      BL       malloc
   \   00000026   0x4680             MOV      R8,R0
    174          	if(masked == NULL) return NULL;
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD101             BNE.N    ??Mask_makeMask_2
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE00D             B.N      ??Mask_makeMask_1
    175          
    176          	maskMakers[mask](width, frame, masked);
   \                     ??Mask_makeMask_2: (+1)
   \   00000032   0x4642             MOV      R2,R8
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x....             LDR.N    R3,??DataTable1
   \   0000003A   0xF853 0x3026      LDR      R3,[R3, R6, LSL #+2]
   \   0000003E   0x4798             BLX      R3
    177          	Mask_writeFormatInformation(width, masked, mask, level);
   \   00000040   0x463B             MOV      R3,R7
   \   00000042   0x4632             MOV      R2,R6
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       Mask_writeFormatInformation
    178          
    179          	return masked;
   \   0000004C   0x4640             MOV      R0,R8
   \                     ??Mask_makeMask_1: (+1)
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    180          }
    181          
    182          
    183          //static int n1;
    184          //static int n2;
    185          //static int n3;
    186          //static int n4;
    187          

   \                                 In section .text, align 2, keep-with-next
    188          static int Mask_calcN1N3(int length, int *runLength)
    189          {
   \                     Mask_calcN1N3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    190          	int i;
    191          	int demerit = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    192          	int fact;
    193          
    194          	for(i=0; i<length; i++) {
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xE034             B.N      ??Mask_calcN1N3_0
    195          		if(runLength[i] >= 5) {
   \                     ??Mask_calcN1N3_1: (+1)
   \   00000008   0xF851 0x5023      LDR      R5,[R1, R3, LSL #+2]
   \   0000000C   0x2D05             CMP      R5,#+5
   \   0000000E   0xDB01             BLT.N    ??Mask_calcN1N3_2
    196          			demerit += N1 + (runLength[i] - 5);
   \   00000010   0x1EAC             SUBS     R4,R5,#+2
   \   00000012   0x18A2             ADDS     R2,R4,R2
    197          			//n1 += N1 + (runLength[i] - 5);
    198          		}
    199          		if((i & 1)) {
   \                     ??Mask_calcN1N3_2: (+1)
   \   00000014   0x07DC             LSLS     R4,R3,#+31
   \   00000016   0xD52B             BPL.N    ??Mask_calcN1N3_3
    200          			if(i >= 3 && i < length-2 && (runLength[i] % 3) == 0) {
   \   00000018   0x2B03             CMP      R3,#+3
   \   0000001A   0xDB29             BLT.N    ??Mask_calcN1N3_3
   \   0000001C   0x1E84             SUBS     R4,R0,#+2
   \   0000001E   0x42A3             CMP      R3,R4
   \   00000020   0xDA26             BGE.N    ??Mask_calcN1N3_3
   \   00000022   0x2403             MOVS     R4,#+3
   \   00000024   0xFB95 0xF4F4      SDIV     R4,R5,R4
   \   00000028   0xEB04 0x0644      ADD      R6,R4,R4, LSL #+1
   \   0000002C   0x1BAD             SUBS     R5,R5,R6
   \   0000002E   0xD11F             BNE.N    ??Mask_calcN1N3_3
    201          				fact = runLength[i] / 3;
    202          				if(runLength[i-2] == fact &&
    203          				   runLength[i-1] == fact &&
    204          				   runLength[i+1] == fact &&
    205          				   runLength[i+2] == fact) {
   \   00000030   0xEB01 0x0583      ADD      R5,R1,R3, LSL #+2
   \   00000034   0xF1A5 0x060C      SUB      R6,R5,#+12
   \   00000038   0x6877             LDR      R7,[R6, #+4]
   \   0000003A   0x42A7             CMP      R7,R4
   \   0000003C   0xD118             BNE.N    ??Mask_calcN1N3_3
   \   0000003E   0x68B6             LDR      R6,[R6, #+8]
   \   00000040   0x42A6             CMP      R6,R4
   \   00000042   0xD115             BNE.N    ??Mask_calcN1N3_3
   \   00000044   0x686E             LDR      R6,[R5, #+4]
   \   00000046   0x42A6             CMP      R6,R4
   \   00000048   0xD112             BNE.N    ??Mask_calcN1N3_3
   \   0000004A   0x1D2E             ADDS     R6,R5,#+4
   \   0000004C   0x6877             LDR      R7,[R6, #+4]
   \   0000004E   0x42A7             CMP      R7,R4
   \   00000050   0xD10E             BNE.N    ??Mask_calcN1N3_3
    206          					if(i == 3 || runLength[i-3] >= 4 * fact) {
   \   00000052   0x2B03             CMP      R3,#+3
   \   00000054   0xD00B             BEQ.N    ??Mask_calcN1N3_4
   \   00000056   0xF855 0x5C0C      LDR      R5,[R5, #-12]
   \   0000005A   0xEBB5 0x0F84      CMP      R5,R4, LSL #+2
   \   0000005E   0xDA06             BGE.N    ??Mask_calcN1N3_4
    207          						demerit += N3;
    208          						//n3 += N3;
    209          					} else if(i+4 >= length || runLength[i+3] >= 4 * fact) {
   \   00000060   0x1D1D             ADDS     R5,R3,#+4
   \   00000062   0x4285             CMP      R5,R0
   \   00000064   0xDA03             BGE.N    ??Mask_calcN1N3_4
   \   00000066   0x68B5             LDR      R5,[R6, #+8]
   \   00000068   0xEBB5 0x0F84      CMP      R5,R4, LSL #+2
   \   0000006C   0xDB00             BLT.N    ??Mask_calcN1N3_3
    210          						demerit += N3;
   \                     ??Mask_calcN1N3_4: (+1)
   \   0000006E   0x3228             ADDS     R2,R2,#+40
    211          						//n3 += N3;
    212          					}
    213          				}
    214          			}
    215          		}
    216          	}
   \                     ??Mask_calcN1N3_3: (+1)
   \   00000070   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Mask_calcN1N3_0: (+1)
   \   00000072   0x4283             CMP      R3,R0
   \   00000074   0xDBC8             BLT.N    ??Mask_calcN1N3_1
    217          
    218          	return demerit;
   \   00000076   0x4610             MOV      R0,R2
   \   00000078   0xBCF0             POP      {R4-R7}
   \   0000007A   0x4770             BX       LR               ;; return
    219          }
    220          

   \                                 In section .text, align 2, keep-with-next
    221          static int Mask_calcN2(int width, unsigned char *frame)
    222          {
   \                     Mask_calcN2: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x460A             MOV      R2,R1
    223          	int x, y;
    224          	unsigned char *p;
    225          	unsigned char b22, w22;
    226          	int demerit = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    227          
    228          	p = frame + width + 1;
   \   00000006   0x1882             ADDS     R2,R0,R2
   \   00000008   0x1C52             ADDS     R2,R2,#+1
    229          	for(y=1; y<width; y++) {
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xE01F             B.N      ??Mask_calcN2_0
    230          		for(x=1; x<width; x++) {
    231          			b22 = p[0] & p[-1] & p[-width] & p [-width-1];
    232          			w22 = p[0] | p[-1] | p[-width] | p [-width-1];
    233          			if((b22 | (w22 ^ 1))&1) {
   \                     ??Mask_calcN2_1: (+1)
   \   0000000E   0x4246             RSBS     R6,R0,#+0
   \   00000010   0x18B5             ADDS     R5,R6,R2
   \   00000012   0xF815 0x5C01      LDRB     R5,[R5, #-1]
   \   00000016   0x5CB6             LDRB     R6,[R6, R2]
   \   00000018   0xF812 0x7C01      LDRB     R7,[R2, #-1]
   \   0000001C   0xF892 0xC000      LDRB     R12,[R2, #+0]
   \   00000020   0xEA07 0x0E0C      AND      LR,R7,R12
   \   00000024   0xEA06 0x0E0E      AND      LR,R6,LR
   \   00000028   0xEA05 0x0E0E      AND      LR,R5,LR
   \   0000002C   0xEA47 0x070C      ORR      R7,R7,R12
   \   00000030   0x433E             ORRS     R6,R6,R7
   \   00000032   0x4335             ORRS     R5,R5,R6
   \   00000034   0xF085 0x0501      EOR      R5,R5,#0x1
   \   00000038   0xEA45 0x050E      ORR      R5,R5,LR
   \   0000003C   0x07ED             LSLS     R5,R5,#+31
   \   0000003E   0xD500             BPL.N    ??Mask_calcN2_2
    234          				demerit += N2;
   \   00000040   0x1CC9             ADDS     R1,R1,#+3
    235          			}
    236          			p++;
   \                     ??Mask_calcN2_2: (+1)
   \   00000042   0x1C52             ADDS     R2,R2,#+1
    237          		}
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_calcN2_3: (+1)
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xDBE1             BLT.N    ??Mask_calcN2_1
    238          		p++;
   \   0000004A   0x1C52             ADDS     R2,R2,#+1
   \   0000004C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Mask_calcN2_0: (+1)
   \   0000004E   0x4283             CMP      R3,R0
   \   00000050   0xDA01             BGE.N    ??Mask_calcN2_4
   \   00000052   0x2401             MOVS     R4,#+1
   \   00000054   0xE7F7             B.N      ??Mask_calcN2_3
    239          	}
    240          
    241          	return demerit;
   \                     ??Mask_calcN2_4: (+1)
   \   00000056   0x4608             MOV      R0,R1
   \   00000058   0xBDF0             POP      {R4-R7,PC}       ;; return
    242          }
    243          

   \                                 In section .text, align 2, keep-with-next
    244          static int Mask_calcRunLength(int width, unsigned char *frame, int dir, int *runLength)
    245          {
   \                     Mask_calcRunLength: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    246          	int head;
    247          	int i;
    248          	unsigned char *p;
    249          	int pitch;
    250          
    251          	pitch = (dir==0)?1:width;
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??Mask_calcRunLength_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xE000             B.N      ??Mask_calcRunLength_1
   \                     ??Mask_calcRunLength_0: (+1)
   \   0000000A   0x4602             MOV      R2,R0
    252          	if(frame[0] & 1) {
   \                     ??Mask_calcRunLength_1: (+1)
   \   0000000C   0x780C             LDRB     R4,[R1, #+0]
   \   0000000E   0x07E4             LSLS     R4,R4,#+31
   \   00000010   0xD504             BPL.N    ??Mask_calcRunLength_2
    253          		runLength[0] = -1;
   \   00000012   0xF04F 0x34FF      MOV      R4,#-1
   \   00000016   0x601C             STR      R4,[R3, #+0]
    254          		head = 1;
   \   00000018   0x2401             MOVS     R4,#+1
   \   0000001A   0xE000             B.N      ??Mask_calcRunLength_3
    255          	} else {
    256          		head = 0;
   \                     ??Mask_calcRunLength_2: (+1)
   \   0000001C   0x2400             MOVS     R4,#+0
    257          	}
    258          	runLength[head] = 1;
   \                     ??Mask_calcRunLength_3: (+1)
   \   0000001E   0x2501             MOVS     R5,#+1
   \   00000020   0xF843 0x5024      STR      R5,[R3, R4, LSL #+2]
    259          	p = frame + pitch;
   \   00000024   0x1851             ADDS     R1,R2,R1
    260          
    261          	for(i=1; i<width; i++) {
   \   00000026   0xE006             B.N      ??Mask_calcRunLength_4
    262          		if((p[0] ^ p[-pitch]) & 1) {
    263          			head++;
    264          			runLength[head] = 1;
    265          		} else {
    266          			runLength[head]++;
   \                     ??Mask_calcRunLength_5: (+1)
   \   00000028   0xF853 0x6024      LDR      R6,[R3, R4, LSL #+2]
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \   0000002E   0xF843 0x6024      STR      R6,[R3, R4, LSL #+2]
    267          		}
    268          		p += pitch;
   \                     ??Mask_calcRunLength_6: (+1)
   \   00000032   0x1851             ADDS     R1,R2,R1
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mask_calcRunLength_4: (+1)
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xDA0A             BGE.N    ??Mask_calcRunLength_7
   \   0000003A   0x780E             LDRB     R6,[R1, #+0]
   \   0000003C   0x4257             RSBS     R7,R2,#+0
   \   0000003E   0x5C7F             LDRB     R7,[R7, R1]
   \   00000040   0x407E             EORS     R6,R7,R6
   \   00000042   0x07F6             LSLS     R6,R6,#+31
   \   00000044   0xD5F0             BPL.N    ??Mask_calcRunLength_5
   \   00000046   0x1C64             ADDS     R4,R4,#+1
   \   00000048   0x2601             MOVS     R6,#+1
   \   0000004A   0xF843 0x6024      STR      R6,[R3, R4, LSL #+2]
   \   0000004E   0xE7F0             B.N      ??Mask_calcRunLength_6
    269          	}
    270          
    271          	return head + 1;
   \                     ??Mask_calcRunLength_7: (+1)
   \   00000050   0x1C60             ADDS     R0,R4,#+1
   \   00000052   0xBCF0             POP      {R4-R7}
   \   00000054   0x4770             BX       LR               ;; return
    272          }
    273          

   \                                 In section .text, align 2, keep-with-next
    274          static int Mask_evaluateSymbol(int width, unsigned char *frame)
    275          {
   \                     Mask_evaluateSymbol: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xF5AD 0x7D33      SUB      SP,SP,#+716
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    276          	int x, y;
    277          	int demerit = 0;
    278          	int runLength[QRSPEC_WIDTH_MAX + 1];
    279          	int length;
    280          
    281          	demerit += Mask_calcN2(width, frame);
   \   0000000A   0x.... 0x....      BL       Mask_calcN2
   \   0000000E   0x4606             MOV      R6,R0
    282          
    283          	for(y=0; y<width; y++) {
   \   00000010   0x2700             MOVS     R7,#+0
   \   00000012   0xE00B             B.N      ??Mask_evaluateSymbol_0
    284          		length = Mask_calcRunLength(width, frame + y * width, 0, runLength);
   \                     ??Mask_evaluateSymbol_1: (+1)
   \   00000014   0xAB00             ADD      R3,SP,#+0
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xFB04 0x5107      MLA      R1,R4,R7,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       Mask_calcRunLength
    285          		demerit += Mask_calcN1N3(length, runLength);
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x.... 0x....      BL       Mask_calcN1N3
   \   00000028   0x1986             ADDS     R6,R0,R6
    286          	}
   \   0000002A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Mask_evaluateSymbol_0: (+1)
   \   0000002C   0x42A7             CMP      R7,R4
   \   0000002E   0xDBF1             BLT.N    ??Mask_evaluateSymbol_1
    287          
    288          	for(x=0; x<width; x++) {
   \   00000030   0x2700             MOVS     R7,#+0
   \   00000032   0xE00A             B.N      ??Mask_evaluateSymbol_2
    289          		length = Mask_calcRunLength(width, frame + x, 1, runLength);
   \                     ??Mask_evaluateSymbol_3: (+1)
   \   00000034   0xAB00             ADD      R3,SP,#+0
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x1979             ADDS     R1,R7,R5
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       Mask_calcRunLength
    290          		demerit += Mask_calcN1N3(length, runLength);
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x.... 0x....      BL       Mask_calcN1N3
   \   00000046   0x1986             ADDS     R6,R0,R6
    291          	}
   \   00000048   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Mask_evaluateSymbol_2: (+1)
   \   0000004A   0x42A7             CMP      R7,R4
   \   0000004C   0xDBF2             BLT.N    ??Mask_evaluateSymbol_3
    292          
    293          	return demerit;
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0xF50D 0x7D33      ADD      SP,SP,#+716
   \   00000054   0xBDF0             POP      {R4-R7,PC}       ;; return
    294          }
    295          

   \                                 In section .text, align 2, keep-with-next
    296          unsigned char *Mask_mask(int width, unsigned char *frame, QRecLevel level)
    297          {
   \                     Mask_mask: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    298          	int i;
    299          	unsigned char *mask, *bestMask;
    300          	int minDemerit = INT_MAX;
   \   0000000A   0xF06F 0x4700      MVN      R7,#-2147483648
    301          	int blacks;
    302          	int bratio;
    303          	int demerit;
    304          	int w2 = width * width;
   \   0000000E   0xFB04 0xF804      MUL      R8,R4,R4
    305          
    306          	mask = (unsigned char *)malloc(w2);
   \   00000012   0x4640             MOV      R0,R8
   \   00000014   0x.... 0x....      BL       malloc
   \   00000018   0x4681             MOV      R9,R0
    307          	if(mask == NULL) return NULL;
   \   0000001A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001E   0xD101             BNE.N    ??Mask_mask_0
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE042             B.N      ??Mask_mask_1
    308          	bestMask = NULL;
   \                     ??Mask_mask_0: (+1)
   \   00000024   0xF04F 0x0A00      MOV      R10,#+0
    309          
    310          	for(i=0; i<maskNum; i++) {
   \   00000028   0x46D3             MOV      R11,R10
   \   0000002A   0xE001             B.N      ??Mask_mask_2
   \                     ??Mask_mask_3: (+1)
   \   0000002C   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??Mask_mask_2: (+1)
   \   00000030   0xF1BB 0x0F08      CMP      R11,#+8
   \   00000034   0xDA35             BGE.N    ??Mask_mask_4
    311          //		n1 = n2 = n3 = n4 = 0;
    312          		demerit = 0;
    313          		blacks = maskMakers[i](width, frame, mask);
   \   00000036   0x464A             MOV      R2,R9
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x....             LDR.N    R3,??DataTable1
   \   0000003E   0xF853 0x302B      LDR      R3,[R3, R11, LSL #+2]
   \   00000042   0x4798             BLX      R3
    314          		blacks += Mask_writeFormatInformation(width, mask, i, level);
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x4633             MOV      R3,R6
   \   00000048   0x465A             MOV      R2,R11
   \   0000004A   0x4649             MOV      R1,R9
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       Mask_writeFormatInformation
   \   00000052   0x9900             LDR      R1,[SP, #+0]
   \   00000054   0x1840             ADDS     R0,R0,R1
    315          		bratio = (200 * blacks + w2) / w2 / 2; /* (int)(100*blacks/w2+0.5) */
    316          		demerit = (abs(bratio - 50) / 5) * N4;
   \   00000056   0x21C8             MOVS     R1,#+200
   \   00000058   0xFB01 0x8000      MLA      R0,R1,R0,R8
   \   0000005C   0xFB90 0xF0F8      SDIV     R0,R0,R8
   \   00000060   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000064   0x1040             ASRS     R0,R0,#+1
   \   00000066   0x3832             SUBS     R0,R0,#+50
   \   00000068   0x.... 0x....      BL       abs
   \   0000006C   0x2105             MOVS     R1,#+5
   \   0000006E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000072   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000076   0x0048             LSLS     R0,R1,#+1
    317          //		n4 = demerit;
    318          		demerit += Mask_evaluateSymbol(width, mask);
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0x4649             MOV      R1,R9
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       Mask_evaluateSymbol
   \   00000082   0x9900             LDR      R1,[SP, #+0]
   \   00000084   0x1840             ADDS     R0,R0,R1
    319          //		printf("(%d,%d,%d,%d)=%d\n", n1, n2, n3 ,n4, demerit);
    320          		if(demerit < minDemerit) {
   \   00000086   0x42B8             CMP      R0,R7
   \   00000088   0xDAD0             BGE.N    ??Mask_mask_3
    321          			minDemerit = demerit;
   \   0000008A   0x4607             MOV      R7,R0
    322          			free(bestMask);
   \   0000008C   0x4650             MOV      R0,R10
   \   0000008E   0x.... 0x....      BL       free
    323          			bestMask = mask;
   \   00000092   0x46CA             MOV      R10,R9
    324          			mask = (unsigned char *)malloc(w2);
   \   00000094   0x4640             MOV      R0,R8
   \   00000096   0x.... 0x....      BL       malloc
   \   0000009A   0x4681             MOV      R9,R0
    325          			if(mask == NULL) break;
   \   0000009C   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A0   0xD1C4             BNE.N    ??Mask_mask_3
    326          		}
    327          	}
    328          	free(mask);
   \                     ??Mask_mask_4: (+1)
   \   000000A2   0x4648             MOV      R0,R9
   \   000000A4   0x.... 0x....      BL       free
    329          	return bestMask;
   \   000000A8   0x4650             MOV      R0,R10
   \                     ??Mask_mask_1: (+1)
   \   000000AA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    330          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     maskMakers

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Mask_calcN1N3
      20   Mask_calcN2
      16   Mask_calcRunLength
     736   Mask_evaluateSymbol
       736   -> Mask_calcN1N3
       736   -> Mask_calcN2
       736   -> Mask_calcRunLength
      24   Mask_makeMask
        24   -- Indirect call
        24   -> Mask_writeFormatInformation
        24   -> __aeabi_errno_addr
        24   -> malloc
      40   Mask_mask
        40   -- Indirect call
        40   -> Mask_evaluateSymbol
        40   -> Mask_writeFormatInformation
        40   -> abs
        40   -> free
        40   -> malloc
      16   Mask_mask0
      16   Mask_mask1
      16   Mask_mask2
      16   Mask_mask3
      16   Mask_mask4
      20   Mask_mask5
      16   Mask_mask6
      16   Mask_mask7
      16   Mask_writeFormatInformation
        16   -> QRspec_getFormatInfo


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
     124  Mask_calcN1N3
      90  Mask_calcN2
      86  Mask_calcRunLength
      86  Mask_evaluateSymbol
      82  Mask_makeMask
     174  Mask_mask
      66  Mask_mask0
      64  Mask_mask1
      74  Mask_mask2
      80  Mask_mask3
      80  Mask_mask4
      86  Mask_mask5
      76  Mask_mask6
      84  Mask_mask7
     128  Mask_writeFormatInformation
      32  maskMakers

 
    32 bytes in section .data
 1 384 bytes in section .text
 
 1 384 bytes of CODE memory
    32 bytes of DATA memory

Errors: none
Warnings: none
