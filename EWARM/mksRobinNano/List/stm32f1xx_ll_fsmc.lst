###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:10
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_fsmc.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_fsmc.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_ll_fsmc.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_ll_fsmc.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_ll_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   FSMC Low Layer HAL module driver.
      8            *
      9            *          This file provides firmware functions to manage the following
     10            *          functionalities of the Flexible Static Memory Controller (FSMC) peripheral memories:
     11            *           + Initialization/de-initialization functions
     12            *           + Peripheral Control functions
     13            *           + Peripheral State functions
     14            *
     15            @verbatim
     16            =============================================================================
     17                                  ##### FSMC peripheral features #####
     18            =============================================================================
     19              [..] The Flexible static memory controller (FSMC) includes following memory controllers:
     20                   (+) The NOR/PSRAM memory controller
     21                   (+) The PC Card memory controller
     22                   (+) The NAND memory controller
     23                       (PC Card and NAND controllers available only on STM32F101xE, STM32F103xE, STM32F101xG and STM32F103xG)
     24          
     25              [..] The FSMC functional block makes the interface with synchronous and asynchronous static
     26                   memories and 16-bit PC memory cards. Its main purposes are:
     27                   (+) to translate AHB transactions into the appropriate external device protocol.
     28                   (+) to meet the access time requirements of the external memory devices.
     29          
     30              [..] All external memories share the addresses, data and control signals with the controller.
     31                   Each external device is accessed by means of a unique Chip Select. The FSMC performs
     32                   only one access at a time to an external device.
     33                   The main features of the FSMC controller are the following:
     34                    (+) Interface with static-memory mapped devices including:
     35                       (++) Static random access memory (SRAM).
     36                       (++) NOR Flash memory.
     37                       (++) PSRAM (4 memory banks).
     38                       (++) 16-bit PC Card compatible devices
     39                       (++) Two banks of NAND Flash memory with ECC hardware to check up to 8 Kbytes of
     40                          data
     41                    (+) Independent Chip Select control for each memory bank
     42                    (+) Independent configuration for each memory bank
     43          
     44            @endverbatim
     45            ******************************************************************************
     46            * @attention
     47            *
     48            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     49            *
     50            * Redistribution and use in source and binary forms, with or without modification,
     51            * are permitted provided that the following conditions are met:
     52            *   1. Redistributions of source code must retain the above copyright notice,
     53            *      this list of conditions and the following disclaimer.
     54            *   2. Redistributions in binary form must reproduce the above copyright notice,
     55            *      this list of conditions and the following disclaimer in the documentation
     56            *      and/or other materials provided with the distribution.
     57            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     58            *      may be used to endorse or promote products derived from this software
     59            *      without specific prior written permission.
     60            *
     61            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     62            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     63            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     64            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     65            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     66            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     67            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     68            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     69            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     70            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     71            *
     72            ******************************************************************************
     73            */
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          #include "stm32f1xx_hal.h"
     77          
     78          /** @addtogroup STM32F1xx_HAL_Driver
     79            * @{
     80            */
     81          
     82          #if defined(HAL_SRAM_MODULE_ENABLED) || defined(HAL_NOR_MODULE_ENABLED) || defined(HAL_PCCARD_MODULE_ENABLED) || defined(HAL_NAND_MODULE_ENABLED)
     83          
     84          #if defined(FSMC_BANK1)
     85          
     86          /** @defgroup FSMC_LL FSMC Low Layer
     87            * @brief FSMC driver modules
     88            * @{
     89            */
     90          
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          /** @defgroup FSMC_LL_Private_Constants FSMC Low Layer Private Constants
     94            * @{
     95            */
     96          
     97          /* ----------------------- FSMC registers bit mask --------------------------- */
     98          /* --- PCR Register ---*/
     99          /* PCR register clear mask */
    100          #define PCR_CLEAR_MASK    ((uint32_t)(FSMC_PCRx_PWAITEN | FSMC_PCRx_PBKEN  | \
    101                                                FSMC_PCRx_PTYP    | FSMC_PCRx_PWID   | \
    102                                                FSMC_PCRx_ECCEN   | FSMC_PCRx_TCLR   | \
    103                                                FSMC_PCRx_TAR     | FSMC_PCRx_ECCPS))
    104          
    105          /* --- SR Register ---*/
    106          /* SR register clear mask */
    107          #define SR_CLEAR_MASK     ((uint32_t)(FSMC_SRx_IRS | FSMC_SRx_ILS | FSMC_SRx_IFS | \
    108                                                FSMC_SRx_IREN | FSMC_SRx_ILEN | FSMC_SRx_IFEN))
    109          
    110          /* --- PMEM Register ---*/
    111          /* PMEM register clear mask */
    112          #define PMEM_CLEAR_MASK   ((uint32_t)(FSMC_PMEMx_MEMSETx  | FSMC_PMEMx_MEMWAITx |\
    113                                                FSMC_PMEMx_MEMHOLDx | FSMC_PMEMx_MEMHIZx))
    114          
    115          /* --- PATT Register ---*/
    116          /* PATT register clear mask */
    117          #define PATT_CLEAR_MASK   ((uint32_t)(FSMC_PATTx_ATTSETx  | FSMC_PATTx_ATTWAITx |\
    118                                                FSMC_PATTx_ATTHOLDx | FSMC_PATTx_ATTHIZx))
    119          
    120          /* --- BCR Register ---*/
    121          /* BCR register clear mask */
    122          #define BCR_CLEAR_MASK                 ((uint32_t)(FSMC_BCRx_FACCEN  | FSMC_BCRx_MUXEN     | \
    123                                                             FSMC_BCRx_MTYP    | FSMC_BCRx_MWID      | \
    124                                                             FSMC_BCRx_BURSTEN | FSMC_BCRx_WAITPOL   | \
    125                                                             FSMC_BCRx_WRAPMOD | FSMC_BCRx_WAITCFG   | \
    126                                                             FSMC_BCRx_WREN    | FSMC_BCRx_WAITEN    | \
    127                                                             FSMC_BCRx_EXTMOD  | FSMC_BCRx_ASYNCWAIT | \
    128                                                             FSMC_BCRx_CBURSTRW))
    129          /* --- BTR Register ---*/
    130          /* BTR register clear mask */
    131          #define BTR_CLEAR_MASK                 ((uint32_t)(FSMC_BTRx_ADDSET | FSMC_BTRx_ADDHLD  |\
    132                                                             FSMC_BTRx_DATAST | FSMC_BTRx_BUSTURN |\
    133                                                             FSMC_BTRx_CLKDIV | FSMC_BTRx_DATLAT  |\
    134                                                             FSMC_BTRx_ACCMOD))
    135          
    136          /* --- BWTR Register ---*/
    137          /* BWTR register clear mask */
    138          #if   (defined(STM32F101xE) || defined(STM32F103xE) || defined(STM32F101xG) || defined(STM32F103xG))
    139          #define BWTR_CLEAR_MASK                ((uint32_t)(FSMC_BWTRx_ADDSET | FSMC_BWTRx_ADDHLD | \
    140                                                             FSMC_BWTRx_DATAST | FSMC_BWTRx_ACCMOD | \
    141                                                             FSMC_BWTRx_BUSTURN))
    142          #else
    143          #define BWTR_CLEAR_MASK                ((uint32_t)(FSMC_BWTRx_ADDSET | FSMC_BWTRx_ADDHLD | \
    144                                                             FSMC_BWTRx_DATAST | FSMC_BWTRx_ACCMOD | \
    145                                                             FSMC_BWTRx_CLKDIV  | FSMC_BWTRx_DATLAT))
    146          #endif /* STM32F101xE || STM32F103xE || STM32F101xG || STM32F103xG */
    147          
    148          /* --- PIO4 Register ---*/
    149          /* PIO4 register clear mask */
    150          #define PIO4_CLEAR_MASK   ((uint32_t)(FSMC_PIO4_IOSET4    | FSMC_PIO4_IOWAIT4   | \
    151                                                FSMC_PIO4_IOHOLD4   | FSMC_PIO4_IOHIZ4))
    152          /**
    153            * @}
    154            */
    155          
    156          /* Private macro -------------------------------------------------------------*/
    157          /** @defgroup FSMC_LL_Private_Macros FSMC Low Layer Private Macros
    158            * @{
    159            */
    160          
    161          /**
    162            * @}
    163            */
    164          
    165          /* Private variables ---------------------------------------------------------*/
    166          /* Private function prototypes -----------------------------------------------*/
    167          /* Exported functions --------------------------------------------------------*/
    168          
    169          /** @defgroup FSMC_LL_Exported_Functions FSMC Low Layer Exported Functions
    170            * @{
    171            */
    172          
    173          /** @defgroup FSMC_NORSRAM FSMC NORSRAM Controller functions
    174            * @brief    NORSRAM Controller functions
    175            *
    176            @verbatim
    177            ==============================================================================
    178                             ##### How to use NORSRAM device driver #####
    179            ==============================================================================
    180          
    181            [..]
    182              This driver contains a set of APIs to interface with the FSMC NORSRAM banks in order
    183              to run the NORSRAM external devices.
    184          
    185              (+) FSMC NORSRAM bank reset using the function FSMC_NORSRAM_DeInit()
    186              (+) FSMC NORSRAM bank control configuration using the function FSMC_NORSRAM_Init()
    187              (+) FSMC NORSRAM bank timing configuration using the function FSMC_NORSRAM_Timing_Init()
    188              (+) FSMC NORSRAM bank extended timing configuration using the function
    189                  FSMC_NORSRAM_Extended_Timing_Init()
    190              (+) FSMC NORSRAM bank enable/disable write operation using the functions
    191                  FSMC_NORSRAM_WriteOperation_Enable()/FSMC_NORSRAM_WriteOperation_Disable()
    192          
    193          
    194          @endverbatim
    195            * @{
    196            */
    197          
    198          /** @defgroup FSMC_NORSRAM_Group1 Initialization/de-initialization functions
    199            * @brief    Initialization and Configuration functions
    200            *
    201            @verbatim
    202            ==============================================================================
    203                        ##### Initialization and de_initialization functions #####
    204            ==============================================================================
    205            [..]
    206              This section provides functions allowing to:
    207              (+) Initialize and configure the FSMC NORSRAM interface
    208              (+) De-initialize the FSMC NORSRAM interface
    209              (+) Configure the FSMC clock and associated GPIOs
    210          
    211          @endverbatim
    212            * @{
    213            */
    214          
    215          /**
    216            * @brief  Initialize the FSMC_NORSRAM device according to the specified
    217            *         control parameters in the FSMC_NORSRAM_InitTypeDef
    218            * @param  Device: Pointer to NORSRAM device instance
    219            * @param  Init: Pointer to NORSRAM Initialization structure
    220            * @retval HAL status
    221            */

   \                                 In section .text, align 2, keep-with-next
    222          HAL_StatusTypeDef  FSMC_NORSRAM_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_InitTypeDef *Init)
    223          {
   \                     FSMC_NORSRAM_Init: (+1)
   \   00000000   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
    224            /* Check the parameters */
    225            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    226            assert_param(IS_FSMC_NORSRAM_BANK(Init->NSBank));
    227            assert_param(IS_FSMC_MUX(Init->DataAddressMux));
    228            assert_param(IS_FSMC_MEMORY(Init->MemoryType));
    229            assert_param(IS_FSMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
    230            assert_param(IS_FSMC_BURSTMODE(Init->BurstAccessMode));
    231            assert_param(IS_FSMC_WAIT_POLARITY(Init->WaitSignalPolarity));
    232            assert_param(IS_FSMC_WRAP_MODE(Init->WrapMode));
    233            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
    234            assert_param(IS_FSMC_WRITE_OPERATION(Init->WriteOperation));
    235            assert_param(IS_FSMC_WAITE_SIGNAL(Init->WaitSignal));
    236            assert_param(IS_FSMC_EXTENDED_MODE(Init->ExtendedMode));
    237            assert_param(IS_FSMC_ASYNWAIT(Init->AsynchronousWait));
    238            assert_param(IS_FSMC_WRITE_BURST(Init->WriteBurst));
    239          
    240            /* Disable NORSRAM Device */
    241            __FSMC_NORSRAM_DISABLE(Device, Init->NSBank);
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0xF850 0x3022      LDR      R3,[R0, R2, LSL #+2]
   \   0000000A   0x085B             LSRS     R3,R3,#+1
   \   0000000C   0x005B             LSLS     R3,R3,#+1
   \   0000000E   0xF840 0x3022      STR      R3,[R0, R2, LSL #+2]
    242          
    243            /* Set NORSRAM device control parameters */
    244            if (Init->MemoryType == FSMC_MEMORY_TYPE_NOR)
   \   00000012   0x6B0A             LDR      R2,[R1, #+48]
   \   00000014   0x9201             STR      R2,[SP, #+4]
   \   00000016   0x6ACA             LDR      R2,[R1, #+44]
   \   00000018   0x6A8B             LDR      R3,[R1, #+40]
   \   0000001A   0x6A4C             LDR      R4,[R1, #+36]
   \   0000001C   0x6A0D             LDR      R5,[R1, #+32]
   \   0000001E   0x69CE             LDR      R6,[R1, #+28]
   \   00000020   0x698F             LDR      R7,[R1, #+24]
   \   00000022   0xF8D1 0xE014      LDR      LR,[R1, #+20]
   \   00000026   0xF8D1 0x8010      LDR      R8,[R1, #+16]
   \   0000002A   0xF8D1 0x900C      LDR      R9,[R1, #+12]
   \   0000002E   0xF8D1 0xA004      LDR      R10,[R1, #+4]
   \   00000032   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000036   0xF8D1 0xC008      LDR      R12,[R1, #+8]
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0x.... 0x....      LDR.W    R10,??DataTable3  ;; 0xfff70081
   \   00000040   0xF1BC 0x0F08      CMP      R12,#+8
   \   00000044   0xF850 0xB021      LDR      R11,[R0, R1, LSL #+2]
   \   00000048   0xEA0A 0x0A0B      AND      R10,R10,R11
   \   0000004C   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \   00000050   0xEA4B 0x0A0A      ORR      R10,R11,R10
   \   00000054   0xEA4C 0x0C0A      ORR      R12,R12,R10
   \   00000058   0xEA49 0x0C0C      ORR      R12,R9,R12
   \   0000005C   0xEA48 0x0C0C      ORR      R12,R8,R12
   \   00000060   0xEA4E 0x0C0C      ORR      R12,LR,R12
   \   00000064   0xEA47 0x070C      ORR      R7,R7,R12
   \   00000068   0xD10B             BNE.N    ??FSMC_NORSRAM_Init_0
    245            {
    246              MODIFY_REG(Device->BTCR[Init->NSBank], BCR_CLEAR_MASK, (uint32_t)(FSMC_NORSRAM_FLASH_ACCESS_ENABLE
    247                         | Init->DataAddressMux
    248                         | Init->MemoryType
    249                         | Init->MemoryDataWidth
    250                         | Init->BurstAccessMode
    251                         | Init->WaitSignalPolarity
    252                         | Init->WrapMode
    253                         | Init->WaitSignalActive
    254                         | Init->WriteOperation
    255                         | Init->WaitSignal
    256                         | Init->ExtendedMode
    257                         | Init->AsynchronousWait
    258                         | Init->WriteBurst
    259                                                                               )
    260                        );
   \   0000006A   0x433E             ORRS     R6,R6,R7
   \   0000006C   0x4335             ORRS     R5,R5,R6
   \   0000006E   0x432C             ORRS     R4,R4,R5
   \   00000070   0x4323             ORRS     R3,R3,R4
   \   00000072   0x431A             ORRS     R2,R2,R3
   \   00000074   0x9B01             LDR      R3,[SP, #+4]
   \   00000076   0x431A             ORRS     R2,R3,R2
   \   00000078   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000007C   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \   00000080   0xE008             B.N      ??FSMC_NORSRAM_Init_1
    261            }
    262            else
    263            {
    264              MODIFY_REG(Device->BTCR[Init->NSBank], BCR_CLEAR_MASK, (uint32_t)(FSMC_NORSRAM_FLASH_ACCESS_DISABLE
    265                         | Init->DataAddressMux
    266                         | Init->MemoryType
    267                         | Init->MemoryDataWidth
    268                         | Init->BurstAccessMode
    269                         | Init->WaitSignalPolarity
    270                         | Init->WrapMode
    271                         | Init->WaitSignalActive
    272                         | Init->WriteOperation
    273                         | Init->WaitSignal
    274                         | Init->ExtendedMode
    275                         | Init->AsynchronousWait
    276                         | Init->WriteBurst
    277                                                                               )
    278                        );
   \                     ??FSMC_NORSRAM_Init_0: (+1)
   \   00000082   0x433E             ORRS     R6,R6,R7
   \   00000084   0x4335             ORRS     R5,R5,R6
   \   00000086   0x432C             ORRS     R4,R4,R5
   \   00000088   0x4323             ORRS     R3,R3,R4
   \   0000008A   0x431A             ORRS     R2,R2,R3
   \   0000008C   0x9B01             LDR      R3,[SP, #+4]
   \   0000008E   0x431A             ORRS     R2,R3,R2
   \   00000090   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    279            }
    280          
    281            return HAL_OK;
   \                     ??FSMC_NORSRAM_Init_1: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE8BD 0x8FF6      POP      {R1,R2,R4-R11,PC}  ;; return
    282          }
    283          
    284          
    285          /**
    286            * @brief  DeInitialize the FSMC_NORSRAM peripheral
    287            * @param  Device: Pointer to NORSRAM device instance
    288            * @param  ExDevice: Pointer to NORSRAM extended mode device instance
    289            * @param  Bank: NORSRAM bank number
    290            * @retval HAL status
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          HAL_StatusTypeDef FSMC_NORSRAM_DeInit(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
    293          {
    294            /* Check the parameters */
    295            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    296            assert_param(IS_FSMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
    297            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    298          
    299            /* Disable the FSMC_NORSRAM device */
    300            __FSMC_NORSRAM_DISABLE(Device, Bank);
   \                     FSMC_NORSRAM_DeInit: (+1)
   \   00000000   0xF850 0x3022      LDR      R3,[R0, R2, LSL #+2]
   \   00000004   0x085B             LSRS     R3,R3,#+1
   \   00000006   0x005B             LSLS     R3,R3,#+1
   \   00000008   0xF840 0x3022      STR      R3,[R0, R2, LSL #+2]
    301          
    302            /* De-initialize the FSMC_NORSRAM device */
    303            /* FSMC_NORSRAM_BANK1 */
    304            if (Bank == FSMC_NORSRAM_BANK1)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD103             BNE.N    ??FSMC_NORSRAM_DeInit_0
    305            {
    306              Device->BTCR[Bank] = 0x000030DB;
   \   00000010   0xF243 0x03DB      MOVW     R3,#+12507
   \   00000014   0x6003             STR      R3,[R0, #+0]
   \   00000016   0xE003             B.N      ??FSMC_NORSRAM_DeInit_1
    307            }
    308            /* FSMC_NORSRAM_BANK2, FSMC_NORSRAM_BANK3 or FSMC_NORSRAM_BANK4 */
    309            else
    310            {
    311              Device->BTCR[Bank] = 0x000030D2;
   \                     ??FSMC_NORSRAM_DeInit_0: (+1)
   \   00000018   0xF243 0x03D2      MOVW     R3,#+12498
   \   0000001C   0xF840 0x3022      STR      R3,[R0, R2, LSL #+2]
    312            }
    313          
    314            Device->BTCR[Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAM_DeInit_1: (+1)
   \   00000020   0xF06F 0x4370      MVN      R3,#-268435456
   \   00000024   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   00000028   0x6043             STR      R3,[R0, #+4]
    315            ExDevice->BWTR[Bank]   = 0x0FFFFFFF;
   \   0000002A   0xF841 0x3022      STR      R3,[R1, R2, LSL #+2]
    316          
    317            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    318          }
    319          
    320          
    321          /**
    322            * @brief  Initialize the FSMC_NORSRAM Timing according to the specified
    323            *         parameters in the FSMC_NORSRAM_TimingTypeDef
    324            * @param  Device: Pointer to NORSRAM device instance
    325            * @param  Timing: Pointer to NORSRAM Timing structure
    326            * @param  Bank: NORSRAM bank number
    327            * @retval HAL status
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          HAL_StatusTypeDef FSMC_NORSRAM_Timing_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
    330          {
   \                     FSMC_NORSRAM_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    331            /* Check the parameters */
    332            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    333            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
    334            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
    335            assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
    336            assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
    337            assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
    338            assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
    339            assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
    340            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    341          
    342            /* Set FSMC_NORSRAM device timing parameters */
    343            MODIFY_REG(Device->BTCR[Bank + 1],                                                    \
    344                       BTR_CLEAR_MASK,                                                                     \
    345                       (uint32_t)(Timing->AddressSetupTime                                               | \
    346                                  ((Timing->AddressHoldTime)        << POSITION_VAL(FSMC_BTRx_ADDHLD))        | \
    347                                  ((Timing->DataSetupTime)          << POSITION_VAL(FSMC_BTRx_DATAST))        | \
    348                                  ((Timing->BusTurnAroundDuration)  << POSITION_VAL(FSMC_BTRx_BUSTURN))       | \
    349                                  (((Timing->CLKDivision) - 1)        << POSITION_VAL(FSMC_BTRx_CLKDIV))        | \
    350                                  (((Timing->DataLatency) - 2)        << POSITION_VAL(FSMC_BTRx_DATLAT))        | \
    351                                  (Timing->AccessMode)));
   \   00000002   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   00000006   0x6842             LDR      R2,[R0, #+4]
   \   00000008   0xF002 0x4240      AND      R2,R2,#0xC0000000
   \   0000000C   0x698B             LDR      R3,[R1, #+24]
   \   0000000E   0x680C             LDR      R4,[R1, #+0]
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x684C             LDR      R4,[R1, #+4]
   \   00000014   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   00000018   0x688C             LDR      R4,[R1, #+8]
   \   0000001A   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000001E   0x68CC             LDR      R4,[R1, #+12]
   \   00000020   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000024   0x690C             LDR      R4,[R1, #+16]
   \   00000026   0x1E64             SUBS     R4,R4,#+1
   \   00000028   0xEA43 0x5304      ORR      R3,R3,R4, LSL #+20
   \   0000002C   0x6949             LDR      R1,[R1, #+20]
   \   0000002E   0x1E89             SUBS     R1,R1,#+2
   \   00000030   0xEA43 0x6101      ORR      R1,R3,R1, LSL #+24
   \   00000034   0x4311             ORRS     R1,R1,R2
   \   00000036   0x6041             STR      R1,[R0, #+4]
    352          
    353            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    354          }
    355          
    356          /**
    357            * @brief  Initialize the FSMC_NORSRAM Extended mode Timing according to the specified
    358            *         parameters in the FSMC_NORSRAM_TimingTypeDef
    359            * @param  Device: Pointer to NORSRAM device instance
    360            * @param  Timing: Pointer to NORSRAM Timing structure
    361            * @param  Bank: NORSRAM bank number
    362            * @param  ExtendedMode: FSMC Extended Mode
    363            *          This parameter can be one of the following values:
    364            *            @arg FSMC_EXTENDED_MODE_DISABLE
    365            *            @arg FSMC_EXTENDED_MODE_ENABLE
    366            * @retval HAL status
    367            */

   \                                 In section .text, align 2, keep-with-next
    368          HAL_StatusTypeDef  FSMC_NORSRAM_Extended_Timing_Init(FSMC_NORSRAM_EXTENDED_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
    369          {
   \                     FSMC_NORSRAM_Extended_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    370            /* Check the parameters */
    371            assert_param(IS_FSMC_EXTENDED_MODE(ExtendedMode));
    372          
    373            /* Set NORSRAM device timing register for write configuration, if extended mode is used */
    374            if (ExtendedMode == FSMC_EXTENDED_MODE_ENABLE)
   \   00000002   0xF5B3 0x4F80      CMP      R3,#+16384
   \   00000006   0xD113             BNE.N    ??FSMC_NORSRAM_Extended_Timing_Init_0
    375            {
    376              /* Check the parameters */
    377              assert_param(IS_FSMC_NORSRAM_EXTENDED_DEVICE(Device));
    378              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
    379              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
    380              assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
    381          #if   (defined(STM32F101xE) || defined(STM32F103xE) || defined(STM32F101xG) || defined(STM32F103xG))
    382              assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
    383          #else
    384              assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
    385              assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
    386          #endif /* STM32F101xE || STM32F103xE || STM32F101xG || STM32F103xG */
    387              assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
    388              assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    389          
    390              /* Set NORSRAM device timing register for write configuration, if extended mode is used */
    391          #if (defined(STM32F101xE) || defined(STM32F103xE) || defined(STM32F101xG) || defined(STM32F103xG))
    392              MODIFY_REG(Device->BWTR[Bank],                                                  \
    393                         BWTR_CLEAR_MASK,                                                              \
    394                         (uint32_t)(Timing->AddressSetupTime                                         | \
    395                                    ((Timing->AddressHoldTime)        << POSITION_VAL(FSMC_BWTRx_ADDHLD)) | \
    396                                    ((Timing->DataSetupTime)          << POSITION_VAL(FSMC_BWTRx_DATAST)) | \
    397                                    Timing->AccessMode                                                          | \
    398                                    ((Timing->BusTurnAroundDuration)  << POSITION_VAL(FSMC_BWTRx_BUSTURN))));
   \   00000008   0xF850 0x3022      LDR      R3,[R0, R2, LSL #+2]
   \   0000000C   0x....             LDR.N    R4,??DataTable3_1  ;; 0xcff00000
   \   0000000E   0x4023             ANDS     R3,R4,R3
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x4323             ORRS     R3,R4,R3
   \   00000014   0x684C             LDR      R4,[R1, #+4]
   \   00000016   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   0000001A   0x688C             LDR      R4,[R1, #+8]
   \   0000001C   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000020   0x698C             LDR      R4,[R1, #+24]
   \   00000022   0x4323             ORRS     R3,R4,R3
   \   00000024   0x68C9             LDR      R1,[R1, #+12]
   \   00000026   0xEA43 0x4101      ORR      R1,R3,R1, LSL #+16
   \   0000002A   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
   \   0000002E   0xE003             B.N      ??FSMC_NORSRAM_Extended_Timing_Init_1
    399          #else
    400              MODIFY_REG(Device->BWTR[Bank],                                                  \
    401                         BWTR_CLEAR_MASK,                                                              \
    402                         (uint32_t)(Timing->AddressSetupTime                                         | \
    403                                    ((Timing->AddressHoldTime)  << POSITION_VAL(FSMC_BWTRx_ADDHLD))       | \
    404                                    ((Timing->DataSetupTime)    << POSITION_VAL(FSMC_BWTRx_DATAST))       | \
    405                                    Timing->AccessMode                                                          | \
    406                                    (((Timing->CLKDivision) - 1)  << POSITION_VAL(FSMC_BTRx_CLKDIV))        | \
    407                                    (((Timing->DataLatency) - 2)  << POSITION_VAL(FSMC_BWTRx_DATLAT))));
    408          #endif /* STM32F101xE || STM32F103xE || STM32F101xG || STM32F103xG */
    409            }
    410            else
    411            {
    412              Device->BWTR[Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAM_Extended_Timing_Init_0: (+1)
   \   00000030   0xF06F 0x4170      MVN      R1,#-268435456
   \   00000034   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
    413            }
    414          
    415            return HAL_OK;
   \                     ??FSMC_NORSRAM_Extended_Timing_Init_1: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    416          }
    417          
    418          
    419          /**
    420            * @}
    421            */
    422          
    423          
    424          /** @defgroup FSMC_NORSRAM_Group2 Control functions
    425           *  @brief   management functions
    426           *
    427          @verbatim
    428            ==============================================================================
    429                                ##### FSMC_NORSRAM Control functions #####
    430            ==============================================================================
    431            [..]
    432              This subsection provides a set of functions allowing to control dynamically
    433              the FSMC NORSRAM interface.
    434          
    435          @endverbatim
    436            * @{
    437            */
    438          
    439          /**
    440            * @brief  Enables dynamically FSMC_NORSRAM write operation.
    441            * @param  Device: Pointer to NORSRAM device instance
    442            * @param  Bank: NORSRAM bank number
    443            * @retval HAL status
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Enable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
    446          {
    447            /* Check the parameters */
    448            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    449            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    450          
    451            /* Enable write operation */
    452            SET_BIT(Device->BTCR[Bank], FSMC_WRITE_OPERATION_ENABLE);
   \                     FSMC_NORSRAM_WriteOperation_Enable: (+1)
   \   00000000   0xF850 0x2021      LDR      R2,[R0, R1, LSL #+2]
   \   00000004   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000008   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    453          
    454            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    455          }
    456          
    457          /**
    458            * @brief  Disables dynamically FSMC_NORSRAM write operation.
    459            * @param  Device: Pointer to NORSRAM device instance
    460            * @param  Bank: NORSRAM bank number
    461            * @retval HAL status
    462            */

   \                                 In section .text, align 2, keep-with-next
    463          HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Disable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
    464          {
    465            /* Check the parameters */
    466            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    467            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    468          
    469            /* Disable write operation */
    470            CLEAR_BIT(Device->BTCR[Bank], FSMC_WRITE_OPERATION_ENABLE);
   \                     FSMC_NORSRAM_WriteOperation_Disable: (+1)
   \   00000000   0xF850 0x2021      LDR      R2,[R0, R1, LSL #+2]
   \   00000004   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000008   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    471          
    472            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    473          }
    474          
    475          /**
    476            * @}
    477            */
    478          
    479          /**
    480            * @}
    481            */
    482          #if (defined (STM32F101xE) || defined(STM32F103xE) || defined(STM32F101xG) || defined(STM32F103xG))
    483          /** @defgroup FSMC_NAND FSMC NAND Controller functions
    484            * @brief    NAND Controller functions
    485            *
    486            @verbatim
    487            ==============================================================================
    488                              ##### How to use NAND device driver #####
    489            ==============================================================================
    490            [..]
    491              This driver contains a set of APIs to interface with the FSMC NAND banks in order
    492              to run the NAND external devices.
    493          
    494              (+) FSMC NAND bank reset using the function FSMC_NAND_DeInit()
    495              (+) FSMC NAND bank control configuration using the function FSMC_NAND_Init()
    496              (+) FSMC NAND bank common space timing configuration using the function
    497                  FSMC_NAND_CommonSpace_Timing_Init()
    498              (+) FSMC NAND bank attribute space timing configuration using the function
    499                  FSMC_NAND_AttributeSpace_Timing_Init()
    500              (+) FSMC NAND bank enable/disable ECC correction feature using the functions
    501                  FSMC_NAND_ECC_Enable()/FSMC_NAND_ECC_Disable()
    502              (+) FSMC NAND bank get ECC correction code using the function FSMC_NAND_GetECC()
    503          
    504          @endverbatim
    505            * @{
    506            */
    507          
    508          /** @defgroup FSMC_NAND_Exported_Functions_Group1 Initialization and de-initialization functions
    509           *  @brief    Initialization and Configuration functions
    510           *
    511          @verbatim
    512            ==============================================================================
    513                        ##### Initialization and de_initialization functions #####
    514            ==============================================================================
    515            [..]
    516              This section provides functions allowing to:
    517              (+) Initialize and configure the FSMC NAND interface
    518              (+) De-initialize the FSMC NAND interface
    519              (+) Configure the FSMC clock and associated GPIOs
    520          
    521          @endverbatim
    522            * @{
    523            */
    524          
    525          /**
    526            * @brief  Initializes the FSMC_NAND device according to the specified
    527            *         control parameters in the FSMC_NAND_HandleTypeDef
    528            * @param  Device: Pointer to NAND device instance
    529            * @param  Init: Pointer to NAND Initialization structure
    530            * @retval HAL status
    531            */

   \                                 In section .text, align 2, keep-with-next
    532          HAL_StatusTypeDef FSMC_NAND_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_InitTypeDef *Init)
    533          {
   \                     FSMC_NAND_Init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    534            /* Check the parameters */
    535            assert_param(IS_FSMC_NAND_DEVICE(Device));
    536            assert_param(IS_FSMC_NAND_BANK(Init->NandBank));
    537            assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
    538            assert_param(IS_FSMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
    539            assert_param(IS_FSMC_ECC_STATE(Init->EccComputation));
    540            assert_param(IS_FSMC_ECCPAGE_SIZE(Init->ECCPageSize));
    541            assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
    542            assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));
    543          
    544            /* Set NAND device control parameters */
    545            if (Init->NandBank == FSMC_NAND_BANK2)
   \   00000002   0x698A             LDR      R2,[R1, #+24]
   \   00000004   0x694B             LDR      R3,[R1, #+20]
   \   00000006   0x690C             LDR      R4,[R1, #+16]
   \   00000008   0x68CD             LDR      R5,[R1, #+12]
   \   0000000A   0x688E             LDR      R6,[R1, #+8]
   \   0000000C   0x684F             LDR      R7,[R1, #+4]
   \   0000000E   0x.... 0x....      LDR.W    R12,??DataTable3_2  ;; 0xfff00181
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x2910             CMP      R1,#+16
   \   00000016   0xD10E             BNE.N    ??FSMC_NAND_Init_0
    546            {
    547              /* NAND bank 2 registers configuration */
    548              MODIFY_REG(Device->PCR2, PCR_CLEAR_MASK, (Init->Waitfeature                  | \
    549                                                        FSMC_PCR_MEMORY_TYPE_NAND                                     | \
    550                                                        Init->MemoryDataWidth                                         | \
    551                                                        Init->EccComputation                                          | \
    552                                                        Init->ECCPageSize                                             | \
    553                                                        ((Init->TCLRSetupTime) << POSITION_VAL(FSMC_PCRx_TCLR))       | \
    554                                                        ((Init->TARSetupTime) << POSITION_VAL(FSMC_PCRx_TAR))));
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xEA0C 0x0101      AND      R1,R12,R1
   \   0000001E   0x4339             ORRS     R1,R7,R1
   \   00000020   0x4331             ORRS     R1,R6,R1
   \   00000022   0x4329             ORRS     R1,R5,R1
   \   00000024   0x4321             ORRS     R1,R4,R1
   \   00000026   0xEA51 0x2143      ORRS     R1,R1,R3, LSL #+9
   \   0000002A   0xEA51 0x3142      ORRS     R1,R1,R2, LSL #+13
   \   0000002E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000032   0x6001             STR      R1,[R0, #+0]
   \   00000034   0xE00D             B.N      ??FSMC_NAND_Init_1
    555            }
    556            else
    557            {
    558              /* NAND bank 3 registers configuration */
    559              MODIFY_REG(Device->PCR3, PCR_CLEAR_MASK, (Init->Waitfeature                  | \
    560                                                        FSMC_PCR_MEMORY_TYPE_NAND                                     | \
    561                                                        Init->MemoryDataWidth                                         | \
    562                                                        Init->EccComputation                                          | \
    563                                                        Init->ECCPageSize                                             | \
    564                                                        ((Init->TCLRSetupTime) << POSITION_VAL(FSMC_PCRx_TCLR))       | \
    565                                                        ((Init->TARSetupTime) << POSITION_VAL(FSMC_PCRx_TAR))));
   \                     ??FSMC_NAND_Init_0: (+1)
   \   00000036   0x6A01             LDR      R1,[R0, #+32]
   \   00000038   0xEA0C 0x0101      AND      R1,R12,R1
   \   0000003C   0x4339             ORRS     R1,R7,R1
   \   0000003E   0x4331             ORRS     R1,R6,R1
   \   00000040   0x4329             ORRS     R1,R5,R1
   \   00000042   0x4321             ORRS     R1,R4,R1
   \   00000044   0xEA51 0x2143      ORRS     R1,R1,R3, LSL #+9
   \   00000048   0xEA51 0x3142      ORRS     R1,R1,R2, LSL #+13
   \   0000004C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000050   0x6201             STR      R1,[R0, #+32]
    566            }
    567          
    568            return HAL_OK;
   \                     ??FSMC_NAND_Init_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBCF0             POP      {R4-R7}
   \   00000056   0x4770             BX       LR               ;; return
    569          
    570          }
    571          
    572          /**
    573            * @brief  Initializes the FSMC_NAND Common space Timing according to the specified
    574            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    575            * @param  Device: Pointer to NAND device instance
    576            * @param  Timing: Pointer to NAND timing structure
    577            * @param  Bank: NAND bank number
    578            * @retval HAL status
    579            */

   \                                 In section .text, align 2, keep-with-next
    580          HAL_StatusTypeDef FSMC_NAND_CommonSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
    581          {
   \                     FSMC_NAND_CommonSpace_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    582            /* Check the parameters */
    583            assert_param(IS_FSMC_NAND_DEVICE(Device));
    584            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    585            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    586            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    587            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    588            assert_param(IS_FSMC_NAND_BANK(Bank));
    589          
    590            /* Set FMC_NAND device timing parameters */
    591            if (Bank == FSMC_NAND_BANK2)
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x684C             LDR      R4,[R1, #+4]
   \   00000006   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000000A   0x688C             LDR      R4,[R1, #+8]
   \   0000000C   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA43 0x6101      ORR      R1,R3,R1, LSL #+24
   \   00000016   0x2A10             CMP      R2,#+16
   \   00000018   0xD102             BNE.N    ??FSMC_NAND_CommonSpace_Timing_Init_0
    592            {
    593              /* NAND bank 2 registers configuration */
    594              MODIFY_REG(Device->PMEM2, PMEM_CLEAR_MASK, (Timing->SetupTime                      | \
    595                                                          ((Timing->WaitSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMWAITx))      | \
    596                                                          ((Timing->HoldSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMHOLDx))      | \
    597                                                          ((Timing->HiZSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMHIZx))));
   \   0000001A   0x6882             LDR      R2,[R0, #+8]
   \   0000001C   0x6081             STR      R1,[R0, #+8]
   \   0000001E   0xE001             B.N      ??FSMC_NAND_CommonSpace_Timing_Init_1
    598            }
    599            else
    600            {
    601              /* NAND bank 3 registers configuration */
    602              MODIFY_REG(Device->PMEM3, PMEM_CLEAR_MASK, (Timing->SetupTime                      | \
    603                                                          ((Timing->WaitSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMWAITx))      | \
    604                                                          ((Timing->HoldSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMHOLDx))      | \
    605                                                          ((Timing->HiZSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMHIZx))));
   \                     ??FSMC_NAND_CommonSpace_Timing_Init_0: (+1)
   \   00000020   0x6A82             LDR      R2,[R0, #+40]
   \   00000022   0x6281             STR      R1,[R0, #+40]
    606            }
    607          
    608            return HAL_OK;
   \                     ??FSMC_NAND_CommonSpace_Timing_Init_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
    609          }
    610          
    611          /**
    612            * @brief  Initializes the FSMC_NAND Attribute space Timing according to the specified
    613            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    614            * @param  Device: Pointer to NAND device instance
    615            * @param  Timing: Pointer to NAND timing structure
    616            * @param  Bank: NAND bank number
    617            * @retval HAL status
    618            */

   \                                 In section .text, align 2, keep-with-next
    619          HAL_StatusTypeDef FSMC_NAND_AttributeSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
    620          {
   \                     FSMC_NAND_AttributeSpace_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    621            /* Check the parameters */
    622            assert_param(IS_FSMC_NAND_DEVICE(Device));
    623            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    624            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    625            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    626            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    627            assert_param(IS_FSMC_NAND_BANK(Bank));
    628          
    629            /* Set FMC_NAND device timing parameters */
    630            if (Bank == FSMC_NAND_BANK2)
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x684C             LDR      R4,[R1, #+4]
   \   00000006   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000000A   0x688C             LDR      R4,[R1, #+8]
   \   0000000C   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA43 0x6101      ORR      R1,R3,R1, LSL #+24
   \   00000016   0x2A10             CMP      R2,#+16
   \   00000018   0xD102             BNE.N    ??FSMC_NAND_AttributeSpace_Timing_Init_0
    631            {
    632              /* NAND bank 2 registers configuration */
    633              MODIFY_REG(Device->PATT2, PATT_CLEAR_MASK, (Timing->SetupTime                       | \
    634                                                          ((Timing->WaitSetupTime) << POSITION_VAL(FSMC_PATTx_ATTWAITx))       | \
    635                                                          ((Timing->HoldSetupTime) << POSITION_VAL(FSMC_PATTx_ATTHOLDx))       | \
    636                                                          ((Timing->HiZSetupTime) << POSITION_VAL(FSMC_PATTx_ATTHIZx))));
   \   0000001A   0x68C2             LDR      R2,[R0, #+12]
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
   \   0000001E   0xE001             B.N      ??FSMC_NAND_AttributeSpace_Timing_Init_1
    637            }
    638            else
    639            {
    640              /* NAND bank 3 registers configuration */
    641              MODIFY_REG(Device->PATT3, PATT_CLEAR_MASK, (Timing->SetupTime                       | \
    642                                                          ((Timing->WaitSetupTime) << POSITION_VAL(FSMC_PATTx_ATTWAITx))       | \
    643                                                          ((Timing->HoldSetupTime) << POSITION_VAL(FSMC_PATTx_ATTHOLDx))       | \
    644                                                          ((Timing->HiZSetupTime) << POSITION_VAL(FSMC_PATTx_ATTHIZx))));
   \                     ??FSMC_NAND_AttributeSpace_Timing_Init_0: (+1)
   \   00000020   0x6AC2             LDR      R2,[R0, #+44]
   \   00000022   0x62C1             STR      R1,[R0, #+44]
    645            }
    646          
    647            return HAL_OK;
   \                     ??FSMC_NAND_AttributeSpace_Timing_Init_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
    648          }
    649          
    650          
    651          /**
    652            * @brief  DeInitializes the FSMC_NAND device
    653            * @param  Device: Pointer to NAND device instance
    654            * @param  Bank: NAND bank number
    655            * @retval HAL status
    656            */

   \                                 In section .text, align 2, keep-with-next
    657          HAL_StatusTypeDef FSMC_NAND_DeInit(FSMC_NAND_TypeDef *Device, uint32_t Bank)
    658          {
    659            /* Check the parameters */
    660            assert_param(IS_FSMC_NAND_DEVICE(Device));
    661            assert_param(IS_FSMC_NAND_BANK(Bank));
    662          
    663            /* Disable the NAND Bank */
    664            __FSMC_NAND_DISABLE(Device, Bank);
   \                     FSMC_NAND_DeInit: (+1)
   \   00000000   0x2910             CMP      R1,#+16
   \   00000002   0xD104             BNE.N    ??FSMC_NAND_DeInit_0
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   \   0000000C   0xE003             B.N      ??FSMC_NAND_DeInit_1
   \                     ??FSMC_NAND_DeInit_0: (+1)
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000014   0x6202             STR      R2,[R0, #+32]
    665          
    666            /* De-initialize the NAND Bank */
    667            if (Bank == FSMC_NAND_BANK2)
   \                     ??FSMC_NAND_DeInit_1: (+1)
   \   00000016   0xF04F 0x32FC      MOV      R2,#-50529028
   \   0000001A   0xD106             BNE.N    ??FSMC_NAND_DeInit_2
    668            {
    669              /* Set the FSMC_NAND_BANK2 registers to their reset values */
    670              WRITE_REG(Device->PCR2,  0x00000018);
   \   0000001C   0x2118             MOVS     R1,#+24
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    671              WRITE_REG(Device->SR2,   0x00000040);
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x6041             STR      R1,[R0, #+4]
    672              WRITE_REG(Device->PMEM2, 0xFCFCFCFC);
   \   00000024   0x6082             STR      R2,[R0, #+8]
    673              WRITE_REG(Device->PATT2, 0xFCFCFCFC);
   \   00000026   0x60C2             STR      R2,[R0, #+12]
   \   00000028   0xE005             B.N      ??FSMC_NAND_DeInit_3
    674            }
    675            /* FSMC_Bank3_NAND */
    676            else
    677            {
    678              /* Set the FSMC_NAND_BANK3 registers to their reset values */
    679              WRITE_REG(Device->PCR3,  0x00000018);
   \                     ??FSMC_NAND_DeInit_2: (+1)
   \   0000002A   0x2118             MOVS     R1,#+24
   \   0000002C   0x6201             STR      R1,[R0, #+32]
    680              WRITE_REG(Device->SR3,   0x00000040);
   \   0000002E   0x2140             MOVS     R1,#+64
   \   00000030   0x6241             STR      R1,[R0, #+36]
    681              WRITE_REG(Device->PMEM3, 0xFCFCFCFC);
   \   00000032   0x6282             STR      R2,[R0, #+40]
    682              WRITE_REG(Device->PATT3, 0xFCFCFCFC);
   \   00000034   0x62C2             STR      R2,[R0, #+44]
    683            }
    684          
    685            return HAL_OK;
   \                     ??FSMC_NAND_DeInit_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
    686          }
    687          
    688          /**
    689            * @}
    690            */
    691          
    692          
    693          /** @defgroup FSMC_NAND_Exported_Functions_Group2 Peripheral Control functions
    694           *  @brief   management functions
    695           *
    696          @verbatim
    697            ==============================================================================
    698                                 ##### FSMC_NAND Control functions #####
    699            ==============================================================================
    700            [..]
    701              This subsection provides a set of functions allowing to control dynamically
    702              the FSMC NAND interface.
    703          
    704          @endverbatim
    705            * @{
    706            */
    707          
    708          
    709          /**
    710            * @brief  Enables dynamically FSMC_NAND ECC feature.
    711            * @param  Device: Pointer to NAND device instance
    712            * @param  Bank: NAND bank number
    713            * @retval HAL status
    714            */

   \                                 In section .text, align 2, keep-with-next
    715          HAL_StatusTypeDef FSMC_NAND_ECC_Enable(FSMC_NAND_TypeDef *Device, uint32_t Bank)
    716          {
    717            /* Check the parameters */
    718            assert_param(IS_FSMC_NAND_DEVICE(Device));
    719            assert_param(IS_FSMC_NAND_BANK(Bank));
    720          
    721            /* Enable ECC feature */
    722            if (Bank == FSMC_NAND_BANK2)
   \                     FSMC_NAND_ECC_Enable: (+1)
   \   00000000   0x2910             CMP      R1,#+16
   \   00000002   0xD104             BNE.N    ??FSMC_NAND_ECC_Enable_0
    723            {
    724              SET_BIT(Device->PCR2, FSMC_PCRx_ECCEN);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0xE003             B.N      ??FSMC_NAND_ECC_Enable_1
    725            }
    726            else
    727            {
    728              SET_BIT(Device->PCR3, FSMC_PCRx_ECCEN);
   \                     ??FSMC_NAND_ECC_Enable_0: (+1)
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000014   0x6201             STR      R1,[R0, #+32]
    729            }
    730          
    731            return HAL_OK;
   \                     ??FSMC_NAND_ECC_Enable_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    732          }
    733          
    734          
    735          /**
    736            * @brief  Disables dynamically FSMC_NAND ECC feature.
    737            * @param  Device: Pointer to NAND device instance
    738            * @param  Bank: NAND bank number
    739            * @retval HAL status
    740            */

   \                                 In section .text, align 2, keep-with-next
    741          HAL_StatusTypeDef FSMC_NAND_ECC_Disable(FSMC_NAND_TypeDef *Device, uint32_t Bank)
    742          {
    743            /* Check the parameters */
    744            assert_param(IS_FSMC_NAND_DEVICE(Device));
    745            assert_param(IS_FSMC_NAND_BANK(Bank));
    746          
    747            /* Disable ECC feature */
    748            if (Bank == FSMC_NAND_BANK2)
   \                     FSMC_NAND_ECC_Disable: (+1)
   \   00000000   0x2910             CMP      R1,#+16
   \   00000002   0xD104             BNE.N    ??FSMC_NAND_ECC_Disable_0
    749            {
    750              CLEAR_BIT(Device->PCR2, FSMC_PCRx_ECCEN);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0xE003             B.N      ??FSMC_NAND_ECC_Disable_1
    751            }
    752            else
    753            {
    754              CLEAR_BIT(Device->PCR3, FSMC_PCRx_ECCEN);
   \                     ??FSMC_NAND_ECC_Disable_0: (+1)
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000014   0x6201             STR      R1,[R0, #+32]
    755            }
    756          
    757            return HAL_OK;
   \                     ??FSMC_NAND_ECC_Disable_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    758          }
    759          
    760          /**
    761            * @brief  Disables dynamically FSMC_NAND ECC feature.
    762            * @param  Device: Pointer to NAND device instance
    763            * @param  ECCval: Pointer to ECC value
    764            * @param  Bank: NAND bank number
    765            * @param  Timeout: Timeout wait value
    766            * @retval HAL status
    767            */

   \                                 In section .text, align 2, keep-with-next
    768          HAL_StatusTypeDef FSMC_NAND_GetECC(FSMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
    769          {
   \                     FSMC_NAND_GetECC: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    770            uint32_t tickstart = 0;
    771          
    772            /* Check the parameters */
    773            assert_param(IS_FSMC_NAND_DEVICE(Device));
    774            assert_param(IS_FSMC_NAND_BANK(Bank));
    775          
    776            /* Get tick */
    777            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4680             MOV      R8,R0
    778          
    779            /* Wait untill FIFO is empty */
    780            while (__FSMC_NAND_GET_FLAG(Device, Bank, FSMC_FLAG_FEMPT) == RESET)
   \                     ??FSMC_NAND_GetECC_0: (+1)
   \   00000012   0x2E10             CMP      R6,#+16
   \   00000014   0xD104             BNE.N    ??FSMC_NAND_GetECC_1
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x0980             LSRS     R0,R0,#+6
   \   0000001A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000001E   0xE003             B.N      ??FSMC_NAND_GetECC_2
   \                     ??FSMC_NAND_GetECC_1: (+1)
   \   00000020   0x6A60             LDR      R0,[R4, #+36]
   \   00000022   0x0980             LSRS     R0,R0,#+6
   \   00000024   0xF000 0x0001      AND      R0,R0,#0x1
   \                     ??FSMC_NAND_GetECC_2: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD10C             BNE.N    ??FSMC_NAND_GetECC_3
    781            {
    782              /* Check for the Timeout */
    783              if (Timeout != HAL_MAX_DELAY)
   \   0000002C   0xF117 0x0F01      CMN      R7,#+1
   \   00000030   0xD0EF             BEQ.N    ??FSMC_NAND_GetECC_0
    784              {
    785                if ((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD005             BEQ.N    ??FSMC_NAND_GetECC_4
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xD2E7             BCS.N    ??FSMC_NAND_GetECC_0
    786                {
    787                  return HAL_TIMEOUT;
   \                     ??FSMC_NAND_GetECC_4: (+1)
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xE007             B.N      ??FSMC_NAND_GetECC_5
    788                }
    789              }
    790            }
    791          
    792            if (Bank == FSMC_NAND_BANK2)
   \                     ??FSMC_NAND_GetECC_3: (+1)
   \   00000046   0x2E10             CMP      R6,#+16
   \   00000048   0xD102             BNE.N    ??FSMC_NAND_GetECC_6
    793            {
    794              /* Get the ECCR2 register value */
    795              *ECCval = (uint32_t)Device->ECCR2;
   \   0000004A   0x6960             LDR      R0,[R4, #+20]
   \   0000004C   0x6028             STR      R0,[R5, #+0]
   \   0000004E   0xE001             B.N      ??FSMC_NAND_GetECC_7
    796            }
    797            else
    798            {
    799              /* Get the ECCR3 register value */
    800              *ECCval = (uint32_t)Device->ECCR3;
   \                     ??FSMC_NAND_GetECC_6: (+1)
   \   00000050   0x6B60             LDR      R0,[R4, #+52]
   \   00000052   0x6028             STR      R0,[R5, #+0]
    801            }
    802          
    803            return HAL_OK;
   \                     ??FSMC_NAND_GetECC_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??FSMC_NAND_GetECC_5: (+1)
   \   00000056   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    804          }
    805          
    806          /**
    807            * @}
    808            */
    809          
    810          /**
    811            * @}
    812            */
    813          
    814          #endif /* STM32F101xE || STM32F103xE || STM32F101xG || STM32F103xG */
    815          #if (defined (STM32F101xE) || defined(STM32F103xE) || defined(STM32F101xG) || defined(STM32F103xG))
    816          /** @defgroup FSMC_PCCARD FSMC PCCARD Controller functions
    817            * @brief    PCCARD Controller functions
    818            *
    819            @verbatim
    820            ==============================================================================
    821                              ##### How to use PCCARD device driver #####
    822            ==============================================================================
    823            [..]
    824              This driver contains a set of APIs to interface with the FSMC PCCARD bank in order
    825              to run the PCCARD/compact flash external devices.
    826          
    827              (+) FSMC PCCARD bank reset using the function FSMC_PCCARD_DeInit()
    828              (+) FSMC PCCARD bank control configuration using the function FSMC_PCCARD_Init()
    829              (+) FSMC PCCARD bank common space timing configuration using the function
    830                  FSMC_PCCARD_CommonSpace_Timing_Init()
    831              (+) FSMC PCCARD bank attribute space timing configuration using the function
    832                  FSMC_PCCARD_AttributeSpace_Timing_Init()
    833              (+) FSMC PCCARD bank IO space timing configuration using the function
    834                  FSMC_PCCARD_IOSpace_Timing_Init()
    835          
    836          
    837          @endverbatim
    838            * @{
    839            */
    840          
    841          /** @defgroup FSMC_PCCARD_Exported_Functions_Group1 Initialization and de-initialization functions
    842           *  @brief    Initialization and Configuration functions
    843           *
    844          @verbatim
    845            ==============================================================================
    846                        ##### Initialization and de_initialization functions #####
    847            ==============================================================================
    848            [..]
    849              This section provides functions allowing to:
    850              (+) Initialize and configure the FSMC PCCARD interface
    851              (+) De-initialize the FSMC PCCARD interface
    852              (+) Configure the FSMC clock and associated GPIOs
    853          
    854          @endverbatim
    855            * @{
    856            */
    857          
    858          /**
    859            * @brief  Initializes the FSMC_PCCARD device according to the specified
    860            *         control parameters in the FSMC_PCCARD_HandleTypeDef
    861            * @param  Device: Pointer to PCCARD device instance
    862            * @param  Init: Pointer to PCCARD Initialization structure
    863            * @retval HAL status
    864            */

   \                                 In section .text, align 2, keep-with-next
    865          HAL_StatusTypeDef FSMC_PCCARD_Init(FSMC_PCCARD_TypeDef *Device, FSMC_PCCARD_InitTypeDef *Init)
    866          {
    867            /* Check the parameters */
    868            assert_param(IS_FSMC_PCCARD_DEVICE(Device));
    869            assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
    870            assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
    871            assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));
    872          
    873            /* Set FSMC_PCCARD device control parameters */
    874            MODIFY_REG(Device->PCR4,                                  \
    875                       (FSMC_PCRx_PTYP | FSMC_PCRx_PWAITEN |  FSMC_PCRx_PWID  |
    876                        FSMC_PCRx_TCLR | FSMC_PCRx_TAR), \
    877                       (FSMC_PCR_MEMORY_TYPE_PCCARD                          | \
    878                        Init->Waitfeature                                     | \
    879                        FSMC_NAND_PCC_MEM_BUS_WIDTH_16                        | \
    880                        (Init->TCLRSetupTime << POSITION_VAL(FSMC_PCRx_TCLR)) | \
    881                        (Init->TARSetupTime << POSITION_VAL(FSMC_PCRx_TAR))));
   \                     FSMC_PCCARD_Init: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x....             LDR.N    R3,??DataTable3_3  ;; 0xfffe01c5
   \   00000004   0x401A             ANDS     R2,R3,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0xEA42 0x2243      ORR      R2,R2,R3, LSL #+9
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0xEA42 0x3141      ORR      R1,R2,R1, LSL #+13
   \   00000016   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    882          
    883            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    884          
    885          }
    886          
    887          /**
    888            * @brief  Initializes the FSMC_PCCARD Common space Timing according to the specified
    889            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    890            * @param  Device: Pointer to PCCARD device instance
    891            * @param  Timing: Pointer to PCCARD timing structure
    892            * @retval HAL status
    893            */

   \                                 In section .text, align 2, keep-with-next
    894          HAL_StatusTypeDef FSMC_PCCARD_CommonSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
    895          {
    896            /* Check the parameters */
    897            assert_param(IS_FSMC_PCCARD_DEVICE(Device));
    898            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    899            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    900            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    901            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    902          
    903            /* Set PCCARD timing parameters */
    904            MODIFY_REG(Device->PMEM4, PMEM_CLEAR_MASK,                            \
    905                       (Timing->SetupTime                                              | \
    906                        ((Timing->WaitSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMWAITx))  | \
    907                        ((Timing->HoldSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMHOLDx))  | \
    908                        ((Timing->HiZSetupTime) << POSITION_VAL(FSMC_PMEMx_MEMHIZx))));
   \                     FSMC_PCCARD_CommonSpace_Timing_Init: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000000A   0x688B             LDR      R3,[R1, #+8]
   \   0000000C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000016   0x6081             STR      R1,[R0, #+8]
    909          
    910            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    911          }
    912          
    913          /**
    914            * @brief  Initializes the FSMC_PCCARD Attribute space Timing according to the specified
    915            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    916            * @param  Device: Pointer to PCCARD device instance
    917            * @param  Timing: Pointer to PCCARD timing structure
    918            * @retval HAL status
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          HAL_StatusTypeDef FSMC_PCCARD_AttributeSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
    921          {
    922            /* Check the parameters */
    923            assert_param(IS_FSMC_PCCARD_DEVICE(Device));
    924            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    925            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    926            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    927            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    928          
    929            /* Set PCCARD timing parameters */
    930            MODIFY_REG(Device->PATT4, PATT_CLEAR_MASK,                          \
    931                       (Timing->SetupTime                                              | \
    932                        ((Timing->WaitSetupTime) << POSITION_VAL(FSMC_PATTx_ATTWAITx))  | \
    933                        ((Timing->HoldSetupTime) << POSITION_VAL(FSMC_PATTx_ATTHOLDx))   | \
    934                        ((Timing->HiZSetupTime) << POSITION_VAL(FSMC_PATTx_ATTHIZx))));
   \                     FSMC_PCCARD_AttributeSpace_Timing_Init: (+1)
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000000A   0x688B             LDR      R3,[R1, #+8]
   \   0000000C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    935          
    936            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    937          }
    938          
    939          /**
    940            * @brief  Initializes the FSMC_PCCARD IO space Timing according to the specified
    941            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    942            * @param  Device: Pointer to PCCARD device instance
    943            * @param  Timing: Pointer to PCCARD timing structure
    944            * @retval HAL status
    945            */

   \                                 In section .text, align 2, keep-with-next
    946          HAL_StatusTypeDef FSMC_PCCARD_IOSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
    947          {
    948            /* Check the parameters */
    949            assert_param(IS_FSMC_PCCARD_DEVICE(Device));
    950            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    951            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    952            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    953            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    954          
    955            /* Set FSMC_PCCARD device timing parameters */
    956            MODIFY_REG(Device->PIO4, PIO4_CLEAR_MASK,                         \
    957                       (Timing->SetupTime                                            | \
    958                        (Timing->WaitSetupTime   << POSITION_VAL(FSMC_PIO4_IOWAIT4)) | \
    959                        (Timing->HoldSetupTime   << POSITION_VAL(FSMC_PIO4_IOHOLD4)) | \
    960                        (Timing->HiZSetupTime    << POSITION_VAL(FSMC_PIO4_IOHIZ4))));
   \                     FSMC_PCCARD_IOSpace_Timing_Init: (+1)
   \   00000000   0x6902             LDR      R2,[R0, #+16]
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000000A   0x688B             LDR      R3,[R1, #+8]
   \   0000000C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000016   0x6101             STR      R1,[R0, #+16]
    961          
    962            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    963          }
    964          
    965          /**
    966            * @brief  DeInitializes the FSMC_PCCARD device
    967            * @param  Device: Pointer to PCCARD device instance
    968            * @retval HAL status
    969            */

   \                                 In section .text, align 2, keep-with-next
    970          HAL_StatusTypeDef FSMC_PCCARD_DeInit(FSMC_PCCARD_TypeDef *Device)
    971          {
    972            /* Check the parameters */
    973            assert_param(IS_FSMC_PCCARD_DEVICE(Device));
    974          
    975            /* Disable the FSMC_PCCARD device */
    976            __FSMC_PCCARD_DISABLE(Device);
   \                     FSMC_PCCARD_DeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000006   0x6001             STR      R1,[R0, #+0]
    977          
    978            /* De-initialize the FSMC_PCCARD device */
    979            WRITE_REG(Device->PCR4,  0x00000018);
   \   00000008   0x2118             MOVS     R1,#+24
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    980            WRITE_REG(Device->SR4,   0x00000040);
   \   0000000C   0x2140             MOVS     R1,#+64
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    981            WRITE_REG(Device->PMEM4, 0xFCFCFCFC);
   \   00000010   0xF04F 0x31FC      MOV      R1,#-50529028
   \   00000014   0x6081             STR      R1,[R0, #+8]
    982            WRITE_REG(Device->PATT4, 0xFCFCFCFC);
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    983            WRITE_REG(Device->PIO4,  0xFCFCFCFC);
   \   00000018   0x6101             STR      R1,[R0, #+16]
    984          
    985            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    986          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xFFF70081         DC32     0xfff70081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xCFF00000         DC32     0xcff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xFFF00181         DC32     0xfff00181

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xFFFE01C5         DC32     0xfffe01c5
    987          
    988          /**
    989            * @}
    990            */
    991          
    992          /**
    993            * @}
    994            */
    995          #endif /* STM32F101xE || STM32F103xE || STM32F101xG || STM32F103xG */
    996          
    997          /**
    998            * @}
    999            */
   1000          
   1001          /**
   1002            * @}
   1003            */
   1004          
   1005          #endif /* FSMC_BANK1 */
   1006          
   1007          #endif /* defined(HAL_SRAM_MODULE_ENABLED) || defined(HAL_NOR_MODULE_ENABLED) || defined(HAL_PCCARD_MODULE_ENABLED) || defined(HAL_NAND_MODULE_ENABLED) */
   1008          
   1009          /**
   1010            * @}
   1011            */
   1012          
   1013          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   FSMC_NAND_AttributeSpace_Timing_Init
       4   FSMC_NAND_CommonSpace_Timing_Init
       0   FSMC_NAND_DeInit
       0   FSMC_NAND_ECC_Disable
       0   FSMC_NAND_ECC_Enable
      24   FSMC_NAND_GetECC
        24   -> HAL_GetTick
      16   FSMC_NAND_Init
       0   FSMC_NORSRAM_DeInit
       4   FSMC_NORSRAM_Extended_Timing_Init
      44   FSMC_NORSRAM_Init
       4   FSMC_NORSRAM_Timing_Init
       0   FSMC_NORSRAM_WriteOperation_Disable
       0   FSMC_NORSRAM_WriteOperation_Enable
       0   FSMC_PCCARD_AttributeSpace_Timing_Init
       0   FSMC_PCCARD_CommonSpace_Timing_Init
       0   FSMC_PCCARD_DeInit
       0   FSMC_PCCARD_IOSpace_Timing_Init
       0   FSMC_PCCARD_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      42  FSMC_NAND_AttributeSpace_Timing_Init
      42  FSMC_NAND_CommonSpace_Timing_Init
      58  FSMC_NAND_DeInit
      26  FSMC_NAND_ECC_Disable
      26  FSMC_NAND_ECC_Enable
      90  FSMC_NAND_GetECC
      88  FSMC_NAND_Init
      50  FSMC_NORSRAM_DeInit
      62  FSMC_NORSRAM_Extended_Timing_Init
     154  FSMC_NORSRAM_Init
      62  FSMC_NORSRAM_Timing_Init
      16  FSMC_NORSRAM_WriteOperation_Disable
      16  FSMC_NORSRAM_WriteOperation_Enable
      28  FSMC_PCCARD_AttributeSpace_Timing_Init
      28  FSMC_PCCARD_CommonSpace_Timing_Init
      30  FSMC_PCCARD_DeInit
      28  FSMC_PCCARD_IOSpace_Timing_Init
      32  FSMC_PCCARD_Init

 
 894 bytes in section .text
 
 894 bytes of CODE memory

Errors: none
Warnings: none
