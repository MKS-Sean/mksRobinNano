###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\spi_flash.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\spi_flash.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.c
      1          /******************** (C) COPYRIGHT 2010 www.armjishu.com ********************
      2          * File Name          : spi_flash.c
      3          * Author             : www.armjishu.com
      4          * Version            : V1.0
      5          * Library            : Using STM32F2XX_STDPERIPH_VERSION V3.3.0
      6          * Date               : 10/16/2010
      7          * Description        : This file provides a set of functions needed to manage the
      8          *                      communication between SPI peripheral and SPI W25X16 FLASH.
      9          *******************************************************************************/
     10          
     11          /* Includes ------------------------------------------------------------------*/
     12          #include "spi.h"
     13          #include "spi_flash.h"

  #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION_MODE" (declared
          at line 466 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",146  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          459 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",158  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 488 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          496 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          504 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          512 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 521 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 535 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",408  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",409  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",425  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 558 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #else defined(MKS_ROBIN_NANO)
        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.h",40  Warning[Pe014]: 
          extra text after expected end of preprocessing directive
     14          #include <stdio.h>
     15          #include "usart.h"
     16          #include "stm32f103xe.h"
     17          #include "stm32f10x_rcc.h"

  #define RCC_HSE_ON                       ((uint32_t)0x00010000)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",68  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_HSE_ON" (declared at line
          305 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",70  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_HSE" (declared at line
          188 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

   #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
           ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",118  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLL_MUL" (declared at
          line 119 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc_ex.h")

  #define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",312  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_HCLK" (declared at line
          208 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",330  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PCLK" (declared at line
          213 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_IT_LSIRDY                    ((uint8_t)0x01)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",341  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_LSIRDY" (declared at line
          453 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_IT_LSERDY                    ((uint8_t)0x02)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",342  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_LSERDY" (declared at line
          454 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_IT_HSIRDY                    ((uint8_t)0x04)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",343  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_HSIRDY" (declared at line
          455 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_IT_HSERDY                    ((uint8_t)0x08)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",344  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_HSERDY" (declared at line
          456 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_IT_PLLRDY                    ((uint8_t)0x10)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",345  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_PLLRDY" (declared at line
          457 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_IT_CSS                       ((uint8_t)0x80)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",346  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_CSS" (declared at line
          458 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_LSE_OFF                      ((uint8_t)0x00)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_LSE_OFF" (declared at line
          314 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_LSE_ON                       ((uint8_t)0x01)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",444  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_LSE_ON" (declared at line
          315 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",446  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_LSE" (declared at line
          190 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_RTCCLK_SOURCE" (declared
          at line 2633 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

   #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
           ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",571  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_MCO" (declared at line
          216 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",595  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_HSIRDY" (declared at
          line 473 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",596  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_HSERDY" (declared at
          line 474 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",597  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PLLRDY" (declared at
          line 475 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",598  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_LSERDY" (declared at
          line 487 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",599  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_LSIRDY" (declared at
          line 478 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",600  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PINRST" (declared at
          line 479 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",601  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PORRST" (declared at
          line 480 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",602  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_SFTRST" (declared at
          line 481 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",603  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_IWDGRST" (declared at
          line 482 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",604  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_WWDGRST" (declared at
          line 483 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",605  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_LPWRRST" (declared at
          line 484 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")

  #define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h",626  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_CALIBRATION_VALUE"
          (declared at line 193 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_rcc.h")
     18          #include "stm32f10x_dma.h"

  #define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",126  Warning[Pe047]: 
          incompatible redefinition of macro "IS_DMA_PERIPHERAL_INC_STATE"
          (declared at line 431 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",138  Warning[Pe047]: 
          incompatible redefinition of macro "IS_DMA_MEMORY_INC_STATE"
          (declared at line 434 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",151  Warning[Pe047]: 
          incompatible redefinition of macro "IS_DMA_PERIPHERAL_DATA_SIZE"
          (declared at line 437 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",165  Warning[Pe047]: 
          incompatible redefinition of macro "IS_DMA_MEMORY_DATA_SIZE"
          (declared at line 441 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",178  Warning[Pe047]: 
          incompatible redefinition of macro "IS_DMA_MODE" (declared at line
          445 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",191  Warning[Pe047]: 
          incompatible redefinition of macro "IS_DMA_PRIORITY" (declared at
          line 448 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define DMA_IT_TC                          ((uint32_t)0x00000002)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",215  Warning[Pe047]: 
          incompatible redefinition of macro "DMA_IT_TC" (declared at line 242
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define DMA_IT_HT                          ((uint32_t)0x00000004)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",216  Warning[Pe047]: 
          incompatible redefinition of macro "DMA_IT_HT" (declared at line 243
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")

  #define DMA_IT_TE                          ((uint32_t)0x00000008)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h",217  Warning[Pe047]: 
          incompatible redefinition of macro "DMA_IT_TE" (declared at line 244
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_dma.h")
     19          #include "stm32f10x_spi.h"
     20          
     21          /* Private typedef -----------------------------------------------------------*/
     22          /** 
     23            * @brief  DMA Init structure definition
     24            */
     25          /* DMA registers Masks */
     26          #define CCR_CLEAR_Mask           ((uint32_t)0xFFFF800F)
     27          #define DMA_CCR1_EN              ((uint16_t)0x0001)            /*!< Channel enable*/
     28          
     29          /**
     30            * @brief  Initializes the DMAy Channelx according to the specified
     31            *         parameters in the DMA_InitStruct.
     32            * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
     33            *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
     34            * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
     35            *         contains the configuration information for the specified DMA Channel.
     36            * @retval None
     37            */

   \                                 In section .text, align 2, keep-with-next
     38          void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef_spi2* DMA_InitStruct)
     39          {
     40            uint32_t tmpreg = 0;
     41          
     42            /* Check the parameters */
     43            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
     44            assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));
     45            assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
     46            assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
     47            assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));   
     48            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
     49            assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
     50            assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
     51            assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
     52            assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));
     53          
     54          /*--------------------------- DMAy Channelx CCR Configuration -----------------*/
     55            /* Get the DMAy_Channelx CCR value */
     56            tmpreg = DMAy_Channelx->CCR;
   \                     DMA_Init: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
     57            /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
     58            tmpreg &= CCR_CLEAR_Mask;
     59            /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
     60            /* Set DIR bit according to DMA_DIR value */
     61            /* Set CIRC bit according to DMA_Mode value */
     62            /* Set PINC bit according to DMA_PeripheralInc value */
     63            /* Set MINC bit according to DMA_MemoryInc value */
     64            /* Set PSIZE bits according to DMA_PeripheralDataSize value */
     65            /* Set MSIZE bits according to DMA_MemoryDataSize value */
     66            /* Set PL bits according to DMA_Priority value */
     67            /* Set the MEM2MEM bit according to DMA_M2M value */
     68            tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
     69                      DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
     70                      DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
     71                      DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
     72          
     73            /* Write to DMAy Channelx CCR */
     74            DMAy_Channelx->CCR = tmpreg;
   \   00000002   0xF36F 0x120E      BFC      R2,#+4,#+11
   \   00000006   0x688B             LDR      R3,[R1, #+8]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x6A0B             LDR      R3,[R1, #+32]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x690B             LDR      R3,[R1, #+16]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x694B             LDR      R3,[R1, #+20]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x698B             LDR      R3,[R1, #+24]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x69CB             LDR      R3,[R1, #+28]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x6A4B             LDR      R3,[R1, #+36]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x6A8B             LDR      R3,[R1, #+40]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6002             STR      R2,[R0, #+0]
     75          
     76          /*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
     77            /* Write to DMAy Channelx CNDTR */
     78            DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
   \   00000028   0x68CA             LDR      R2,[R1, #+12]
   \   0000002A   0x6042             STR      R2,[R0, #+4]
     79          
     80          /*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
     81            /* Write to DMAy Channelx CPAR */
     82            DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
   \   0000002C   0x680A             LDR      R2,[R1, #+0]
   \   0000002E   0x6082             STR      R2,[R0, #+8]
     83          
     84          /*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
     85            /* Write to DMAy Channelx CMAR */
     86            DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
   \   00000030   0x6849             LDR      R1,[R1, #+4]
   \   00000032   0x60C1             STR      R1,[R0, #+12]
     87          }
   \   00000034   0x4770             BX       LR               ;; return
     88          
     89          /* Private define ------------------------------------------------------------*/
     90          #define W25X_WriteEnable		0x06 
     91          #define W25X_WriteDisable		0x04 
     92          #define W25X_ReadStatusReg		0x05 
     93          #define W25X_WriteStatusReg		0x01 
     94          #define W25X_ReadData			0x03 
     95          #define W25X_FastReadData		0x0B 
     96          #define W25X_FastReadDual		0x3B 
     97          #define W25X_PageProgram		0x02 
     98          #define W25X_BlockErase			0xD8 
     99          #define W25X_SectorErase		0x20 
    100          #define W25X_ChipErase			0xC7 
    101          #define W25X_PowerDown			0xB9 
    102          #define W25X_ReleasePowerDown	        0xAB 
    103          #define W25X_DeviceID			0xAB 
    104          #define W25X_ManufactDeviceID	        0x90 
    105          #define W25X_JedecDeviceID		0x9F 
    106          
    107          #define WIP_Flag                0x01  /* Write In Progress (WIP) flag */
    108          
    109          #define Dummy_Byte              0xA5
    110          

   \                                 In section .data, align 4
    111          uint8_t DMA_ERRO_FLAG = 0;
   \                     DMA_ERRO_FLAG:
   \   00000000   0x00               DC8 0
    112          extern unsigned char bmp_public_buf[16 * 1024];
    113          static uint32_t dummynum = 100000;
    114          static unsigned char tx_buf= 0xff;
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          /* Private functions ---------------------------------------------------------*/
    119          char flash_dma_mode = 1;
   \                     flash_dma_mode:
   \   00000001   0x01               DC8 1
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x000186A0         DC32 100000
   \   00000008   0xFF               DC8 255
    120          //char dma1_5_IRQ_sel = 0;// 0:flash中断；1:usart1中断。
    121          
    122          
    123          /**
    124            * @brief  Deinitializes the DMAy Channelx registers to their default reset
    125            *         values.
    126            * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
    127            *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
    128            * @retval None
    129            */
    130            
    131          /* DMA1 Channelx interrupt pending bit masks */
    132          #define DMA1_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))
    133          #define DMA1_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))
    134          #define DMA1_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))
    135          #define DMA1_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))
    136          #define DMA1_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))
    137          #define DMA1_Channel6_IT_Mask    ((uint32_t)(DMA_ISR_GIF6 | DMA_ISR_TCIF6 | DMA_ISR_HTIF6 | DMA_ISR_TEIF6))
    138          #define DMA1_Channel7_IT_Mask    ((uint32_t)(DMA_ISR_GIF7 | DMA_ISR_TCIF7 | DMA_ISR_HTIF7 | DMA_ISR_TEIF7))
    139          
    140          /* DMA2 Channelx interrupt pending bit masks */
    141          #define DMA2_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))
    142          #define DMA2_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))
    143          #define DMA2_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))
    144          #define DMA2_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))
    145          #define DMA2_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))

   \                                 In section .text, align 2, keep-with-next
    146          void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
    147          {
    148            /* Check the parameters */
    149            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
    150            
    151            /* Disable the selected DMAy Channelx */
    152            DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
   \                     DMA_DeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF64F 0x72FE      MOVW     R2,#+65534
   \   00000006   0x4011             ANDS     R1,R2,R1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    153            
    154            /* Reset DMAy Channelx control register */
    155            DMAy_Channelx->CCR  = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    156            
    157            /* Reset DMAy Channelx remaining bytes register */
    158            DMAy_Channelx->CNDTR = 0;
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    159            
    160            /* Reset DMAy Channelx peripheral address register */
    161            DMAy_Channelx->CPAR  = 0;
   \   00000010   0x6081             STR      R1,[R0, #+8]
    162            
    163            /* Reset DMAy Channelx memory address register */
    164            DMAy_Channelx->CMAR = 0;
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    165            
    166            if (DMAy_Channelx == DMA1_Channel1)
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x40020008
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD106             BNE.N    ??DMA_DeInit_0
    167            {
    168              /* Reset interrupt pending bits for DMA1 Channel1 */
    169              DMA1->IFCR |= DMA1_Channel1_IT_Mask;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0xF041 0x010F      ORR      R1,R1,#0xF
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0x4770             BX       LR
    170            }
    171            else if (DMAy_Channelx == DMA1_Channel2)
   \                     ??DMA_DeInit_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x4002001c
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD106             BNE.N    ??DMA_DeInit_1
    172            {
    173              /* Reset interrupt pending bits for DMA1 Channel2 */
    174              DMA1->IFCR |= DMA1_Channel2_IT_Mask;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   \   0000003E   0x4770             BX       LR
    175            }
    176            else if (DMAy_Channelx == DMA1_Channel3)
   \                     ??DMA_DeInit_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable14_3  ;; 0x40020030
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD106             BNE.N    ??DMA_DeInit_2
    177            {
    178              /* Reset interrupt pending bits for DMA1 Channel3 */
    179              DMA1->IFCR |= DMA1_Channel3_IT_Mask;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF441 0x6170      ORR      R1,R1,#0xF00
   \   00000052   0x6001             STR      R1,[R0, #+0]
   \   00000054   0x4770             BX       LR
    180            }
    181            else if (DMAy_Channelx == DMA1_Channel4)
   \                     ??DMA_DeInit_2: (+1)
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable14_4  ;; 0x40020044
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD106             BNE.N    ??DMA_DeInit_3
    182            {
    183              /* Reset interrupt pending bits for DMA1 Channel4 */
    184              DMA1->IFCR |= DMA1_Channel4_IT_Mask;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF441 0x4170      ORR      R1,R1,#0xF000
   \   00000068   0x6001             STR      R1,[R0, #+0]
   \   0000006A   0x4770             BX       LR
    185            }
    186            else if (DMAy_Channelx == DMA1_Channel5)
   \                     ??DMA_DeInit_3: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable14_5  ;; 0x40020058
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD106             BNE.N    ??DMA_DeInit_4
    187            {
    188              /* Reset interrupt pending bits for DMA1 Channel5 */
    189              DMA1->IFCR |= DMA1_Channel5_IT_Mask;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0xF441 0x2170      ORR      R1,R1,#0xF0000
   \   0000007E   0x6001             STR      R1,[R0, #+0]
   \   00000080   0x4770             BX       LR
    190            }
    191            else if (DMAy_Channelx == DMA1_Channel6)
   \                     ??DMA_DeInit_4: (+1)
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x4002006c
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD106             BNE.N    ??DMA_DeInit_5
    192            {
    193              /* Reset interrupt pending bits for DMA1 Channel6 */
    194              DMA1->IFCR |= DMA1_Channel6_IT_Mask;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   0000008E   0x6801             LDR      R1,[R0, #+0]
   \   00000090   0xF441 0x0170      ORR      R1,R1,#0xF00000
   \   00000094   0x6001             STR      R1,[R0, #+0]
   \   00000096   0x4770             BX       LR
    195            }
    196            else if (DMAy_Channelx == DMA1_Channel7)
   \                     ??DMA_DeInit_5: (+1)
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x40020080
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD106             BNE.N    ??DMA_DeInit_6
    197            {
    198              /* Reset interrupt pending bits for DMA1 Channel7 */
    199              DMA1->IFCR |= DMA1_Channel7_IT_Mask;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40020004
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xF041 0x6170      ORR      R1,R1,#0xF000000
   \   000000AA   0x6001             STR      R1,[R0, #+0]
   \   000000AC   0x4770             BX       LR
    200            }
    201            else if (DMAy_Channelx == DMA2_Channel1)
   \                     ??DMA_DeInit_6: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14_8  ;; 0x40020408
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD106             BNE.N    ??DMA_DeInit_7
    202            {
    203              /* Reset interrupt pending bits for DMA2 Channel1 */
    204              DMA2->IFCR |= DMA2_Channel1_IT_Mask;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40020404
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0xF041 0x010F      ORR      R1,R1,#0xF
   \   000000C0   0x6001             STR      R1,[R0, #+0]
   \   000000C2   0x4770             BX       LR
    205            }
    206            else if (DMAy_Channelx == DMA2_Channel2)
   \                     ??DMA_DeInit_7: (+1)
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable14_10  ;; 0x4002041c
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xD106             BNE.N    ??DMA_DeInit_8
    207            {
    208              /* Reset interrupt pending bits for DMA2 Channel2 */
    209              DMA2->IFCR |= DMA2_Channel2_IT_Mask;
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40020404
   \   000000D0   0x6801             LDR      R1,[R0, #+0]
   \   000000D2   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   000000D6   0x6001             STR      R1,[R0, #+0]
   \   000000D8   0x4770             BX       LR
    210            }
    211            else if (DMAy_Channelx == DMA2_Channel3)
   \                     ??DMA_DeInit_8: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable14_11  ;; 0x40020430
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD106             BNE.N    ??DMA_DeInit_9
    212            {
    213              /* Reset interrupt pending bits for DMA2 Channel3 */
    214              DMA2->IFCR |= DMA2_Channel3_IT_Mask;
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40020404
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0xF441 0x6170      ORR      R1,R1,#0xF00
   \   000000EC   0x6001             STR      R1,[R0, #+0]
   \   000000EE   0x4770             BX       LR
    215            }
    216            else if (DMAy_Channelx == DMA2_Channel4)
   \                     ??DMA_DeInit_9: (+1)
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable14_12  ;; 0x40020444
   \   000000F4   0x4288             CMP      R0,R1
   \   000000F6   0xD106             BNE.N    ??DMA_DeInit_10
    217            {
    218              /* Reset interrupt pending bits for DMA2 Channel4 */
    219              DMA2->IFCR |= DMA2_Channel4_IT_Mask;
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40020404
   \   000000FC   0x6801             LDR      R1,[R0, #+0]
   \   000000FE   0xF441 0x4170      ORR      R1,R1,#0xF000
   \   00000102   0x6001             STR      R1,[R0, #+0]
   \   00000104   0x4770             BX       LR
    220            }
    221            else
    222            { 
    223              if (DMAy_Channelx == DMA2_Channel5)
   \                     ??DMA_DeInit_10: (+1)
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable14_13  ;; 0x40020458
   \   0000010A   0x4288             CMP      R0,R1
   \   0000010C   0xD105             BNE.N    ??DMA_DeInit_11
    224              {
    225                /* Reset interrupt pending bits for DMA2 Channel5 */
    226                DMA2->IFCR |= DMA2_Channel5_IT_Mask;
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x40020404
   \   00000112   0x6801             LDR      R1,[R0, #+0]
   \   00000114   0xF441 0x2170      ORR      R1,R1,#0xF0000
   \   00000118   0x6001             STR      R1,[R0, #+0]
    227              }
    228            }
    229          }
   \                     ??DMA_DeInit_11: (+1)
   \   0000011A   0x4770             BX       LR               ;; return
    230          #if 0
    231          /**
    232            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    233            * @param  SPIx: where x can be
    234            *   - 1, 2 or 3 in SPI mode 
    235            *   - 2 or 3 in I2S mode
    236            * @param  SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request to be enabled or disabled. 
    237            *   This parameter can be any combination of the following values:
    238            *     @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    239            *     @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    240            * @param  NewState: new state of the selected SPI/I2S DMA transfer request.
    241            *   This parameter can be: ENABLE or DISABLE.
    242            * @retval None
    243            */
    244          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    245          {
    246            /* Check the parameters */
    247            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    248            assert_param(IS_FUNCTIONAL_STATE(NewState));
    249            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    250            if (NewState != DISABLE)
    251            {
    252              /* Enable the selected SPI/I2S DMA requests */
    253              SPIx->CR2 |= SPI_I2S_DMAReq;
    254            }
    255            else
    256            {
    257              /* Disable the selected SPI/I2S DMA requests */
    258              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
    259            }
    260          }
    261          #endif

   \                                 In section .text, align 2, keep-with-next
    262          void DMAx_Init()
    263          {
   \                     DMAx_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    264          	DMA_InitTypeDef_spi2  DMA_InitStructure;
    265          	//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    266          	RCC->AHBENR |= RCC_AHBPeriph_DMA1;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14_14  ;; 0x40021014
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    267          	DMA_DeInit(DMA1_Channel4);
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable14_4  ;; 0x40020044
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       DMA_DeInit
    268          	DMA_DeInit(DMA1_Channel5);
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable14_5  ;; 0x40020058
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       DMA_DeInit
    269          	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&SPI2->DR;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable14_15  ;; 0x4000380c
   \   00000028   0x9000             STR      R0,[SP, #+0]
    270          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)bmp_public_buf;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_16
   \   0000002E   0x9001             STR      R0,[SP, #+4]
    271          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9002             STR      R0,[SP, #+8]
    272          	DMA_InitStructure.DMA_BufferSize = 16*1024;
   \   00000034   0xF44F 0x4080      MOV      R0,#+16384
   \   00000038   0x9003             STR      R0,[SP, #+12]
    273          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9004             STR      R0,[SP, #+16]
    274          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   0000003E   0x2080             MOVS     R0,#+128
   \   00000040   0x9005             STR      R0,[SP, #+20]
    275          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9006             STR      R0,[SP, #+24]
    276          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   00000046   0x9007             STR      R0,[SP, #+28]
    277          	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000048   0x9008             STR      R0,[SP, #+32]
    278          	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
   \   0000004A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000004E   0x9009             STR      R0,[SP, #+36]
    279          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x900A             STR      R0,[SP, #+40]
    280          	DMA_Init(DMA1_Channel4, &DMA_InitStructure);
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       DMA_Init
    281          
    282          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&tx_buf;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \   00000060   0x9001             STR      R0,[SP, #+4]
    283          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0x9002             STR      R0,[SP, #+8]
    284          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9005             STR      R0,[SP, #+20]
    285          	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
   \   0000006A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000006E   0x9009             STR      R0,[SP, #+36]
    286          	DMA_Init(DMA1_Channel5, &DMA_InitStructure);
   \   00000070   0xA900             ADD      R1,SP,#+0
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       DMA_Init
    287          
    288          	SPI_I2S_DMACmd (SPI2, SPI_I2S_DMAReq_Tx, ENABLE);
   \   00000078   0x.... 0x....      LDR.W    R4,??DataTable14_18  ;; 0x40003800
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x2102             MOVS     R1,#+2
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       SPI_I2S_DMACmd
    289          	SPI_I2S_DMACmd (SPI2, SPI_I2S_DMAReq_Rx, ENABLE);
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0x4611             MOV      R1,R2
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       SPI_I2S_DMACmd
    290          }
   \   00000090   0xB00B             ADD      SP,SP,#+44
   \   00000092   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    291          void exchangeFlashMode(char dmaMode)
    292          {
   \                     exchangeFlashMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    293          	if(flash_dma_mode != dmaMode)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable14_19
   \   00000006   0xF991 0x2001      LDRSB    R2,[R1, #+1]
   \   0000000A   0x4282             CMP      R2,R0
   \   0000000C   0xD01B             BEQ.N    ??exchangeFlashMode_0
    294          	{
    295          		flash_dma_mode = dmaMode;
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
    296          		if(flash_dma_mode == 1)
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD102             BNE.N    ??exchangeFlashMode_1
    297          		{
    298          			//HAL_DMA_DeInit(huart1.hdmarx);
    299          			//dma1_5_IRQ_sel = 0;
    300          			DMAx_Init();//DMA1初始化
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x....             B.N      DMAx_Init
    301          			//MX_SPI2_Init();
    302          		}
    303          		else
    304          		{
    305          			//HAL_SPI_MspDeInit(&hspi2);
    306          			//HAL_DMA_DeInit(hspi2.hdmarx);
    307              	//HAL_DMA_DeInit(hspi2.hdmatx);
    308          			DMA_DeInit(DMA1_Channel4);
   \                     ??exchangeFlashMode_1: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable14_4  ;; 0x40020044
   \   0000001E   0x.... 0x....      BL       DMA_DeInit
    309          			DMA_DeInit(DMA1_Channel5);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable14_5  ;; 0x40020058
   \   00000026   0x.... 0x....      BL       DMA_DeInit
    310          			SPI_I2S_DMACmd (SPI2, SPI_I2S_DMAReq_Tx, DISABLE);
   \   0000002A   0x.... 0x....      LDR.W    R4,??DataTable14_18  ;; 0x40003800
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       SPI_I2S_DMACmd
    311          			SPI_I2S_DMACmd (SPI2, SPI_I2S_DMAReq_Rx, DISABLE);			
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000042   0x.... 0x....      B.W      SPI_I2S_DMACmd
    312          		}
    313          	}
    314          }
   \                     ??exchangeFlashMode_0: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    315          
    316          //读取芯片ID
    317          //返回值如下:				   
    318          //0XEF13,表示芯片型号为W25Q80  
    319          //0XEF14,表示芯片型号为W25Q16    
    320          //0XEF15,表示芯片型号为W25Q32  
    321          //0XEF16,表示芯片型号为W25Q64 
    322          //0XEF17,表示芯片型号为W25Q128 	  

   \                                 In section .text, align 2, keep-with-next
    323          u16 W25QXX_ReadID(void)
    324          {
   \                     W25QXX_ReadID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    325          	u16 Temp = 0;	  
    326          	W25QXX_CS=0;				    
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14_20  ;; 0x422181b0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
    327          	SPI2_ReadWriteByte(0x90);//发送读取ID命令	    
   \   0000000A   0x2090             MOVS     R0,#+144
   \   0000000C   0x.... 0x....      BL       SPI2_ReadWriteByte
    328          	SPI2_ReadWriteByte(0x00); 	    
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       SPI2_ReadWriteByte
    329          	SPI2_ReadWriteByte(0x00); 	    
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       SPI2_ReadWriteByte
    330          	SPI2_ReadWriteByte(0x00); 	 			   
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       SPI2_ReadWriteByte
    331          	Temp|=SPI2_ReadWriteByte(0xFF)<<8;  
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      BL       SPI2_ReadWriteByte
   \   00000028   0x0205             LSLS     R5,R0,#+8
    332          	Temp|=SPI2_ReadWriteByte(0xFF);	 
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x.... 0x....      BL       SPI2_ReadWriteByte
   \   00000030   0x4328             ORRS     R0,R0,R5
    333          	W25QXX_CS=1;				    
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x6021             STR      R1,[R4, #+0]
    334          	return Temp;
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    335          }   		    
    336          
    337          /*******************************************************************************
    338          * Function Name  : SPI_FLASH_SectorErase
    339          * Description    : Erases the specified FLASH sector.
    340          * Input          : SectorAddr: address of the sector to erase.
    341          * Output         : None
    342          * Return         : None
    343          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    344          void SPI_FLASH_SectorErase(u32 SectorAddr)
    345          {
   \                     SPI_FLASH_SectorErase: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    346            /* Send write enable instruction */
    347            SPI_FLASH_WriteEnable();
   \   00000004   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    348          
    349            /* Sector Erase */
    350            /* Select the FLASH: Chip Select low */
    351          	W25QXX_CS=0;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable14_20  ;; 0x422181b0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6028             STR      R0,[R5, #+0]
    352            /* Send Sector Erase instruction */
    353            SPI_FLASH_SendByte(W25X_SectorErase);
   \   00000010   0x2020             MOVS     R0,#+32
   \   00000012   0x.... 0x....      BL       SPI_FLASH_SendByte
    354            /* Send SectorAddr high nibble address byte */
    355            SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
   \   00000016   0x0C20             LSRS     R0,R4,#+16
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       SPI_FLASH_SendByte
    356            /* Send SectorAddr medium nibble address byte */
    357            SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
   \   0000001E   0x0A20             LSRS     R0,R4,#+8
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x.... 0x....      BL       SPI_FLASH_SendByte
    358            /* Send SectorAddr low nibble address byte */
    359            SPI_FLASH_SendByte(SectorAddr & 0xFF);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x.... 0x....      BL       SPI_FLASH_SendByte
    360            /* Deselect the FLASH: Chip Select high */
    361          
    362            W25QXX_CS=1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x6028             STR      R0,[R5, #+0]
    363            /* Wait the end of Flash writing */
    364            SPI_FLASH_WaitForWriteEnd();
   \   00000032   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000036   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    365          }
    366          
    367          /*******************************************************************************
    368          * Function Name  : SPI_FLASH_BulkErase
    369          * Description    : Erases the entire FLASH.
    370          * Input          : None
    371          * Output         : None
    372          * Return         : None
    373          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    374          void SPI_FLASH_BulkErase(void)
    375          {
   \                     SPI_FLASH_BulkErase: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    376            /* Send write enable instruction */
    377            SPI_FLASH_WriteEnable();
   \   00000002   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    378          
    379            /* Bulk Erase */
    380            /* Select the FLASH: Chip Select low */
    381          
    382          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-1
   \   00000006   0x....             LDR.N    R4,??DataTable14_20  ;; 0x422181b0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    383            
    384            /* Send Bulk Erase instruction  */
    385            SPI_FLASH_SendByte(W25X_ChipErase);
   \   0000000C   0x20C7             MOVS     R0,#+199
   \   0000000E   0x.... 0x....      BL       SPI_FLASH_SendByte
    386            /* Deselect the FLASH: Chip Select high */
    387          
    388          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x6020             STR      R0,[R4, #+0]
    389          
    390          
    391            /* Wait the end of Flash writing */
    392            SPI_FLASH_WaitForWriteEnd();
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    393          }
    394          
    395          /*******************************************************************************
    396          * Function Name  : SPI_FLASH_PageWrite
    397          * Description    : Writes more than one byte to the FLASH with a single WRITE
    398          *                  cycle(Page WRITE sequence). The number of byte can't exceed
    399          *                  the FLASH page size.
    400          * Input          : - pBuffer : pointer to the buffer  containing the data to be
    401          *                    written to the FLASH.
    402          *                  - WriteAddr : FLASH's internal address to write to.
    403          *                  - NumByteToWrite : number of bytes to write to the FLASH,
    404          *                    must be equal or less than "SPI_FLASH_PageSize" value.
    405          * Output         : None
    406          * Return         : None
    407          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          void SPI_FLASH_PageWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite)
    409          {
   \                     SPI_FLASH_PageWrite: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    410            /* Enable the write access to the FLASH */
    411            SPI_FLASH_WriteEnable();
   \   00000008   0x.... 0x....      BL       SPI_FLASH_WriteEnable
    412          
    413            /* Select the FLASH: Chip Select low */
    414            W25QXX_CS=0;
   \   0000000C   0x....             LDR.N    R7,??DataTable14_20  ;; 0x422181b0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6038             STR      R0,[R7, #+0]
    415            /* Send "Write to Memory " instruction */
    416            SPI_FLASH_SendByte(W25X_PageProgram);
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       SPI_FLASH_SendByte
    417            /* Send WriteAddr high nibble address byte to write to */
    418            SPI_FLASH_SendByte((WriteAddr & 0xFF0000) >> 16);
   \   00000018   0x0C28             LSRS     R0,R5,#+16
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x.... 0x....      BL       SPI_FLASH_SendByte
    419            /* Send WriteAddr medium nibble address byte to write to */
    420            SPI_FLASH_SendByte((WriteAddr & 0xFF00) >> 8);
   \   00000020   0x0A28             LSRS     R0,R5,#+8
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       SPI_FLASH_SendByte
    421            /* Send WriteAddr low nibble address byte to write to */
    422            SPI_FLASH_SendByte(WriteAddr & 0xFF);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       SPI_FLASH_SendByte
    423          
    424            if(NumByteToWrite > SPI_FLASH_PerWritePageSize)
   \   00000030   0xF5B6 0x7F80      CMP      R6,#+256
   \   00000034   0xDD06             BLE.N    ??SPI_FLASH_PageWrite_0
    425            {
    426               NumByteToWrite = SPI_FLASH_PerWritePageSize;
   \   00000036   0xF44F 0x7680      MOV      R6,#+256
   \   0000003A   0xE003             B.N      ??SPI_FLASH_PageWrite_0
    427              // printf("\n\r Err: SPI_FLASH_PageWrite too large!");
    428            }
    429          
    430            /* while there is data to be written on the FLASH */
    431            while (NumByteToWrite--)
    432            {
    433              /* Send the current byte */
    434              SPI_FLASH_SendByte(*pBuffer);
   \                     ??SPI_FLASH_PageWrite_1: (+1)
   \   0000003C   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000040   0x.... 0x....      BL       SPI_FLASH_SendByte
    435              /* Point on the next byte to be written */
    436              pBuffer++;
    437            }
   \                     ??SPI_FLASH_PageWrite_0: (+1)
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x1E46             SUBS     R6,R0,#+1
   \   00000048   0xB280             UXTH     R0,R0
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD1F6             BNE.N    ??SPI_FLASH_PageWrite_1
    438          
    439            /* Deselect the FLASH: Chip Select high */
    440            W25QXX_CS=1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x6038             STR      R0,[R7, #+0]
    441          
    442            /* Wait the end of Flash writing */
    443            SPI_FLASH_WaitForWriteEnd();
   \   00000052   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000056   0x....             B.N      SPI_FLASH_WaitForWriteEnd
    444          }
    445          
    446          /*******************************************************************************
    447          * Function Name  : SPI_FLASH_BufferWrite
    448          * Description    : Writes block of data to the FLASH. In this function, the
    449          *                  number of WRITE cycles are reduced, using Page WRITE sequence.
    450          * Input          : - pBuffer : pointer to the buffer  containing the data to be
    451          *                    written to the FLASH.
    452          *                  - WriteAddr : FLASH's internal address to write to.
    453          *                  - NumByteToWrite : number of bytes to write to the FLASH.
    454          * Output         : None
    455          * Return         : None
    456          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    457          void SPI_FLASH_BufferWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite)
    458          {
   \                     SPI_FLASH_BufferWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    459            u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
    460          
    461            Addr = WriteAddr % SPI_FLASH_PageSize;
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0xB2C0             UXTB     R0,R0
    462            count = SPI_FLASH_PageSize - Addr;
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x424E             RSBS     R6,R1,#+0
   \   00000010   0xB2F6             UXTB     R6,R6
    463            NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
   \   00000012   0x0A17             LSRS     R7,R2,#+8
    464            NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
   \   00000014   0x4690             MOV      R8,R2
   \   00000016   0xFA5F 0xF888      UXTB     R8,R8
    465          
    466            if (Addr == 0) /* WriteAddr is SPI_FLASH_PageSize aligned  */
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD111             BNE.N    ??SPI_FLASH_BufferWrite_0
    467            {
    468              if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PageSize */
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD020             BEQ.N    ??SPI_FLASH_BufferWrite_1
    469              {
    470                SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
    471              }
    472              else /* NumByteToWrite > SPI_FLASH_PageSize */
    473              {
    474                while (NumOfPage--)
   \                     ??SPI_FLASH_BufferWrite_2: (+1)
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x1E47             SUBS     R7,R0,#+1
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD03F             BEQ.N    ??SPI_FLASH_BufferWrite_3
    475                {
    476                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
   \   0000002C   0xF44F 0x7280      MOV      R2,#+256
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       SPI_FLASH_PageWrite
    477                  WriteAddr +=  SPI_FLASH_PageSize;
   \   00000038   0xF505 0x7580      ADD      R5,R5,#+256
    478                  pBuffer += SPI_FLASH_PageSize;
   \   0000003C   0xF504 0x7480      ADD      R4,R4,#+256
   \   00000040   0xE7EF             B.N      ??SPI_FLASH_BufferWrite_2
    479                }
    480          
    481                SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
    482              }
    483            }
    484            else /* WriteAddr is not SPI_FLASH_PageSize aligned  */
    485            {
    486              if (NumOfPage == 0) /* NumByteToWrite < SPI_FLASH_PageSize */
   \                     ??SPI_FLASH_BufferWrite_0: (+1)
   \   00000042   0x2F00             CMP      R7,#+0
   \   00000044   0xD113             BNE.N    ??SPI_FLASH_BufferWrite_4
    487              {
    488                if (NumOfSingle > count) /* (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize */
   \   00000046   0x4546             CMP      R6,R8
   \   00000048   0xDA0C             BGE.N    ??SPI_FLASH_BufferWrite_1
    489                {
    490                  temp = NumOfSingle - count;
    491          
    492                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
   \   0000004A   0x4632             MOV      R2,R6
   \   0000004C   0x4629             MOV      R1,R5
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       SPI_FLASH_PageWrite
    493                  WriteAddr +=  count;
    494                  pBuffer += count;
    495          
    496                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
   \   00000054   0xEBA8 0x0206      SUB      R2,R8,R6
   \   00000058   0xB2D2             UXTB     R2,R2
   \   0000005A   0x1971             ADDS     R1,R6,R5
   \   0000005C   0x1930             ADDS     R0,R6,R4
   \   0000005E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000062   0x....             B.N      SPI_FLASH_PageWrite
    497                }
    498                else
    499                {
    500                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
   \                     ??SPI_FLASH_BufferWrite_1: (+1)
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000006C   0x....             B.N      SPI_FLASH_PageWrite
    501                }
    502              }
    503              else /* NumByteToWrite > SPI_FLASH_PageSize */
    504              {
    505                NumByteToWrite -= count;
   \                     ??SPI_FLASH_BufferWrite_4: (+1)
   \   0000006E   0x1B92             SUBS     R2,R2,R6
    506                NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
   \   00000070   0xB292             UXTH     R2,R2
   \   00000072   0x0A17             LSRS     R7,R2,#+8
    507                NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
   \   00000074   0xB2D2             UXTB     R2,R2
   \   00000076   0x4690             MOV      R8,R2
    508          
    509                SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
   \   00000078   0x4632             MOV      R2,R6
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       SPI_FLASH_PageWrite
    510                WriteAddr +=  count;
   \   00000082   0x1975             ADDS     R5,R6,R5
    511                pBuffer += count;
   \   00000084   0x1934             ADDS     R4,R6,R4
   \   00000086   0xE009             B.N      ??SPI_FLASH_BufferWrite_5
    512          
    513                while (NumOfPage--)
    514                {
    515                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
   \                     ??SPI_FLASH_BufferWrite_6: (+1)
   \   00000088   0xF44F 0x7280      MOV      R2,#+256
   \   0000008C   0x4629             MOV      R1,R5
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       SPI_FLASH_PageWrite
    516                  WriteAddr +=  SPI_FLASH_PageSize;
   \   00000094   0xF505 0x7580      ADD      R5,R5,#+256
    517                  pBuffer += SPI_FLASH_PageSize;
   \   00000098   0xF504 0x7480      ADD      R4,R4,#+256
    518                }
   \                     ??SPI_FLASH_BufferWrite_5: (+1)
   \   0000009C   0x4638             MOV      R0,R7
   \   0000009E   0x1E47             SUBS     R7,R0,#+1
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD1F0             BNE.N    ??SPI_FLASH_BufferWrite_6
    519          
    520                if (NumOfSingle != 0)
   \   000000A6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AA   0xD005             BEQ.N    ??SPI_FLASH_BufferWrite_7
    521                {
    522                  SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
   \                     ??SPI_FLASH_BufferWrite_3: (+1)
   \   000000AC   0x4642             MOV      R2,R8
   \   000000AE   0x4629             MOV      R1,R5
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000B6   0x....             B.N      SPI_FLASH_PageWrite
    523                }
    524              }
    525            }
    526          }
   \                     ??SPI_FLASH_BufferWrite_7: (+1)
   \   000000B8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    527          
    528          /*******************************************************************************
    529          * Function Name  : SPI_FLASH_BufferRead
    530          * Description    : Reads a block of data from the FLASH.
    531          * Input          : - pBuffer : pointer to the buffer that receives the data read
    532          *                    from the FLASH.
    533          *                  - ReadAddr : FLASH's internal address to read from.
    534          *                  - NumByteToRead : number of bytes to read from the FLASH.
    535          * Output         : None
    536          * Return         : None
    537          *******************************************************************************/
    538          
    539          /*
    540          STM32F103
    541          SPI2_RX DMA1_Channel 4
    542          SPI2_TX DAM1_Channel 5
    543          STM32F407
    544          SPI1_RX DMA2_Stream0
    545          SPI1_TX DMA2_Stream3
    546          */
    547          extern DMA_HandleTypeDef hdma_spi2_rx;

   \                                 In section .text, align 2, keep-with-next
    548          void SPI_FLASH_BufferRead(u8* pBuffer, u32 ReadAddr, u16 NumByteToRead)
    549          {
   \                     SPI_FLASH_BufferRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
    550            /* Select the FLASH: Chip Select low */
    551            W25QXX_CS=0;
   \   00000008   0x....             LDR.N    R4,??DataTable14_20  ;; 0x422181b0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    552          
    553            /* Send "Read from Memory " instruction */
    554            SPI_FLASH_SendByte(W25X_ReadData);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    555          
    556            /* Send ReadAddr high nibble address byte to read from */
    557            SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000014   0x0C38             LSRS     R0,R7,#+16
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x.... 0x....      BL       SPI_FLASH_SendByte
    558            /* Send ReadAddr medium nibble address byte to read from */
    559            SPI_FLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   0000001C   0x0A38             LSRS     R0,R7,#+8
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x.... 0x....      BL       SPI_FLASH_SendByte
    560            /* Send ReadAddr low nibble address byte to read from */
    561            SPI_FLASH_SendByte(ReadAddr & 0xFF);
   \   00000024   0x4638             MOV      R0,R7
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x.... 0x....      BL       SPI_FLASH_SendByte
    562          
    563            if((NumByteToRead<33)	|| (!flash_dma_mode))
   \   0000002C   0x2E21             CMP      R6,#+33
   \   0000002E   0xDB04             BLT.N    ??SPI_FLASH_BufferRead_0
   \   00000030   0x....             LDR.N    R0,??DataTable14_19
   \   00000032   0xF990 0x1001      LDRSB    R1,[R0, #+1]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD10A             BNE.N    ??SPI_FLASH_BufferRead_1
    564            {
    565              while (NumByteToRead--) /* while there is data to be read */
   \                     ??SPI_FLASH_BufferRead_0: (+1)
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x1E46             SUBS     R6,R0,#+1
   \   0000003E   0xB280             UXTH     R0,R0
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD047             BEQ.N    ??SPI_FLASH_BufferRead_2
    566              {
    567                /* Read a byte from the FLASH */
    568                *pBuffer = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000044   0x20A5             MOVS     R0,#+165
   \   00000046   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   0000004A   0xF805 0x0B01      STRB     R0,[R5], #+1
    569                /* Point to the next location where the byte read will be saved */
    570                pBuffer++;
   \   0000004E   0xE7F4             B.N      ??SPI_FLASH_BufferRead_0
    571              }
    572            }
    573            else
    574            {
    575            #if 0
    576            		//dma1_5_IRQ_sel = 0;
    577                HAL_SPI_Receive_DMA(&hspi2, pBuffer, NumByteToRead);      //启动DMA接收
    578                while(hdma_spi2_rx.State ==HAL_DMA_STATE_BUSY);          //等待DMA接收完成
    579                
    580                //此时会触发中断  void DMA2_Stream2_IRQHandler(void)
    581          			#endif
    582                DMA1_Channel5->CCR &= ~( 1 << 0 ) ; 				//关闭DMA通道5
   \                     ??SPI_FLASH_BufferRead_1: (+1)
   \   00000050   0x....             LDR.N    R1,??DataTable14_21  ;; 0x40020000
   \   00000052   0x6D8A             LDR      R2,[R1, #+88]
   \   00000054   0x0852             LSRS     R2,R2,#+1
   \   00000056   0x0052             LSLS     R2,R2,#+1
   \   00000058   0x658A             STR      R2,[R1, #+88]
    583                DMA1_Channel4->CCR &= ~( 1 << 0 ) ; 				//关闭DMA通道4
   \   0000005A   0x6C4A             LDR      R2,[R1, #+68]
   \   0000005C   0x0852             LSRS     R2,R2,#+1
   \   0000005E   0x0052             LSLS     R2,R2,#+1
   \   00000060   0x644A             STR      R2,[R1, #+68]
    584                     
    585                DMA1_Channel5->CMAR = (u32)&tx_buf ; //设置DMA存储器地址，注意MSIZE
   \   00000062   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000066   0x664A             STR      R2,[R1, #+100]
    586                DMA1_Channel4->CMAR = (u32)pBuffer ; //设置DMA存储器地址，注意MSIZE
   \   00000068   0x650D             STR      R5,[R1, #+80]
    587                
    588                DMA1_Channel4->CNDTR = 0x0000 	; 					//传输数量寄存器清零
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x648A             STR      R2,[R1, #+72]
    589                DMA1_Channel4->CNDTR = NumByteToRead ;				 //传输数量设置为buffersize个
   \   0000006E   0x648E             STR      R6,[R1, #+72]
    590                
    591                DMA1_Channel5->CNDTR = 0x0000 	; 					//传输数量寄存器清零
   \   00000070   0x65CA             STR      R2,[R1, #+92]
    592                DMA1_Channel5->CNDTR = NumByteToRead ;				 //传输数量设置为buffersize个
   \   00000072   0x65CE             STR      R6,[R1, #+92]
    593                
    594                DMA1->IFCR = 0xF000 ; 												//清除通道4的标志位
   \   00000074   0xF44F 0x4270      MOV      R2,#+61440
   \   00000078   0x604A             STR      R2,[R1, #+4]
    595                DMA1->IFCR = 0xF0000 ;												//清除通道5的标志位
   \   0000007A   0xF44F 0x2270      MOV      R2,#+983040
   \   0000007E   0x604A             STR      R2,[R1, #+4]
    596                
    597                SPI2->DR ;									//接送前读一次SPI1->DR，保证接收缓冲区为空
   \   00000080   0x....             LDR.N    R2,??DataTable14_22  ;; 0x40003808
   \   00000082   0x6853             LDR      R3,[R2, #+4]
    598                dummynum = 200000;
   \   00000084   0x....             LDR.N    R3,??DataTable14_23  ;; 0x30d40
   \   00000086   0x6043             STR      R3,[R0, #+4]
    599                while(((SPI2->SR & 0x02) == 0)&&((dummynum--)!=0));
   \                     ??SPI_FLASH_BufferRead_3: (+1)
   \   00000088   0x6815             LDR      R5,[R2, #+0]
   \   0000008A   0x07AD             LSLS     R5,R5,#+30
   \   0000008C   0xD404             BMI.N    ??SPI_FLASH_BufferRead_4
   \   0000008E   0x6845             LDR      R5,[R0, #+4]
   \   00000090   0x1E6E             SUBS     R6,R5,#+1
   \   00000092   0x6046             STR      R6,[R0, #+4]
   \   00000094   0x2D00             CMP      R5,#+0
   \   00000096   0xD1F7             BNE.N    ??SPI_FLASH_BufferRead_3
    600                
    601                DMA1_Channel5->CCR |= 1 << 0 ;							//开启DMA通道5
   \                     ??SPI_FLASH_BufferRead_4: (+1)
   \   00000098   0x6D8A             LDR      R2,[R1, #+88]
   \   0000009A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000009E   0x658A             STR      R2,[R1, #+88]
    602                DMA1_Channel4->CCR |= 1 << 0 ;							//开启DMA通道4	
   \   000000A0   0x6C4A             LDR      R2,[R1, #+68]
   \   000000A2   0xF042 0x0201      ORR      R2,R2,#0x1
   \   000000A6   0x644A             STR      R2,[R1, #+68]
    603                
    604                dummynum = 200000;
   \   000000A8   0x6043             STR      R3,[R0, #+4]
    605                while(((DMA1->ISR & 0x2000)== 0)&&((dummynum--)!=0));
   \                     ??SPI_FLASH_BufferRead_5: (+1)
   \   000000AA   0x680A             LDR      R2,[R1, #+0]
   \   000000AC   0x0492             LSLS     R2,R2,#+18
   \   000000AE   0xD404             BMI.N    ??SPI_FLASH_BufferRead_6
   \   000000B0   0x6842             LDR      R2,[R0, #+4]
   \   000000B2   0x1E53             SUBS     R3,R2,#+1
   \   000000B4   0x6043             STR      R3,[R0, #+4]
   \   000000B6   0x2A00             CMP      R2,#+0
   \   000000B8   0xD1F7             BNE.N    ??SPI_FLASH_BufferRead_5
    606                
    607                DMA1_Channel5->CCR &= ~( 1 << 0 ) ; 				//关闭DMA通道5
   \                     ??SPI_FLASH_BufferRead_6: (+1)
   \   000000BA   0x6D8A             LDR      R2,[R1, #+88]
   \   000000BC   0x0852             LSRS     R2,R2,#+1
   \   000000BE   0x0052             LSLS     R2,R2,#+1
   \   000000C0   0x658A             STR      R2,[R1, #+88]
    608                DMA1_Channel4->CCR &= ~( 1 << 0 ) ; 				//关闭DMA通道4
   \   000000C2   0x6C4A             LDR      R2,[R1, #+68]
   \   000000C4   0x0852             LSRS     R2,R2,#+1
   \   000000C6   0x0052             LSLS     R2,R2,#+1
   \   000000C8   0x644A             STR      R2,[R1, #+68]
    609          
    610                if(DMA1_Channel4->CNDTR != 0)
   \   000000CA   0x6C89             LDR      R1,[R1, #+72]
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD001             BEQ.N    ??SPI_FLASH_BufferRead_2
    611                {
    612                    DMA_ERRO_FLAG = 1;
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x7001             STRB     R1,[R0, #+0]
    613                }         			
    614             }
    615            W25QXX_CS=1;
   \                     ??SPI_FLASH_BufferRead_2: (+1)
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6020             STR      R0,[R4, #+0]
    616          }
   \   000000D8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    617          
    618          /*******************************************************************************
    619          * Function Name  : SPI_FLASH_ReadID
    620          * Description    : Reads FLASH identification.
    621          * Input          : None
    622          * Output         : None
    623          * Return         : FLASH identification
    624          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    625          u32 SPI_FLASH_ReadID(void)
    626          {
   \                     SPI_FLASH_ReadID: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    627            u32 Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
    628          
    629            /* Select the FLASH: Chip Select low */
    630           
    631          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-2
   \   00000002   0x....             LDR.N    R4,??DataTable14_20  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    632          
    633          
    634            /* Send "RDID " instruction */
    635            SPI_FLASH_SendByte(W25X_JedecDeviceID);
   \   00000008   0x209F             MOVS     R0,#+159
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    636          
    637            /* Read a byte from the FLASH */
    638            Temp0 = SPI_FLASH_SendByte(Dummy_Byte);
   \   0000000E   0x20A5             MOVS     R0,#+165
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000014   0x4605             MOV      R5,R0
    639          
    640            /* Read a byte from the FLASH */
    641            Temp1 = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000016   0x20A5             MOVS     R0,#+165
   \   00000018   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   0000001C   0x4606             MOV      R6,R0
    642          
    643            /* Read a byte from the FLASH */
    644            Temp2 = SPI_FLASH_SendByte(Dummy_Byte);
   \   0000001E   0x20A5             MOVS     R0,#+165
   \   00000020   0x.... 0x....      BL       SPI_FLASH_SendByte
    645          
    646            /* Deselect the FLASH: Chip Select high */
    647          
    648          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x6021             STR      R1,[R4, #+0]
    649          
    650          
    651            Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
    652          
    653            return Temp;
   \   00000028   0x0231             LSLS     R1,R6,#+8
   \   0000002A   0xEA41 0x4105      ORR      R1,R1,R5, LSL #+16
   \   0000002E   0x4308             ORRS     R0,R0,R1
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    654          }
    655          /*******************************************************************************
    656          * Function Name  : SPI_FLASH_ReadID
    657          * Description    : Reads FLASH identification.
    658          * Input          : None
    659          * Output         : None
    660          * Return         : FLASH identification
    661          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    662          u32 SPI_FLASH_ReadDeviceID(void)
    663          {
   \                     SPI_FLASH_ReadDeviceID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    664            u32 Temp = 0;
    665          
    666            /* Select the FLASH: Chip Select low */
    667          
    668          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-3
   \   00000002   0x....             LDR.N    R4,??DataTable14_20  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    669          
    670          
    671            /* Send "RDID " instruction */
    672            SPI_FLASH_SendByte(W25X_DeviceID);
   \   00000008   0x20AB             MOVS     R0,#+171
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    673            SPI_FLASH_SendByte(Dummy_Byte);
   \   0000000E   0x20A5             MOVS     R0,#+165
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
    674            SPI_FLASH_SendByte(Dummy_Byte);
   \   00000014   0x20A5             MOVS     R0,#+165
   \   00000016   0x.... 0x....      BL       SPI_FLASH_SendByte
    675            SPI_FLASH_SendByte(Dummy_Byte);
   \   0000001A   0x20A5             MOVS     R0,#+165
   \   0000001C   0x.... 0x....      BL       SPI_FLASH_SendByte
    676            
    677            /* Read a byte from the FLASH */
    678            Temp = SPI_FLASH_SendByte(Dummy_Byte);
   \   00000020   0x20A5             MOVS     R0,#+165
   \   00000022   0x.... 0x....      BL       SPI_FLASH_SendByte
    679          
    680            /* Deselect the FLASH: Chip Select high */
    681          
    682          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x6021             STR      R1,[R4, #+0]
    683          
    684          
    685            return Temp;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    686          }
    687          /*******************************************************************************
    688          * Function Name  : SPI_FLASH_StartReadSequence
    689          * Description    : Initiates a read data byte (READ) sequence from the Flash.
    690          *                  This is done by driving the /CS line low to select the device,
    691          *                  then the READ instruction is transmitted followed by 3 bytes
    692          *                  address. This function exit and keep the /CS line low, so the
    693          *                  Flash still being selected. With this technique the whole
    694          *                  content of the Flash is read with a single READ instruction.
    695          * Input          : - ReadAddr : FLASH's internal address to read from.
    696          * Output         : None
    697          * Return         : None
    698          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    699          void SPI_FLASH_StartReadSequence(u32 ReadAddr)
    700          {
   \                     SPI_FLASH_StartReadSequence: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    701            /* Select the FLASH: Chip Select low */
    702          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-4
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable14_20  ;; 0x422181b0
   \   00000008   0x6008             STR      R0,[R1, #+0]
    703            
    704          
    705            /* Send "Read from Memory " instruction */
    706            SPI_FLASH_SendByte(W25X_ReadData);
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x.... 0x....      BL       SPI_FLASH_SendByte
    707          
    708            /* Send the 24-bit address of the address to read from -----------------------*/
    709            /* Send ReadAddr high nibble address byte */
    710            SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000010   0x0C20             LSRS     R0,R4,#+16
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x.... 0x....      BL       SPI_FLASH_SendByte
    711            /* Send ReadAddr medium nibble address byte */
    712            SPI_FLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   00000018   0x0A20             LSRS     R0,R4,#+8
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x.... 0x....      BL       SPI_FLASH_SendByte
    713            /* Send ReadAddr low nibble address byte */
    714            SPI_FLASH_SendByte(ReadAddr & 0xFF);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x....             B.N      SPI_FLASH_SendByte
    715          }
    716          
    717          /*******************************************************************************
    718          * Function Name  : SPI_FLASH_ReadByte
    719          * Description    : Reads a byte from the SPI Flash.
    720          *                  This function must be used only if the Start_Read_Sequence
    721          *                  function has been previously called.
    722          * Input          : None
    723          * Output         : None
    724          * Return         : Byte Read from the SPI Flash.
    725          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    726          u8 SPI_FLASH_ReadByte(void)
    727          {
    728            return (SPI_FLASH_SendByte(Dummy_Byte));
   \                     SPI_FLASH_ReadByte: (+1)
   \   00000000   0x20A5             MOVS     R0,#+165
   \   00000002                      REQUIRE SPI_FLASH_SendByte
   \   00000002                      ;; // Fall through to label SPI_FLASH_SendByte
    729          }
    730          
    731          /*******************************************************************************
    732          * Function Name  : SPI_FLASH_SendByte
    733          * Description    : Sends a byte through the SPI interface and return the byte
    734          *                  received from the SPI bus.
    735          * Input          : byte : byte to send.
    736          * Output         : None
    737          * Return         : The value of the received byte.
    738          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    739          u8 SPI_FLASH_SendByte(u8 byte)
    740          {
   \                     SPI_FLASH_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable14_18  ;; 0x40003800
    741            /* Loop while DR register in not emplty */
    742            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??SPI_FLASH_SendByte_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ.N    ??SPI_FLASH_SendByte_0
    743          
    744            /* Send byte through the SPI1 peripheral */
    745            SPI_I2S_SendData(SPI2, byte);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       SPI_I2S_SendData
    746          
    747            /* Wait to receive a byte */
    748            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??SPI_FLASH_SendByte_1: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??SPI_FLASH_SendByte_1
    749          
    750            /* Return the byte read from the SPI bus */
    751            return SPI_I2S_ReceiveData(SPI2);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       SPI_I2S_ReceiveData
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    752          }
    753          
    754          /*******************************************************************************
    755          * Function Name  : SPI_FLASH_SendHalfWord
    756          * Description    : Sends a Half Word through the SPI interface and return the
    757          *                  Half Word received from the SPI bus.
    758          * Input          : Half Word : Half Word to send.
    759          * Output         : None
    760          * Return         : The value of the received Half Word.
    761          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    762          u16 SPI_FLASH_SendHalfWord(u16 HalfWord)
    763          {
   \                     SPI_FLASH_SendHalfWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable14_18  ;; 0x40003800
    764            /* Loop while DR register in not emplty */
    765            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??SPI_FLASH_SendHalfWord_0: (+1)
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD0F9             BEQ.N    ??SPI_FLASH_SendHalfWord_0
    766          
    767            /* Send Half Word through the SPI1 peripheral */
    768            SPI_I2S_SendData(SPI2, HalfWord);
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       SPI_I2S_SendData
    769          
    770            /* Wait to receive a Half Word */
    771            while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??SPI_FLASH_SendHalfWord_1: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ.N    ??SPI_FLASH_SendHalfWord_1
    772          
    773            /* Return the Half Word read from the SPI bus */
    774            return SPI_I2S_ReceiveData(SPI2);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x.... 0x....      B.W      SPI_I2S_ReceiveData
    775          }
    776          
    777          /*******************************************************************************
    778          * Function Name  : SPI_FLASH_WriteEnable
    779          * Description    : Enables the write access to the FLASH.
    780          * Input          : None
    781          * Output         : None
    782          * Return         : None
    783          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    784          void SPI_FLASH_WriteEnable(void)
    785          {
   \                     SPI_FLASH_WriteEnable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    786            /* Select the FLASH: Chip Select low */
    787          
    788          	W25QXX_CS=0;
   \   00000002   0x....             LDR.N    R4,??DataTable14_20  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    789            /* Send "Write Enable" instruction */
    790            SPI_FLASH_SendByte(W25X_WriteEnable);
   \   00000008   0x2006             MOVS     R0,#+6
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    791          
    792            /* Deselect the FLASH: Chip Select high */
    793          	W25QXX_CS=1;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x6020             STR      R0,[R4, #+0]
    794          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    795          
    796          /*******************************************************************************
    797          * Function Name  : SPI_FLASH_WaitForWriteEnd
    798          * Description    : Polls the status of the Write In Progress (WIP) flag in the
    799          *                  FLASH's status  register  and  loop  until write  opertaion
    800          *                  has completed.
    801          * Input          : None
    802          * Output         : None
    803          * Return         : None
    804          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    805          void SPI_FLASH_WaitForWriteEnd(void)
    806          {
   \                     SPI_FLASH_WaitForWriteEnd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    807            u8 FLASH_Status = 0;
    808          
    809            /* Select the FLASH: Chip Select low */
    810            W25QXX_CS=0;
   \   00000002   0x....             LDR.N    R4,??DataTable14_20  ;; 0x422181b0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    811            /* Send "Read Status Register" instruction */
    812            SPI_FLASH_SendByte(W25X_ReadStatusReg);
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_SendByte
    813          
    814            /* Loop as long as the memory is busy with a write cycle */
    815            do
    816            {
    817              /* Send a dummy byte to generate the clock needed by the FLASH
    818              and put the value of the status register in FLASH_Status variable */
    819              FLASH_Status = SPI_FLASH_SendByte(Dummy_Byte);
    820          
    821            }
    822            while ((FLASH_Status & WIP_Flag) == SET); /* Write in progress */
   \                     ??SPI_FLASH_WaitForWriteEnd_0: (+1)
   \   0000000E   0x20A5             MOVS     R0,#+165
   \   00000010   0x.... 0x....      BL       SPI_FLASH_SendByte
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD4FA             BMI.N    ??SPI_FLASH_WaitForWriteEnd_0
    823          
    824            /* Deselect the FLASH: Chip Select high */
    825            W25QXX_CS=1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    826          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    827          
    828          
    829          //进入掉电模式

   \                                 In section .text, align 2, keep-with-next
    830          void SPI_Flash_PowerDown(void)   
    831          { 
    832            /* Select the FLASH: Chip Select low */
    833          #if 0
    834          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-5
    835          	
    836          
    837            /* Send "Power Down" instruction */
    838            SPI_FLASH_SendByte(W25X_PowerDown);
    839          
    840            /* Deselect the FLASH: Chip Select high */
    841          
    842          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
    843          #endif
    844          }   
   \                     SPI_Flash_PowerDown: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    845          
    846          //唤醒

   \                                 In section .text, align 2, keep-with-next
    847          void SPI_Flash_WAKEUP(void)   
    848          {
    849            /* Select the FLASH: Chip Select low */
    850          #if 0
    851          	W25QXX_CS=0;//SPI_FLASH_CS_LOW();-6
    852          
    853          
    854            /* Send "Power Down" instruction */
    855            SPI_FLASH_SendByte(W25X_ReleasePowerDown);
    856          
    857            /* Deselect the FLASH: Chip Select high */
    858          
    859          	W25QXX_CS=1;//SPI_FLASH_CS_HIGH();
    860                                  //等待TRES1
    861          #endif	
    862          }   
   \                     SPI_Flash_WAKEUP: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x4002001C         DC32     0x4002001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40020030         DC32     0x40020030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x40020044         DC32     0x40020044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x40020058         DC32     0x40020058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x4002006C         DC32     0x4002006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x40020080         DC32     0x40020080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x40020408         DC32     0x40020408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x40020404         DC32     0x40020404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x4002041C         DC32     0x4002041c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x40020430         DC32     0x40020430

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x40020444         DC32     0x40020444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x40020458         DC32     0x40020458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x40021014         DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x4000380C         DC32     0x4000380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     bmp_public_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     DMA_ERRO_FLAG+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \   00000000   0x........         DC32     DMA_ERRO_FLAG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \   00000000   0x422181B0         DC32     0x422181b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_22:
   \   00000000   0x40003808         DC32     0x40003808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_23:
   \   00000000   0x00030D40         DC32     0x30d40
    863          
    864          /******************* (C) COPYRIGHT 2010 www.armjishu.com *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA_DeInit
       0   DMA_Init
      56   DMAx_Init
        56   -> DMA_DeInit
        56   -> DMA_Init
        56   -> SPI_I2S_DMACmd
      24   SPI_FLASH_BufferRead
        24   -> SPI_FLASH_SendByte
      24   SPI_FLASH_BufferWrite
         0   -> SPI_FLASH_PageWrite
        24   -> SPI_FLASH_PageWrite
       8   SPI_FLASH_BulkErase
         8   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_WriteEnable
      24   SPI_FLASH_PageWrite
        24   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
        24   -> SPI_FLASH_WriteEnable
       0   SPI_FLASH_ReadByte
         0   -> SPI_FLASH_SendByte
       8   SPI_FLASH_ReadDeviceID
         8   -> SPI_FLASH_SendByte
      16   SPI_FLASH_ReadID
        16   -> SPI_FLASH_SendByte
      16   SPI_FLASH_SectorErase
        16   -> SPI_FLASH_SendByte
         0   -> SPI_FLASH_WaitForWriteEnd
        16   -> SPI_FLASH_WriteEnable
      16   SPI_FLASH_SendByte
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   SPI_FLASH_SendHalfWord
        16   -> SPI_I2S_GetFlagStatus
         0   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
       8   SPI_FLASH_StartReadSequence
         0   -> SPI_FLASH_SendByte
         8   -> SPI_FLASH_SendByte
       8   SPI_FLASH_WaitForWriteEnd
         8   -> SPI_FLASH_SendByte
       8   SPI_FLASH_WriteEnable
         8   -> SPI_FLASH_SendByte
       0   SPI_Flash_PowerDown
       0   SPI_Flash_WAKEUP
      16   W25QXX_ReadID
        16   -> SPI2_ReadWriteByte
       8   exchangeFlashMode
         8   -> DMA_DeInit
         0   -> DMAx_Init
         0   -> SPI_I2S_DMACmd
         8   -> SPI_I2S_DMACmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
     284  DMA_DeInit
       9  DMA_ERRO_FLAG
          flash_dma_mode
          dummynum
          tx_buf
      54  DMA_Init
     148  DMAx_Init
     218  SPI_FLASH_BufferRead
     188  SPI_FLASH_BufferWrite
      28  SPI_FLASH_BulkErase
      88  SPI_FLASH_PageWrite
       2  SPI_FLASH_ReadByte
      44  SPI_FLASH_ReadDeviceID
      50  SPI_FLASH_ReadID
      56  SPI_FLASH_SectorErase
      48  SPI_FLASH_SendByte
      48  SPI_FLASH_SendHalfWord
      42  SPI_FLASH_StartReadSequence
      30  SPI_FLASH_WaitForWriteEnd
      20  SPI_FLASH_WriteEnable
       2  SPI_Flash_PowerDown
       2  SPI_Flash_WAKEUP
      56  W25QXX_ReadID
      72  exchangeFlashMode

 
     9 bytes in section .data
 1 576 bytes in section .text
 
 1 576 bytes of CODE memory
     9 bytes of DATA memory

Errors: none
Warnings: 49
