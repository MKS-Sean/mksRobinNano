###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:47
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\planner.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\planner.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * planner.cpp
     25           *
     26           * Buffer movement commands and manage the acceleration profile plan
     27           *
     28           * Derived from Grbl
     29           * Copyright (c) 2009-2011 Simen Svale Skogsrud
     30           *
     31           * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
     32           *
     33           *
     34           * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
     35           *
     36           * s == speed, a == acceleration, t == time, d == distance
     37           *
     38           * Basic definitions:
     39           *   Speed[s_, a_, t_] := s + (a*t)
     40           *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
     41           *
     42           * Distance to reach a specific speed with a constant acceleration:
     43           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
     44           *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
     45           *
     46           * Speed after a given distance of travel with constant acceleration:
     47           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
     48           *   m -> Sqrt[2 a d + s^2]
     49           *
     50           * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
     51           *
     52           * When to start braking (di) to reach a specified destination speed (s2) after accelerating
     53           * from initial speed s1 without ever stopping at a plateau:
     54           *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
     55           *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
     56           *
     57           * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
     58           *
     59           */
     60          #include "Marlin.h"

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp long CORESIGN(long)
   \                     _Z8CORESIGNl: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000004   0xF891 0x1058      LDRB     R1,[R1, #+88]
   \   00000008   0x22A8             MOVS     R2,#+168
   \   0000000A   0x4211             TST      R1,R2
   \   0000000C   0xD000             BEQ.N    ??CORESIGN_0
   \   0000000E   0x4240             RSBS     R0,R0,#+0
   \                     ??CORESIGN_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     61          
     62          #include "MarlinConfig.h"
     63          #include "planner.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::refresh_e_factor(uint8_t)
   \                     _ZN7Planner16refresh_e_factorEh: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x4F0D             LDR.N    R7,??refresh_e_factor_0
   \   00000006   0xF937 0x0016      LDRSH    R0,[R7, R6, LSL #+1]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2d
   \   0000000E   0x4A0C             LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
   \   00000010   0x4B0C             LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
   \   00000012   0x.... 0x....      BL       __aeabi_dmul
   \   00000016   0x4604             MOV      R4,R0
   \   00000018   0x460D             MOV      R5,R1
   \   0000001A   0xEB07 0x0086      ADD      R0,R7,R6, LSL #+2
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x.... 0x....      BL       __aeabi_d2f
   \   00000030   0x4905             LDR.N    R1,??refresh_e_factor_0+0xC
   \   00000032   0xEB01 0x0186      ADD      R1,R1,R6, LSL #+2
   \   00000036   0x6508             STR      R0,[R1, #+80]
   \   00000038   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??refresh_e_factor_0:
   \   0000003C   0x........         DC32     _ZN7Planner15flow_percentageE
   \   00000040   0x47AE147B         DC32     0x47ae147b
   \   00000044   0x3F847AE1         DC32     0x3f847ae1
   \   00000048   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4
   \   __interwork __softfp uint8_t Planner::movesplanned()
   \                     _ZN7Planner12movesplannedEv: (+1)
   \   00000000   0x4803             LDR.N    R0,??movesplanned_0
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x1A08             SUBS     R0,R1,R0
   \   00000008   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000C   0x4770             BX       LR               ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??movesplanned_0:
   \   00000010   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??blocks_queued_0
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD001             BEQ.N    ??blocks_queued_1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??blocks_queued_0:
   \   00000014   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 2

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless
   \   __interwork __softfp signed char const Planner::next_block_index(int8_t)
   \                     _ZN7Planner16next_block_indexEa: (+1)
   \   00000000   0x1C40             ADDS     R0,R0,#+1
   \   00000002   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless
   \   __interwork __softfp signed char const Planner::prev_block_index(int8_t)
   \                     _ZN7Planner16prev_block_indexEa: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float Planner::estimate_acceleration_distance(float const &, float const &, float const &)
   \                     _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000012   0xD101             BNE.N    ??estimate_acceleration_distance_0
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0xE03B             B.N      ??estimate_acceleration_distance_1
   \                     ??estimate_acceleration_distance_0: (+1)
   \   00000018   0xF8D3 0x8000      LDR      R8,[R3, #+0]
   \   0000001C   0xF04F 0x0902      MOV      R9,#+2
   \   00000020   0xF04F 0x557E      MOV      R5,#+1065353216
   \   00000024   0x462E             MOV      R6,R5
   \   00000026   0xE004             B.N      ??estimate_acceleration_distance_2
   \                     ??estimate_acceleration_distance_3: (+1)
   \   00000028   0x4640             MOV      R0,R8
   \   0000002A   0x4641             MOV      R1,R8
   \   0000002C   0x.... 0x....      BL       __aeabi_fmul
   \   00000030   0x4680             MOV      R8,R0
   \                     ??estimate_acceleration_distance_2: (+1)
   \   00000032   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000036   0xD504             BPL.N    ??estimate_acceleration_distance_4
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x4641             MOV      R1,R8
   \   0000003C   0x.... 0x....      BL       __aeabi_fmul
   \   00000040   0x4606             MOV      R6,R0
   \                     ??estimate_acceleration_distance_4: (+1)
   \   00000042   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000046   0xD1EF             BNE.N    ??estimate_acceleration_distance_3
   \   00000048   0x683F             LDR      R7,[R7, #+0]
   \   0000004A   0xF04F 0x0802      MOV      R8,#+2
   \   0000004E   0xE004             B.N      ??estimate_acceleration_distance_5
   \                     ??estimate_acceleration_distance_6: (+1)
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x4639             MOV      R1,R7
   \   00000054   0x.... 0x....      BL       __aeabi_fmul
   \   00000058   0x4607             MOV      R7,R0
   \                     ??estimate_acceleration_distance_5: (+1)
   \   0000005A   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000005E   0xD504             BPL.N    ??estimate_acceleration_distance_7
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x4639             MOV      R1,R7
   \   00000064   0x.... 0x....      BL       __aeabi_fmul
   \   00000068   0x4605             MOV      R5,R0
   \                     ??estimate_acceleration_distance_7: (+1)
   \   0000006A   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   0000006E   0xD1EF             BNE.N    ??estimate_acceleration_distance_6
   \   00000070   0x4630             MOV      R0,R6
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0x.... 0x....      BL       __aeabi_fsub
   \   00000078   0x4605             MOV      R5,R0
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000080   0x.... 0x....      BL       __aeabi_fmul
   \   00000084   0x4601             MOV      R1,R0
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   0000008C   0x.... 0x....      B.W      __aeabi_fdiv
   \                     ??estimate_acceleration_distance_1: (+1)
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float Planner::intersection_distance(float const &, float const &, float const &, float const &)
   \                     _ZN7Planner21intersection_distanceERKfS1_S1_S1_: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000014   0xD101             BNE.N    ??intersection_distance_0
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0xE047             B.N      ??intersection_distance_1
   \                     ??intersection_distance_0: (+1)
   \   0000001A   0xF8D6 0x9000      LDR      R9,[R6, #+0]
   \   0000001E   0xF04F 0x0A02      MOV      R10,#+2
   \   00000022   0xF04F 0x567E      MOV      R6,#+1065353216
   \   00000026   0x4637             MOV      R7,R6
   \   00000028   0xE004             B.N      ??intersection_distance_2
   \                     ??intersection_distance_3: (+1)
   \   0000002A   0x4648             MOV      R0,R9
   \   0000002C   0x4649             MOV      R1,R9
   \   0000002E   0x.... 0x....      BL       __aeabi_fmul
   \   00000032   0x4681             MOV      R9,R0
   \                     ??intersection_distance_2: (+1)
   \   00000034   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000038   0xD504             BPL.N    ??intersection_distance_4
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x.... 0x....      BL       __aeabi_fmul
   \   00000042   0x4607             MOV      R7,R0
   \                     ??intersection_distance_4: (+1)
   \   00000044   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000048   0xD1EF             BNE.N    ??intersection_distance_3
   \   0000004A   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   0000004E   0xF04F 0x0902      MOV      R9,#+2
   \   00000052   0xE004             B.N      ??intersection_distance_5
   \                     ??intersection_distance_6: (+1)
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x4641             MOV      R1,R8
   \   00000058   0x.... 0x....      BL       __aeabi_fmul
   \   0000005C   0x4680             MOV      R8,R0
   \                     ??intersection_distance_5: (+1)
   \   0000005E   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000062   0xD504             BPL.N    ??intersection_distance_7
   \   00000064   0x4630             MOV      R0,R6
   \   00000066   0x4641             MOV      R1,R8
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0x4606             MOV      R6,R0
   \                     ??intersection_distance_7: (+1)
   \   0000006E   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000072   0xD1EF             BNE.N    ??intersection_distance_6
   \   00000074   0x6824             LDR      R4,[R4, #+0]
   \   00000076   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000007A   0x4621             MOV      R1,R4
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0x6829             LDR      R1,[R5, #+0]
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x4639             MOV      R1,R7
   \   00000088   0x.... 0x....      BL       __aeabi_fsub
   \   0000008C   0x4631             MOV      R1,R6
   \   0000008E   0x.... 0x....      BL       __aeabi_fadd
   \   00000092   0x4605             MOV      R5,R0
   \   00000094   0xF04F 0x4081      MOV      R0,#+1082130432
   \   00000098   0x4621             MOV      R1,R4
   \   0000009A   0x.... 0x....      BL       __aeabi_fmul
   \   0000009E   0x4601             MOV      R1,R0
   \   000000A0   0x4628             MOV      R0,R5
   \   000000A2   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000A6   0x.... 0x....      B.W      __aeabi_fdiv
   \                     ??intersection_distance_1: (+1)
   \   000000AA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float Planner::max_allowable_speed(float const &, float const &, float const &)
   \                     _ZN7Planner19max_allowable_speedERKfS1_S1_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x680E             LDR      R6,[R1, #+0]
   \   0000000A   0x2702             MOVS     R7,#+2
   \   0000000C   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000010   0xE004             B.N      ??max_allowable_speed_0
   \                     ??max_allowable_speed_1: (+1)
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x4631             MOV      R1,R6
   \   00000016   0x.... 0x....      BL       __aeabi_fmul
   \   0000001A   0x4606             MOV      R6,R0
   \                     ??max_allowable_speed_0: (+1)
   \   0000001C   0x07F8             LSLS     R0,R7,#+31
   \   0000001E   0xD504             BPL.N    ??max_allowable_speed_2
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x4631             MOV      R1,R6
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x4680             MOV      R8,R0
   \                     ??max_allowable_speed_2: (+1)
   \   0000002A   0x087F             LSRS     R7,R7,#+1
   \   0000002C   0xD1F1             BNE.N    ??max_allowable_speed_1
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000034   0x.... 0x....      BL       __aeabi_fmul
   \   00000038   0x6829             LDR      R1,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       __aeabi_fmul
   \   0000003E   0x4601             MOV      R1,R0
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0x.... 0x....      BL       __aeabi_fsub
   \   00000046   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000004A   0x.... 0x....      B.W      sqrtf
     64          #include "stepper.h"
     65          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
   \                     _ZN11Temperature16tooColdToExtrudeEh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x480B             LDR.N    R0,??tooColdToExtrude_0
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??tooColdToExtrude_1
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??tooColdToExtrude_1: (+1)
   \   00000010   0x4809             LDR.N    R0,??tooColdToExtrude_0+0x4
   \   00000012   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       __aeabi_i2f
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x460D             MOV      R5,R1
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002A   0xD201             BCS.N    ??tooColdToExtrude_2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??tooColdToExtrude_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??tooColdToExtrude_0:
   \   00000034   0x........         DC32     _ZN11Temperature18allow_cold_extrudeE
   \   00000038   0x........         DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4901             LDR.N    R1,??degHotend_0
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??degHotend_0:
   \   00000008   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4902             LDR.N    R1,??degTargetHotend_0
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0x.... 0x....      B.W      __aeabi_i2f
   \   0000000A   0xBF00             Nop      
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000004   0x.... 0x....      BL       __aeabi_f2iz
   \   00000008   0x4903             LDR.N    R1,??setTargetHotend_0
   \   0000000A   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000018   0x........         DC32     _ZN11Temperature18target_temperatureE

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
     66          #include "ultralcd.h"
     67          #include "language.h"
     68          #include "ubl.h"

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t unified_bed_leveling::get_cell_index_x(float const &)
   \                     _ZN20unified_bed_leveling16get_cell_index_xERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E55             LDR.N    R6,??get_cell_index_x_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??get_cell_index_x_1

          	cx = (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
          	   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",182  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x813C      LDR.W    R8,??get_cell_index_x_0+0x4
   \   00000026   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493C             LDR.N    R1,??get_cell_index_x_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05C             B.N      ??get_cell_index_x_2

  					cx = (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",184  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??get_cell_index_x_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF106 0x0060      ADD      R0,R6,#+96
   \   000000A6   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
   \   000000AA   0x68B0             LDR      R0,[R6, #+8]
   \   000000AC   0x4651             MOV      R1,R10
   \   000000AE   0x.... 0x....      BL       __aeabi_fadd
   \   000000B2   0x4605             MOV      R5,R0
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BA   0xD202             BCS.N    ??get_cell_index_x_3
   \   000000BC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000C0   0xE000             B.N      ??get_cell_index_x_4
   \                     ??get_cell_index_x_3: (+1)
   \   000000C2   0x9500             STR      R5,[SP, #+0]
   \                     ??get_cell_index_x_4: (+1)
   \   000000C4   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C8   0x4659             MOV      R1,R11
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x4639             MOV      R1,R7
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0x4607             MOV      R7,R0
   \   000000D6   0x4648             MOV      R0,R9
   \   000000D8   0x4651             MOV      R1,R10
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x4601             MOV      R1,R0
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E6   0xD300             BCC.N    ??get_cell_index_x_5
   \   000000E8   0x460F             MOV      R7,R1
   \                     ??get_cell_index_x_5: (+1)
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x4641             MOV      R1,R8
   \   000000EE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F2   0xD300             BCC.N    ??get_cell_index_x_6
   \   000000F4   0x46A8             MOV      R8,R5
   \                     ??get_cell_index_x_6: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x9900             LDR      R1,[SP, #+0]
   \   000000FA   0x.... 0x....      BL       __aeabi_fsub
   \   000000FE   0x.... 0x....      BL       __aeabi_f2d
   \   00000102   0x4604             MOV      R4,R0
   \   00000104   0x460D             MOV      R5,R1
   \   00000106   0x4638             MOV      R0,R7
   \   00000108   0x4641             MOV      R1,R8
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x4607             MOV      R7,R0
   \   00000110   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000114   0x1E40             SUBS     R0,R0,#+1
   \   00000116   0x.... 0x....      BL       __aeabi_i2f
   \   0000011A   0x4601             MOV      R1,R0
   \   0000011C   0x4638             MOV      R0,R7
   \   0000011E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000122   0x.... 0x....      BL       __aeabi_f2d
   \   00000126   0x4602             MOV      R2,R0
   \   00000128   0x460B             MOV      R3,R1
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x490D             LDR.N    R1,??get_cell_index_x_0+0x8  ;; 0x3ff00000
   \   0000012E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000132   0x4622             MOV      R2,R4
   \   00000134   0x462B             MOV      R3,R5
   \   00000136   0x.... 0x....      BL       __aeabi_dmul
   \   0000013A   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??get_cell_index_x_2: (+1)
   \   0000013E   0xB240             SXTB     R0,R0
   \   00000140   0x0001             MOVS     R1,R0
   \   00000142   0xD501             BPL.N    ??get_cell_index_x_7
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE005             B.N      ??get_cell_index_x_8
   \                     ??get_cell_index_x_7: (+1)
   \   00000148   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   0000014C   0x1E53             SUBS     R3,R2,#+1
   \   0000014E   0x428B             CMP      R3,R1
   \   00000150   0xDA00             BGE.N    ??get_cell_index_x_8
   \   00000152   0x1E50             SUBS     R0,R2,#+1
   \                     ??get_cell_index_x_8: (+1)
   \   00000154   0xB240             SXTB     R0,R0
   \   00000156   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   0000015A   0xBF00             Nop      
   \                     ??get_cell_index_x_0:
   \   0000015C   0x........         DC32     mksCfg
   \   00000160   0x........         DC32     mksTmp
   \   00000164   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t unified_bed_leveling::get_cell_index_y(float const &)
   \                     _ZN20unified_bed_leveling16get_cell_index_yERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E54             LDR.N    R6,??get_cell_index_y_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??get_cell_index_y_1

  					cy = (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",195  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x8138      LDR.W    R8,??get_cell_index_y_0+0x4
   \   00000026   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493B             LDR.N    R1,??get_cell_index_y_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05A             B.N      ??get_cell_index_y_2

  					cy = (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",197  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??get_cell_index_y_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF8D6 0xA070      LDR      R10,[R6, #+112]
   \   000000A6   0x68F0             LDR      R0,[R6, #+12]
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fadd
   \   000000AE   0x4605             MOV      R5,R0
   \   000000B0   0x4641             MOV      R1,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B6   0xD202             BCS.N    ??get_cell_index_y_3
   \   000000B8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000BC   0xE000             B.N      ??get_cell_index_y_4
   \                     ??get_cell_index_y_3: (+1)
   \   000000BE   0x9500             STR      R5,[SP, #+0]
   \                     ??get_cell_index_y_4: (+1)
   \   000000C0   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C4   0x4659             MOV      R1,R11
   \   000000C6   0x.... 0x....      BL       __aeabi_fmul
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      BL       __aeabi_fsub
   \   000000D0   0x4607             MOV      R7,R0
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fadd
   \   000000DA   0x4601             MOV      R1,R0
   \   000000DC   0x4638             MOV      R0,R7
   \   000000DE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E2   0xD300             BCC.N    ??get_cell_index_y_5
   \   000000E4   0x460F             MOV      R7,R1
   \                     ??get_cell_index_y_5: (+1)
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x4641             MOV      R1,R8
   \   000000EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EE   0xD300             BCC.N    ??get_cell_index_y_6
   \   000000F0   0x46A8             MOV      R8,R5
   \                     ??get_cell_index_y_6: (+1)
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x9900             LDR      R1,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       __aeabi_fsub
   \   000000FA   0x.... 0x....      BL       __aeabi_f2d
   \   000000FE   0x4604             MOV      R4,R0
   \   00000100   0x460D             MOV      R5,R1
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x4641             MOV      R1,R8
   \   00000106   0x.... 0x....      BL       __aeabi_fsub
   \   0000010A   0x4607             MOV      R7,R0
   \   0000010C   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000110   0x1E40             SUBS     R0,R0,#+1
   \   00000112   0x.... 0x....      BL       __aeabi_i2f
   \   00000116   0x4601             MOV      R1,R0
   \   00000118   0x4638             MOV      R0,R7
   \   0000011A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011E   0x.... 0x....      BL       __aeabi_f2d
   \   00000122   0x4602             MOV      R2,R0
   \   00000124   0x460B             MOV      R3,R1
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x490D             LDR.N    R1,??get_cell_index_y_0+0x8  ;; 0x3ff00000
   \   0000012A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000012E   0x4622             MOV      R2,R4
   \   00000130   0x462B             MOV      R3,R5
   \   00000132   0x.... 0x....      BL       __aeabi_dmul
   \   00000136   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??get_cell_index_y_2: (+1)
   \   0000013A   0xB240             SXTB     R0,R0
   \   0000013C   0x0001             MOVS     R1,R0
   \   0000013E   0xD501             BPL.N    ??get_cell_index_y_7
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE005             B.N      ??get_cell_index_y_8
   \                     ??get_cell_index_y_7: (+1)
   \   00000144   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   00000148   0x1E53             SUBS     R3,R2,#+1
   \   0000014A   0x428B             CMP      R3,R1
   \   0000014C   0xDA00             BGE.N    ??get_cell_index_y_8
   \   0000014E   0x1E50             SUBS     R0,R2,#+1
   \                     ??get_cell_index_y_8: (+1)
   \   00000150   0xB240             SXTB     R0,R0
   \   00000152   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   00000156   0xBF00             Nop      
   \                     ??get_cell_index_y_0:
   \   00000158   0x........         DC32     mksCfg
   \   0000015C   0x........         DC32     mksTmp
   \   00000160   0x3FF00000         DC32     0x3ff00000

  					px= (x - (MESH_MIN_X_IS_KINEMATIC) + (MESH_X_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  					  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",208  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					px= (x - (MESH_MIN_X_IS_Cartesian) + (MESH_X_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",210  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_KINEMATIC) + (MESH_Y_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",219  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_Cartesian) + (MESH_Y_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",221  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 2
   \   __interwork __softfp float unified_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
   \                     _ZN20unified_bed_leveling7calc_z0ERKfS1_S1_S1_S1_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461D             MOV      R5,R3
   \   00000008   0x9806             LDR      R0,[SP, #+24]
   \   0000000A   0x680E             LDR      R6,[R1, #+0]
   \   0000000C   0x6817             LDR      R7,[R2, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x4639             MOV      R1,R7
   \   00000012   0x.... 0x....      BL       __aeabi_fsub
   \   00000016   0x4680             MOV      R8,R0
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x4631             MOV      R1,R6
   \   0000001C   0x.... 0x....      BL       __aeabi_fsub
   \   00000020   0x4641             MOV      R1,R8
   \   00000022   0x.... 0x....      BL       __aeabi_fmul
   \   00000026   0x4604             MOV      R4,R0
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x4631             MOV      R1,R6
   \   0000002C   0x.... 0x....      BL       __aeabi_fsub
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       __aeabi_fdiv
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000003E   0x.... 0x....      B.W      __aeabi_fadd

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::get_z_correction(float const &, float const &)
   \                     _ZN20unified_bed_leveling16get_z_correctionERKfS1_: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_cell_index_xERKf
   \   0000000E   0x4606             MOV      R6,R0
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_cell_index_yERKf
   \   00000016   0x4607             MOV      R7,R0
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   00000020   0x9008             STR      R0,[SP, #+32]
   \   00000022   0x1C70             ADDS     R0,R6,#+1
   \   00000024   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000028   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002C   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   00000030   0x9007             STR      R0,[SP, #+28]
   \   00000032   0xF8DF 0x80BC      LDR.W    R8,??get_z_correction_0
   \   00000036   0xF898 0x0060      LDRB     R0,[R8, #+96]
   \   0000003A   0x1E80             SUBS     R0,R0,#+2
   \   0000003C   0x4286             CMP      R6,R0
   \   0000003E   0xDC00             BGT.N    ??get_z_correction_1
   \   00000040   0x4630             MOV      R0,R6
   \                     ??get_z_correction_1: (+1)
   \   00000042   0xF04F 0x0930      MOV      R9,#+48
   \   00000046   0xF8DF 0xA0AC      LDR.W    R10,??get_z_correction_0+0x4
   \   0000004A   0xFB09 0xAB06      MLA      R11,R9,R6,R10
   \   0000004E   0xFB09 0xA000      MLA      R0,R9,R0,R10
   \   00000052   0xEB00 0x0087      ADD      R0,R0,R7, LSL #+2
   \   00000056   0x3030             ADDS     R0,R0,#+48
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0xAB07             ADD      R3,SP,#+28
   \   0000005C   0xEB0B 0x0287      ADD      R2,R11,R7, LSL #+2
   \   00000060   0xA908             ADD      R1,SP,#+32
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       _ZN20unified_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \   00000068   0x9003             STR      R0,[SP, #+12]
   \   0000006A   0x4630             MOV      R0,R6
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   00000072   0x9006             STR      R0,[SP, #+24]
   \   00000074   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000078   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   0000007C   0x9005             STR      R0,[SP, #+20]
   \   0000007E   0xF898 0x0060      LDRB     R0,[R8, #+96]
   \   00000082   0x1E80             SUBS     R0,R0,#+2
   \   00000084   0x4286             CMP      R6,R0
   \   00000086   0xDD00             BLE.N    ??get_z_correction_2
   \   00000088   0x4606             MOV      R6,R0
   \                     ??get_z_correction_2: (+1)
   \   0000008A   0xF108 0x0060      ADD      R0,R8,#+96
   \   0000008E   0x7840             LDRB     R0,[R0, #+1]
   \   00000090   0x1E80             SUBS     R0,R0,#+2
   \   00000092   0x4287             CMP      R7,R0
   \   00000094   0xDC00             BGT.N    ??get_z_correction_3
   \   00000096   0x4638             MOV      R0,R7
   \                     ??get_z_correction_3: (+1)
   \   00000098   0xFB09 0xA106      MLA      R1,R9,R6,R10
   \   0000009C   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   000000A0   0x3134             ADDS     R1,R1,#+52
   \   000000A2   0x9100             STR      R1,[SP, #+0]
   \   000000A4   0xAB05             ADD      R3,SP,#+20
   \   000000A6   0xEB0B 0x0080      ADD      R0,R11,R0, LSL #+2
   \   000000AA   0x1D02             ADDS     R2,R0,#+4
   \   000000AC   0xA906             ADD      R1,SP,#+24
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       _ZN20unified_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \   000000B4   0x9002             STR      R0,[SP, #+8]
   \   000000B6   0x4638             MOV      R0,R7
   \   000000B8   0xB2C0             UXTB     R0,R0
   \   000000BA   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
   \   000000BE   0x9004             STR      R0,[SP, #+16]
   \   000000C0   0x1C78             ADDS     R0,R7,#+1
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
   \   000000C8   0x9001             STR      R0,[SP, #+4]
   \   000000CA   0xA802             ADD      R0,SP,#+8
   \   000000CC   0x9000             STR      R0,[SP, #+0]
   \   000000CE   0xAB01             ADD      R3,SP,#+4
   \   000000D0   0xAA03             ADD      R2,SP,#+12
   \   000000D2   0xA904             ADD      R1,SP,#+16
   \   000000D4   0x4628             MOV      R0,R5
   \   000000D6   0x.... 0x....      BL       _ZN20unified_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \   000000DA   0x4604             MOV      R4,R0
   \   000000DC   0x.... 0x....      BL       __iar_FDtest
   \   000000E0   0x2802             CMP      R0,#+2
   \   000000E2   0xD100             BNE.N    ??get_z_correction_4
   \   000000E4   0x2400             MOVS     R4,#+0
   \                     ??get_z_correction_4: (+1)
   \   000000E6   0x4620             MOV      R0,R4
   \   000000E8   0xB009             ADD      SP,SP,#+36
   \   000000EA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   000000EE   0xBF00             Nop      
   \                     ??get_z_correction_0:
   \   000000F0   0x........         DC32     mksCfg
   \   000000F4   0x........         DC32     _ZN20unified_bed_leveling8z_valuesE

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_xposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4F4A             LDR.N    R7,??mesh_index_to_xpos_0
   \   00000008   0xF897 0x6060      LDRB     R6,[R7, #+96]
   \   0000000C   0xF107 0x0008      ADD      R0,R7,#+8
   \   00000010   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   00000014   0xF240 0x3202      MOVW     R2,#+770
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD02B             BEQ.N    ??mesh_index_to_xpos_1
   \   0000001C   0x42B5             CMP      R5,R6
   \   0000001E   0xD203             BCS.N    ??mesh_index_to_xpos_2
   \   00000020   0x4844             LDR.N    R0,??mesh_index_to_xpos_0+0x4
   \   00000022   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000026   0xE081             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_2: (+1)
   \   00000028   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000030   0x4682             MOV      R10,R0
   \   00000032   0x4C41             LDR.N    R4,??mesh_index_to_xpos_0+0x8
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fadd
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_ui2f
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x4651             MOV      R1,R10
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4604             MOV      R4,R0
   \   00000056   0x1E70             SUBS     R0,R6,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000070   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_1: (+1)
   \   00000074   0x42B5             CMP      R5,R6
   \   00000076   0xD203             BCS.N    ??mesh_index_to_xpos_4
   \   00000078   0x482E             LDR.N    R0,??mesh_index_to_xpos_0+0x4
   \   0000007A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000007E   0xE055             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_4: (+1)
   \   00000080   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   00000084   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   00000094   0x.... 0x....      BL       __aeabi_ui2f
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fadd
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF107 0x0060      ADD      R0,R7,#+96
   \   000000AE   0xF8D0 0xB00C      LDR      R11,[R0, #+12]
   \   000000B2   0x68B8             LDR      R0,[R7, #+8]
   \   000000B4   0x4659             MOV      R1,R11
   \   000000B6   0x.... 0x....      BL       __aeabi_fadd
   \   000000BA   0x4607             MOV      R7,R0
   \   000000BC   0x4621             MOV      R1,R4
   \   000000BE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C2   0xD201             BCS.N    ??mesh_index_to_xpos_5
   \   000000C4   0x9400             STR      R4,[SP, #+0]
   \   000000C6   0xE000             B.N      ??mesh_index_to_xpos_6
   \                     ??mesh_index_to_xpos_5: (+1)
   \   000000C8   0x9700             STR      R7,[SP, #+0]
   \                     ??mesh_index_to_xpos_6: (+1)
   \   000000CA   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CE   0x4649             MOV      R1,R9
   \   000000D0   0x.... 0x....      BL       __aeabi_fmul
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fsub
   \   000000DA   0x4681             MOV      R9,R0
   \   000000DC   0x4640             MOV      R0,R8
   \   000000DE   0x4659             MOV      R1,R11
   \   000000E0   0x.... 0x....      BL       __aeabi_fadd
   \   000000E4   0x4601             MOV      R1,R0
   \   000000E6   0x4648             MOV      R0,R9
   \   000000E8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EC   0xD300             BCC.N    ??mesh_index_to_xpos_7
   \   000000EE   0x4689             MOV      R9,R1
   \                     ??mesh_index_to_xpos_7: (+1)
   \   000000F0   0x4638             MOV      R0,R7
   \   000000F2   0x4621             MOV      R1,R4
   \   000000F4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F8   0xD300             BCC.N    ??mesh_index_to_xpos_8
   \   000000FA   0x463C             MOV      R4,R7
   \                     ??mesh_index_to_xpos_8: (+1)
   \   000000FC   0x4628             MOV      R0,R5
   \   000000FE   0x.... 0x....      BL       __aeabi_ui2f
   \   00000102   0x4605             MOV      R5,R0
   \   00000104   0x4648             MOV      R0,R9
   \   00000106   0x4621             MOV      R1,R4
   \   00000108   0x.... 0x....      BL       __aeabi_fsub
   \   0000010C   0x4604             MOV      R4,R0
   \   0000010E   0x1E70             SUBS     R0,R6,#+1
   \   00000110   0x.... 0x....      BL       __aeabi_i2f
   \   00000114   0x4601             MOV      R1,R0
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x.... 0x....      BL       __aeabi_fmul
   \   00000122   0x9900             LDR      R1,[SP, #+0]
   \   00000124   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000128   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_3: (+1)
   \   0000012C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??mesh_index_to_xpos_0:
   \   00000130   0x........         DC32     mksCfg
   \   00000134   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE
   \   00000138   0x........         DC32     mksTmp

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_yposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4F49             LDR.N    R7,??mesh_index_to_ypos_0
   \   00000008   0xF897 0x6061      LDRB     R6,[R7, #+97]
   \   0000000C   0xF107 0x000C      ADD      R0,R7,#+12
   \   00000010   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   00000014   0xF240 0x3202      MOVW     R2,#+770
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD02B             BEQ.N    ??mesh_index_to_ypos_1
   \   0000001C   0x42B5             CMP      R5,R6
   \   0000001E   0xD203             BCS.N    ??mesh_index_to_ypos_2
   \   00000020   0x4843             LDR.N    R0,??mesh_index_to_ypos_0+0x4
   \   00000022   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000026   0xE07F             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_2: (+1)
   \   00000028   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000030   0x4682             MOV      R10,R0
   \   00000032   0x4C40             LDR.N    R4,??mesh_index_to_ypos_0+0x8
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fadd
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_ui2f
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x4651             MOV      R1,R10
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4604             MOV      R4,R0
   \   00000056   0x1E70             SUBS     R0,R6,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000070   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_1: (+1)
   \   00000074   0x42B5             CMP      R5,R6
   \   00000076   0xD203             BCS.N    ??mesh_index_to_ypos_4
   \   00000078   0x482D             LDR.N    R0,??mesh_index_to_ypos_0+0x4
   \   0000007A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000007E   0xE053             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_4: (+1)
   \   00000080   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   00000084   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   00000094   0x.... 0x....      BL       __aeabi_ui2f
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fadd
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF8D7 0xB070      LDR      R11,[R7, #+112]
   \   000000AE   0x68F8             LDR      R0,[R7, #+12]
   \   000000B0   0x4659             MOV      R1,R11
   \   000000B2   0x.... 0x....      BL       __aeabi_fadd
   \   000000B6   0x4607             MOV      R7,R0
   \   000000B8   0x4621             MOV      R1,R4
   \   000000BA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BE   0xD201             BCS.N    ??mesh_index_to_ypos_5
   \   000000C0   0x9400             STR      R4,[SP, #+0]
   \   000000C2   0xE000             B.N      ??mesh_index_to_ypos_6
   \                     ??mesh_index_to_ypos_5: (+1)
   \   000000C4   0x9700             STR      R7,[SP, #+0]
   \                     ??mesh_index_to_ypos_6: (+1)
   \   000000C6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CA   0x4649             MOV      R1,R9
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4651             MOV      R1,R10
   \   000000D2   0x.... 0x....      BL       __aeabi_fsub
   \   000000D6   0x4681             MOV      R9,R0
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x4659             MOV      R1,R11
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x4601             MOV      R1,R0
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E8   0xD300             BCC.N    ??mesh_index_to_ypos_7
   \   000000EA   0x4689             MOV      R9,R1
   \                     ??mesh_index_to_ypos_7: (+1)
   \   000000EC   0x4638             MOV      R0,R7
   \   000000EE   0x4621             MOV      R1,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F4   0xD300             BCC.N    ??mesh_index_to_ypos_8
   \   000000F6   0x463C             MOV      R4,R7
   \                     ??mesh_index_to_ypos_8: (+1)
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000FE   0x4605             MOV      R5,R0
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x4621             MOV      R1,R4
   \   00000104   0x.... 0x....      BL       __aeabi_fsub
   \   00000108   0x4604             MOV      R4,R0
   \   0000010A   0x1E70             SUBS     R0,R6,#+1
   \   0000010C   0x.... 0x....      BL       __aeabi_i2f
   \   00000110   0x4601             MOV      R1,R0
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       __aeabi_fdiv
   \   00000118   0x4629             MOV      R1,R5
   \   0000011A   0x.... 0x....      BL       __aeabi_fmul
   \   0000011E   0x9900             LDR      R1,[SP, #+0]
   \   00000120   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000124   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_3: (+1)
   \   00000128   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??mesh_index_to_ypos_0:
   \   0000012C   0x........         DC32     mksCfg
   \   00000130   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
   \   00000134   0x........         DC32     mksTmp
     69          #include "gcode.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::seen(char)
   \                     _ZN11GCodeParser4seenEc: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x291A             CMP      R1,#+26
   \   00000008   0xD301             BCC.N    ??seen_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
   \                     ??seen_0: (+1)
   \   0000000E   0x10C8             ASRS     R0,R1,#+3
   \   00000010   0x4A0A             LDR.N    R2,??seen_1
   \   00000012   0x5C80             LDRB     R0,[R0, R2]
   \   00000014   0xF001 0x0207      AND      R2,R1,#0x7
   \   00000018   0x40D0             LSRS     R0,R0,R2
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0xD00B             BEQ.N    ??seen_2
   \   00000020   0x4A07             LDR.N    R2,??seen_1+0x4
   \   00000022   0x5C89             LDRB     R1,[R1, R2]
   \   00000024   0x4A07             LDR.N    R2,??seen_1+0x8
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??seen_3
   \   0000002A   0x4B07             LDR.N    R3,??seen_1+0xC
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x18C9             ADDS     R1,R1,R3
   \   00000030   0x6011             STR      R1,[R2, #+0]
   \   00000032   0x4770             BX       LR
   \                     ??seen_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \                     ??seen_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??seen_1:
   \   0000003C   0x........         DC32     _ZN11GCodeParser8codebitsE
   \   00000040   0x........         DC32     _ZN11GCodeParser5paramE
   \   00000044   0x........         DC32     _ZN11GCodeParser9value_ptrE
   \   00000048   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp float GCodeParser::value_float()
   \                     _ZN11GCodeParser11value_floatEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4A12             LDR.N    R2,??value_float_0
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01D             BEQ.N    ??value_float_1
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xE000             B.N      ??value_float_2
   \                     ??value_float_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??value_float_2: (+1)
   \   00000010   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD001             BEQ.N    ??value_float_4
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD106             BNE.N    ??value_float_5
   \                     ??value_float_4: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       strtod
   \   00000022   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??value_float_5: (+1)
   \   0000002A   0x2D45             CMP      R5,#+69
   \   0000002C   0xD001             BEQ.N    ??value_float_6
   \   0000002E   0x2D65             CMP      R5,#+101
   \   00000030   0xD1ED             BNE.N    ??value_float_3
   \                     ??value_float_6: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x6810             LDR      R0,[R2, #+0]
   \   0000003A   0x.... 0x....      BL       strtod
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x7025             STRB     R5,[R4, #+0]
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??value_float_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \   0000004A   0xBF00             Nop      
   \                     ??value_float_0:
   \   0000004C   0x........         DC32     _ZN11GCodeParser9value_ptrE

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_celsius()
   \                     _ZN11GCodeParser13value_celsiusEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_celsius_diff()
   \                     _ZN11GCodeParser18value_celsius_diffEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv
     70          
     71          
     72          
     73          #if 1//ENABLED(MESH_BED_LEVELING)
     74            #include "mesh_bed_leveling.h"

  	#define MESH_X_DIST_IS_KINEMATIC ((MESH_MAX_X_IS_KINEMATIC - (MESH_MIN_X_IS_KINEMATIC)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",41  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_KINEMATIC"
          (declared at line 74 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_KINEMATIC ((MESH_MAX_Y_IS_KINEMATIC - (MESH_MIN_Y_IS_KINEMATIC)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",42  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_KINEMATIC"
          (declared at line 75 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_X_DIST_IS_Cartesian ((MESH_MAX_X_IS_Cartesian - (MESH_MIN_X_IS_Cartesian)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",43  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_Cartesian"
          (declared at line 76 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_Cartesian ((MESH_MAX_Y_IS_Cartesian - (MESH_MIN_Y_IS_Cartesian)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",44  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_Cartesian"
          (declared at line 77 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_xERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E55             LDR.N    R6,??cell_index_x_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??cell_index_x_1

  				cx= (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",83  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x813C      LDR.W    R8,??cell_index_x_0+0x4
   \   00000026   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493C             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05C             B.N      ??cell_index_x_2

  				cx= (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",87  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_x_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF106 0x0060      ADD      R0,R6,#+96
   \   000000A6   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
   \   000000AA   0x68B0             LDR      R0,[R6, #+8]
   \   000000AC   0x4651             MOV      R1,R10
   \   000000AE   0x.... 0x....      BL       __aeabi_fadd
   \   000000B2   0x4605             MOV      R5,R0
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BA   0xD202             BCS.N    ??cell_index_x_3
   \   000000BC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000C0   0xE000             B.N      ??cell_index_x_4
   \                     ??cell_index_x_3: (+1)
   \   000000C2   0x9500             STR      R5,[SP, #+0]
   \                     ??cell_index_x_4: (+1)
   \   000000C4   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C8   0x4659             MOV      R1,R11
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x4639             MOV      R1,R7
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0x4607             MOV      R7,R0
   \   000000D6   0x4648             MOV      R0,R9
   \   000000D8   0x4651             MOV      R1,R10
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x4601             MOV      R1,R0
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E6   0xD300             BCC.N    ??cell_index_x_5
   \   000000E8   0x460F             MOV      R7,R1
   \                     ??cell_index_x_5: (+1)
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x4641             MOV      R1,R8
   \   000000EE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F2   0xD300             BCC.N    ??cell_index_x_6
   \   000000F4   0x46A8             MOV      R8,R5
   \                     ??cell_index_x_6: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x9900             LDR      R1,[SP, #+0]
   \   000000FA   0x.... 0x....      BL       __aeabi_fsub
   \   000000FE   0x.... 0x....      BL       __aeabi_f2d
   \   00000102   0x4604             MOV      R4,R0
   \   00000104   0x460D             MOV      R5,R1
   \   00000106   0x4638             MOV      R0,R7
   \   00000108   0x4641             MOV      R1,R8
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x4607             MOV      R7,R0
   \   00000110   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000114   0x1E40             SUBS     R0,R0,#+1
   \   00000116   0x.... 0x....      BL       __aeabi_i2f
   \   0000011A   0x4601             MOV      R1,R0
   \   0000011C   0x4638             MOV      R0,R7
   \   0000011E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000122   0x.... 0x....      BL       __aeabi_f2d
   \   00000126   0x4602             MOV      R2,R0
   \   00000128   0x460B             MOV      R3,R1
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x490D             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   0000012E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000132   0x4622             MOV      R2,R4
   \   00000134   0x462B             MOV      R3,R5
   \   00000136   0x.... 0x....      BL       __aeabi_dmul
   \   0000013A   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??cell_index_x_2: (+1)
   \   0000013E   0xB240             SXTB     R0,R0
   \   00000140   0x0001             MOVS     R1,R0
   \   00000142   0xD501             BPL.N    ??cell_index_x_7
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE005             B.N      ??cell_index_x_8
   \                     ??cell_index_x_7: (+1)
   \   00000148   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   0000014C   0x1E93             SUBS     R3,R2,#+2
   \   0000014E   0x428B             CMP      R3,R1
   \   00000150   0xDA00             BGE.N    ??cell_index_x_8
   \   00000152   0x1E90             SUBS     R0,R2,#+2
   \                     ??cell_index_x_8: (+1)
   \   00000154   0xB240             SXTB     R0,R0
   \   00000156   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   0000015A   0xBF00             Nop      
   \                     ??cell_index_x_0:
   \   0000015C   0x........         DC32     mksCfg
   \   00000160   0x........         DC32     mksTmp
   \   00000164   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_yERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E54             LDR.N    R6,??cell_index_y_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??cell_index_y_1

  				cy= (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",95  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x8138      LDR.W    R8,??cell_index_y_0+0x4
   \   00000026   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493B             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05A             B.N      ??cell_index_y_2

  				cy= (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",97  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_y_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF8D6 0xA070      LDR      R10,[R6, #+112]
   \   000000A6   0x68F0             LDR      R0,[R6, #+12]
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fadd
   \   000000AE   0x4605             MOV      R5,R0
   \   000000B0   0x4641             MOV      R1,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B6   0xD202             BCS.N    ??cell_index_y_3
   \   000000B8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000BC   0xE000             B.N      ??cell_index_y_4
   \                     ??cell_index_y_3: (+1)
   \   000000BE   0x9500             STR      R5,[SP, #+0]
   \                     ??cell_index_y_4: (+1)
   \   000000C0   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C4   0x4659             MOV      R1,R11
   \   000000C6   0x.... 0x....      BL       __aeabi_fmul
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      BL       __aeabi_fsub
   \   000000D0   0x4607             MOV      R7,R0
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fadd
   \   000000DA   0x4601             MOV      R1,R0
   \   000000DC   0x4638             MOV      R0,R7
   \   000000DE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E2   0xD300             BCC.N    ??cell_index_y_5
   \   000000E4   0x460F             MOV      R7,R1
   \                     ??cell_index_y_5: (+1)
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x4641             MOV      R1,R8
   \   000000EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EE   0xD300             BCC.N    ??cell_index_y_6
   \   000000F0   0x46A8             MOV      R8,R5
   \                     ??cell_index_y_6: (+1)
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x9900             LDR      R1,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       __aeabi_fsub
   \   000000FA   0x.... 0x....      BL       __aeabi_f2d
   \   000000FE   0x4604             MOV      R4,R0
   \   00000100   0x460D             MOV      R5,R1
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x4641             MOV      R1,R8
   \   00000106   0x.... 0x....      BL       __aeabi_fsub
   \   0000010A   0x4607             MOV      R7,R0
   \   0000010C   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000110   0x1E40             SUBS     R0,R0,#+1
   \   00000112   0x.... 0x....      BL       __aeabi_i2f
   \   00000116   0x4601             MOV      R1,R0
   \   00000118   0x4638             MOV      R0,R7
   \   0000011A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011E   0x.... 0x....      BL       __aeabi_f2d
   \   00000122   0x4602             MOV      R2,R0
   \   00000124   0x460B             MOV      R3,R1
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x490D             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   0000012A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000012E   0x4622             MOV      R2,R4
   \   00000130   0x462B             MOV      R3,R5
   \   00000132   0x.... 0x....      BL       __aeabi_dmul
   \   00000136   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??cell_index_y_2: (+1)
   \   0000013A   0xB240             SXTB     R0,R0
   \   0000013C   0x0001             MOVS     R1,R0
   \   0000013E   0xD501             BPL.N    ??cell_index_y_7
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE005             B.N      ??cell_index_y_8
   \                     ??cell_index_y_7: (+1)
   \   00000144   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   00000148   0x1E93             SUBS     R3,R2,#+2
   \   0000014A   0x428B             CMP      R3,R1
   \   0000014C   0xDA00             BGE.N    ??cell_index_y_8
   \   0000014E   0x1E90             SUBS     R0,R2,#+2
   \                     ??cell_index_y_8: (+1)
   \   00000150   0xB240             SXTB     R0,R0
   \   00000152   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   00000156   0xBF00             Nop      
   \                     ??cell_index_y_0:
   \   00000158   0x........         DC32     mksCfg
   \   0000015C   0x........         DC32     mksTmp
   \   00000160   0x3FF00000         DC32     0x3ff00000

  				px = (x - (MESH_MIN_X_IS_KINEMATIC) + 0.5 * (MESH_X_DIST_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",105  Warning[Pa093]: 
          implicit conversion from floating point to integer

  				px = (x - (MESH_MIN_X_IS_Cartesian) + 0.5 * (MESH_X_DIST_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",107  Warning[Pa093]: 
          implicit conversion from floating point to integer

        	py = (y - (MESH_MIN_Y_IS_KINEMATIC) + 0.5 * (MESH_Y_DIST_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
        	   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",115  Warning[Pa093]: 
          implicit conversion from floating point to integer

  				py = (y - (MESH_MIN_Y_IS_Cartesian) + 0.5 * (MESH_Y_DIST_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",117  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 2
   \   __interwork __softfp float mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
   \                     _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0x9D06             LDR      R5,[SP, #+24]
   \   00000008   0x6816             LDR      R6,[R2, #+0]
   \   0000000A   0x680F             LDR      R7,[R1, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4639             MOV      R1,R7
   \   00000010   0x.... 0x....      BL       __aeabi_fsub
   \   00000014   0x4680             MOV      R8,R0
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x4631             MOV      R1,R6
   \   0000001A   0x.... 0x....      BL       __aeabi_fsub
   \   0000001E   0x4605             MOV      R5,R0
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x4639             MOV      R1,R7
   \   00000024   0x.... 0x....      BL       __aeabi_fsub
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x.... 0x....      BL       __aeabi_fmul
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000003C   0x.... 0x....      B.W      __aeabi_fadd

   \                                 In section .text, align 4
   \   __interwork __softfp float mesh_bed_leveling::get_z(float const &, float const &, float const &)
   \                     _ZN17mesh_bed_leveling5get_zERKfS1_S1_: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \   00000010   0x4682             MOV      R10,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \   00000018   0x4606             MOV      R6,R0
   \   0000001A   0xEB0A 0x004A      ADD      R0,R10,R10, LSL #+1
   \   0000001E   0x491A             LDR.N    R1,??get_z_0
   \   00000020   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000024   0xEB00 0x0886      ADD      R8,R0,R6, LSL #+2
   \   00000028   0xEB00 0x0986      ADD      R9,R0,R6, LSL #+2
   \   0000002C   0x4817             LDR.N    R0,??get_z_0+0x4
   \   0000002E   0xEB00 0x0A8A      ADD      R10,R0,R10, LSL #+2
   \   00000032   0xF109 0x0030      ADD      R0,R9,#+48
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0xF10A 0x0304      ADD      R3,R10,#+4
   \   0000003C   0x4642             MOV      R2,R8
   \   0000003E   0x4651             MOV      R1,R10
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0x.... 0x....      BL       _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \   00000046   0x9002             STR      R0,[SP, #+8]
   \   00000048   0xF109 0x0034      ADD      R0,R9,#+52
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0xF10A 0x0304      ADD      R3,R10,#+4
   \   00000052   0xF108 0x0204      ADD      R2,R8,#+4
   \   00000056   0x4651             MOV      R1,R10
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \   0000005E   0x9001             STR      R0,[SP, #+4]
   \   00000060   0x480B             LDR.N    R0,??get_z_0+0x8
   \   00000062   0xEB00 0x0186      ADD      R1,R0,R6, LSL #+2
   \   00000066   0xA801             ADD      R0,SP,#+4
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x1D0B             ADDS     R3,R1,#+4
   \   0000006C   0xAA02             ADD      R2,SP,#+8
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \   00000074   0x6829             LDR      R1,[R5, #+0]
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0x4906             LDR.N    R1,??get_z_0+0xC
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x.... 0x....      BL       __aeabi_fadd
   \   00000082   0xB004             ADD      SP,SP,#+16
   \   00000084   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??get_z_0:
   \   00000088   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE
   \   0000008C   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \   00000090   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \   00000094   0x........         DC32     _ZN17mesh_bed_leveling8z_offsetE
     75          #endif
     76          

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
     77          Planner planner;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable12
   \   00000008   0x1D20             ADDS     R0,R4,#+4
   \   0000000A   0x.... 0x....      BL       _ZN7PlannerC1Ev
     78          
     79            // public:
     80          
     81          /**
     82           * A ring buffer of moves described in steps
     83           */
     84          block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
     85          volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
     86                           Planner::block_buffer_tail = 0;
     87          
     88          float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
     89                Planner::axis_steps_per_mm[XYZE_N],
     90                Planner::steps_to_mm[XYZE_N];
     91          
     92          #if ENABLED(DISTINCT_E_FACTORS)
     93            uint8_t Planner::last_extruder = 0;     // Respond to extruder change
     94          #endif
     95          
     96          int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
     97          
     98          float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
     99          
    100          #if DISABLED(NO_VOLUMETRICS)
    101            float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
    102                  Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
   \   0000000E   0xF04F 0x0800      MOV      R8,#+0
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable12_1  ;; 0x3ff80000
   \   00000016   0x2502             MOVS     R5,#+2
   \   00000018   0x4646             MOV      R6,R8
   \   0000001A   0x.... 0x....      LDR.W    R7,??DataTable12_2  ;; 0x3ff00000
   \   0000001E   0xE007             B.N      ??__sti__routine_0
   \                     ??__sti__routine_1: (+1)
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x4649             MOV      R1,R9
   \   00000024   0x4642             MOV      R2,R8
   \   00000026   0x464B             MOV      R3,R9
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x4680             MOV      R8,R0
   \   0000002E   0x4689             MOV      R9,R1
   \                     ??__sti__routine_0: (+1)
   \   00000030   0x07E8             LSLS     R0,R5,#+31
   \   00000032   0xD507             BPL.N    ??__sti__routine_2
   \   00000034   0x4642             MOV      R2,R8
   \   00000036   0x464B             MOV      R3,R9
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0x.... 0x....      BL       __aeabi_dmul
   \   00000040   0x4606             MOV      R6,R0
   \   00000042   0x460F             MOV      R7,R1
   \                     ??__sti__routine_2: (+1)
   \   00000044   0x086D             LSRS     R5,R5,#+1
   \   00000046   0xD1EB             BNE.N    ??__sti__routine_1
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x54442d18
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable12_4  ;; 0x400921fb
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0x463B             MOV      R3,R7
   \   00000054   0x.... 0x....      BL       __aeabi_dmul
   \   00000058   0x.... 0x....      BL       __aeabi_d2f
   \   0000005C   0x6020             STR      R0,[R4, #+0]
   \   0000005E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 4
   \                     _ZN7Planner23volumetric_area_nominalE:
   \   00000000                      DS8 4
   \                     planner:
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner12block_bufferE:
   \   00000000                      DS8 1344
    103                  Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
    104          #endif
    105          
    106          unsigned long Planner::max_acceleration_steps_per_s2[XYZE_N],
    107                   Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
    108          
    109          uint32_t Planner::min_segment_time_us;
    110          
    111          // Initialized by settings.load()
    112          float Planner::min_feedrate_mm_s,
    113                Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
    114                Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
    115                Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
    116                Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
    117                Planner::min_travel_feedrate_mm_s;
    118          
    119          #if 1//HAS_LEVELING
    120            bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
    121            #if 1//ABL_PLANAR
    122              matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
    123            #endif
    124            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    125              float Planner::z_fade_height,      // Initialized by settings.load()
    126                    Planner::inverse_z_fade_height,
    127                    Planner::last_fade_z;
    128            #endif
    129          #else
    130            constexpr bool Planner::leveling_active;
    131          #endif
    132          
    133          #if ENABLED(SKEW_CORRECTION)
    134            #if ENABLED(SKEW_CORRECTION_GCODE)
    135              float Planner::xy_skew_factor;
    136            #else
    137              constexpr float Planner::xy_skew_factor;
    138            #endif
    139            #if ENABLED(SKEW_CORRECTION_FOR_Z) && ENABLED(SKEW_CORRECTION_GCODE)
    140              float Planner::xz_skew_factor, Planner::yz_skew_factor;
    141            #else
    142              constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
    143            #endif
    144          #endif
    145          
    146          #if ENABLED(AUTOTEMP)
    147            float Planner::autotemp_max = 250,
    148                  Planner::autotemp_min = 210,
    149                  Planner::autotemp_factor = 0.1;
    150            bool Planner::autotemp_enabled = false;
    151          #endif
    152          
    153          // private:
    154          
    155          int32_t Planner::position[NUM_AXIS] = { 0 };
    156          
    157          uint32_t Planner::cutoff_long;
    158          
    159          float Planner::previous_speed[NUM_AXIS],
    160                Planner::previous_nominal_speed;
    161          
    162          #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
    163            uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
    164          #endif
    165          
    166          #ifdef XY_FREQUENCY_LIMIT
    167            // Old direction bits. Used for speed calculations
    168            unsigned char Planner::old_direction_bits = 0;
    169            // Segment times (in 碌s). Used for speed calculations
    170            uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
    171          #endif
    172          
    173          #if ENABLED(LIN_ADVANCE)
    174            float Planner::extruder_advance_k, // Initialized by settings.load()
    175                  Planner::advance_ed_ratio,   // Initialized by settings.load()
    176                  Planner::position_float[XYZE], // Needed for accurate maths. Steps cannot be used!
    177                  Planner::lin_dist_xy,
    178                  Planner::lin_dist_e;
    179          #endif
    180          
    181          #if ENABLED(ULTRA_LCD)
    182            volatile uint32_t Planner::block_buffer_runtime_us = 0;
    183          #endif
    184          
    185          /**
    186           * Class and Instance Methods
    187           */
    188          

   \                                 In section .text, align 2, keep-with-next
    189          Planner::Planner() { init(); }
   \                     _ZN7PlannerC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN7Planner4initEv
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void Planner::init() {
   \                     _ZN7Planner4initEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    192            block_buffer_head = block_buffer_tail = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable12_6
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7060             STRB     R0,[R4, #+1]
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
    193            ZERO(position);
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0xF104 0x0040      ADD      R0,R4,#+64
   \   00000014   0x.... 0x....      BL       memset
    194            #if ENABLED(LIN_ADVANCE)
    195              ZERO(position_float);
    196            #endif
    197            ZERO(previous_speed);
   \   00000018   0x2210             MOVS     R2,#+16
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000020   0x.... 0x....      BL       memset
    198            previous_nominal_speed = 0.0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x67A0             STR      R0,[R4, #+120]
    199            #if 1//ABL_PLANAR
    200              bed_level_matrix.set_to_identity();
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030   0x.... 0x....      B.W      _ZN10matrix_3x315set_to_identityEv
    201            #endif
    202          }
    203          
    204          #define MINIMAL_STEP_RATE 120
    205          
    206          /**
    207           * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
    208           * by the provided factors.
    209           */

   \                                 In section .text, align 4, keep-with-next
    210          void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   \                     _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
    211            uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000000C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000000E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000012   0x6829             LDR      R1,[R5, #+0]
   \   00000014   0x.... 0x....      BL       __aeabi_fmul
   \   00000018   0x.... 0x....      BL       ceilf
   \   0000001C   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000020   0x4605             MOV      R5,R0
    212                     final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000022   0x6BE0             LDR      R0,[R4, #+60]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2f
   \   00000028   0x6831             LDR      R1,[R6, #+0]
   \   0000002A   0x.... 0x....      BL       __aeabi_fmul
   \   0000002E   0x.... 0x....      BL       ceilf
   \   00000032   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000036   0x4606             MOV      R6,R0
    213          
    214            // Limit minimal step rate (Otherwise the timer will overflow.)
    215            NOLESS(initial_rate, MINIMAL_STEP_RATE);
   \   00000038   0x2D78             CMP      R5,#+120
   \   0000003A   0xD200             BCS.N    ??calculate_trapezoid_for_block_0
   \   0000003C   0x2578             MOVS     R5,#+120
    216            NOLESS(final_rate, MINIMAL_STEP_RATE);
   \                     ??calculate_trapezoid_for_block_0: (+1)
   \   0000003E   0x2E78             CMP      R6,#+120
   \   00000040   0xD200             BCS.N    ??calculate_trapezoid_for_block_1
   \   00000042   0x2678             MOVS     R6,#+120
    217          
    218            const int32_t accel = block->acceleration_steps_per_s2;
   \                     ??calculate_trapezoid_for_block_1: (+1)
   \   00000044   0xF8D4 0xB048      LDR      R11,[R4, #+72]
    219          
    220                    // Steps required for acceleration, deceleration to/from nominal rate
    221            int32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000004E   0x4607             MOV      R7,R0
   \   00000050   0x9705             STR      R7,[SP, #+20]
   \   00000052   0x6BE0             LDR      R0,[R4, #+60]
   \   00000054   0x.... 0x....      BL       __aeabi_ui2f
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x4658             MOV      R0,R11
   \   0000005C   0x.... 0x....      BL       __aeabi_i2f
   \   00000060   0x4680             MOV      R8,R0
   \   00000062   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \   00000066   0xAA04             ADD      R2,SP,#+16
   \   00000068   0xA901             ADD      R1,SP,#+4
   \   0000006A   0xA805             ADD      R0,SP,#+20
   \   0000006C   0x.... 0x....      BL       _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_
   \   00000070   0x.... 0x....      BL       ceilf
   \   00000074   0x.... 0x....      BL       __aeabi_f2iz
   \   00000078   0x4681             MOV      R9,R0
    222                    decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000007A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000007C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       __aeabi_ui2f
   \   00000088   0x4682             MOV      R10,R0
   \   0000008A   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   0000008E   0xF1CB 0x0000      RSB      R0,R11,#+0
   \   00000092   0x.... 0x....      BL       __aeabi_i2f
   \   00000096   0x9002             STR      R0,[SP, #+8]
   \   00000098   0xAA02             ADD      R2,SP,#+8
   \   0000009A   0xA903             ADD      R1,SP,#+12
   \   0000009C   0xA800             ADD      R0,SP,#+0
   \   0000009E   0x.... 0x....      BL       _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_
   \   000000A2   0x.... 0x....      BL       floorf
   \   000000A6   0x.... 0x....      BL       __aeabi_f2iz
    223                    // Steps between acceleration and deceleration, if any
    224                    plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
   \   000000AA   0x6961             LDR      R1,[R4, #+20]
   \   000000AC   0xEBA1 0x0109      SUB      R1,R1,R9
   \   000000B0   0x1A08             SUBS     R0,R1,R0
    225          
    226            // Does accelerate_steps + decelerate_steps exceed step_event_count?
    227            // Then we can't possibly reach the nominal rate, there will be no cruising.
    228            // Use intersection_distance() to calculate accel / braking time in order to
    229            // reach the final_rate exactly at the end of this block.
    230            if (plateau_steps < 0) {
   \   000000B2   0xD51D             BPL.N    ??calculate_trapezoid_for_block_2
    231              accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000000B4   0x9703             STR      R7,[SP, #+12]
   \   000000B6   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \   000000BA   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000BE   0x6960             LDR      R0,[R4, #+20]
   \   000000C0   0x.... 0x....      BL       __aeabi_ui2f
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0xAB00             ADD      R3,SP,#+0
   \   000000C8   0xAA01             ADD      R2,SP,#+4
   \   000000CA   0xA902             ADD      R1,SP,#+8
   \   000000CC   0xA803             ADD      R0,SP,#+12
   \   000000CE   0x.... 0x....      BL       _ZN7Planner21intersection_distanceERKfS1_S1_S1_
   \   000000D2   0x.... 0x....      BL       ceilf
   \   000000D6   0x.... 0x....      BL       __aeabi_f2iz
   \   000000DA   0x4681             MOV      R9,R0
    232              NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
   \   000000DC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E0   0xD501             BPL.N    ??calculate_trapezoid_for_block_3
   \   000000E2   0xF04F 0x0900      MOV      R9,#+0
    233              accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
   \                     ??calculate_trapezoid_for_block_3: (+1)
   \   000000E6   0x6960             LDR      R0,[R4, #+20]
   \   000000E8   0x4581             CMP      R9,R0
   \   000000EA   0xD300             BCC.N    ??calculate_trapezoid_for_block_4
   \   000000EC   0x4681             MOV      R9,R0
    234              plateau_steps = 0;
   \                     ??calculate_trapezoid_for_block_4: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
    235            }
    236          
    237            // block->accelerate_until = accelerate_steps;
    238            // block->decelerate_after = accelerate_steps+plateau_steps;
    239          
    240            CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   \                     ??calculate_trapezoid_for_block_2: (+1)
   \   000000F0   0xB672             cpsid i
    241            if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
   \   000000F2   0x7821             LDRB     R1,[R4, #+0]
   \   000000F4   0x0709             LSLS     R1,R1,#+28
   \   000000F6   0xD405             BMI.N    ??calculate_trapezoid_for_block_5
    242              block->accelerate_until = accelerate_steps;
   \   000000F8   0xF8C4 0x9018      STR      R9,[R4, #+24]
    243              block->decelerate_after = accelerate_steps + plateau_steps;
   \   000000FC   0x4448             ADD      R0,R0,R9
   \   000000FE   0x61E0             STR      R0,[R4, #+28]
    244              block->initial_rate = initial_rate;
   \   00000100   0x6425             STR      R5,[R4, #+64]
    245              block->final_rate = final_rate;
   \   00000102   0x6466             STR      R6,[R4, #+68]
    246            }
    247            CRITICAL_SECTION_END;
   \                     ??calculate_trapezoid_for_block_5: (+1)
   \   00000104   0xB662             cpsie i
    248          }
   \   00000106   0xB007             ADD      SP,SP,#+28
   \   00000108   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    249          
    250          // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
    251          // This method will calculate the junction jerk as the euclidean distance between the nominal
    252          // velocities of the respective blocks.
    253          //inline float junction_jerk(block_t *before, block_t *after) {
    254          //  return SQRT(
    255          //    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
    256          //}
    257          
    258          
    259          // The kernel called by recalculate() when scanning the plan from last to first entry.

   \                                 In section .text, align 2, keep-with-next
    260          void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
   \                     _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    261            if (!current || !next) return;
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD02F             BEQ.N    ??reverse_pass_kernel_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD02D             BEQ.N    ??reverse_pass_kernel_0
    262            // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
    263            // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
    264            // check for maximum allowable speed reductions to ensure maximum possible planned speed.
    265            float max_entry_speed = current->max_entry_speed;
   \   0000000E   0x6B26             LDR      R6,[R4, #+48]
    266            if (current->entry_speed != max_entry_speed) {
   \   00000010   0x6AE0             LDR      R0,[R4, #+44]
   \   00000012   0x4631             MOV      R1,R6
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000018   0xD027             BEQ.N    ??reverse_pass_kernel_0
    267              // If nominal length true, max junction speed is guaranteed to be reached. Only compute
    268              // for max allowable speed if block is decelerating and nominal length is false.
    269              current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
    270                ? max_entry_speed
    271                : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD41F             BMI.N    ??reverse_pass_kernel_1
   \   00000020   0x6AE8             LDR      R0,[R5, #+44]
   \   00000022   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000026   0xD91B             BLS.N    ??reverse_pass_kernel_1
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0xF104 0x0234      ADD      R2,R4,#+52
   \   00000034   0xF105 0x012C      ADD      R1,R5,#+44
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   0000003E   0x4601             MOV      R1,R0
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000046   0xD30B             BCC.N    ??reverse_pass_kernel_1
   \   00000048   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0xF104 0x0234      ADD      R2,R4,#+52
   \   00000054   0xF105 0x012C      ADD      R1,R5,#+44
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   0000005E   0x4606             MOV      R6,R0
   \                     ??reverse_pass_kernel_1: (+1)
   \   00000060   0x62E6             STR      R6,[R4, #+44]
    272              SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \   00000062   0x7820             LDRB     R0,[R4, #+0]
   \   00000064   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000068   0x7020             STRB     R0,[R4, #+0]
    273            }
    274          }
   \                     ??reverse_pass_kernel_0: (+1)
   \   0000006A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    275          
    276          /**
    277           * recalculate() needs to go over the current plan twice.
    278           * Once in reverse and once forward. This implements the reverse pass.
    279           */

   \                                 In section .text, align 2, keep-with-next
    280          void Planner::reverse_pass() {
   \                     _ZN7Planner12reverse_passEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    281            if (movesplanned() > 3) {
   \   00000004   0x.... 0x....      BL       _ZN7Planner12movesplannedEv
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xDB24             BLT.N    ??reverse_pass_0
    282              const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 2); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_6
   \   00000010   0x7841             LDRB     R1,[R0, #+1]
   \   00000012   0x1C89             ADDS     R1,R1,#+2
   \   00000014   0xF001 0x040F      AND      R4,R1,#0xF
    283                                                                      // tail+2 because the index is not yet advanced when checked
    284              uint8_t blocknr = prev_block_index(block_buffer_head);
   \   00000018   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       _ZN7Planner16prev_block_indexEa
   \   00000020   0x4607             MOV      R7,R0
   \   00000022   0xB2FF             UXTB     R7,R7
    285              block_t* current = &block_buffer[blocknr];
   \   00000024   0x2554             MOVS     R5,#+84
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable12_8
   \   0000002A   0x4638             MOV      R0,R7
   \   0000002C   0xFB05 0x6800      MLA      R8,R5,R0,R6
    286          
    287              do {
    288                const block_t * const next = current;
   \                     ??reverse_pass_1: (+1)
   \   00000030   0x46C1             MOV      R9,R8
    289                blocknr = prev_block_index(blocknr);
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0xB240             SXTB     R0,R0
   \   00000036   0x.... 0x....      BL       _ZN7Planner16prev_block_indexEa
   \   0000003A   0x4607             MOV      R7,R0
   \   0000003C   0xB2FF             UXTB     R7,R7
    290                current = &block_buffer[blocknr];
   \   0000003E   0xFB05 0x6807      MLA      R8,R5,R7,R6
    291                if (TEST(current->flag, BLOCK_BIT_START_FROM_FULL_HALT)) // Up to this every block is already optimized.
   \   00000042   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000046   0x0740             LSLS     R0,R0,#+29
   \   00000048   0xD405             BMI.N    ??reverse_pass_0
    292                  break;
    293                reverse_pass_kernel(current, next);
   \   0000004A   0x4649             MOV      R1,R9
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_
    294              } while (blocknr != endnr);
   \   00000052   0x42A7             CMP      R7,R4
   \   00000054   0xD1EC             BNE.N    ??reverse_pass_1
    295            }
    296          }
   \                     ??reverse_pass_0: (+1)
   \   00000056   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    297          
    298          // The kernel called by recalculate() when scanning the plan from first to last entry.

   \                                 In section .text, align 2, keep-with-next
    299          void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
   \                     _ZN7Planner19forward_pass_kernelEPK7block_tPS0_: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    300            if (!previous) return;
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD02E             BEQ.N    ??forward_pass_kernel_0
    301          
    302            // If the previous block is an acceleration block, but it is not long enough to complete the
    303            // full speed change within the block, we need to adjust the entry speed accordingly. Entry
    304            // speeds have already been reset, maximized, and reverse planned by reverse planner.
    305            // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
    306            if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD42B             BMI.N    ??forward_pass_kernel_0
    307              if (previous->entry_speed < current->entry_speed) {
   \   00000012   0x6AE0             LDR      R0,[R4, #+44]
   \   00000014   0x6AE9             LDR      R1,[R5, #+44]
   \   00000016   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000001A   0xD226             BCS.N    ??forward_pass_kernel_0
    308                float entry_speed = min(current->entry_speed,
    309                                         max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
   \   0000001C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000001E   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xF104 0x0234      ADD      R2,R4,#+52
   \   00000028   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x6AEA             LDR      R2,[R5, #+44]
   \   00000036   0x4610             MOV      R0,R2
   \   00000038   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000003C   0xD30B             BCC.N    ??forward_pass_kernel_1
   \   0000003E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000040   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0xF104 0x0234      ADD      R2,R4,#+52
   \   0000004A   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   00000054   0x4602             MOV      R2,R0
    310                // Check for junction speed change
    311                if (current->entry_speed != entry_speed) {
   \                     ??forward_pass_kernel_1: (+1)
   \   00000056   0x6AE8             LDR      R0,[R5, #+44]
   \   00000058   0x4611             MOV      R1,R2
   \   0000005A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000005E   0xD004             BEQ.N    ??forward_pass_kernel_0
    312                  current->entry_speed = entry_speed;
   \   00000060   0x62EA             STR      R2,[R5, #+44]
    313                  SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \   00000062   0x7828             LDRB     R0,[R5, #+0]
   \   00000064   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000068   0x7028             STRB     R0,[R5, #+0]
    314                }
    315              }
    316            }
    317          }
   \                     ??forward_pass_kernel_0: (+1)
   \   0000006A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    318          
    319          /**
    320           * recalculate() needs to go over the current plan twice.
    321           * Once in reverse and once forward. This implements the forward pass.
    322           */

   \                                 In section .text, align 2, keep-with-next
    323          void Planner::forward_pass() {
   \                     _ZN7Planner12forward_passEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    324            block_t* block[3] = { NULL, NULL, NULL };
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x4625             MOV      R5,R4
    325          
    326            for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable12_6
   \   0000000A   0x7877             LDRB     R7,[R6, #+1]
   \   0000000C   0xE00F             B.N      ??forward_pass_0
    327              block[0] = block[1];
   \                     ??forward_pass_1: (+1)
   \   0000000E   0x4620             MOV      R0,R4
    328              block[1] = block[2];
   \   00000010   0x462C             MOV      R4,R5
    329              block[2] = &block_buffer[b];
   \   00000012   0x2154             MOVS     R1,#+84
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable12_8
   \   00000018   0xFB01 0x2507      MLA      R5,R1,R7,R2
    330              forward_pass_kernel(block[0], block[1]);
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x.... 0x....      BL       _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    331            }
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0xB240             SXTB     R0,R0
   \   00000026   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   0000002A   0x4607             MOV      R7,R0
   \   0000002C   0xB2FF             UXTB     R7,R7
   \                     ??forward_pass_0: (+1)
   \   0000002E   0x7830             LDRB     R0,[R6, #+0]
   \   00000030   0x4287             CMP      R7,R0
   \   00000032   0xD1EC             BNE.N    ??forward_pass_1
    332            forward_pass_kernel(block[1], block[2]);
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000003C   0x....             B.N      _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    333          }
    334          
    335          /**
    336           * Recalculate the trapezoid speed profiles for all blocks in the plan
    337           * according to the entry_factor for each junction. Must be called by
    338           * recalculate() after updating the blocks.
    339           */

   \                                 In section .text, align 2, keep-with-next
    340          void Planner::recalculate_trapezoids() {
   \                     _ZN7Planner22recalculate_trapezoidsEv: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    341            int8_t block_index = block_buffer_tail;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable12_6
   \   00000008   0xF995 0x6001      LDRSB    R6,[R5, #+1]
    342            block_t *current, *next = NULL;
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE02A             B.N      ??recalculate_trapezoids_0
    343          
    344            while (block_index != block_buffer_head) {
    345              current = next;
   \                     ??recalculate_trapezoids_1: (+1)
   \   00000010   0x4627             MOV      R7,R4
    346              next = &block_buffer[block_index];
   \   00000012   0x2054             MOVS     R0,#+84
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000018   0xFB00 0x1406      MLA      R4,R0,R6,R1
    347              if (current) {
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD01E             BEQ.N    ??recalculate_trapezoids_2
    348                // Recalculate if current block entry or exit junction speed has changed.
    349                if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
   \   00000020   0x7838             LDRB     R0,[R7, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD402             BMI.N    ??recalculate_trapezoids_3
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD518             BPL.N    ??recalculate_trapezoids_2
    350                  // NOTE: Entry and exit factors always > 0 by all previous logic operations.
    351                  const float nomr = 1.0 / current->nominal_speed;
   \                     ??recalculate_trapezoids_3: (+1)
   \   0000002C   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000030   0x6AB9             LDR      R1,[R7, #+40]
   \   00000032   0x.... 0x....      BL       __aeabi_fdiv
   \   00000036   0x4680             MOV      R8,R0
    352                  calculate_trapezoid_for_block(current, current->entry_speed * nomr, next->entry_speed * nomr);
   \   00000038   0x6AF8             LDR      R0,[R7, #+44]
   \   0000003A   0x4641             MOV      R1,R8
   \   0000003C   0x.... 0x....      BL       __aeabi_fmul
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x6AE0             LDR      R0,[R4, #+44]
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0xA901             ADD      R1,SP,#+4
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    353                  CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
   \   00000056   0x7838             LDRB     R0,[R7, #+0]
   \   00000058   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000005C   0x7038             STRB     R0,[R7, #+0]
    354                }
    355              }
    356              block_index = next_block_index(block_index);
   \                     ??recalculate_trapezoids_2: (+1)
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   00000064   0x4606             MOV      R6,R0
    357            }
   \                     ??recalculate_trapezoids_0: (+1)
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x7829             LDRB     R1,[R5, #+0]
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD1D0             BNE.N    ??recalculate_trapezoids_1
    358            // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
    359            if (next) {
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD01D             BEQ.N    ??recalculate_trapezoids_4
    360              const float nomr = 1.0 / next->nominal_speed;
   \   00000072   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000076   0x6AA1             LDR      R1,[R4, #+40]
   \   00000078   0x.... 0x....      BL       __aeabi_fdiv
   \   0000007C   0x4605             MOV      R5,R0
    361              calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
   \   0000007E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000080   0x4629             MOV      R1,R5
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0x.... 0x....      BL       __aeabi_f2d
   \   0000008E   0x....             LDR.N    R2,??DataTable12_9  ;; 0x9999999a
   \   00000090   0x....             LDR.N    R3,??DataTable12_10  ;; 0x3fa99999
   \   00000092   0x.... 0x....      BL       __aeabi_dmul
   \   00000096   0x.... 0x....      BL       __aeabi_d2f
   \   0000009A   0x9001             STR      R0,[SP, #+4]
   \   0000009C   0xAA01             ADD      R2,SP,#+4
   \   0000009E   0xA900             ADD      R1,SP,#+0
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    362              CBI(next->flag, BLOCK_BIT_RECALCULATE);
   \   000000A6   0x7820             LDRB     R0,[R4, #+0]
   \   000000A8   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   000000AC   0x7020             STRB     R0,[R4, #+0]
    363            }
    364          }
   \                     ??recalculate_trapezoids_4: (+1)
   \   000000AE   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    365          
    366          /*
    367           * Recalculate the motion plan according to the following algorithm:
    368           *
    369           *   1. Go over every block in reverse order...
    370           *
    371           *      Calculate a junction speed reduction (block_t.entry_factor) so:
    372           *
    373           *      a. The junction jerk is within the set limit, and
    374           *
    375           *      b. No speed reduction within one block requires faster
    376           *         deceleration than the one, true constant acceleration.
    377           *
    378           *   2. Go over every block in chronological order...
    379           *
    380           *      Dial down junction speed reduction values if:
    381           *      a. The speed increase within one block would require faster
    382           *         acceleration than the one, true constant acceleration.
    383           *
    384           * After that, all blocks will have an entry_factor allowing all speed changes to
    385           * be performed using only the one, true constant acceleration, and where no junction
    386           * jerk is jerkier than the set limit, Jerky. Finally it will:
    387           *
    388           *   3. Recalculate "trapezoids" for all blocks.
    389           */

   \                                 In section .text, align 2, keep-with-next
    390          void Planner::recalculate() {
   \                     _ZN7Planner11recalculateEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    391            reverse_pass();
   \   00000002   0x.... 0x....      BL       _ZN7Planner12reverse_passEv
    392            forward_pass();
   \   00000006   0x.... 0x....      BL       _ZN7Planner12forward_passEv
    393            recalculate_trapezoids();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x....             B.N      _ZN7Planner22recalculate_trapezoidsEv
    394          }
    395          
    396          
    397          #if ENABLED(AUTOTEMP)
    398          

   \                                 In section .text, align 2, keep-with-next
    399            void Planner::getHighESpeed() {
   \                     _ZN7Planner13getHighESpeedEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    400              static float oldt = 0;
    401          
    402              if (!autotemp_enabled) return;
   \   00000004   0x....             LDR.N    R7,??DataTable12_6
   \   00000006   0x78F8             LDRB     R0,[R7, #+3]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD075             BEQ.N    ??getHighESpeed_0
    403              if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
   \   0000000C   0x6DFC             LDR      R4,[R7, #+92]
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000014   0xF04F 0x4180      MOV      R1,#+1073741824
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000022   0xD369             BCC.N    ??getHighESpeed_0
    404          
    405              float high = 0.0;
   \   00000024   0x2500             MOVS     R5,#+0
    406              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   00000026   0x787E             LDRB     R6,[R7, #+1]
   \   00000028   0xE02C             B.N      ??getHighESpeed_1
    407                block_t* block = &block_buffer[b];
   \                     ??getHighESpeed_2: (+1)
   \   0000002A   0x2054             MOVS     R0,#+84
   \   0000002C   0x....             LDR.N    R1,??DataTable12_8
   \   0000002E   0xFB00 0x1806      MLA      R8,R0,R6,R1
    408                if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
   \   00000032   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD107             BNE.N    ??getHighESpeed_3
   \   0000003A   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD103             BNE.N    ??getHighESpeed_3
   \   00000042   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD016             BEQ.N    ??getHighESpeed_4
    409                  float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
   \                     ??getHighESpeed_3: (+1)
   \   0000004A   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   0000004E   0x.... 0x....      BL       __aeabi_i2f
   \   00000052   0x4681             MOV      R9,R0
   \   00000054   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \   00000058   0x.... 0x....      BL       __aeabi_ui2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4648             MOV      R0,R9
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0xF8D8 0x1028      LDR      R1,[R8, #+40]
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0x4601             MOV      R1,R0
    410                  NOLESS(high, se);
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000074   0xD200             BCS.N    ??getHighESpeed_4
   \   00000076   0x460D             MOV      R5,R1
    411                }
    412              }
   \                     ??getHighESpeed_4: (+1)
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0xB240             SXTB     R0,R0
   \   0000007C   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   00000080   0x4606             MOV      R6,R0
   \   00000082   0xB2F6             UXTB     R6,R6
   \                     ??getHighESpeed_1: (+1)
   \   00000084   0x7838             LDRB     R0,[R7, #+0]
   \   00000086   0x4286             CMP      R6,R0
   \   00000088   0xD1CF             BNE.N    ??getHighESpeed_2
    413          
    414              float t = autotemp_min + high * autotemp_factor;
   \   0000008A   0x6E38             LDR      R0,[R7, #+96]
   \   0000008C   0x4629             MOV      R1,R5
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4621             MOV      R1,R4
   \   00000094   0x.... 0x....      BL       __aeabi_fadd
   \   00000098   0x4602             MOV      R2,R0
    415              t = constrain(t, autotemp_min, autotemp_max);
   \   0000009A   0x4621             MOV      R1,R4
   \   0000009C   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000A0   0xD201             BCS.N    ??getHighESpeed_5
   \   000000A2   0x4622             MOV      R2,R4
   \   000000A4   0xE005             B.N      ??getHighESpeed_6
   \                     ??getHighESpeed_5: (+1)
   \   000000A6   0x6DB8             LDR      R0,[R7, #+88]
   \   000000A8   0x4611             MOV      R1,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000AE   0xD200             BCS.N    ??getHighESpeed_6
   \   000000B0   0x4602             MOV      R2,R0
    416              if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
   \                     ??getHighESpeed_6: (+1)
   \   000000B2   0x6FFE             LDR      R6,[R7, #+124]
   \   000000B4   0x4610             MOV      R0,R2
   \   000000B6   0x4631             MOV      R1,R6
   \   000000B8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BC   0xD215             BCS.N    ??getHighESpeed_7
   \   000000BE   0x.... 0x....      BL       __aeabi_f2d
   \   000000C2   0x....             LDR.N    R2,??DataTable12_11  ;; 0x47ae1480
   \   000000C4   0x....             LDR.N    R3,??DataTable12_12  ;; 0x3f947ae1
   \   000000C6   0x.... 0x....      BL       __aeabi_dmul
   \   000000CA   0x4604             MOV      R4,R0
   \   000000CC   0x460D             MOV      R5,R1
   \   000000CE   0x4630             MOV      R0,R6
   \   000000D0   0x.... 0x....      BL       __aeabi_f2d
   \   000000D4   0x....             LDR.N    R2,??DataTable12_13  ;; 0xf5c28f5c
   \   000000D6   0x....             LDR.N    R3,??DataTable12_14  ;; 0x3fef5c28
   \   000000D8   0x.... 0x....      BL       __aeabi_dmul
   \   000000DC   0x4622             MOV      R2,R4
   \   000000DE   0x462B             MOV      R3,R5
   \   000000E0   0x.... 0x....      BL       __aeabi_dadd
   \   000000E4   0x.... 0x....      BL       __aeabi_d2f
   \   000000E8   0x4602             MOV      R2,R0
    417              oldt = t;
   \                     ??getHighESpeed_7: (+1)
   \   000000EA   0x67FA             STR      R2,[R7, #+124]
    418              thermalManager.setTargetHotend(t, 0);
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x4610             MOV      R0,R2
   \   000000F0   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000F4   0x.... 0x....      B.W      _ZN11Temperature15setTargetHotendEfh
   \                     ??getHighESpeed_0: (+1)
   \   000000F8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    419            }

   \                                 In section .data, align 4
   \                     _ZN7Planner17block_buffer_headE:
   \   00000000   0x00               DC8 0
   \                     _ZN7Planner17block_buffer_tailE:
   \   00000001   0x00               DC8 0
   \                     _ZN7Planner13last_extruderE:
   \   00000002   0x00               DC8 0
   \                     _ZN7Planner16autotemp_enabledE:
   \   00000003   0x00               DC8 0
   \                     _ZN7Planner17axis_steps_per_mmE:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner11steps_to_mmE:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner29max_acceleration_steps_per_s2E:
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner8positionE:
   \   00000040   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \                     _ZN7Planner8e_factorE:
   \   00000050   0x3F800000         DC32 3F800000H, 3F800000H
   \              0x3F800000   
   \                     _ZN7Planner12autotemp_maxE:
   \   00000058   0x437A0000         DC32 437A0000H
   \                     _ZN7Planner12autotemp_minE:
   \   0000005C   0x43520000         DC32 43520000H
   \                     _ZN7Planner15autotemp_factorE:
   \   00000060   0x3DCCCCCD         DC32 3DCCCCCDH
   \                     _ZN7Planner11cutoff_longE:
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Planner14previous_speedE:
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner22previous_nominal_speedE:
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000007C   0x00000000         DC32 0H

   \                                 In section .data, align 4
   \                     _ZN7Planner15flow_percentageE:
   \   00000000   0x0064 0x0064      DC16 100, 100
   \                     _ZN7Planner21volumetric_multiplierE:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner13filament_sizeE:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    420          
    421          #endif // AUTOTEMP
    422          
    423          /**
    424           * Maintain fans, paste extruder pressure,
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          void Planner::check_axes_activity() {
   \                     _ZN7Planner19check_axes_activityEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    427            unsigned char axis_active[NUM_AXIS] = { 0 },
    428                          tail_fan_speed[FAN_COUNT];
                                 ^
Warning[Pe550]: variable "tail_fan_speed" was set but never used
    429          
    430            #if ENABLED(BARICUDA)
    431              #if HAS_HEATER_1
    432                uint8_t tail_valve_pressure;
    433              #endif
    434              #if HAS_HEATER_2
    435                uint8_t tail_e_to_p_pressure;
    436              #endif
    437            #endif
    438          
    439            if (blocks_queued()) {
   \   00000002   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD013             BEQ.N    ??check_axes_activity_0
    440          
    441              #if FAN_COUNT > 0
    442                for (uint8_t i = 0; i < FAN_COUNT; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R4,??DataTable12_6
   \   0000000E   0xE000             B.N      ??check_axes_activity_1
    443                  tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
   \                     ??check_axes_activity_2: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \                     ??check_axes_activity_1: (+1)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0xD0FB             BEQ.N    ??check_axes_activity_2
    444              #endif
    445          
    446              block_t* block;
    447          
    448              #if ENABLED(BARICUDA)
    449                block = &block_buffer[block_buffer_tail];
    450                #if HAS_HEATER_1
    451                  tail_valve_pressure = block->valve_pressure;
    452                #endif
    453                #if HAS_HEATER_2
    454                  tail_e_to_p_pressure = block->e_to_p_pressure;
    455                #endif
    456              #endif
    457          
    458              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   00000018   0xE006             B.N      ??check_axes_activity_3
    459                block = &block_buffer[b];
    460                LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
   \                     ??check_axes_activity_4: (+1)
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \                     ??check_axes_activity_5: (+1)
   \   0000001C   0x2904             CMP      R1,#+4
   \   0000001E   0xDBFC             BLT.N    ??check_axes_activity_4
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   00000026   0xB2C0             UXTB     R0,R0
   \                     ??check_axes_activity_3: (+1)
   \   00000028   0x7821             LDRB     R1,[R4, #+0]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD006             BEQ.N    ??check_axes_activity_6
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xE7F4             B.N      ??check_axes_activity_5
    461              }
    462            }
    463            else {
    464              #if FAN_COUNT > 0
    465                for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
   \                     ??check_axes_activity_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE000             B.N      ??check_axes_activity_7
   \                     ??check_axes_activity_8: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \                     ??check_axes_activity_7: (+1)
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD0FC             BEQ.N    ??check_axes_activity_8
    466              #endif
    467          
    468              #if ENABLED(BARICUDA)
    469                #if HAS_HEATER_1
    470                  tail_valve_pressure = baricuda_valve_pressure;
    471                #endif
    472                #if HAS_HEATER_2
    473                  tail_e_to_p_pressure = baricuda_e_to_p_pressure;
    474                #endif
    475              #endif
    476            }
    477          
    478            #if ENABLED(DISABLE_X)
    479              if (!axis_active[X_AXIS]) disable_X();
    480            #endif
    481            #if ENABLED(DISABLE_Y)
    482              if (!axis_active[Y_AXIS]) disable_Y();
    483            #endif
    484            #if ENABLED(DISABLE_Z)
    485              if (!axis_active[Z_AXIS]) disable_Z();
    486            #endif
    487            #if ENABLED(DISABLE_E)
    488              if (!axis_active[E_AXIS]) disable_e_steppers();
    489            #endif
    490          
    491            #if FAN_COUNT > 0
    492          
    493              #if FAN_KICKSTART_TIME > 0
    494          
    495                static millis_t fan_kick_end[FAN_COUNT] = { 0 };
    496          
    497                #define KICKSTART_FAN(f) \
    498                  if (tail_fan_speed[f]) { \
    499                    millis_t ms = millis(); \
    500                    if (fan_kick_end[f] == 0) { \
    501                      fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
    502                      tail_fan_speed[f] = 255; \
    503                    } else if (PENDING(ms, fan_kick_end[f])) \
    504                      tail_fan_speed[f] = 255; \
    505                  } else fan_kick_end[f] = 0
    506          
    507                #if HAS_FAN0
    508                  KICKSTART_FAN(0);
    509                #endif
    510                #if HAS_FAN1
    511                  KICKSTART_FAN(1);
    512                #endif
    513                #if HAS_FAN2
    514                  KICKSTART_FAN(2);
    515                #endif
    516          
    517              #endif // FAN_KICKSTART_TIME > 0
    518          
    519              #ifdef FAN_MIN_PWM
    520                #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
    521              #else
    522                #define CALC_FAN_SPEED(f) tail_fan_speed[f]
    523              #endif
    524          
    525              #if ENABLED(FAN_SOFT_PWM)
    526                #if HAS_FAN0
    527                  thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
    528                #endif
    529                #if HAS_FAN1
    530                  thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
    531                #endif
    532                #if HAS_FAN2
    533                  thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
    534                #endif
    535              #else
    536                #if HAS_FAN0
    537                  //analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
    538                #endif
    539                #if HAS_FAN1
    540                  //analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
    541                #endif
    542                #if HAS_FAN2
    543                  //analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
    544                #endif
    545              #endif
    546          
    547            #endif // FAN_COUNT > 0
    548          
    549            #if ENABLED(AUTOTEMP)
    550              getHighESpeed();
   \                     ??check_axes_activity_6: (+1)
   \   0000003C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000040   0x....             B.N      _ZN7Planner13getHighESpeedEv
    551            #endif
    552          
    553            #if ENABLED(BARICUDA)
    554              #if HAS_HEATER_1
    555                analogWrite(HEATER_1_PIN, tail_valve_pressure);
    556              #endif
    557              #if HAS_HEATER_2
    558                analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
    559              #endif
    560            #endif
    561          }
    562          
    563          #if DISABLED(NO_VOLUMETRICS)
    564          
    565            /**
    566             * Get a volumetric multiplier from a filament diameter.
    567             * This is the reciprocal of the circular cross-section area.
    568             * Return 1.0 with volumetric off or a diameter of 0.0.
    569             */

   \                                 In section .text, align 4
    570            inline float calculate_volumetric_multiplier(const float &diameter) {
   \                     _Z31calculate_volumetric_multiplierRKf: (+1)
   \   00000000   0xE92D 0x4370      PUSH     {R4-R6,R8,R9,LR}
    571              return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
   \   00000004   0x491F             LDR.N    R1,??calculate_volumetric_multiplier_0
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD037             BEQ.N    ??calculate_volumetric_multiplier_1
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x4610             MOV      R0,R2
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000016   0xD031             BEQ.N    ??calculate_volumetric_multiplier_1
   \   00000018   0x.... 0x....      BL       __aeabi_f2d
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x4B1A             LDR.N    R3,??calculate_volumetric_multiplier_0+0x4  ;; 0x3fe00000
   \   00000020   0x.... 0x....      BL       __aeabi_dmul
   \   00000024   0x4604             MOV      R4,R0
   \   00000026   0x460D             MOV      R5,R1
   \   00000028   0x2602             MOVS     R6,#+2
   \   0000002A   0xF04F 0x0800      MOV      R8,#+0
   \   0000002E   0xF8DF 0x905C      LDR.W    R9,??calculate_volumetric_multiplier_0+0x8  ;; 0x3ff00000
   \   00000032   0xE007             B.N      ??calculate_volumetric_multiplier_2
   \                     ??calculate_volumetric_multiplier_3: (+1)
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4622             MOV      R2,R4
   \   0000003A   0x462B             MOV      R3,R5
   \   0000003C   0x.... 0x....      BL       __aeabi_dmul
   \   00000040   0x4604             MOV      R4,R0
   \   00000042   0x460D             MOV      R5,R1
   \                     ??calculate_volumetric_multiplier_2: (+1)
   \   00000044   0x07F0             LSLS     R0,R6,#+31
   \   00000046   0xD507             BPL.N    ??calculate_volumetric_multiplier_4
   \   00000048   0x4622             MOV      R2,R4
   \   0000004A   0x462B             MOV      R3,R5
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x4649             MOV      R1,R9
   \   00000050   0x.... 0x....      BL       __aeabi_dmul
   \   00000054   0x4680             MOV      R8,R0
   \   00000056   0x4689             MOV      R9,R1
   \                     ??calculate_volumetric_multiplier_4: (+1)
   \   00000058   0x0876             LSRS     R6,R6,#+1
   \   0000005A   0xD1EB             BNE.N    ??calculate_volumetric_multiplier_3
   \   0000005C   0x480C             LDR.N    R0,??calculate_volumetric_multiplier_0+0xC  ;; 0x54442d18
   \   0000005E   0x490D             LDR.N    R1,??calculate_volumetric_multiplier_0+0x10  ;; 0x400921fb
   \   00000060   0x4642             MOV      R2,R8
   \   00000062   0x464B             MOV      R3,R9
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x4602             MOV      R2,R0
   \   0000006A   0x460B             MOV      R3,R1
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4907             LDR.N    R1,??calculate_volumetric_multiplier_0+0x8  ;; 0x3ff00000
   \   00000070   0x.... 0x....      BL       __aeabi_ddiv
   \   00000074   0xE8BD 0x4370      POP      {R4-R6,R8,R9,LR}
   \   00000078   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??calculate_volumetric_multiplier_1: (+1)
   \   0000007C   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000080   0xE8BD 0x8370      POP      {R4-R6,R8,R9,PC}  ;; return
   \                     ??calculate_volumetric_multiplier_0:
   \   00000084   0x........         DC32     _ZN11GCodeParser18volumetric_enabledE
   \   00000088   0x3FE00000         DC32     0x3fe00000
   \   0000008C   0x3FF00000         DC32     0x3ff00000
   \   00000090   0x54442D18         DC32     0x54442d18
   \   00000094   0x400921FB         DC32     0x400921fb
    572            }
    573          
    574            /**
    575             * Convert the filament sizes into volumetric multipliers.
    576             * The multiplier converts a given E value into a length.
    577             */

   \                                 In section .text, align 2, keep-with-next
    578            void Planner::calculate_volumetric_multipliers() {
   \                     _ZN7Planner32calculate_volumetric_multipliersEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    579              for (uint8_t i = 0; i < COUNT(filament_size); i++) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE00B             B.N      ??calculate_volumetric_multipliers_0
   \                     ??calculate_volumetric_multipliers_1: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable12_15
   \   00000008   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   0000000C   0xF105 0x000C      ADD      R0,R5,#+12
    580                volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
   \   00000010   0x.... 0x....      BL       _Z31calculate_volumetric_multiplierRKf
   \   00000014   0x6068             STR      R0,[R5, #+4]
    581                refresh_e_factor(i);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7Planner16refresh_e_factorEh
    582              }
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \                     ??calculate_volumetric_multipliers_0: (+1)
   \   0000001E   0x2C02             CMP      R4,#+2
   \   00000020   0xD3F1             BCC.N    ??calculate_volumetric_multipliers_1
    583            }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    584          
    585          #endif // !NO_VOLUMETRICS
    586          
    587          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    588            /**
    589             * Convert the ratio value given by the filament width sensor
    590             * into a volumetric multiplier. Conversion differs when using
    591             * linear extrusion vs volumetric extrusion.
    592             */
    593            void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
    594              // Reconstitute the nominal/measured ratio
    595              const float nom_meas_ratio = 1.0 + 0.01 * encoded_ratio,
    596                          ratio_2 = sq(nom_meas_ratio);
    597          
    598              volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
    599                ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5) // Volumetric uses a true volumetric multiplier
    600                : ratio_2;                                            // Linear squares the ratio, which scales the volume
    601          
    602              refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
    603            }
    604          #endif
    605          
    606          #if 1//PLANNER_LEVELING
    607            /**
    608             * rx, ry, rz - Cartesian positions in mm
    609             *              Leveled XYZ on completion
    610             */

   \                                 In section .text, align 2, keep-with-next
    611            void Planner::apply_leveling(float &rx, float &ry, float &rz) {
   \                     _ZN7Planner14apply_levelingERfS0_S0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    612          
    613              #if ENABLED(SKEW_CORRECTION)
    614                skew(rx, ry, rz);
    615              #endif
    616          
    617              if (!leveling_active) return;
   \   0000000A   0x....             LDR.N    R0,??DataTable12_16
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD059             BEQ.N    ??apply_leveling_0
    618          
    619              //#if ABL_PLANAR
    620              if(BED_LEVELING_METHOD & ABL_PLANAR)
   \   00000012   0x....             LDR.N    R0,??DataTable12_5
   \   00000014   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   00000018   0x2206             MOVS     R2,#+6
   \   0000001A   0x4211             TST      R1,R2
   \   0000001C   0xD016             BEQ.N    ??apply_leveling_1
    621              {
    622                float dx = rx - (X_TILT_FULCRUM),
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x9009             STR      R0,[SP, #+36]
    623                      dy = ry - (Y_TILT_FULCRUM);
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x9008             STR      R0,[SP, #+32]
    624          
    625                apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
   \   00000026   0x9607             STR      R6,[SP, #+28]
   \   00000028   0xA808             ADD      R0,SP,#+32
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   \   0000002C   0xA809             ADD      R0,SP,#+36
   \   0000002E   0x9005             STR      R0,[SP, #+20]
   \   00000030   0x....             LDR.N    R1,??DataTable12_7
   \   00000032   0xB084             SUB      SP,SP,#+16
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x2224             MOVS     R2,#+36
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000003C   0xBC0F             POP      {R0-R3}
   \   0000003E   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
    626          
    627                rx = dx + X_TILT_FULCRUM;
   \   00000042   0x9809             LDR      R0,[SP, #+36]
   \   00000044   0x6020             STR      R0,[R4, #+0]
    628                ry = dy + Y_TILT_FULCRUM;
   \   00000046   0x9808             LDR      R0,[SP, #+32]
   \   00000048   0x6028             STR      R0,[R5, #+0]
   \   0000004A   0xE03C             B.N      ??apply_leveling_0
    629              }
    630              //#else
    631              else
    632              {
    633                #if 0//ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    634                  const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
    635                  if (!fade_scaling_factor) return;
    636                //#elif HAS_MESH
    637                #else
    638                  float fade_scaling_factor;
    639                  if(BED_LEVELING_METHOD & HAS_MESH)
   \                     ??apply_leveling_1: (+1)
   \   0000004C   0x2238             MOVS     R2,#+56
   \   0000004E   0x4211             TST      R1,R2
   \   00000050   0xD002             BEQ.N    ??apply_leveling_2
    640                      fade_scaling_factor = 1.0;
   \   00000052   0xF04F 0x517E      MOV      R1,#+1065353216
   \   00000056   0x9100             STR      R1,[SP, #+0]
    641                #endif
    642          
    643                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    644                float raw[XYZ];
    645                if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \                     ??apply_leveling_2: (+1)
   \   00000058   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   0000005C   0x0709             LSLS     R1,R1,#+28
   \   0000005E   0xD505             BPL.N    ??apply_leveling_3
    646                {
    647                  raw[0] = rx;
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x9101             STR      R1,[SP, #+4]
    648                  raw[1] = ry;
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0x9102             STR      R1,[SP, #+8]
    649                  raw[2] = 0;
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x9103             STR      R1,[SP, #+12]
    650                }
    651                //#endif
    652          /*
    653                rz += (
    654                  #if ENABLED(AUTO_BED_LEVELING_UBL)
    655                    ubl.get_z_correction(rx, ry) * fade_scaling_factor
    656                  #elif ENABLED(MESH_BED_LEVELING)
    657                    mbl.get_z(rx, ry
    658                      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    659                        , fade_scaling_factor
    660                      #endif
    661                    )
    662                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    663                    bilinear_z_offset(raw) * fade_scaling_factor
    664                  #else
    665                    0
    666                  #endif
    667                );
    668          */        
    669                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??apply_leveling_3: (+1)
   \   0000006C   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000070   0x06C1             LSLS     R1,R0,#+27
   \   00000072   0xD50B             BPL.N    ??apply_leveling_4
    670                      rz += (ubl.get_z_correction(rx, ry) * fade_scaling_factor);
   \   00000074   0x4629             MOV      R1,R5
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_z_correctionERKfS1_
   \   0000007C   0x9900             LDR      R1,[SP, #+0]
   \   0000007E   0x.... 0x....      BL       __aeabi_fmul
   \   00000082   0x6831             LDR      R1,[R6, #+0]
   \   00000084   0x.... 0x....      BL       __aeabi_fadd
   \   00000088   0x6030             STR      R0,[R6, #+0]
   \   0000008A   0xE01C             B.N      ??apply_leveling_0
    671                  else if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??apply_leveling_4: (+1)
   \   0000008C   0x0681             LSLS     R1,R0,#+26
   \   0000008E   0xD50A             BPL.N    ??apply_leveling_5
    672                      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    673                      rz += ( mbl.get_z(rx, ry,fade_scaling_factor));
   \   00000090   0xAA00             ADD      R2,SP,#+0
   \   00000092   0x4629             MOV      R1,R5
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       _ZN17mesh_bed_leveling5get_zERKfS1_S1_
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x6830             LDR      R0,[R6, #+0]
   \   0000009E   0x.... 0x....      BL       __aeabi_fadd
   \   000000A2   0x6030             STR      R0,[R6, #+0]
   \   000000A4   0xE00F             B.N      ??apply_leveling_0
    674                      #else
    675                      rz += ( mbl.get_z(rx, ry));
    676                      #endif
    677                  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \                     ??apply_leveling_5: (+1)
   \   000000A6   0x0700             LSLS     R0,R0,#+28
   \   000000A8   0xD50B             BPL.N    ??apply_leveling_6
    678                      rz += bilinear_z_offset(raw) * fade_scaling_factor;
   \   000000AA   0xA801             ADD      R0,SP,#+4
   \   000000AC   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   000000B0   0x4601             MOV      R1,R0
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x.... 0x....      BL       __aeabi_fmul
   \   000000B8   0x6831             LDR      R1,[R6, #+0]
   \   000000BA   0x.... 0x....      BL       __aeabi_fadd
   \   000000BE   0x6030             STR      R0,[R6, #+0]
   \   000000C0   0xE001             B.N      ??apply_leveling_0
    679                  else
    680                      rz += 0;
   \                     ??apply_leveling_6: (+1)
   \   000000C2   0x6830             LDR      R0,[R6, #+0]
   \   000000C4   0x6030             STR      R0,[R6, #+0]
    681                  //#endif
    682              }
    683              //#endif
    684            }
   \                     ??apply_leveling_0: (+1)
   \   000000C6   0xB00A             ADD      SP,SP,#+40
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
    685          

   \                                 In section .text, align 2, keep-with-next
    686            void Planner::unapply_leveling(float raw[XYZ]) {
   \                     _ZN7Planner16unapply_levelingEPf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x4604             MOV      R4,R0
    687          
    688              #if 0//ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    689                const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
    690              #else
    691                constexpr float fade_scaling_factor = 1.0;
   \   00000006   0xF04F 0x507E      MOV      R0,#+1065353216
   \   0000000A   0x900A             STR      R0,[SP, #+40]
    692              #endif
    693          
    694              if (leveling_active && fade_scaling_factor) {
   \   0000000C   0x....             LDR.N    R0,??DataTable12_16
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD055             BEQ.N    ??unapply_leveling_0
   \   00000014   0x....             LDR.N    R0,??DataTable12_5
   \   00000016   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000001A   0x2106             MOVS     R1,#+6
   \   0000001C   0x4208             TST      R0,R1
   \   0000001E   0xD022             BEQ.N    ??unapply_leveling_1
    695          
    696                //#if ABL_PLANAR
    697                if(BED_LEVELING_METHOD & ABL_PLANAR)
    698                {
    699                  matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
   \   00000020   0x....             LDR.N    R1,??DataTable12_7
   \   00000022   0xB083             SUB      SP,SP,#+12
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x2224             MOVS     R2,#+36
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002C   0xBC0E             POP      {R1-R3}
   \   0000002E   0xA80B             ADD      R0,SP,#+44
   \   00000030   0x.... 0x....      BL       _ZN10matrix_3x39transposeES_
    700          
    701                  float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x9009             STR      R0,[SP, #+36]
    702                        dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x9008             STR      R0,[SP, #+32]
    703          
    704                  apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
   \   0000003C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000040   0x9007             STR      R0,[SP, #+28]
   \   00000042   0xA808             ADD      R0,SP,#+32
   \   00000044   0x9006             STR      R0,[SP, #+24]
   \   00000046   0xA809             ADD      R0,SP,#+36
   \   00000048   0x9005             STR      R0,[SP, #+20]
   \   0000004A   0xA90B             ADD      R1,SP,#+44
   \   0000004C   0xB084             SUB      SP,SP,#+16
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x2224             MOVS     R2,#+36
   \   00000052   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000056   0xBC0F             POP      {R0-R3}
   \   00000058   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
    705          
    706                  raw[X_AXIS] = dx + X_TILT_FULCRUM;
   \   0000005C   0x9809             LDR      R0,[SP, #+36]
   \   0000005E   0x6020             STR      R0,[R4, #+0]
    707                  raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
   \   00000060   0x9808             LDR      R0,[SP, #+32]
   \   00000062   0x6060             STR      R0,[R4, #+4]
   \   00000064   0xE02C             B.N      ??unapply_leveling_0
    708                }
    709                //#else // !ABL_PLANAR
    710                else
    711                {
    712                  if((BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL))
   \                     ??unapply_leveling_1: (+1)
   \   00000066   0x2810             CMP      R0,#+16
   \   00000068   0xD10C             BNE.N    ??unapply_leveling_2
    713                  {
    714                    raw[Z_AXIS] -= (ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor);
   \   0000006A   0x1D21             ADDS     R1,R4,#+4
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       _ZN20unified_bed_leveling16get_z_correctionERKfS1_
   \   00000072   0x990A             LDR      R1,[SP, #+40]
   \   00000074   0x.... 0x....      BL       __aeabi_fmul
   \   00000078   0x4601             MOV      R1,R0
   \   0000007A   0x68A0             LDR      R0,[R4, #+8]
   \   0000007C   0x.... 0x....      BL       __aeabi_fsub
   \   00000080   0x60A0             STR      R0,[R4, #+8]
   \   00000082   0xE01D             B.N      ??unapply_leveling_0
    715                  }
    716                  else if((BED_LEVELING_METHOD == MESH_BED_LEVELING))
   \                     ??unapply_leveling_2: (+1)
   \   00000084   0x2820             CMP      R0,#+32
   \   00000086   0xD10A             BNE.N    ??unapply_leveling_3
    717                  {
    718                      
    719                      raw[Z_AXIS] -= mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
    720                        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    721                          , fade_scaling_factor
    722                        #endif
    723                      );
   \   00000088   0xAA0A             ADD      R2,SP,#+40
   \   0000008A   0x1D21             ADDS     R1,R4,#+4
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       _ZN17mesh_bed_leveling5get_zERKfS1_S1_
   \   00000092   0x4601             MOV      R1,R0
   \   00000094   0x68A0             LDR      R0,[R4, #+8]
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x60A0             STR      R0,[R4, #+8]
   \   0000009C   0xE010             B.N      ??unapply_leveling_0
    724                  }
    725                  else if((BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR))
   \                     ??unapply_leveling_3: (+1)
   \   0000009E   0x2808             CMP      R0,#+8
   \   000000A0   0xD10C             BNE.N    ??unapply_leveling_4
    726                  {
    727                      raw[Z_AXIS] -= (bilinear_z_offset(raw) * fade_scaling_factor);
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   000000A8   0x4601             MOV      R1,R0
   \   000000AA   0x980A             LDR      R0,[SP, #+40]
   \   000000AC   0x.... 0x....      BL       __aeabi_fmul
   \   000000B0   0x4601             MOV      R1,R0
   \   000000B2   0x68A0             LDR      R0,[R4, #+8]
   \   000000B4   0x.... 0x....      BL       __aeabi_fsub
   \   000000B8   0x60A0             STR      R0,[R4, #+8]
   \   000000BA   0xE001             B.N      ??unapply_leveling_0
    728                  }
    729                  else
    730                  {
    731                      raw[Z_AXIS] -= 0;
   \                     ??unapply_leveling_4: (+1)
   \   000000BC   0x68A0             LDR      R0,[R4, #+8]
   \   000000BE   0x60A0             STR      R0,[R4, #+8]
    732                  }
    733                  /*
    734                  raw[Z_AXIS] -= (
    735                    #if ENABLED(AUTO_BED_LEVELING_UBL)
    736                      ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
    737                    #elif ENABLED(MESH_BED_LEVELING)
    738                      mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
    739                        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    740                          , fade_scaling_factor
    741                        #endif
    742                      )
    743                    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    744                      bilinear_z_offset(raw) * fade_scaling_factor
    745                    #else
    746                      0
    747                    #endif
    748                  );
    749                  */
    750                }
    751                //#endif // !ABL_PLANAR
    752              }
    753          
    754              #if ENABLED(SKEW_CORRECTION)
    755                unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
    756              #endif
    757            }
   \                     ??unapply_leveling_0: (+1)
   \   000000C0   0xB014             ADD      SP,SP,#+80
   \   000000C2   0xBD10             POP      {R4,PC}          ;; return
    758          
    759          #endif // PLANNER_LEVELING
    760          
    761          /**
    762           * Planner::_buffer_steps
    763           *
    764           * Add a new linear movement to the buffer (in terms of steps).
    765           *
    766           *  target      - target position in steps units
    767           *  fr_mm_s     - (target) speed of the move
    768           *  extruder    - target extruder
    769           */

   \                                 In section .text, align 4, keep-with-next
    770          void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner13_buffer_stepsERA4_Kifh: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB090             SUB      SP,SP,#+64
    771          
    772            const int32_t da = target[X_AXIS] - position[X_AXIS],
   \   00000006   0xF8DF 0x4D10      LDR.W    R4,??_buffer_steps_0
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6C21             LDR      R1,[R4, #+64]
   \   0000000E   0x1A45             SUBS     R5,R0,R1
    773                          db = target[Y_AXIS] - position[Y_AXIS],
   \   00000010   0x9810             LDR      R0,[SP, #+64]
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x6C61             LDR      R1,[R4, #+68]
   \   00000016   0xEBA0 0x0801      SUB      R8,R0,R1
    774                          dc = target[Z_AXIS] - position[Z_AXIS];
   \   0000001A   0x9810             LDR      R0,[SP, #+64]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x6CA1             LDR      R1,[R4, #+72]
   \   00000020   0xEBA0 0x0901      SUB      R9,R0,R1
    775          
    776            int32_t de = target[E_AXIS] - position[E_AXIS];
   \   00000024   0x9810             LDR      R0,[SP, #+64]
   \   00000026   0x68C0             LDR      R0,[R0, #+12]
   \   00000028   0x6CE1             LDR      R1,[R4, #+76]
   \   0000002A   0x1A47             SUBS     R7,R0,R1
    777          
    778          
    779            /* <-- add a slash to enable
    780              SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
    781              SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
    782              SERIAL_ECHOPAIR(" (", da);
    783              SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
    784              SERIAL_ECHOPAIR(" (", db);
    785              SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
    786              SERIAL_ECHOPAIR(" (", dc);
    787              SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
    788              SERIAL_ECHOPAIR(" (", de);
    789              SERIAL_ECHOLNPGM(" steps)");
    790            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
    791          
    792            // If LIN_ADVANCE is disabled then do E move prevention with integers
    793            // Otherwise it's done in _buffer_segment.
    794            #if DISABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
    795              if (de) {
   \   0000002C   0xD036             BEQ.N    ??_buffer_steps_1
    796                #if ENABLED(PREVENT_COLD_EXTRUSION)
    797                  if (thermalManager.tooColdToExtrude(extruder)) {
   \   0000002E   0x4610             MOV      R0,R2
   \   00000030   0x.... 0x....      BL       _ZN11Temperature16tooColdToExtrudeEh
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00B             BEQ.N    ??_buffer_steps_2
    798                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000038   0x9810             LDR      R0,[SP, #+64]
   \   0000003A   0x68C0             LDR      R0,[R0, #+12]
   \   0000003C   0x64E0             STR      R0,[R4, #+76]
    799                    de = 0; // no difference
   \   0000003E   0x2700             MOVS     R7,#+0
    800                    SERIAL_ECHO_START();
   \   00000040   0xF8DF 0x0CD8      LDR.W    R0,??_buffer_steps_0+0x4
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
    801                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   \   00000048   0xF8DF 0x0CD4      LDR.W    R0,??_buffer_steps_0+0x8
   \   0000004C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    802                  }
    803                #endif // PREVENT_COLD_EXTRUSION
    804                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
    805                  if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_2: (+1)
   \   00000050   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   00000054   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x4638             MOV      R0,R7
   \   0000005C   0x.... 0x....      BL       __aeabi_i2f
   \   00000060   0x9901             LDR      R1,[SP, #+4]
   \   00000062   0x6D09             LDR      R1,[R1, #+80]
   \   00000064   0x.... 0x....      BL       __aeabi_fmul
   \   00000068   0x.... 0x....      BL       __aeabi_f2iz
   \   0000006C   0x.... 0x....      BL       labs
   \   00000070   0x4606             MOV      R6,R0
   \   00000072   0x9801             LDR      R0,[SP, #+4]
   \   00000074   0x6900             LDR      R0,[R0, #+16]
   \   00000076   0x.... 0x....      BL       __aeabi_f2iz
   \   0000007A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000007E   0x4348             MULS     R0,R1,R0
   \   00000080   0x42B0             CMP      R0,R6
   \   00000082   0xDA0B             BGE.N    ??_buffer_steps_1
    806                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000084   0x9810             LDR      R0,[SP, #+64]
   \   00000086   0x68C0             LDR      R0,[R0, #+12]
   \   00000088   0x64E0             STR      R0,[R4, #+76]
    807                    de = 0; // no difference
   \   0000008A   0x2700             MOVS     R7,#+0
    808                    SERIAL_ECHO_START();
   \   0000008C   0xF8DF 0x0C8C      LDR.W    R0,??_buffer_steps_0+0x4
   \   00000090   0x.... 0x....      BL       _Z14serialprintPGMPKc
    809                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \   00000094   0xF8DF 0x0DDC      LDR.W    R0,??_buffer_steps_3
   \   00000098   0x.... 0x....      BL       _Z14serialprintPGMPKc
    810                  }
    811                #endif // PREVENT_LENGTHY_EXTRUDE
    812              }
    813            #endif // !LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
    814          
    815            // Compute direction bit-mask for this block
    816            uint8_t dm = 0;
   \                     ??_buffer_steps_1: (+1)
   \   0000009C   0x2600             MOVS     R6,#+0
   \   0000009E   0xF8DF 0x0DD8      LDR.W    R0,??_buffer_steps_3+0x4
   \   000000A2   0xF9B0 0x1058      LDRSH    R1,[R0, #+88]
   \   000000A6   0x220C             MOVS     R2,#+12
   \   000000A8   0x4211             TST      R1,R2
   \   000000AA   0xD01A             BEQ.N    ??_buffer_steps_4
    817            //#if CORE_IS_XY
    818            if(MACHINETPYE & CORE_IS_XY)
    819            {
    820              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
   \   000000AC   0x2D00             CMP      R5,#+0
   \   000000AE   0xD500             BPL.N    ??_buffer_steps_5
   \   000000B0   0x2610             MOVS     R6,#+16
    821              if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
   \                     ??_buffer_steps_5: (+1)
   \   000000B2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000B6   0xD501             BPL.N    ??_buffer_steps_6
   \   000000B8   0xF046 0x0620      ORR      R6,R6,#0x20
    822              if (dc < 0) SBI(dm, Z_AXIS);
   \                     ??_buffer_steps_6: (+1)
   \   000000BC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000C0   0xD501             BPL.N    ??_buffer_steps_7
   \   000000C2   0xF046 0x0604      ORR      R6,R6,#0x4
    823              if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
   \                     ??_buffer_steps_7: (+1)
   \   000000C6   0xEB18 0x0005      ADDS     R0,R8,R5
   \   000000CA   0xD501             BPL.N    ??_buffer_steps_8
   \   000000CC   0xF046 0x0601      ORR      R6,R6,#0x1
    824              if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   \                     ??_buffer_steps_8: (+1)
   \   000000D0   0xEBA5 0x0008      SUB      R0,R5,R8
   \   000000D4   0x.... 0x....      BL       _Z8CORESIGNl
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD54B             BPL.N    ??_buffer_steps_9
   \   000000DC   0xF046 0x0602      ORR      R6,R6,#0x2
   \   000000E0   0xE048             B.N      ??_buffer_steps_9
    825            }
    826            //#elif CORE_IS_XZ
    827            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_4: (+1)
   \   000000E2   0x2230             MOVS     R2,#+48
   \   000000E4   0x4211             TST      R1,R2
   \   000000E6   0xD01A             BEQ.N    ??_buffer_steps_10
    828            {
    829              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
   \   000000E8   0x2D00             CMP      R5,#+0
   \   000000EA   0xD500             BPL.N    ??_buffer_steps_11
   \   000000EC   0x2610             MOVS     R6,#+16
    830              if (db < 0) SBI(dm, Y_AXIS);
   \                     ??_buffer_steps_11: (+1)
   \   000000EE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F2   0xD501             BPL.N    ??_buffer_steps_12
   \   000000F4   0xF046 0x0602      ORR      R6,R6,#0x2
    831              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
   \                     ??_buffer_steps_12: (+1)
   \   000000F8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000FC   0xD501             BPL.N    ??_buffer_steps_13
   \   000000FE   0xF046 0x0640      ORR      R6,R6,#0x40
    832              if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
   \                     ??_buffer_steps_13: (+1)
   \   00000102   0xEB19 0x0005      ADDS     R0,R9,R5
   \   00000106   0xD501             BPL.N    ??_buffer_steps_14
   \   00000108   0xF046 0x0601      ORR      R6,R6,#0x1
    833              if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   \                     ??_buffer_steps_14: (+1)
   \   0000010C   0xEBA5 0x0009      SUB      R0,R5,R9
   \   00000110   0x.... 0x....      BL       _Z8CORESIGNl
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD52D             BPL.N    ??_buffer_steps_9
   \   00000118   0xF046 0x0604      ORR      R6,R6,#0x4
   \   0000011C   0xE02A             B.N      ??_buffer_steps_9
    834            }
    835            //#elif CORE_IS_YZ
    836            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_10: (+1)
   \   0000011E   0x20C0             MOVS     R0,#+192
   \   00000120   0x4201             TST      R1,R0
   \   00000122   0xD01A             BEQ.N    ??_buffer_steps_15
    837            {
    838              if (da < 0) SBI(dm, X_AXIS);
   \   00000124   0x2D00             CMP      R5,#+0
   \   00000126   0xD500             BPL.N    ??_buffer_steps_16
   \   00000128   0x2601             MOVS     R6,#+1
    839              if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
   \                     ??_buffer_steps_16: (+1)
   \   0000012A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000012E   0xD501             BPL.N    ??_buffer_steps_17
   \   00000130   0xF046 0x0620      ORR      R6,R6,#0x20
    840              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
   \                     ??_buffer_steps_17: (+1)
   \   00000134   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000138   0xD501             BPL.N    ??_buffer_steps_18
   \   0000013A   0xF046 0x0640      ORR      R6,R6,#0x40
    841              if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
   \                     ??_buffer_steps_18: (+1)
   \   0000013E   0xEB19 0x0008      ADDS     R0,R9,R8
   \   00000142   0xD501             BPL.N    ??_buffer_steps_19
   \   00000144   0xF046 0x0602      ORR      R6,R6,#0x2
    842              if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   \                     ??_buffer_steps_19: (+1)
   \   00000148   0xEBA8 0x0009      SUB      R0,R8,R9
   \   0000014C   0x.... 0x....      BL       _Z8CORESIGNl
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD50F             BPL.N    ??_buffer_steps_9
   \   00000154   0xF046 0x0604      ORR      R6,R6,#0x4
   \   00000158   0xE00C             B.N      ??_buffer_steps_9
    843            }
    844            //#else
    845            else
    846            {
    847              if (da < 0) SBI(dm, X_AXIS);
   \                     ??_buffer_steps_15: (+1)
   \   0000015A   0x2D00             CMP      R5,#+0
   \   0000015C   0xD500             BPL.N    ??_buffer_steps_20
   \   0000015E   0x2601             MOVS     R6,#+1
    848              if (db < 0) SBI(dm, Y_AXIS);
   \                     ??_buffer_steps_20: (+1)
   \   00000160   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000164   0xD501             BPL.N    ??_buffer_steps_21
   \   00000166   0xF046 0x0602      ORR      R6,R6,#0x2
    849              if (dc < 0) SBI(dm, Z_AXIS);
   \                     ??_buffer_steps_21: (+1)
   \   0000016A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000016E   0xD501             BPL.N    ??_buffer_steps_9
   \   00000170   0xF046 0x0604      ORR      R6,R6,#0x4
    850            }
    851            //#endif
    852            if (de < 0) SBI(dm, E_AXIS);
   \                     ??_buffer_steps_9: (+1)
   \   00000174   0x2F00             CMP      R7,#+0
   \   00000176   0xD501             BPL.N    ??_buffer_steps_22
   \   00000178   0xF046 0x0608      ORR      R6,R6,#0x8
    853          
    854            const float esteps_float = de * e_factor[extruder];
   \                     ??_buffer_steps_22: (+1)
   \   0000017C   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   00000180   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000184   0x9001             STR      R0,[SP, #+4]
   \   00000186   0x4638             MOV      R0,R7
   \   00000188   0x.... 0x....      BL       __aeabi_i2f
   \   0000018C   0x9901             LDR      R1,[SP, #+4]
   \   0000018E   0x6D09             LDR      R1,[R1, #+80]
   \   00000190   0x.... 0x....      BL       __aeabi_fmul
   \   00000194   0x9000             STR      R0,[SP, #+0]
    855            const int32_t esteps = abs(esteps_float) + 0.5;
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000196   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   0000019A   0x.... 0x....      BL       __aeabi_f2d
   \   0000019E   0x2200             MOVS     R2,#+0
   \   000001A0   0x.... 0x....      LDR.W    R3,??DataTable13  ;; 0x3fe00000
   \   000001A4   0x.... 0x....      BL       __aeabi_dadd
   \   000001A8   0x.... 0x....      BL       __aeabi_d2iz
   \   000001AC   0x9002             STR      R0,[SP, #+8]
    856          
    857            // Calculate the buffer head after we push this byte
    858            const uint8_t next_buffer_head = next_block_index(block_buffer_head);
   \   000001AE   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   000001B2   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   000001B6   0xB2C0             UXTB     R0,R0
   \   000001B8   0x9004             STR      R0,[SP, #+16]
   \   000001BA   0xE001             B.N      ??_buffer_steps_23
    859          
    860            // If the buffer is full: good! That means we are well ahead of the robot.
    861            // Rest here until there is room in the buffer.
    862            while (block_buffer_tail == next_buffer_head) idle();
   \                     ??_buffer_steps_24: (+1)
   \   000001BC   0x.... 0x....      BL       _Z4idlev
   \                     ??_buffer_steps_23: (+1)
   \   000001C0   0x7860             LDRB     R0,[R4, #+1]
   \   000001C2   0x9904             LDR      R1,[SP, #+16]
   \   000001C4   0x4288             CMP      R0,R1
   \   000001C6   0xD0F9             BEQ.N    ??_buffer_steps_24
    863          
    864            // Prepare to set up new block
    865            block_t* block = &block_buffer[block_buffer_head];
   \   000001C8   0x7820             LDRB     R0,[R4, #+0]
   \   000001CA   0x2154             MOVS     R1,#+84
   \   000001CC   0x.... 0x....      LDR.W    R2,??DataTable13_1
   \   000001D0   0xFB01 0x2700      MLA      R7,R1,R0,R2
    866          
    867            // Clear all flags, including the "busy" bit
    868            block->flag = 0x00;
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x7038             STRB     R0,[R7, #+0]
    869          
    870            // Set direction bits
    871            block->direction_bits = dm;
   \   000001D8   0xF887 0x6024      STRB     R6,[R7, #+36]
    872          
    873            // Number of steps for each axis
    874            // See http://www.corexy.com/theory.html
    875            //#if CORE_IS_XY
    876            if(MACHINETPYE & CORE_IS_XY)
   \   000001DC   0xF8DF 0x0C98      LDR.W    R0,??_buffer_steps_3+0x4
   \   000001E0   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   000001E4   0x210C             MOVS     R1,#+12
   \   000001E6   0x4208             TST      R0,R1
   \   000001E8   0xD00E             BEQ.N    ??_buffer_steps_25
    877            {
    878              block->steps[A_AXIS] = labs(da + db);
   \   000001EA   0xEB08 0x0005      ADD      R0,R8,R5
   \   000001EE   0x.... 0x....      BL       labs
   \   000001F2   0x6078             STR      R0,[R7, #+4]
    879              block->steps[B_AXIS] = labs(da - db);
   \   000001F4   0xEBA5 0x0008      SUB      R0,R5,R8
   \   000001F8   0x.... 0x....      BL       labs
   \   000001FC   0x60B8             STR      R0,[R7, #+8]
    880              block->steps[Z_AXIS] = labs(dc);
   \   000001FE   0x4648             MOV      R0,R9
   \   00000200   0x.... 0x....      BL       labs
   \   00000204   0x60F8             STR      R0,[R7, #+12]
   \   00000206   0xE02E             B.N      ??_buffer_steps_26
    881            }
    882            //#elif CORE_IS_XZ
    883            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_25: (+1)
   \   00000208   0x2130             MOVS     R1,#+48
   \   0000020A   0x4208             TST      R0,R1
   \   0000020C   0xD00E             BEQ.N    ??_buffer_steps_27
    884            {
    885              block->steps[A_AXIS] = labs(da + dc);
   \   0000020E   0xEB09 0x0005      ADD      R0,R9,R5
   \   00000212   0x.... 0x....      BL       labs
   \   00000216   0x6078             STR      R0,[R7, #+4]
    886              block->steps[Y_AXIS] = labs(db);
   \   00000218   0x4640             MOV      R0,R8
   \   0000021A   0x.... 0x....      BL       labs
   \   0000021E   0x60B8             STR      R0,[R7, #+8]
    887              block->steps[C_AXIS] = labs(da - dc);
   \   00000220   0xEBA5 0x0009      SUB      R0,R5,R9
   \   00000224   0x.... 0x....      BL       labs
   \   00000228   0x60F8             STR      R0,[R7, #+12]
   \   0000022A   0xE01C             B.N      ??_buffer_steps_26
    888            }
    889            //#elif CORE_IS_YZ
    890            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_27: (+1)
   \   0000022C   0x21C0             MOVS     R1,#+192
   \   0000022E   0x4208             TST      R0,R1
   \   00000230   0x4628             MOV      R0,R5
   \   00000232   0xD00D             BEQ.N    ??_buffer_steps_28
    891            {
    892              block->steps[X_AXIS] = labs(da);
   \   00000234   0x.... 0x....      BL       labs
   \   00000238   0x6078             STR      R0,[R7, #+4]
    893              block->steps[B_AXIS] = labs(db + dc);
   \   0000023A   0xEB09 0x0008      ADD      R0,R9,R8
   \   0000023E   0x.... 0x....      BL       labs
   \   00000242   0x60B8             STR      R0,[R7, #+8]
    894              block->steps[C_AXIS] = labs(db - dc);
   \   00000244   0xEBA8 0x0009      SUB      R0,R8,R9
   \   00000248   0x.... 0x....      BL       labs
   \   0000024C   0x60F8             STR      R0,[R7, #+12]
   \   0000024E   0xE00A             B.N      ??_buffer_steps_26
    895            }
    896            //#else
    897            else
    898            {
    899              // default non-h-bot planning
    900              block->steps[X_AXIS] = labs(da);
   \                     ??_buffer_steps_28: (+1)
   \   00000250   0x.... 0x....      BL       labs
   \   00000254   0x6078             STR      R0,[R7, #+4]
    901              block->steps[Y_AXIS] = labs(db);
   \   00000256   0x4640             MOV      R0,R8
   \   00000258   0x.... 0x....      BL       labs
   \   0000025C   0x60B8             STR      R0,[R7, #+8]
    902              block->steps[Z_AXIS] = labs(dc);
   \   0000025E   0x4648             MOV      R0,R9
   \   00000260   0x.... 0x....      BL       labs
   \   00000264   0x60F8             STR      R0,[R7, #+12]
    903            }
    904            //#endif
    905          
    906            block->steps[E_AXIS] = esteps;
   \                     ??_buffer_steps_26: (+1)
   \   00000266   0x9802             LDR      R0,[SP, #+8]
   \   00000268   0x6138             STR      R0,[R7, #+16]
    907            block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
   \   0000026A   0x6878             LDR      R0,[R7, #+4]
   \   0000026C   0x68B9             LDR      R1,[R7, #+8]
   \   0000026E   0x460A             MOV      R2,R1
   \   00000270   0x4281             CMP      R1,R0
   \   00000272   0xDA00             BGE.N    ??_buffer_steps_29
   \   00000274   0x4602             MOV      R2,R0
   \                     ??_buffer_steps_29: (+1)
   \   00000276   0x68FB             LDR      R3,[R7, #+12]
   \   00000278   0x4293             CMP      R3,R2
   \   0000027A   0xDA01             BGE.N    ??_buffer_steps_30
   \   0000027C   0x4616             MOV      R6,R2
   \   0000027E   0xE000             B.N      ??_buffer_steps_31
   \                     ??_buffer_steps_30: (+1)
   \   00000280   0x461E             MOV      R6,R3
   \                     ??_buffer_steps_31: (+1)
   \   00000282   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   \   00000286   0x45B4             CMP      R12,R6
   \   00000288   0xDA07             BGE.N    ??_buffer_steps_32
   \   0000028A   0x4293             CMP      R3,R2
   \   0000028C   0xDA03             BGE.N    ??_buffer_steps_33
   \   0000028E   0x4281             CMP      R1,R0
   \   00000290   0xDB04             BLT.N    ??_buffer_steps_34
   \   00000292   0x4608             MOV      R0,R1
   \   00000294   0xE002             B.N      ??_buffer_steps_34
   \                     ??_buffer_steps_33: (+1)
   \   00000296   0x4618             MOV      R0,R3
   \   00000298   0xE000             B.N      ??_buffer_steps_34
   \                     ??_buffer_steps_32: (+1)
   \   0000029A   0x4660             MOV      R0,R12
   \                     ??_buffer_steps_34: (+1)
   \   0000029C   0x6178             STR      R0,[R7, #+20]
    908          
    909            // Bail if this is a zero-length block
    910            if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
   \   0000029E   0x2806             CMP      R0,#+6
   \   000002A0   0xF0C0 0x861C      BCC.W    ??_buffer_steps_35
    911          
    912            // For a mixing extruder, get a magnified step_event_count for each
    913            #if ENABLED(MIXING_EXTRUDER)
    914              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
    915                block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
    916            #endif
    917          
    918            #if FAN_COUNT > 0
    919              for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   \   000002A4   0x2000             MOVS     R0,#+0
   \   000002A6   0xE005             B.N      ??_buffer_steps_36
   \                     ??_buffer_steps_37: (+1)
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   000002AC   0x6800             LDR      R0,[R0, #+0]
   \   000002AE   0xF8A7 0x004C      STRH     R0,[R7, #+76]
   \   000002B2   0x2001             MOVS     R0,#+1
   \                     ??_buffer_steps_36: (+1)
   \   000002B4   0x2800             CMP      R0,#+0
   \   000002B6   0xD0F7             BEQ.N    ??_buffer_steps_37
    920            #endif
    921          
    922            #if ENABLED(BARICUDA)
    923              block->valve_pressure = baricuda_valve_pressure;
    924              block->e_to_p_pressure = baricuda_e_to_p_pressure;
    925            #endif
    926          
    927            block->active_extruder = extruder;
   \   000002B8   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000002BC   0x7078             STRB     R0,[R7, #+1]
    928          
    929            //enable active axes
    930            #if 0
    931            #if CORE_IS_XY
    932              if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
    933                enable_X();
    934                enable_Y();
    935              }
    936              #if DISABLED(Z_LATE_ENABLE)
    937                if (block->steps[Z_AXIS]) enable_Z();
    938              #endif
    939            #elif CORE_IS_XZ
    940              if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
    941                enable_X();
    942                enable_Z();
    943              }
    944              if (block->steps[Y_AXIS]) enable_Y();
    945            #elif CORE_IS_YZ
    946              if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
    947                enable_Y();
    948                enable_Z();
    949              }
    950              if (block->steps[X_AXIS]) enable_X();
    951            #else
    952              if (block->steps[X_AXIS]) enable_X();
    953              if (block->steps[Y_AXIS]) enable_Y();
    954              #if DISABLED(Z_LATE_ENABLE)
    955                if (block->steps[Z_AXIS]) enable_Z();
    956              #endif
    957            #endif
    958          #endif
    959            if(MACHINETPYE & CORE_IS_XY)
   \   000002BE   0xF8DF 0x0BB8      LDR.W    R0,??_buffer_steps_3+0x4
   \   000002C2   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   000002C6   0x210C             MOVS     R1,#+12
   \   000002C8   0x4208             TST      R0,R1
   \   000002CA   0xD01B             BEQ.N    ??_buffer_steps_38
    960           {
    961          	  if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
   \   000002CC   0x6878             LDR      R0,[R7, #+4]
   \   000002CE   0x2800             CMP      R0,#+0
   \   000002D0   0xD103             BNE.N    ??_buffer_steps_39
   \   000002D2   0x68B8             LDR      R0,[R7, #+8]
   \   000002D4   0x2800             CMP      R0,#+0
   \   000002D6   0xF000 0x809B      BEQ.W    ??_buffer_steps_40
    962          		enable_X();
   \                     ??_buffer_steps_39: (+1)
   \   000002DA   0x.... 0x....      LDR.W    R11,??DataTable14
   \   000002DE   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   000002E2   0x.... 0x....      LDR.W    R10,??DataTable14_2
   \   000002E6   0xF99B 0x2003      LDRSB    R2,[R11, #+3]
   \   000002EA   0xF8BA 0x1004      LDRH     R1,[R10, #+4]
   \   000002EE   0x68B0             LDR      R0,[R6, #+8]
   \   000002F0   0x.... 0x....      BL       HAL_GPIO_WritePin
    963          		enable_Y();
   \   000002F4   0xF99B 0x2004      LDRSB    R2,[R11, #+4]
   \   000002F8   0xF8BA 0x100E      LDRH     R1,[R10, #+14]
   \   000002FC   0x69F0             LDR      R0,[R6, #+28]
   \   000002FE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000302   0xE085             B.N      ??_buffer_steps_40
    964          	  }
    965            	#if DISABLED(Z_LATE_ENABLE)
    966          		if (block->steps[Z_AXIS]) enable_Z();
    967            	#endif
    968            }
    969            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_38: (+1)
   \   00000304   0x2130             MOVS     R1,#+48
   \   00000306   0x4208             TST      R0,R1
   \   00000308   0xD030             BEQ.N    ??_buffer_steps_41
    970            	{
    971          	  if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
   \   0000030A   0x6878             LDR      R0,[R7, #+4]
   \   0000030C   0x2800             CMP      R0,#+0
   \   0000030E   0xD102             BNE.N    ??_buffer_steps_42
   \   00000310   0x4618             MOV      R0,R3
   \   00000312   0x2800             CMP      R0,#+0
   \   00000314   0xD01A             BEQ.N    ??_buffer_steps_43
    972          		enable_X();
   \                     ??_buffer_steps_42: (+1)
   \   00000316   0x.... 0x....      LDR.W    R11,??DataTable14
   \   0000031A   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   0000031E   0x.... 0x....      LDR.W    R10,??DataTable14_2
   \   00000322   0xF99B 0x2003      LDRSB    R2,[R11, #+3]
   \   00000326   0xF8BA 0x1004      LDRH     R1,[R10, #+4]
   \   0000032A   0x68B0             LDR      R0,[R6, #+8]
   \   0000032C   0x.... 0x....      BL       HAL_GPIO_WritePin
    973          		enable_Z();
   \   00000330   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   00000334   0xF8BA 0x1018      LDRH     R1,[R10, #+24]
   \   00000338   0x6B30             LDR      R0,[R6, #+48]
   \   0000033A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000033E   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   00000342   0xF8BA 0x1028      LDRH     R1,[R10, #+40]
   \   00000346   0x6D30             LDR      R0,[R6, #+80]
   \   00000348   0x.... 0x....      BL       HAL_GPIO_WritePin
    974          	  }
    975          	  if (block->steps[Y_AXIS]) enable_Y();
   \                     ??_buffer_steps_43: (+1)
   \   0000034C   0x68B8             LDR      R0,[R7, #+8]
   \   0000034E   0x2800             CMP      R0,#+0
   \   00000350   0xD075             BEQ.N    ??_buffer_steps_44
   \   00000352   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000356   0xF990 0x2004      LDRSB    R2,[R0, #+4]
   \   0000035A   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000035E   0x89C1             LDRH     R1,[R0, #+14]
   \   00000360   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000364   0x69C0             LDR      R0,[R0, #+28]
   \   00000366   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000036A   0xE068             B.N      ??_buffer_steps_44
    976            	}
    977            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_41: (+1)
   \   0000036C   0x21C0             MOVS     R1,#+192
   \   0000036E   0x4208             TST      R0,R1
   \   00000370   0xD030             BEQ.N    ??_buffer_steps_45
    978            	{
    979          	  if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
   \   00000372   0x68B8             LDR      R0,[R7, #+8]
   \   00000374   0x2800             CMP      R0,#+0
   \   00000376   0xD102             BNE.N    ??_buffer_steps_46
   \   00000378   0x4618             MOV      R0,R3
   \   0000037A   0x2800             CMP      R0,#+0
   \   0000037C   0xD01A             BEQ.N    ??_buffer_steps_47
    980          		enable_Y();
   \                     ??_buffer_steps_46: (+1)
   \   0000037E   0x.... 0x....      LDR.W    R11,??DataTable14
   \   00000382   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   00000386   0x.... 0x....      LDR.W    R10,??DataTable14_2
   \   0000038A   0xF99B 0x2004      LDRSB    R2,[R11, #+4]
   \   0000038E   0xF8BA 0x100E      LDRH     R1,[R10, #+14]
   \   00000392   0x69F0             LDR      R0,[R6, #+28]
   \   00000394   0x.... 0x....      BL       HAL_GPIO_WritePin
    981          		enable_Z();
   \   00000398   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   0000039C   0xF8BA 0x1018      LDRH     R1,[R10, #+24]
   \   000003A0   0x6B30             LDR      R0,[R6, #+48]
   \   000003A2   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000003A6   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   000003AA   0xF8BA 0x1028      LDRH     R1,[R10, #+40]
   \   000003AE   0x6D30             LDR      R0,[R6, #+80]
   \   000003B0   0x.... 0x....      BL       HAL_GPIO_WritePin
    982          	  }
    983          	  if (block->steps[X_AXIS]) enable_X();
   \                     ??_buffer_steps_47: (+1)
   \   000003B4   0x6878             LDR      R0,[R7, #+4]
   \   000003B6   0x2800             CMP      R0,#+0
   \   000003B8   0xD041             BEQ.N    ??_buffer_steps_44
   \   000003BA   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000003BE   0xF990 0x2003      LDRSB    R2,[R0, #+3]
   \   000003C2   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000003C6   0x8881             LDRH     R1,[R0, #+4]
   \   000003C8   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000003CC   0x6880             LDR      R0,[R0, #+8]
   \   000003CE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000003D2   0xE034             B.N      ??_buffer_steps_44
    984            	}
    985          	else
    986          	{
    987          		if (block->steps[X_AXIS]) enable_X();
   \                     ??_buffer_steps_45: (+1)
   \   000003D4   0x6878             LDR      R0,[R7, #+4]
   \   000003D6   0x2800             CMP      R0,#+0
   \   000003D8   0xD00B             BEQ.N    ??_buffer_steps_48
   \   000003DA   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000003DE   0xF990 0x2003      LDRSB    R2,[R0, #+3]
   \   000003E2   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000003E6   0x8881             LDRH     R1,[R0, #+4]
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000003EC   0x6880             LDR      R0,[R0, #+8]
   \   000003EE   0x.... 0x....      BL       HAL_GPIO_WritePin
    988          		if (block->steps[Y_AXIS]) enable_Y();
   \                     ??_buffer_steps_48: (+1)
   \   000003F2   0x68B8             LDR      R0,[R7, #+8]
   \   000003F4   0x2800             CMP      R0,#+0
   \   000003F6   0xD00B             BEQ.N    ??_buffer_steps_40
   \   000003F8   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000003FC   0xF990 0x2004      LDRSB    R2,[R0, #+4]
   \   00000400   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000404   0x89C1             LDRH     R1,[R0, #+14]
   \   00000406   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000040A   0x69C0             LDR      R0,[R0, #+28]
   \   0000040C   0x.... 0x....      BL       HAL_GPIO_WritePin
    989          	  #if DISABLED(Z_LATE_ENABLE)
    990          		  if (block->steps[Z_AXIS]) enable_Z();
   \                     ??_buffer_steps_40: (+1)
   \   00000410   0x68F8             LDR      R0,[R7, #+12]
   \   00000412   0x2800             CMP      R0,#+0
   \   00000414   0xD013             BEQ.N    ??_buffer_steps_44
   \   00000416   0x.... 0x....      LDR.W    R11,??DataTable14
   \   0000041A   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   0000041E   0x.... 0x....      LDR.W    R10,??DataTable14_2
   \   00000422   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   00000426   0xF8BA 0x1018      LDRH     R1,[R10, #+24]
   \   0000042A   0x6B30             LDR      R0,[R6, #+48]
   \   0000042C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000430   0xF99B 0x2005      LDRSB    R2,[R11, #+5]
   \   00000434   0xF8BA 0x1028      LDRH     R1,[R10, #+40]
   \   00000438   0x6D30             LDR      R0,[R6, #+80]
   \   0000043A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??_buffer_steps_44: (+1)
   \   0000043E   0x9802             LDR      R0,[SP, #+8]
   \   00000440   0x2800             CMP      R0,#+0
   \   00000442   0xD05A             BEQ.N    ??_buffer_steps_49
    991          	  #endif
    992          	}
    993          
    994            // Enable extruder(s)
    995            if (esteps) {
    996          
    997              #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
    998          
    999                #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
   1000          
   1001                for (uint8_t i = 0; i < EXTRUDERS; i++)
   \   00000444   0x2000             MOVS     R0,#+0
   \   00000446   0x.... 0x....      LDR.W    R2,??DataTable18
   \   0000044A   0xE006             B.N      ??_buffer_steps_50
   1002                  if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
   \                     ??_buffer_steps_51: (+1)
   \   0000044C   0x4611             MOV      R1,R2
   \   0000044E   0x5C41             LDRB     R1,[R0, R1]
   \   00000450   0x2900             CMP      R1,#+0
   \   00000452   0xD001             BEQ.N    ??_buffer_steps_52
   \   00000454   0x1E49             SUBS     R1,R1,#+1
   \   00000456   0x5481             STRB     R1,[R0, R2]
   \                     ??_buffer_steps_52: (+1)
   \   00000458   0x1C40             ADDS     R0,R0,#+1
   \                     ??_buffer_steps_50: (+1)
   \   0000045A   0x2802             CMP      R0,#+2
   \   0000045C   0xDBF6             BLT.N    ??_buffer_steps_51
   1003          
   1004                switch(extruder) {
   \   0000045E   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   00000462   0x2800             CMP      R0,#+0
   \   00000464   0xD002             BEQ.N    ??_buffer_steps_53
   \   00000466   0x2801             CMP      R0,#+1
   \   00000468   0xD027             BEQ.N    ??_buffer_steps_54
   \   0000046A   0xE046             B.N      ??_buffer_steps_49
   1005                  case 0:
   1006                    enable_E0();
   \                     ??_buffer_steps_53: (+1)
   \   0000046C   0x.... 0x....      LDR.W    R11,??DataTable14
   \   00000470   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   00000474   0x.... 0x....      LDR.W    R10,??DataTable14_2
   \   00000478   0xF99B 0x2006      LDRSB    R2,[R11, #+6]
   \   0000047C   0xF8BA 0x1022      LDRH     R1,[R10, #+34]
   \   00000480   0x6C70             LDR      R0,[R6, #+68]
   \   00000482   0x.... 0x....      BL       HAL_GPIO_WritePin
   1007                    g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
   \   00000486   0x2020             MOVS     R0,#+32
   \   00000488   0x.... 0x....      LDR.W    R1,??DataTable18
   \   0000048C   0x7008             STRB     R0,[R1, #+0]
   1008                    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1009                      if (extruder_duplication_enabled) {
   1010                        enable_E1();
   1011                        g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
   1012                      }
   1013                    #endif
   1014                    #if EXTRUDERS > 1
   1015                      if(mksCfg.z2_enable != 1)
   \   0000048E   0xF8DF 0x09E8      LDR.W    R0,??_buffer_steps_3+0x4
   \   00000492   0xF890 0x0101      LDRB     R0,[R0, #+257]
   \   00000496   0x2801             CMP      R0,#+1
   \   00000498   0xD02F             BEQ.N    ??_buffer_steps_49
   1016                          DISABLE_IDLE_E(1);
   \   0000049A   0x4608             MOV      R0,R1
   \   0000049C   0x7840             LDRB     R0,[R0, #+1]
   \   0000049E   0x2800             CMP      R0,#+0
   \   000004A0   0xD12B             BNE.N    ??_buffer_steps_49
   \   000004A2   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \   000004A6   0x1E42             SUBS     R2,R0,#+1
   \   000004A8   0x4192             SBCS     R2,R2,R2
   \   000004AA   0x0FD2             LSRS     R2,R2,#+31
   \   000004AC   0xB252             SXTB     R2,R2
   \   000004AE   0xF8BA 0x1028      LDRH     R1,[R10, #+40]
   \   000004B2   0x6D30             LDR      R0,[R6, #+80]
   \   000004B4   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000004B8   0xE01F             B.N      ??_buffer_steps_49
   1017                      #if EXTRUDERS > 2
   1018                        DISABLE_IDLE_E(2);
   1019                        #if EXTRUDERS > 3
   1020                          DISABLE_IDLE_E(3);
   1021                          #if EXTRUDERS > 4
   1022                            DISABLE_IDLE_E(4);
   1023                          #endif // EXTRUDERS > 4
   1024                        #endif // EXTRUDERS > 3
   1025                      #endif // EXTRUDERS > 2
   1026                    #endif // EXTRUDERS > 1
   1027                  break;
   1028                  #if EXTRUDERS > 1
   1029                    case 1:
   1030                      enable_E1();
   \                     ??_buffer_steps_54: (+1)
   \   000004BA   0x.... 0x....      LDR.W    R11,??DataTable14
   \   000004BE   0x.... 0x....      LDR.W    R6,??DataTable14_1
   \   000004C2   0x.... 0x....      LDR.W    R10,??DataTable14_2
   \   000004C6   0xF99B 0x2006      LDRSB    R2,[R11, #+6]
   \   000004CA   0xF8BA 0x1028      LDRH     R1,[R10, #+40]
   \   000004CE   0x6D30             LDR      R0,[R6, #+80]
   \   000004D0   0x.... 0x....      BL       HAL_GPIO_WritePin
   1031                      g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
   \   000004D4   0x2020             MOVS     R0,#+32
   \   000004D6   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000004DA   0x7048             STRB     R0,[R1, #+1]
   1032                      DISABLE_IDLE_E(0);
   \   000004DC   0x4608             MOV      R0,R1
   \   000004DE   0x7800             LDRB     R0,[R0, #+0]
   \   000004E0   0x2800             CMP      R0,#+0
   \   000004E2   0xD10A             BNE.N    ??_buffer_steps_49
   \   000004E4   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \   000004E8   0x1E42             SUBS     R2,R0,#+1
   \   000004EA   0x4192             SBCS     R2,R2,R2
   \   000004EC   0x0FD2             LSRS     R2,R2,#+31
   \   000004EE   0xB252             SXTB     R2,R2
   \   000004F0   0xF8BA 0x1022      LDRH     R1,[R10, #+34]
   \   000004F4   0x6C70             LDR      R0,[R6, #+68]
   \   000004F6   0x.... 0x....      BL       HAL_GPIO_WritePin
   1033                      #if EXTRUDERS > 2
   1034                        DISABLE_IDLE_E(2);
   1035                        #if EXTRUDERS > 3
   1036                          DISABLE_IDLE_E(3);
   1037                          #if EXTRUDERS > 4
   1038                            DISABLE_IDLE_E(4);
   1039                          #endif // EXTRUDERS > 4
   1040                        #endif // EXTRUDERS > 3
   1041                      #endif // EXTRUDERS > 2
   1042                    break;
   1043                    #if EXTRUDERS > 2
   1044                      case 2:
   1045                        enable_E2();
   1046                        g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
   1047                        DISABLE_IDLE_E(0);
   1048                        DISABLE_IDLE_E(1);
   1049                        #if EXTRUDERS > 3
   1050                          DISABLE_IDLE_E(3);
   1051                          #if EXTRUDERS > 4
   1052                            DISABLE_IDLE_E(4);
   1053                          #endif
   1054                        #endif
   1055                      break;
   1056                      #if EXTRUDERS > 3
   1057                        case 3:
   1058                          enable_E3();
   1059                          g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
   1060                          DISABLE_IDLE_E(0);
   1061                          DISABLE_IDLE_E(1);
   1062                          DISABLE_IDLE_E(2);
   1063                          #if EXTRUDERS > 4
   1064                            DISABLE_IDLE_E(4);
   1065                          #endif
   1066                        break;
   1067                        #if EXTRUDERS > 4
   1068                          case 4:
   1069                            enable_E4();
   1070                            g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
   1071                            DISABLE_IDLE_E(0);
   1072                            DISABLE_IDLE_E(1);
   1073                            DISABLE_IDLE_E(2);
   1074                            DISABLE_IDLE_E(3);
   1075                          break;
   1076                        #endif // EXTRUDERS > 4
   1077                      #endif // EXTRUDERS > 3
   1078                    #endif // EXTRUDERS > 2
   1079                  #endif // EXTRUDERS > 1
   1080                }
   1081              #else
   1082                enable_E0();
   1083                enable_E1();
   1084                enable_E2();
   1085                enable_E3();
   1086                enable_E4();
   1087              #endif
   1088            }
   1089          
   1090            if (esteps)
   \                     ??_buffer_steps_49: (+1)
   \   000004FA   0x9802             LDR      R0,[SP, #+8]
   \   000004FC   0x2800             CMP      R0,#+0
   \   000004FE   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000502   0xD006             BEQ.N    ??_buffer_steps_55
   1091              NOLESS(fr_mm_s, min_feedrate_mm_s);
   \   00000504   0x69C1             LDR      R1,[R0, #+28]
   \   00000506   0x9811             LDR      R0,[SP, #+68]
   \   00000508   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000050C   0xD207             BCS.N    ??_buffer_steps_56
   \   0000050E   0x9111             STR      R1,[SP, #+68]
   \   00000510   0xE005             B.N      ??_buffer_steps_56
   1092            else
   1093              NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
   \                     ??_buffer_steps_55: (+1)
   \   00000512   0x6BC1             LDR      R1,[R0, #+60]
   \   00000514   0x9811             LDR      R0,[SP, #+68]
   \   00000516   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000051A   0xD200             BCS.N    ??_buffer_steps_56
   \   0000051C   0x9111             STR      R1,[SP, #+68]
   1094          
   1095            /**
   1096             * This part of the code calculates the total length of the movement.
   1097             * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
   1098             * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
   1099             * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
   1100             * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
   1101             * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
   1102             */
   1103            //#if IS_CORE
   1104              float delta_mm[Z_HEAD + 1];
   1105            if(MACHINETPYE & IS_CORE) {
   \                     ??_buffer_steps_56: (+1)
   \   0000051E   0xF8DF 0x0958      LDR.W    R0,??_buffer_steps_3+0x4
   \   00000522   0xF9B0 0xA058      LDRSH    R10,[R0, #+88]
   \   00000526   0xAE09             ADD      R6,SP,#+36
   \   00000528   0x21FC             MOVS     R1,#+252
   \   0000052A   0xEA1A 0x0F01      TST      R10,R1
   \   0000052E   0xF000 0x8088      BEQ.W    ??_buffer_steps_57
   1106              //#if CORE_IS_XY
   1107              if(MACHINETPYE & CORE_IS_XY) {
   \   00000532   0x210C             MOVS     R1,#+12
   \   00000534   0xEA1A 0x0F01      TST      R10,R1
   \   00000538   0xD027             BEQ.N    ??_buffer_steps_58
   \   0000053A   0x4628             MOV      R0,R5
   \   0000053C   0x.... 0x....      BL       __aeabi_i2f
   \   00000540   0x69A1             LDR      R1,[R4, #+24]
   \   00000542   0x.... 0x....      BL       __aeabi_fmul
   \   00000546   0x6130             STR      R0,[R6, #+16]
   \   00000548   0x4640             MOV      R0,R8
   \   0000054A   0x.... 0x....      BL       __aeabi_i2f
   \   0000054E   0x69E1             LDR      R1,[R4, #+28]
   \   00000550   0x.... 0x....      BL       __aeabi_fmul
   \   00000554   0x6170             STR      R0,[R6, #+20]
   1108                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   1109                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   1110                delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \   00000556   0x4648             MOV      R0,R9
   \   00000558   0x.... 0x....      BL       __aeabi_i2f
   \   0000055C   0x6A21             LDR      R1,[R4, #+32]
   \   0000055E   0x.... 0x....      BL       __aeabi_fmul
   \   00000562   0x60B0             STR      R0,[R6, #+8]
   1111                delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
   \   00000564   0xEB08 0x0005      ADD      R0,R8,R5
   \   00000568   0x.... 0x....      BL       __aeabi_i2f
   \   0000056C   0x69A1             LDR      R1,[R4, #+24]
   \   0000056E   0x.... 0x....      BL       __aeabi_fmul
   \   00000572   0x9009             STR      R0,[SP, #+36]
   1112                delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];}
   \   00000574   0xEBA5 0x0008      SUB      R0,R5,R8
   \   00000578   0x.... 0x....      BL       _Z8CORESIGNl
   \   0000057C   0x.... 0x....      BL       __aeabi_i2f
   \   00000580   0x69E1             LDR      R1,[R4, #+28]
   \   00000582   0x.... 0x....      BL       __aeabi_fmul
   \   00000586   0x6070             STR      R0,[R6, #+4]
   \   00000588   0xE070             B.N      ??_buffer_steps_59
   1113             // #elif CORE_IS_XZ
   1114             else if(MACHINETPYE & CORE_IS_XZ) {
   \                     ??_buffer_steps_58: (+1)
   \   0000058A   0x2130             MOVS     R1,#+48
   \   0000058C   0xEA1A 0x0F01      TST      R10,R1
   \   00000590   0xD029             BEQ.N    ??_buffer_steps_60
   \   00000592   0x4628             MOV      R0,R5
   \   00000594   0x.... 0x....      BL       __aeabi_i2f
   \   00000598   0x69A1             LDR      R1,[R4, #+24]
   \   0000059A   0x.... 0x....      BL       __aeabi_fmul
   \   0000059E   0x6130             STR      R0,[R6, #+16]
   1115                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   1116                delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \   000005A0   0x4640             MOV      R0,R8
   \   000005A2   0x.... 0x....      BL       __aeabi_i2f
   \   000005A6   0x69E1             LDR      R1,[R4, #+28]
   \   000005A8   0x.... 0x....      BL       __aeabi_fmul
   \   000005AC   0x6070             STR      R0,[R6, #+4]
   1117                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   \   000005AE   0xF8D4 0xB020      LDR      R11,[R4, #+32]
   \   000005B2   0x4648             MOV      R0,R9
   \   000005B4   0x.... 0x....      BL       __aeabi_i2f
   \   000005B8   0x4659             MOV      R1,R11
   \   000005BA   0x.... 0x....      BL       __aeabi_fmul
   \   000005BE   0x61B0             STR      R0,[R6, #+24]
   1118                delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
   \   000005C0   0xEB09 0x0005      ADD      R0,R9,R5
   \   000005C4   0x.... 0x....      BL       __aeabi_i2f
   \   000005C8   0x69A1             LDR      R1,[R4, #+24]
   \   000005CA   0x.... 0x....      BL       __aeabi_fmul
   \   000005CE   0x9009             STR      R0,[SP, #+36]
   1119                delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];}
   \   000005D0   0xEBA5 0x0009      SUB      R0,R5,R9
   \   000005D4   0x.... 0x....      BL       _Z8CORESIGNl
   \   000005D8   0x.... 0x....      BL       __aeabi_i2f
   \   000005DC   0x4659             MOV      R1,R11
   \   000005DE   0x.... 0x....      BL       __aeabi_fmul
   \   000005E2   0x60B0             STR      R0,[R6, #+8]
   \   000005E4   0xE042             B.N      ??_buffer_steps_59
   1120              //#elif CORE_IS_YZ
   1121              else if(MACHINETPYE & CORE_IS_YZ) {
   \                     ??_buffer_steps_60: (+1)
   \   000005E6   0x21C0             MOVS     R1,#+192
   \   000005E8   0xEA1A 0x0F01      TST      R10,R1
   \   000005EC   0xD03E             BEQ.N    ??_buffer_steps_59
   1122                delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \   000005EE   0x4628             MOV      R0,R5
   \   000005F0   0x.... 0x....      BL       __aeabi_i2f
   \   000005F4   0x69A1             LDR      R1,[R4, #+24]
   \   000005F6   0x.... 0x....      BL       __aeabi_fmul
   \   000005FA   0x9009             STR      R0,[SP, #+36]
   \   000005FC   0x4640             MOV      R0,R8
   \   000005FE   0x.... 0x....      BL       __aeabi_i2f
   \   00000602   0x69E1             LDR      R1,[R4, #+28]
   \   00000604   0x.... 0x....      BL       __aeabi_fmul
   \   00000608   0x6170             STR      R0,[R6, #+20]
   1123                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   1124                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   \   0000060A   0xF8D4 0xB020      LDR      R11,[R4, #+32]
   \   0000060E   0x4648             MOV      R0,R9
   \   00000610   0x.... 0x....      BL       __aeabi_i2f
   \   00000614   0x4659             MOV      R1,R11
   \   00000616   0x.... 0x....      BL       __aeabi_fmul
   \   0000061A   0x61B0             STR      R0,[R6, #+24]
   1125                delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
   \   0000061C   0xEB09 0x0008      ADD      R0,R9,R8
   \   00000620   0x.... 0x....      BL       __aeabi_i2f
   \   00000624   0x69E1             LDR      R1,[R4, #+28]
   \   00000626   0x.... 0x....      BL       __aeabi_fmul
   \   0000062A   0x6070             STR      R0,[R6, #+4]
   1126                delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];}
   \   0000062C   0xEBA8 0x0009      SUB      R0,R8,R9
   \   00000630   0x.... 0x....      BL       _Z8CORESIGNl
   \   00000634   0x.... 0x....      BL       __aeabi_i2f
   \   00000638   0x4659             MOV      R1,R11
   \   0000063A   0x.... 0x....      BL       __aeabi_fmul
   \   0000063E   0x60B0             STR      R0,[R6, #+8]
   \   00000640   0xE014             B.N      ??_buffer_steps_59
   1127              //#endif
   1128            	}
   1129            //#else
   1130            else
   1131            {
   1132              //float delta_mm[XYZE];
   1133              delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \                     ??_buffer_steps_57: (+1)
   \   00000642   0x4628             MOV      R0,R5
   \   00000644   0x.... 0x....      BL       __aeabi_i2f
   \   00000648   0x69A1             LDR      R1,[R4, #+24]
   \   0000064A   0x.... 0x....      BL       __aeabi_fmul
   \   0000064E   0x9009             STR      R0,[SP, #+36]
   1134              delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \   00000650   0x4640             MOV      R0,R8
   \   00000652   0x.... 0x....      BL       __aeabi_i2f
   \   00000656   0x69E1             LDR      R1,[R4, #+28]
   \   00000658   0x.... 0x....      BL       __aeabi_fmul
   \   0000065C   0x6070             STR      R0,[R6, #+4]
   1135              delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \   0000065E   0x4648             MOV      R0,R9
   \   00000660   0x.... 0x....      BL       __aeabi_i2f
   \   00000664   0x6A21             LDR      R1,[R4, #+32]
   \   00000666   0x.... 0x....      BL       __aeabi_fmul
   \   0000066A   0x60B0             STR      R0,[R6, #+8]
   1136            }
   1137            //#endif
   1138            delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
   \                     ??_buffer_steps_59: (+1)
   \   0000066C   0x9900             LDR      R1,[SP, #+0]
   \   0000066E   0x9801             LDR      R0,[SP, #+4]
   \   00000670   0x6A40             LDR      R0,[R0, #+36]
   \   00000672   0x.... 0x....      BL       __aeabi_fmul
   \   00000676   0x60F0             STR      R0,[R6, #+12]
   1139          
   1140            if (block->steps[X_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Y_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Z_AXIS] < MIN_STEPS_PER_SEGMENT) {
   \   00000678   0x6879             LDR      R1,[R7, #+4]
   \   0000067A   0x2906             CMP      R1,#+6
   \   0000067C   0xDA09             BGE.N    ??_buffer_steps_61
   \   0000067E   0x68B9             LDR      R1,[R7, #+8]
   \   00000680   0x2906             CMP      R1,#+6
   \   00000682   0xDA06             BGE.N    ??_buffer_steps_61
   \   00000684   0x68F9             LDR      R1,[R7, #+12]
   \   00000686   0x2906             CMP      R1,#+6
   \   00000688   0xDA03             BGE.N    ??_buffer_steps_61
   1141              block->millimeters = FABS(delta_mm[E_AXIS]);
   \   0000068A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   0000068E   0x6378             STR      R0,[R7, #+52]
   \   00000690   0xE136             B.N      ??_buffer_steps_62
   1142            }
   1143            else {
   1144            	/*
   1145              block->millimeters = SQRT(
   1146                #if CORE_IS_XY
   1147                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
   1148                #elif CORE_IS_XZ
   1149                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
   1150                #elif CORE_IS_YZ
   1151                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
   1152                #else
   1153                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
   1154                #endif
   1155              );
   1156              */
   1157          		if(MACHINETPYE & CORE_IS_XY)
   \                     ??_buffer_steps_61: (+1)
   \   00000692   0xF04F 0x557E      MOV      R5,#+1065353216
   \   00000696   0x200C             MOVS     R0,#+12
   \   00000698   0xEA1A 0x0F00      TST      R10,R0
   \   0000069C   0xD04B             BEQ.N    ??_buffer_steps_63
   1158          			block->millimeters = sqrt(sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS]));
   \   0000069E   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \   000006A2   0xF04F 0x0A02      MOV      R10,#+2
   \   000006A6   0x46A8             MOV      R8,R5
   \   000006A8   0xE004             B.N      ??_buffer_steps_64
   \                     ??_buffer_steps_65: (+1)
   \   000006AA   0x4648             MOV      R0,R9
   \   000006AC   0x4649             MOV      R1,R9
   \   000006AE   0x.... 0x....      BL       __aeabi_fmul
   \   000006B2   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_64: (+1)
   \   000006B4   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000006B8   0xD504             BPL.N    ??_buffer_steps_66
   \   000006BA   0x4640             MOV      R0,R8
   \   000006BC   0x4649             MOV      R1,R9
   \   000006BE   0x.... 0x....      BL       __aeabi_fmul
   \   000006C2   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_66: (+1)
   \   000006C4   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000006C8   0xD1EF             BNE.N    ??_buffer_steps_65
   \   000006CA   0xF8D6 0xB014      LDR      R11,[R6, #+20]
   \   000006CE   0xF04F 0x0A02      MOV      R10,#+2
   \   000006D2   0x46A9             MOV      R9,R5
   \   000006D4   0xE004             B.N      ??_buffer_steps_67
   \                     ??_buffer_steps_68: (+1)
   \   000006D6   0x4658             MOV      R0,R11
   \   000006D8   0x4659             MOV      R1,R11
   \   000006DA   0x.... 0x....      BL       __aeabi_fmul
   \   000006DE   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_67: (+1)
   \   000006E0   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000006E4   0xD504             BPL.N    ??_buffer_steps_69
   \   000006E6   0x4648             MOV      R0,R9
   \   000006E8   0x4659             MOV      R1,R11
   \   000006EA   0x.... 0x....      BL       __aeabi_fmul
   \   000006EE   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_69: (+1)
   \   000006F0   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000006F4   0xD1EF             BNE.N    ??_buffer_steps_68
   \   000006F6   0xF8D6 0xA008      LDR      R10,[R6, #+8]
   \   000006FA   0xF04F 0x0B02      MOV      R11,#+2
   \   000006FE   0xE004             B.N      ??_buffer_steps_70
   \                     ??_buffer_steps_71: (+1)
   \   00000700   0x4650             MOV      R0,R10
   \   00000702   0x4651             MOV      R1,R10
   \   00000704   0x.... 0x....      BL       __aeabi_fmul
   \   00000708   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_70: (+1)
   \   0000070A   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   0000070E   0xD504             BPL.N    ??_buffer_steps_72
   \   00000710   0x4628             MOV      R0,R5
   \   00000712   0x4651             MOV      R1,R10
   \   00000714   0x.... 0x....      BL       __aeabi_fmul
   \   00000718   0x4605             MOV      R5,R0
   \                     ??_buffer_steps_72: (+1)
   \   0000071A   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   0000071E   0xD1EF             BNE.N    ??_buffer_steps_71
   \   00000720   0x4640             MOV      R0,R8
   \   00000722   0x4649             MOV      R1,R9
   \   00000724   0x.... 0x....      BL       __aeabi_fadd
   \   00000728   0x4629             MOV      R1,R5
   \   0000072A   0x.... 0x....      BL       __aeabi_fadd
   \   0000072E   0x.... 0x....      BL       sqrtf
   \   00000732   0x6378             STR      R0,[R7, #+52]
   \   00000734   0xE0E4             B.N      ??_buffer_steps_62
   1159          		else if (MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_steps_63: (+1)
   \   00000736   0x2030             MOVS     R0,#+48
   \   00000738   0xEA1A 0x0F00      TST      R10,R0
   \   0000073C   0xD04B             BEQ.N    ??_buffer_steps_73
   1160          			block->millimeters = sqrt(sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD]));
   \   0000073E   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \   00000742   0xF04F 0x0A02      MOV      R10,#+2
   \   00000746   0x46A8             MOV      R8,R5
   \   00000748   0xE004             B.N      ??_buffer_steps_74
   \                     ??_buffer_steps_75: (+1)
   \   0000074A   0x4648             MOV      R0,R9
   \   0000074C   0x4649             MOV      R1,R9
   \   0000074E   0x.... 0x....      BL       __aeabi_fmul
   \   00000752   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_74: (+1)
   \   00000754   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000758   0xD504             BPL.N    ??_buffer_steps_76
   \   0000075A   0x4640             MOV      R0,R8
   \   0000075C   0x4649             MOV      R1,R9
   \   0000075E   0x.... 0x....      BL       __aeabi_fmul
   \   00000762   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_76: (+1)
   \   00000764   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000768   0xD1EF             BNE.N    ??_buffer_steps_75
   \   0000076A   0xF8D6 0xB004      LDR      R11,[R6, #+4]
   \   0000076E   0xF04F 0x0A02      MOV      R10,#+2
   \   00000772   0x46A9             MOV      R9,R5
   \   00000774   0xE004             B.N      ??_buffer_steps_77
   \                     ??_buffer_steps_78: (+1)
   \   00000776   0x4658             MOV      R0,R11
   \   00000778   0x4659             MOV      R1,R11
   \   0000077A   0x.... 0x....      BL       __aeabi_fmul
   \   0000077E   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_77: (+1)
   \   00000780   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000784   0xD504             BPL.N    ??_buffer_steps_79
   \   00000786   0x4648             MOV      R0,R9
   \   00000788   0x4659             MOV      R1,R11
   \   0000078A   0x.... 0x....      BL       __aeabi_fmul
   \   0000078E   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_79: (+1)
   \   00000790   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000794   0xD1EF             BNE.N    ??_buffer_steps_78
   \   00000796   0xF8D6 0xA018      LDR      R10,[R6, #+24]
   \   0000079A   0xF04F 0x0B02      MOV      R11,#+2
   \   0000079E   0xE004             B.N      ??_buffer_steps_80
   \                     ??_buffer_steps_81: (+1)
   \   000007A0   0x4650             MOV      R0,R10
   \   000007A2   0x4651             MOV      R1,R10
   \   000007A4   0x.... 0x....      BL       __aeabi_fmul
   \   000007A8   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_80: (+1)
   \   000007AA   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   000007AE   0xD504             BPL.N    ??_buffer_steps_82
   \   000007B0   0x4628             MOV      R0,R5
   \   000007B2   0x4651             MOV      R1,R10
   \   000007B4   0x.... 0x....      BL       __aeabi_fmul
   \   000007B8   0x4605             MOV      R5,R0
   \                     ??_buffer_steps_82: (+1)
   \   000007BA   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   000007BE   0xD1EF             BNE.N    ??_buffer_steps_81
   \   000007C0   0x4640             MOV      R0,R8
   \   000007C2   0x4649             MOV      R1,R9
   \   000007C4   0x.... 0x....      BL       __aeabi_fadd
   \   000007C8   0x4629             MOV      R1,R5
   \   000007CA   0x.... 0x....      BL       __aeabi_fadd
   \   000007CE   0x.... 0x....      BL       sqrtf
   \   000007D2   0x6378             STR      R0,[R7, #+52]
   \   000007D4   0xE094             B.N      ??_buffer_steps_62
   1161          		else if (MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_steps_73: (+1)
   \   000007D6   0x20C0             MOVS     R0,#+192
   \   000007D8   0xEA1A 0x0F00      TST      R10,R0
   \   000007DC   0xF8DD 0x9024      LDR      R9,[SP, #+36]
   \   000007E0   0xF04F 0x0A02      MOV      R10,#+2
   \   000007E4   0x46A8             MOV      R8,R5
   \   000007E6   0xD04B             BEQ.N    ??_buffer_steps_83
   1162          			block->millimeters = sqrt(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD]));
   \   000007E8   0xE004             B.N      ??_buffer_steps_84
   \                     ??_buffer_steps_85: (+1)
   \   000007EA   0x4648             MOV      R0,R9
   \   000007EC   0x4649             MOV      R1,R9
   \   000007EE   0x.... 0x....      BL       __aeabi_fmul
   \   000007F2   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_84: (+1)
   \   000007F4   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000007F8   0xD504             BPL.N    ??_buffer_steps_86
   \   000007FA   0x4640             MOV      R0,R8
   \   000007FC   0x4649             MOV      R1,R9
   \   000007FE   0x.... 0x....      BL       __aeabi_fmul
   \   00000802   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_86: (+1)
   \   00000804   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000808   0xD1EF             BNE.N    ??_buffer_steps_85
   \   0000080A   0xF8D6 0xB014      LDR      R11,[R6, #+20]
   \   0000080E   0xF04F 0x0A02      MOV      R10,#+2
   \   00000812   0x46A9             MOV      R9,R5
   \   00000814   0xE004             B.N      ??_buffer_steps_87
   \                     ??_buffer_steps_88: (+1)
   \   00000816   0x4658             MOV      R0,R11
   \   00000818   0x4659             MOV      R1,R11
   \   0000081A   0x.... 0x....      BL       __aeabi_fmul
   \   0000081E   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_87: (+1)
   \   00000820   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000824   0xD504             BPL.N    ??_buffer_steps_89
   \   00000826   0x4648             MOV      R0,R9
   \   00000828   0x4659             MOV      R1,R11
   \   0000082A   0x.... 0x....      BL       __aeabi_fmul
   \   0000082E   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_89: (+1)
   \   00000830   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000834   0xD1EF             BNE.N    ??_buffer_steps_88
   \   00000836   0xF8D6 0xA018      LDR      R10,[R6, #+24]
   \   0000083A   0xF04F 0x0B02      MOV      R11,#+2
   \   0000083E   0xE004             B.N      ??_buffer_steps_90
   \                     ??_buffer_steps_91: (+1)
   \   00000840   0x4650             MOV      R0,R10
   \   00000842   0x4651             MOV      R1,R10
   \   00000844   0x.... 0x....      BL       __aeabi_fmul
   \   00000848   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_90: (+1)
   \   0000084A   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   0000084E   0xD504             BPL.N    ??_buffer_steps_92
   \   00000850   0x4628             MOV      R0,R5
   \   00000852   0x4651             MOV      R1,R10
   \   00000854   0x.... 0x....      BL       __aeabi_fmul
   \   00000858   0x4605             MOV      R5,R0
   \                     ??_buffer_steps_92: (+1)
   \   0000085A   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   0000085E   0xD1EF             BNE.N    ??_buffer_steps_91
   \   00000860   0x4640             MOV      R0,R8
   \   00000862   0x4649             MOV      R1,R9
   \   00000864   0x.... 0x....      BL       __aeabi_fadd
   \   00000868   0x4629             MOV      R1,R5
   \   0000086A   0x.... 0x....      BL       __aeabi_fadd
   \   0000086E   0x.... 0x....      BL       sqrtf
   \   00000872   0x6378             STR      R0,[R7, #+52]
   \   00000874   0xE044             B.N      ??_buffer_steps_62
   \                     ??_buffer_steps_93: (+1)
   \   00000876   0x4648             MOV      R0,R9
   \   00000878   0x4649             MOV      R1,R9
   \   0000087A   0x.... 0x....      BL       __aeabi_fmul
   \   0000087E   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_83: (+1)
   \   00000880   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000884   0xD504             BPL.N    ??_buffer_steps_94
   \   00000886   0x4640             MOV      R0,R8
   \   00000888   0x4649             MOV      R1,R9
   \   0000088A   0x.... 0x....      BL       __aeabi_fmul
   \   0000088E   0x4680             MOV      R8,R0
   \                     ??_buffer_steps_94: (+1)
   \   00000890   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000894   0xD1EF             BNE.N    ??_buffer_steps_93
   1163          		else	
   1164          			block->millimeters = sqrt(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS]));
   \   00000896   0xF8D6 0xB004      LDR      R11,[R6, #+4]
   \   0000089A   0xF04F 0x0A02      MOV      R10,#+2
   \   0000089E   0x46A9             MOV      R9,R5
   \   000008A0   0xE004             B.N      ??_buffer_steps_95
   \                     ??_buffer_steps_96: (+1)
   \   000008A2   0x4658             MOV      R0,R11
   \   000008A4   0x4659             MOV      R1,R11
   \   000008A6   0x.... 0x....      BL       __aeabi_fmul
   \   000008AA   0x4683             MOV      R11,R0
   \                     ??_buffer_steps_95: (+1)
   \   000008AC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000008B0   0xD504             BPL.N    ??_buffer_steps_97
   \   000008B2   0x4648             MOV      R0,R9
   \   000008B4   0x4659             MOV      R1,R11
   \   000008B6   0x.... 0x....      BL       __aeabi_fmul
   \   000008BA   0x4681             MOV      R9,R0
   \                     ??_buffer_steps_97: (+1)
   \   000008BC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000008C0   0xD1EF             BNE.N    ??_buffer_steps_96
   \   000008C2   0xF8D6 0xA008      LDR      R10,[R6, #+8]
   \   000008C6   0xF04F 0x0B02      MOV      R11,#+2
   \   000008CA   0xE004             B.N      ??_buffer_steps_98
   \                     ??_buffer_steps_99: (+1)
   \   000008CC   0x4650             MOV      R0,R10
   \   000008CE   0x4651             MOV      R1,R10
   \   000008D0   0x.... 0x....      BL       __aeabi_fmul
   \   000008D4   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_98: (+1)
   \   000008D6   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   000008DA   0xD504             BPL.N    ??_buffer_steps_100
   \   000008DC   0x4628             MOV      R0,R5
   \   000008DE   0x4651             MOV      R1,R10
   \   000008E0   0x.... 0x....      BL       __aeabi_fmul
   \   000008E4   0x4605             MOV      R5,R0
   \                     ??_buffer_steps_100: (+1)
   \   000008E6   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   000008EA   0xD1EF             BNE.N    ??_buffer_steps_99
   1165          			
   1166              
   1167            }
   \   000008EC   0x4640             MOV      R0,R8
   \   000008EE   0x4649             MOV      R1,R9
   \   000008F0   0x.... 0x....      BL       __aeabi_fadd
   \   000008F4   0x4629             MOV      R1,R5
   \   000008F6   0x.... 0x....      BL       __aeabi_fadd
   \   000008FA   0x.... 0x....      BL       sqrtf
   \   000008FE   0x6378             STR      R0,[R7, #+52]
   1168            const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
   \                     ??_buffer_steps_62: (+1)
   \   00000900   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000904   0x6B79             LDR      R1,[R7, #+52]
   \   00000906   0x.... 0x....      BL       __aeabi_fdiv
   \   0000090A   0x9000             STR      R0,[SP, #+0]
   1169          
   1170            // Calculate inverse time for this move. No divide by zero due to previous checks.
   1171            // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   1172            float inverse_secs = fr_mm_s * inverse_millimeters;
   \   0000090C   0x9911             LDR      R1,[SP, #+68]
   \   0000090E   0x.... 0x....      BL       __aeabi_fmul
   \   00000912   0x4680             MOV      R8,R0
   1173          
   1174            const uint8_t moves_queued = movesplanned();
   \   00000914   0x.... 0x....      BL       _ZN7Planner12movesplannedEv
   \   00000918   0x9003             STR      R0,[SP, #+12]
   1175          
   1176            // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   1177            //#if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
   1178              // Segment time im micro seconds
   1179              uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   \   0000091A   0x4640             MOV      R0,R8
   \   0000091C   0x.... 0x....      BL       __aeabi_f2d
   \   00000920   0x4602             MOV      R2,R0
   \   00000922   0x460B             MOV      R3,R1
   \   00000924   0x2000             MOVS     R0,#+0
   \   00000926   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x412e8480
   \   0000092A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000092E   0x.... 0x....      BL       lround
   \   00000932   0x4605             MOV      R5,R0
   1180            //#endif
   1181          
   1182            //#if ENABLED(SLOWDOWN)
   1183            if(!(MACHINETPYE & IS_KINEMATIC))
   \   00000934   0xF8DF 0x0540      LDR.W    R0,??_buffer_steps_3+0x4
   \   00000938   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   0000093C   0xF240 0x3102      MOVW     R1,#+770
   \   00000940   0x4208             TST      R0,R1
   \   00000942   0xD11E             BNE.N    ??_buffer_steps_101
   1184            { 
   1185              if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
   \   00000944   0x9803             LDR      R0,[SP, #+12]
   \   00000946   0x1E80             SUBS     R0,R0,#+2
   \   00000948   0x2806             CMP      R0,#+6
   \   0000094A   0xD21A             BCS.N    ??_buffer_steps_101
   1186                if (segment_time_us < min_segment_time_us) {
   \   0000094C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000950   0x6980             LDR      R0,[R0, #+24]
   \   00000952   0x4285             CMP      R5,R0
   \   00000954   0xD215             BCS.N    ??_buffer_steps_101
   1187                  // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
   1188                  const uint32_t nst = segment_time_us + LROUND((double)(2 * (min_segment_time_us - segment_time_us) / moves_queued));
   \   00000956   0x1B40             SUBS     R0,R0,R5
   \   00000958   0x0040             LSLS     R0,R0,#+1
   \   0000095A   0x9903             LDR      R1,[SP, #+12]
   \   0000095C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000960   0x.... 0x....      BL       __aeabi_ui2d
   \   00000964   0x.... 0x....      BL       lround
   \   00000968   0x1940             ADDS     R0,R0,R5
   1189                  inverse_secs = 1000000.0 / nst;
   \   0000096A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000096E   0x4602             MOV      R2,R0
   \   00000970   0x460B             MOV      R3,R1
   \   00000972   0x2000             MOVS     R0,#+0
   \   00000974   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x412e8480
   \   00000978   0x.... 0x....      BL       __aeabi_ddiv
   \   0000097C   0x.... 0x....      BL       __aeabi_d2f
   \   00000980   0x4680             MOV      R8,R0
   1190                  #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
   1191                    segment_time_us = nst;
   1192                  #endif
   1193                }
   1194              }
   1195             }
   1196            //#endif
   1197          
   1198            #if ENABLED(ULTRA_LCD)
   1199              CRITICAL_SECTION_START
   1200                block_buffer_runtime_us += segment_time_us;
   1201              CRITICAL_SECTION_END
   1202            #endif
   1203          
   1204            block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
   \                     ??_buffer_steps_101: (+1)
   \   00000982   0x6B78             LDR      R0,[R7, #+52]
   \   00000984   0x4641             MOV      R1,R8
   \   00000986   0x.... 0x....      BL       __aeabi_fmul
   \   0000098A   0x62B8             STR      R0,[R7, #+40]
   1205            block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000098C   0x6978             LDR      R0,[R7, #+20]
   \   0000098E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000992   0x4641             MOV      R1,R8
   \   00000994   0x.... 0x....      BL       __aeabi_fmul
   \   00000998   0x.... 0x....      BL       ceilf
   \   0000099C   0x.... 0x....      BL       __aeabi_f2uiz
   \   000009A0   0x63F8             STR      R0,[R7, #+60]
   1206          
   1207            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1208              static float filwidth_e_count = 0, filwidth_delay_dist = 0;
   1209          
   1210              //FMM update ring buffer used for delay with filament measurements
   1211              if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
   1212          
   1213                constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
   1214          
   1215                // increment counters with next move in e axis
   1216                filwidth_e_count += delta_mm[E_AXIS];
   1217                filwidth_delay_dist += delta_mm[E_AXIS];
   1218          
   1219                // Only get new measurements on forward E movement
   1220                if (!UNEAR_ZERO(filwidth_e_count)) {
   1221          
   1222                  // Loop the delay distance counter (modulus by the mm length)
   1223                  while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
   1224          
   1225                  // Convert into an index into the measurement array
   1226                  filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
   1227          
   1228                  // If the index has changed (must have gone forward)...
   1229                  if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
   1230                    filwidth_e_count = 0; // Reset the E movement counter
   1231                    const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
   1232                    do {
   1233                      filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
   1234                      measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
   1235                    } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
   1236                  }
   1237                }
   1238              }
   1239            #endif
   1240          
   1241            // Calculate and limit speed in mm/sec for each axis
   1242            float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   \   000009A2   0xF04F 0x557E      MOV      R5,#+1065353216
   \   000009A6   0x46A9             MOV      R9,R5
   1243            LOOP_XYZE(i) {
   \   000009A8   0xF04F 0x0A00      MOV      R10,#+0
   \   000009AC   0xF10D 0x0B14      ADD      R11,SP,#+20
   \   000009B0   0xE023             B.N      ??_buffer_steps_102
   1244              const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
   \                     ??_buffer_steps_103: (+1)
   \   000009B2   0xF856 0x002A      LDR      R0,[R6, R10, LSL #+2]
   \   000009B6   0x4641             MOV      R1,R8
   \   000009B8   0x.... 0x....      BL       __aeabi_fmul
   \   000009BC   0xF84B 0x002A      STR      R0,[R11, R10, LSL #+2]
   \   000009C0   0xF020 0x4100      BIC      R1,R0,#0x80000000
   1245              #if ENABLED(DISTINCT_E_FACTORS)
   1246                if (i == E_AXIS) i += extruder;
   \   000009C4   0xF1BA 0x0F03      CMP      R10,#+3
   \   000009C8   0xD104             BNE.N    ??_buffer_steps_104
   \   000009CA   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000009CE   0x4482             ADD      R10,R0,R10
   \   000009D0   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??_buffer_steps_104: (+1)
   \   000009D4   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000009D8   0xEB00 0x008A      ADD      R0,R0,R10, LSL #+2
   \   000009DC   0x6840             LDR      R0,[R0, #+4]
   \   000009DE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000009E2   0xD206             BCS.N    ??_buffer_steps_105
   1247              #endif
   1248              if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   \   000009E4   0x.... 0x....      BL       __aeabi_fdiv
   \   000009E8   0x4649             MOV      R1,R9
   \   000009EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000009EE   0xD200             BCS.N    ??_buffer_steps_105
   \   000009F0   0x4681             MOV      R9,R0
   1249            }
   \                     ??_buffer_steps_105: (+1)
   \   000009F2   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   000009F6   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??_buffer_steps_102: (+1)
   \   000009FA   0xF1BA 0x0F04      CMP      R10,#+4
   \   000009FE   0xDBD8             BLT.N    ??_buffer_steps_103
   1250          
   1251            // Max segment time in 碌s.
   1252            #ifdef XY_FREQUENCY_LIMIT
   1253          
   1254              // Check and limit the xy direction change frequency
   1255              const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
   1256              old_direction_bits = block->direction_bits;
   1257              segment_time_us = LROUND((float)segment_time_us / speed_factor);
   1258          
   1259              uint32_t xs0 = axis_segment_time_us[X_AXIS][0],
   1260                       xs1 = axis_segment_time_us[X_AXIS][1],
   1261                       xs2 = axis_segment_time_us[X_AXIS][2],
   1262                       ys0 = axis_segment_time_us[Y_AXIS][0],
   1263                       ys1 = axis_segment_time_us[Y_AXIS][1],
   1264                       ys2 = axis_segment_time_us[Y_AXIS][2];
   1265          
   1266              if (TEST(direction_change, X_AXIS)) {
   1267                xs2 = axis_segment_time_us[X_AXIS][2] = xs1;
   1268                xs1 = axis_segment_time_us[X_AXIS][1] = xs0;
   1269                xs0 = 0;
   1270              }
   1271              xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
   1272          
   1273              if (TEST(direction_change, Y_AXIS)) {
   1274                ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
   1275                ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
   1276                ys0 = 0;
   1277              }
   1278              ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
   1279          
   1280              const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
   1281                             max_y_segment_time = MAX3(ys0, ys1, ys2),
   1282                             min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
   1283              if (min_xy_segment_time < MAX_FREQ_TIME_US) {
   1284                const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
   1285                NOMORE(speed_factor, low_sf);
   1286              }
   1287            #endif // XY_FREQUENCY_LIMIT
   1288          
   1289            // Correct the speed
   1290            if (speed_factor < 1.0) {
   \   00000A00   0x4648             MOV      R0,R9
   \   00000A02   0x4629             MOV      R1,R5
   \   00000A04   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000A08   0xD219             BCS.N    ??_buffer_steps_106
   1291              LOOP_XYZE(i) current_speed[i] *= speed_factor;
   \   00000A0A   0x2600             MOVS     R6,#+0
   \   00000A0C   0xE007             B.N      ??_buffer_steps_107
   \                     ??_buffer_steps_108: (+1)
   \   00000A0E   0xF85B 0x0026      LDR      R0,[R11, R6, LSL #+2]
   \   00000A12   0x4649             MOV      R1,R9
   \   00000A14   0x.... 0x....      BL       __aeabi_fmul
   \   00000A18   0xF84B 0x0026      STR      R0,[R11, R6, LSL #+2]
   \   00000A1C   0x1C76             ADDS     R6,R6,#+1
   \                     ??_buffer_steps_107: (+1)
   \   00000A1E   0x2E04             CMP      R6,#+4
   \   00000A20   0xDBF5             BLT.N    ??_buffer_steps_108
   1292              block->nominal_speed *= speed_factor;
   \   00000A22   0x6AB8             LDR      R0,[R7, #+40]
   \   00000A24   0x4649             MOV      R1,R9
   \   00000A26   0x.... 0x....      BL       __aeabi_fmul
   \   00000A2A   0x62B8             STR      R0,[R7, #+40]
   1293              block->nominal_rate *= speed_factor;
   \   00000A2C   0x6BF8             LDR      R0,[R7, #+60]
   \   00000A2E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A32   0x4649             MOV      R1,R9
   \   00000A34   0x.... 0x....      BL       __aeabi_fmul
   \   00000A38   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000A3C   0x63F8             STR      R0,[R7, #+60]
   1294            }
   1295          
   1296            // Compute and limit the acceleration rate for the trapezoid generator.
   1297            const float steps_per_mm = block->step_event_count * inverse_millimeters;
   \                     ??_buffer_steps_106: (+1)
   \   00000A3E   0x6978             LDR      R0,[R7, #+20]
   \   00000A40   0x.... 0x....      BL       __aeabi_ui2f
   \   00000A44   0x9900             LDR      R1,[SP, #+0]
   \   00000A46   0x.... 0x....      BL       __aeabi_fmul
   \   00000A4A   0x4606             MOV      R6,R0
   1298            uint32_t accel;
   1299            if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
   \   00000A4C   0x6878             LDR      R0,[R7, #+4]
   \   00000A4E   0x2800             CMP      R0,#+0
   \   00000A50   0xD111             BNE.N    ??_buffer_steps_109
   \   00000A52   0x68B8             LDR      R0,[R7, #+8]
   \   00000A54   0x2800             CMP      R0,#+0
   \   00000A56   0xD10E             BNE.N    ??_buffer_steps_109
   \   00000A58   0x68F8             LDR      R0,[R7, #+12]
   \   00000A5A   0x2800             CMP      R0,#+0
   \   00000A5C   0xD10B             BNE.N    ??_buffer_steps_109
   1300              // convert to: acceleration steps/sec^2
   1301              accel = CEIL(retract_acceleration * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000A5E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000A62   0x6A40             LDR      R0,[R0, #+36]
   \   00000A64   0x4631             MOV      R1,R6
   \   00000A66   0x.... 0x....      BL       __aeabi_fmul
   \   00000A6A   0x.... 0x....      BL       ceilf
   \   00000A6E   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000A72   0x4681             MOV      R9,R0
   \   00000A74   0xE0F4             B.N      ??_buffer_steps_110
   1302            }
   1303            else {
   1304              #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
   1305                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1306                  const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
   1307                  if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
   1308                } \
   1309              }while(0)
   1310          
   1311              #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
   1312                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1313                  const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
   1314                  if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
   1315                } \
   1316              }while(0)
   1317          
   1318              // Start with print or travel acceleration
   1319              accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_109: (+1)
   \   00000A76   0x9802             LDR      R0,[SP, #+8]
   \   00000A78   0x2800             CMP      R0,#+0
   \   00000A7A   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000A7E   0xD001             BEQ.N    ??_buffer_steps_111
   \   00000A80   0x6A00             LDR      R0,[R0, #+32]
   \   00000A82   0xE000             B.N      ??_buffer_steps_112
   \                     ??_buffer_steps_111: (+1)
   \   00000A84   0x6A80             LDR      R0,[R0, #+40]
   \                     ??_buffer_steps_112: (+1)
   \   00000A86   0x4631             MOV      R1,R6
   \   00000A88   0x.... 0x....      BL       __aeabi_fmul
   \   00000A8C   0x.... 0x....      BL       ceilf
   \   00000A90   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000A94   0x4681             MOV      R9,R0
   1320          
   1321              #if ENABLED(DISTINCT_E_FACTORS)
   1322                #define ACCEL_IDX extruder
   1323              #else
   1324                #define ACCEL_IDX 0
   1325              #endif
   1326          
   1327              // Limit acceleration per axis
   1328              if (block->step_event_count <= cutoff_long) {
   \   00000A96   0xF8D7 0xA004      LDR      R10,[R7, #+4]
   \   00000A9A   0xF8D7 0x8014      LDR      R8,[R7, #+20]
   \   00000A9E   0x6E60             LDR      R0,[R4, #+100]
   \   00000AA0   0x4540             CMP      R0,R8
   \   00000AA2   0xD342             BCC.N    ??_buffer_steps_113
   1329                LIMIT_ACCEL_LONG(X_AXIS, 0);
   \   00000AA4   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000AA8   0xD00A             BEQ.N    ??_buffer_steps_114
   \   00000AAA   0x6AE0             LDR      R0,[R4, #+44]
   \   00000AAC   0x4548             CMP      R0,R9
   \   00000AAE   0xD207             BCS.N    ??_buffer_steps_114
   \   00000AB0   0xFB08 0xF000      MUL      R0,R8,R0
   \   00000AB4   0xFB0A 0xF109      MUL      R1,R10,R9
   \   00000AB8   0x4288             CMP      R0,R1
   \   00000ABA   0xD201             BCS.N    ??_buffer_steps_114
   \   00000ABC   0xFBB0 0xF9FA      UDIV     R9,R0,R10
   1330                LIMIT_ACCEL_LONG(Y_AXIS, 0);
   \                     ??_buffer_steps_114: (+1)
   \   00000AC0   0xF8D7 0xA008      LDR      R10,[R7, #+8]
   \   00000AC4   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000AC8   0xD00A             BEQ.N    ??_buffer_steps_115
   \   00000ACA   0x6B20             LDR      R0,[R4, #+48]
   \   00000ACC   0x4548             CMP      R0,R9
   \   00000ACE   0xD207             BCS.N    ??_buffer_steps_115
   \   00000AD0   0xFB08 0xF000      MUL      R0,R8,R0
   \   00000AD4   0xFB0A 0xF109      MUL      R1,R10,R9
   \   00000AD8   0x4288             CMP      R0,R1
   \   00000ADA   0xD201             BCS.N    ??_buffer_steps_115
   \   00000ADC   0xFBB0 0xF9FA      UDIV     R9,R0,R10
   1331                LIMIT_ACCEL_LONG(Z_AXIS, 0);
   \                     ??_buffer_steps_115: (+1)
   \   00000AE0   0xF8D7 0xA00C      LDR      R10,[R7, #+12]
   \   00000AE4   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000AE8   0xD00A             BEQ.N    ??_buffer_steps_116
   \   00000AEA   0x6B60             LDR      R0,[R4, #+52]
   \   00000AEC   0x4548             CMP      R0,R9
   \   00000AEE   0xD207             BCS.N    ??_buffer_steps_116
   \   00000AF0   0xFB08 0xF000      MUL      R0,R8,R0
   \   00000AF4   0xFB0A 0xF109      MUL      R1,R10,R9
   \   00000AF8   0x4288             CMP      R0,R1
   \   00000AFA   0xD201             BCS.N    ??_buffer_steps_116
   \   00000AFC   0xFBB0 0xF9FA      UDIV     R9,R0,R10
   1332                LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
   \                     ??_buffer_steps_116: (+1)
   \   00000B00   0xF8D7 0xA010      LDR      R10,[R7, #+16]
   \   00000B04   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000B08   0xF000 0x80AA      BEQ.W    ??_buffer_steps_110
   \   00000B0C   0x9801             LDR      R0,[SP, #+4]
   \   00000B0E   0x6B80             LDR      R0,[R0, #+56]
   \   00000B10   0x4548             CMP      R0,R9
   \   00000B12   0xF080 0x80A5      BCS.W    ??_buffer_steps_110
   \   00000B16   0xFB08 0xF000      MUL      R0,R8,R0
   \   00000B1A   0xFB0A 0xF109      MUL      R1,R10,R9
   \   00000B1E   0x4288             CMP      R0,R1
   \   00000B20   0xF080 0x809E      BCS.W    ??_buffer_steps_110
   \   00000B24   0xFBB0 0xF9FA      UDIV     R9,R0,R10
   \   00000B28   0xE09A             B.N      ??_buffer_steps_110
   1333              }
   1334              else {
   1335                LIMIT_ACCEL_FLOAT(X_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_113: (+1)
   \   00000B2A   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000B2E   0xD021             BEQ.N    ??_buffer_steps_117
   \   00000B30   0x6AE0             LDR      R0,[R4, #+44]
   \   00000B32   0x4548             CMP      R0,R9
   \   00000B34   0xD21E             BCS.N    ??_buffer_steps_117
   \   00000B36   0x.... 0x....      BL       __aeabi_ui2f
   \   00000B3A   0x4683             MOV      R11,R0
   \   00000B3C   0x4640             MOV      R0,R8
   \   00000B3E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000B42   0x4659             MOV      R1,R11
   \   00000B44   0x.... 0x....      BL       __aeabi_fmul
   \   00000B48   0x4683             MOV      R11,R0
   \   00000B4A   0x4650             MOV      R0,R10
   \   00000B4C   0x.... 0x....      BL       __aeabi_i2f
   \   00000B50   0x4682             MOV      R10,R0
   \   00000B52   0x4648             MOV      R0,R9
   \   00000B54   0x.... 0x....      BL       __aeabi_ui2f
   \   00000B58   0x4651             MOV      R1,R10
   \   00000B5A   0x.... 0x....      BL       __aeabi_fmul
   \   00000B5E   0x4601             MOV      R1,R0
   \   00000B60   0x4658             MOV      R0,R11
   \   00000B62   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000B66   0xD205             BCS.N    ??_buffer_steps_117
   \   00000B68   0x4651             MOV      R1,R10
   \   00000B6A   0x.... 0x....      BL       __aeabi_fdiv
   \   00000B6E   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000B72   0x4681             MOV      R9,R0
   1336                LIMIT_ACCEL_FLOAT(Y_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_117: (+1)
   \   00000B74   0xF8D7 0xA008      LDR      R10,[R7, #+8]
   \   00000B78   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000B7C   0xD021             BEQ.N    ??_buffer_steps_118
   \   00000B7E   0x6B20             LDR      R0,[R4, #+48]
   \   00000B80   0x4548             CMP      R0,R9
   \   00000B82   0xD21E             BCS.N    ??_buffer_steps_118
   \   00000B84   0x.... 0x....      BL       __aeabi_ui2f
   \   00000B88   0x4683             MOV      R11,R0
   \   00000B8A   0x4640             MOV      R0,R8
   \   00000B8C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000B90   0x4659             MOV      R1,R11
   \   00000B92   0x.... 0x....      BL       __aeabi_fmul
   \   00000B96   0x4683             MOV      R11,R0
   \   00000B98   0x4650             MOV      R0,R10
   \   00000B9A   0x.... 0x....      BL       __aeabi_i2f
   \   00000B9E   0x4682             MOV      R10,R0
   \   00000BA0   0x4648             MOV      R0,R9
   \   00000BA2   0x.... 0x....      BL       __aeabi_ui2f
   \   00000BA6   0x4651             MOV      R1,R10
   \   00000BA8   0x.... 0x....      BL       __aeabi_fmul
   \   00000BAC   0x4601             MOV      R1,R0
   \   00000BAE   0x4658             MOV      R0,R11
   \   00000BB0   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000BB4   0xD205             BCS.N    ??_buffer_steps_118
   \   00000BB6   0x4651             MOV      R1,R10
   \   00000BB8   0x.... 0x....      BL       __aeabi_fdiv
   \   00000BBC   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000BC0   0x4681             MOV      R9,R0
   1337                LIMIT_ACCEL_FLOAT(Z_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_118: (+1)
   \   00000BC2   0xF8D7 0xA00C      LDR      R10,[R7, #+12]
   \   00000BC6   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000BCA   0xD021             BEQ.N    ??_buffer_steps_119
   \   00000BCC   0x6B60             LDR      R0,[R4, #+52]
   \   00000BCE   0x4548             CMP      R0,R9
   \   00000BD0   0xD21E             BCS.N    ??_buffer_steps_119
   \   00000BD2   0x.... 0x....      BL       __aeabi_ui2f
   \   00000BD6   0x4683             MOV      R11,R0
   \   00000BD8   0x4640             MOV      R0,R8
   \   00000BDA   0x.... 0x....      BL       __aeabi_ui2f
   \   00000BDE   0x4659             MOV      R1,R11
   \   00000BE0   0x.... 0x....      BL       __aeabi_fmul
   \   00000BE4   0x4683             MOV      R11,R0
   \   00000BE6   0x4650             MOV      R0,R10
   \   00000BE8   0x.... 0x....      BL       __aeabi_i2f
   \   00000BEC   0x4682             MOV      R10,R0
   \   00000BEE   0x4648             MOV      R0,R9
   \   00000BF0   0x.... 0x....      BL       __aeabi_ui2f
   \   00000BF4   0x4651             MOV      R1,R10
   \   00000BF6   0x.... 0x....      BL       __aeabi_fmul
   \   00000BFA   0x4601             MOV      R1,R0
   \   00000BFC   0x4658             MOV      R0,R11
   \   00000BFE   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C02   0xD205             BCS.N    ??_buffer_steps_119
   \   00000C04   0x4651             MOV      R1,R10
   \   00000C06   0x.... 0x....      BL       __aeabi_fdiv
   \   00000C0A   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000C0E   0x4681             MOV      R9,R0
   1338                LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_119: (+1)
   \   00000C10   0xF8D7 0xA010      LDR      R10,[R7, #+16]
   \   00000C14   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000C18   0xD022             BEQ.N    ??_buffer_steps_110
   \   00000C1A   0x9801             LDR      R0,[SP, #+4]
   \   00000C1C   0x6B80             LDR      R0,[R0, #+56]
   \   00000C1E   0x4548             CMP      R0,R9
   \   00000C20   0xD21E             BCS.N    ??_buffer_steps_110
   \   00000C22   0x.... 0x....      BL       __aeabi_ui2f
   \   00000C26   0x4683             MOV      R11,R0
   \   00000C28   0x4640             MOV      R0,R8
   \   00000C2A   0x.... 0x....      BL       __aeabi_ui2f
   \   00000C2E   0x4659             MOV      R1,R11
   \   00000C30   0x.... 0x....      BL       __aeabi_fmul
   \   00000C34   0x4680             MOV      R8,R0
   \   00000C36   0x4650             MOV      R0,R10
   \   00000C38   0x.... 0x....      BL       __aeabi_i2f
   \   00000C3C   0x4682             MOV      R10,R0
   \   00000C3E   0x4648             MOV      R0,R9
   \   00000C40   0x.... 0x....      BL       __aeabi_ui2f
   \   00000C44   0x4651             MOV      R1,R10
   \   00000C46   0x.... 0x....      BL       __aeabi_fmul
   \   00000C4A   0x4601             MOV      R1,R0
   \   00000C4C   0x4640             MOV      R0,R8
   \   00000C4E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C52   0xD205             BCS.N    ??_buffer_steps_110
   \   00000C54   0x4651             MOV      R1,R10
   \   00000C56   0x.... 0x....      BL       __aeabi_fdiv
   \   00000C5A   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000C5E   0x4681             MOV      R9,R0
   1339              }
   1340            }
   1341            block->acceleration_steps_per_s2 = accel;
   \                     ??_buffer_steps_110: (+1)
   \   00000C60   0xF8C7 0x9048      STR      R9,[R7, #+72]
   1342            block->acceleration = accel / steps_per_mm;
   \   00000C64   0x4648             MOV      R0,R9
   \   00000C66   0x.... 0x....      BL       __aeabi_ui2f
   \   00000C6A   0x4631             MOV      R1,R6
   \   00000C6C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000C70   0x63B8             STR      R0,[R7, #+56]
   1343            //block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
   1344            block->acceleration_rate = (long)(accel * 8.388608); // * 8.388608
   \   00000C72   0x4648             MOV      R0,R9
   \   00000C74   0x.... 0x....      BL       __aeabi_ui2d
   \   00000C78   0x.... 0x....      LDR.W    R2,??DataTable21_1  ;; 0xa0b5ed8d
   \   00000C7C   0x.... 0x....      LDR.W    R3,??DataTable21_2  ;; 0x4020c6f7
   \   00000C80   0x.... 0x....      BL       __aeabi_dmul
   \   00000C84   0x.... 0x....      BL       __aeabi_d2iz
   \   00000C88   0x6238             STR      R0,[R7, #+32]
   1345          
   1346            // Initial limit on the segment entry velocity
   1347            float vmax_junction;
   1348          
   1349            #if 0  // Use old jerk for now
   1350          
   1351              float junction_deviation = 0.1;
   1352          
   1353              // Compute path unit vector
   1354              double unit_vec[XYZ] = {
   1355                delta_mm[X_AXIS] * inverse_millimeters,
   1356                delta_mm[Y_AXIS] * inverse_millimeters,
   1357                delta_mm[Z_AXIS] * inverse_millimeters
   1358              };
   1359          
   1360              /*
   1361                 Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
   1362          
   1363                 Let a circle be tangent to both previous and current path line segments, where the junction
   1364                 deviation is defined as the distance from the junction to the closest edge of the circle,
   1365                 collinear with the circle center.
   1366          
   1367                 The circular segment joining the two paths represents the path of centripetal acceleration.
   1368                 Solve for max velocity based on max acceleration about the radius of the circle, defined
   1369                 indirectly by junction deviation.
   1370          
   1371                 This may be also viewed as path width or max_jerk in the previous grbl version. This approach
   1372                 does not actually deviate from path, but used as a robust way to compute cornering speeds, as
   1373                 it takes into account the nonlinearities of both the junction angle and junction velocity.
   1374               */
   1375          
   1376              vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
   1377          
   1378              // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
   1379              if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
   1380                // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
   1381                // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
   1382                const float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
   1383                                        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
   1384                                        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS];
   1385                // Skip and use default max junction speed for 0 degree acute junction.
   1386                if (cos_theta < 0.95) {
   1387                  vmax_junction = min(previous_nominal_speed, block->nominal_speed);
   1388                  // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
   1389                  if (cos_theta > -0.95) {
   1390                    // Compute maximum junction velocity based on maximum acceleration and junction deviation
   1391                    float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
   1392                    NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
   1393                  }
   1394                }
   1395              }
   1396            #endif
   1397          
   1398            /**
   1399             * Adapted from Pr暖拧a MKS firmware
   1400             * https://github.com/prusa3d/Prusa-Firmware
   1401             *
   1402             * Start with a safe speed (from which the machine may halt to stop immediately).
   1403             */
   1404          
   1405            // Exit speed limited by a jerk to full halt of a previous last segment
   1406            static float previous_safe_speed;
   1407          
   1408            float safe_speed = block->nominal_speed;
   \   00000C8A   0xF8D7 0x8028      LDR      R8,[R7, #+40]
   1409            uint8_t limited = 0;
   \   00000C8E   0xF04F 0x0900      MOV      R9,#+0
   1410            LOOP_XYZE(i) {
   \   00000C92   0x46CA             MOV      R10,R9
   \   00000C94   0xE004             B.N      ??_buffer_steps_120
   1411              const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
   1412              if (jerk > maxj) {
   1413                if (limited) {
   1414                  const float mjerk = maxj * block->nominal_speed;
   1415                  if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
   1416                }
   1417                else {
   1418                  ++limited;
   \                     ??_buffer_steps_121: (+1)
   \   00000C96   0xF04F 0x0901      MOV      R9,#+1
   1419                  safe_speed = maxj;
   \   00000C9A   0x46B0             MOV      R8,R6
   1420                }
   \                     ??_buffer_steps_122: (+1)
   \   00000C9C   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??_buffer_steps_120: (+1)
   \   00000CA0   0xF1BA 0x0F04      CMP      R10,#+4
   \   00000CA4   0xDA24             BGE.N    ??_buffer_steps_123
   \   00000CA6   0xA805             ADD      R0,SP,#+20
   \   00000CA8   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \   00000CAC   0xF020 0x4B00      BIC      R11,R0,#0x80000000
   \   00000CB0   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000CB4   0xEB00 0x008A      ADD      R0,R0,R10, LSL #+2
   \   00000CB8   0x6AC6             LDR      R6,[R0, #+44]
   \   00000CBA   0x4630             MOV      R0,R6
   \   00000CBC   0x4659             MOV      R1,R11
   \   00000CBE   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000CC2   0xD2EB             BCS.N    ??_buffer_steps_122
   \   00000CC4   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000CC8   0xD0E5             BEQ.N    ??_buffer_steps_121
   \   00000CCA   0x6AB8             LDR      R0,[R7, #+40]
   \   00000CCC   0x4631             MOV      R1,R6
   \   00000CCE   0x.... 0x....      BL       __aeabi_fmul
   \   00000CD2   0x4606             MOV      R6,R0
   \   00000CD4   0x4658             MOV      R0,R11
   \   00000CD6   0x4641             MOV      R1,R8
   \   00000CD8   0x.... 0x....      BL       __aeabi_fmul
   \   00000CDC   0x4601             MOV      R1,R0
   \   00000CDE   0x4630             MOV      R0,R6
   \   00000CE0   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000CE4   0xD2DA             BCS.N    ??_buffer_steps_122
   \   00000CE6   0x4659             MOV      R1,R11
   \   00000CE8   0x.... 0x....      BL       __aeabi_fdiv
   \   00000CEC   0x4680             MOV      R8,R0
   \   00000CEE   0xE7D5             B.N      ??_buffer_steps_122
   1421              }
   1422            }
   1423          
   1424            if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
   \                     ??_buffer_steps_123: (+1)
   \   00000CF0   0x9803             LDR      R0,[SP, #+12]
   \   00000CF2   0x2800             CMP      R0,#+0
   \   00000CF4   0xF000 0x809A      BEQ.W    ??_buffer_steps_124
   \   00000CF8   0x6FA2             LDR      R2,[R4, #+120]
   \   00000CFA   0x4610             MOV      R0,R2
   \   00000CFC   0x.... 0x....      LDR.W    R1,??DataTable21_3  ;; 0x358637be
   \   00000D00   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000D04   0xF0C0 0x8092      BCC.W    ??_buffer_steps_124
   1425              // Estimate a maximum velocity allowed at a joint of two successive segments.
   1426              // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
   1427              // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
   1428          
   1429              // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
   1430              // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
   1431              vmax_junction = min(block->nominal_speed, previous_nominal_speed);
   \   00000D08   0x6AB8             LDR      R0,[R7, #+40]
   \   00000D0A   0x4611             MOV      R1,R2
   \   00000D0C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000D10   0xD208             BCS.N    ??_buffer_steps_125
   \   00000D12   0x9000             STR      R0,[SP, #+0]
   \   00000D14   0xE007             B.N      ??_buffer_steps_126
   \   00000D16   0xBF00             Nop      
   \                     ??_buffer_steps_0:
   \   00000D18   0x........         DC32     _ZN7Planner17block_buffer_headE
   \   00000D1C   0x........         DC32     echomagic
   \   00000D20   0x........         DC32     `?<Constant " cold extrusion preve...">`
   \                     ??_buffer_steps_125: (+1)
   \   00000D24   0x9200             STR      R2,[SP, #+0]
   1432          
   1433              // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
   1434              float v_factor = 1;
   1435              limited = 0;
   \                     ??_buffer_steps_126: (+1)
   \   00000D26   0xF04F 0x0900      MOV      R9,#+0
   1436          
   1437              // Now limit the jerk in all axes.
   1438              const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
   \   00000D2A   0x9800             LDR      R0,[SP, #+0]
   \   00000D2C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000D30   0x9001             STR      R0,[SP, #+4]
   1439              LOOP_XYZE(axis) {
   \   00000D32   0x464E             MOV      R6,R9
   \   00000D34   0xE012             B.N      ??_buffer_steps_127
   1440                // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
   1441                float v_exit = previous_speed[axis] * smaller_speed_factor,
   1442                      v_entry = current_speed[axis];
   1443                if (limited) {
   1444                  v_exit *= v_factor;
   1445                  v_entry *= v_factor;
   1446                }
   1447          
   1448                // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
   1449                const float jerk = (v_exit > v_entry)
   1450                    ? //                                  coasting             axis reversal
   1451                      ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
   1452                    : // v_exit <= v_entry                coasting             axis reversal
   1453                      ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
   \                     ??_buffer_steps_128: (+1)
   \   00000D36   0x4652             MOV      R2,R10
   \                     ??_buffer_steps_129: (+1)
   \   00000D38   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000D3C   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   00000D40   0x6AC0             LDR      R0,[R0, #+44]
   \   00000D42   0x4611             MOV      R1,R2
   \   00000D44   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000D48   0xD207             BCS.N    ??_buffer_steps_130
   1454          
   1455                if (jerk > max_jerk[axis]) {
   1456                  v_factor *= max_jerk[axis] / jerk;
   \   00000D4A   0x.... 0x....      BL       __aeabi_fdiv
   \   00000D4E   0x4629             MOV      R1,R5
   \   00000D50   0x.... 0x....      BL       __aeabi_fmul
   \   00000D54   0x4605             MOV      R5,R0
   1457                  ++limited;
   \   00000D56   0xF109 0x0901      ADD      R9,R9,#+1
   1458                }
   \                     ??_buffer_steps_130: (+1)
   \   00000D5A   0x1C76             ADDS     R6,R6,#+1
   \                     ??_buffer_steps_127: (+1)
   \   00000D5C   0x2E04             CMP      R6,#+4
   \   00000D5E   0xDA4C             BGE.N    ??_buffer_steps_131
   \   00000D60   0xEB04 0x0086      ADD      R0,R4,R6, LSL #+2
   \   00000D64   0x6E80             LDR      R0,[R0, #+104]
   \   00000D66   0x9901             LDR      R1,[SP, #+4]
   \   00000D68   0x.... 0x....      BL       __aeabi_fmul
   \   00000D6C   0x4683             MOV      R11,R0
   \   00000D6E   0xA805             ADD      R0,SP,#+20
   \   00000D70   0xF850 0xA026      LDR      R10,[R0, R6, LSL #+2]
   \   00000D74   0xFA5F 0xF989      UXTB     R9,R9
   \   00000D78   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000D7C   0xD009             BEQ.N    ??_buffer_steps_132
   \   00000D7E   0x4658             MOV      R0,R11
   \   00000D80   0x4629             MOV      R1,R5
   \   00000D82   0x.... 0x....      BL       __aeabi_fmul
   \   00000D86   0x4683             MOV      R11,R0
   \   00000D88   0x4650             MOV      R0,R10
   \   00000D8A   0x4629             MOV      R1,R5
   \   00000D8C   0x.... 0x....      BL       __aeabi_fmul
   \   00000D90   0x4682             MOV      R10,R0
   \                     ??_buffer_steps_132: (+1)
   \   00000D92   0x4650             MOV      R0,R10
   \   00000D94   0x4659             MOV      R1,R11
   \   00000D96   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000D9A   0xD217             BCS.N    ??_buffer_steps_133
   \   00000D9C   0x2100             MOVS     R1,#+0
   \   00000D9E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000DA2   0xD303             BCC.N    ??_buffer_steps_134
   \   00000DA4   0x4658             MOV      R0,R11
   \   00000DA6   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000DAA   0xD205             BCS.N    ??_buffer_steps_135
   \                     ??_buffer_steps_134: (+1)
   \   00000DAC   0x4658             MOV      R0,R11
   \   00000DAE   0x4651             MOV      R1,R10
   \   00000DB0   0x.... 0x....      BL       __aeabi_fsub
   \   00000DB4   0x4602             MOV      R2,R0
   \   00000DB6   0xE7BF             B.N      ??_buffer_steps_129
   \                     ??_buffer_steps_135: (+1)
   \   00000DB8   0x4652             MOV      R2,R10
   \   00000DBA   0xF082 0x4200      EOR      R2,R2,#0x80000000
   \   00000DBE   0x4610             MOV      R0,R2
   \   00000DC0   0x4659             MOV      R1,R11
   \   00000DC2   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000DC6   0xD2B7             BCS.N    ??_buffer_steps_129
   \   00000DC8   0x465A             MOV      R2,R11
   \   00000DCA   0xE7B5             B.N      ??_buffer_steps_129
   \                     ??_buffer_steps_133: (+1)
   \   00000DCC   0x2100             MOVS     R1,#+0
   \   00000DCE   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000DD2   0xD303             BCC.N    ??_buffer_steps_136
   \   00000DD4   0x4658             MOV      R0,R11
   \   00000DD6   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000DDA   0xD205             BCS.N    ??_buffer_steps_137
   \                     ??_buffer_steps_136: (+1)
   \   00000DDC   0x4650             MOV      R0,R10
   \   00000DDE   0x4659             MOV      R1,R11
   \   00000DE0   0x.... 0x....      BL       __aeabi_fsub
   \   00000DE4   0x4602             MOV      R2,R0
   \   00000DE6   0xE7A7             B.N      ??_buffer_steps_129
   \                     ??_buffer_steps_137: (+1)
   \   00000DE8   0x465A             MOV      R2,R11
   \   00000DEA   0xF082 0x4200      EOR      R2,R2,#0x80000000
   \   00000DEE   0x4650             MOV      R0,R10
   \   00000DF0   0x4611             MOV      R1,R2
   \   00000DF2   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000DF6   0xD29E             BCS.N    ??_buffer_steps_128
   \   00000DF8   0xE79E             B.N      ??_buffer_steps_129
   1459              }
   1460              if (limited) vmax_junction *= v_factor;
   \                     ??_buffer_steps_131: (+1)
   \   00000DFA   0xFA5F 0xF989      UXTB     R9,R9
   \   00000DFE   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000E02   0xD004             BEQ.N    ??_buffer_steps_138
   \   00000E04   0x9800             LDR      R0,[SP, #+0]
   \   00000E06   0x4629             MOV      R1,R5
   \   00000E08   0x.... 0x....      BL       __aeabi_fmul
   \   00000E0C   0x9000             STR      R0,[SP, #+0]
   1461              // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
   1462              // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
   1463              const float vmax_junction_threshold = vmax_junction * 0.99f;
   \                     ??_buffer_steps_138: (+1)
   \   00000E0E   0x9900             LDR      R1,[SP, #+0]
   \   00000E10   0x.... 0x....      LDR.W    R0,??DataTable21_4  ;; 0x3f7d70a4
   \   00000E14   0x.... 0x....      BL       __aeabi_fmul
   1464              if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
   \   00000E18   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000E1C   0x6C09             LDR      R1,[R1, #+64]
   \   00000E1E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000E22   0xD209             BCS.N    ??_buffer_steps_139
   \   00000E24   0x4641             MOV      R1,R8
   \   00000E26   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000E2A   0xD205             BCS.N    ??_buffer_steps_139
   1465                // Not coasting. The machine will stop and start the movements anyway,
   1466                // better to start the segment from start.
   1467                SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   1468                vmax_junction = safe_speed;
   1469              }
   1470            }
   1471            else {
   1472              SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   \                     ??_buffer_steps_124: (+1)
   \   00000E2C   0x7838             LDRB     R0,[R7, #+0]
   \   00000E2E   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000E32   0x7038             STRB     R0,[R7, #+0]
   1473              vmax_junction = safe_speed;
   \   00000E34   0xF8CD 0x8000      STR      R8,[SP, #+0]
   1474            }
   1475          
   1476            // Max entry speed of this block equals the max exit speed of the previous block.
   1477            block->max_entry_speed = vmax_junction;
   \                     ??_buffer_steps_139: (+1)
   \   00000E38   0x9800             LDR      R0,[SP, #+0]
   \   00000E3A   0x6338             STR      R0,[R7, #+48]
   1478          
   1479            // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   1480            const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   \   00000E3C   0x6BB8             LDR      R0,[R7, #+56]
   \   00000E3E   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   00000E42   0x9002             STR      R0,[SP, #+8]
   \   00000E44   0x.... 0x....      LDR.W    R0,??DataTable21_5  ;; 0x3d4ccccd
   \   00000E48   0x9001             STR      R0,[SP, #+4]
   \   00000E4A   0xF107 0x0234      ADD      R2,R7,#+52
   \   00000E4E   0xA901             ADD      R1,SP,#+4
   \   00000E50   0xA802             ADD      R0,SP,#+8
   \   00000E52   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   00000E56   0x4601             MOV      R1,R0
   1481            block->entry_speed = min(vmax_junction, v_allowable);
   \   00000E58   0x9800             LDR      R0,[SP, #+0]
   \   00000E5A   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000E5E   0xD300             BCC.N    ??_buffer_steps_140
   \   00000E60   0x4608             MOV      R0,R1
   \                     ??_buffer_steps_140: (+1)
   \   00000E62   0x62F8             STR      R0,[R7, #+44]
   1482          
   1483            // Initialize planner efficiency flags
   1484            // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   1485            // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   1486            // the current block and next block junction speeds are guaranteed to always be at their maximum
   1487            // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   1488            // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   1489            // the reverse and forward planners, the corresponding block junction speed will always be at the
   1490            // the maximum junction speed and may always be ignored for any speed reduction checks.
   1491            block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
   \   00000E64   0x4608             MOV      R0,R1
   \   00000E66   0x6AB9             LDR      R1,[R7, #+40]
   \   00000E68   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000E6C   0xD806             BHI.N    ??_buffer_steps_141
   \   00000E6E   0x2002             MOVS     R0,#+2
   \   00000E70   0xE005             B.N      ??_buffer_steps_142
   \   00000E72   0xBF00             Nop      
   \                     ??_buffer_steps_3:
   \   00000E74   0x........         DC32     `?<Constant " too long extrusion p...">`
   \   00000E78   0x........         DC32     mksCfg
   \                     ??_buffer_steps_141: (+1)
   \   00000E7C   0x2000             MOVS     R0,#+0
   \                     ??_buffer_steps_142: (+1)
   \   00000E7E   0x7839             LDRB     R1,[R7, #+0]
   \   00000E80   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000E84   0x4308             ORRS     R0,R0,R1
   \   00000E86   0x7038             STRB     R0,[R7, #+0]
   1492          
   1493            // Update previous path unit_vector and nominal speed
   1494            COPY(previous_speed, current_speed);
   \   00000E88   0x2210             MOVS     R2,#+16
   \   00000E8A   0xA905             ADD      R1,SP,#+20
   \   00000E8C   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000E90   0x.... 0x....      BL       memcpy
   1495            previous_nominal_speed = block->nominal_speed;
   \   00000E94   0x6AB8             LDR      R0,[R7, #+40]
   \   00000E96   0x67A0             STR      R0,[R4, #+120]
   1496            previous_safe_speed = safe_speed;
   \   00000E98   0x....             LDR.N    R0,??DataTable18
   \   00000E9A   0xF8C0 0x8040      STR      R8,[R0, #+64]
   1497          
   1498            #if ENABLED(LIN_ADVANCE)
   1499              /**
   1500               *
   1501               * Use LIN_ADVANCE for blocks if all these are true:
   1502               *
   1503               * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
   1504               *
   1505               * extruder_advance_k                 : There is an advance factor set.
   1506               *
   1507               * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
   1508               *                                      In that case, the retract and move will be executed together.
   1509               *                                      This leads to too many advance steps due to a huge e_acceleration.
   1510               *                                      The math is good, but we must avoid retract moves with advance!
   1511               * lin_dist_e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
   1512               */
   1513              block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
   1514                                      && extruder_advance_k
   1515                                      && (uint32_t)esteps != block->step_event_count
   1516                                      && lin_dist_e > 0;
   1517              if (block->use_advance_lead)
   1518                block->abs_adv_steps_multiplier8 = LROUND(
   1519                  extruder_advance_k
   1520                  * (UNEAR_ZERO(advance_ed_ratio) ? lin_dist_e / lin_dist_xy : advance_ed_ratio) // Use the fixed ratio, if set
   1521                  * (block->nominal_speed / (float)block->nominal_rate)
   1522                  * axis_steps_per_mm[E_AXIS_N] * 256.0
   1523                );
   1524          
   1525            #endif // LIN_ADVANCE
   1526          
   1527            const float bnsr = 1.0 / block->nominal_speed;
   \   00000E9E   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000EA2   0x6AB9             LDR      R1,[R7, #+40]
   \   00000EA4   0x.... 0x....      BL       __aeabi_fdiv
   \   00000EA8   0x4605             MOV      R5,R0
   1528            calculate_trapezoid_for_block(block, block->entry_speed * bnsr, safe_speed * bnsr);
   \   00000EAA   0x6AF8             LDR      R0,[R7, #+44]
   \   00000EAC   0x4629             MOV      R1,R5
   \   00000EAE   0x.... 0x....      BL       __aeabi_fmul
   \   00000EB2   0x9001             STR      R0,[SP, #+4]
   \   00000EB4   0x4640             MOV      R0,R8
   \   00000EB6   0x4629             MOV      R1,R5
   \   00000EB8   0x.... 0x....      BL       __aeabi_fmul
   \   00000EBC   0x9000             STR      R0,[SP, #+0]
   \   00000EBE   0xAA00             ADD      R2,SP,#+0
   \   00000EC0   0xA901             ADD      R1,SP,#+4
   \   00000EC2   0x4638             MOV      R0,R7
   \   00000EC4   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
   1529          
   1530            // Move buffer head
   1531            block_buffer_head = next_buffer_head;
   \   00000EC8   0x9804             LDR      R0,[SP, #+16]
   \   00000ECA   0x7020             STRB     R0,[R4, #+0]
   1532          
   1533            // Update the position (only when a move was queued)
   1534            static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   1535            COPY(position, target);
   \   00000ECC   0x2210             MOVS     R2,#+16
   \   00000ECE   0x9910             LDR      R1,[SP, #+64]
   \   00000ED0   0xF104 0x0040      ADD      R0,R4,#+64
   \   00000ED4   0x.... 0x....      BL       memcpy
   1536          
   1537            recalculate();
   \   00000ED8   0x.... 0x....      BL       _ZN7Planner11recalculateEv
   1538          
   1539          } // _buffer_steps()
   \                     ??_buffer_steps_35: (+1)
   \   00000EDC   0xB013             ADD      SP,SP,#+76
   \   00000EDE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .bss, align 4
   \                     _ZN7Planner23g_uc_extruder_last_moveE:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     _ZN7Planner17max_feedrate_mm_sE:
   \   00000004                      DS8 20
   \                     _ZN7Planner19min_segment_time_usE:
   \   00000018                      DS8 4
   \                     _ZN7Planner17min_feedrate_mm_sE:
   \   0000001C                      DS8 4
   \                     _ZN7Planner12accelerationE:
   \   00000020                      DS8 4
   \                     _ZN7Planner20retract_accelerationE:
   \   00000024                      DS8 4
   \                     _ZN7Planner19travel_accelerationE:
   \   00000028                      DS8 4
   \                     _ZN7Planner8max_jerkE:
   \   0000002C                      DS8 16
   \                     _ZN7Planner24min_travel_feedrate_mm_sE:
   \   0000003C                      DS8 4
   \   00000040                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner26max_acceleration_mm_per_s2E:
   \   00000000                      DS8 20

   \                                 In section .bss, align 1
   \                     _ZN7Planner15leveling_activeE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZN7Planner16bed_level_matrixE:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
   \                     _ZN7Planner13z_fade_heightE:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner21inverse_z_fade_heightE:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner11last_fade_zE:
   \   00000000                      DS8 4
   1540          
   1541          /**
   1542           * Planner::buffer_segment
   1543           *
   1544           * Add a new linear movement to the buffer in axis units.
   1545           *
   1546           * Leveling and kinematics should be applied ahead of calling this.
   1547           *
   1548           *  a,b,c,e   - target positions in mm and/or degrees
   1549           *  fr_mm_s   - (target) speed of the move
   1550           *  extruder  - target extruder
   1551           */

   \                                 In section .text, align 2, keep-with-next
   1552          void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   \   0000000E   0x9C15             LDR      R4,[SP, #+84]
   1553          
   1554          
   1555            
   1556            // When changing extruders recalculate steps corresponding to the E position
   1557            #if ENABLED(DISTINCT_E_FACTORS)
   1558              if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
   \   00000010   0x46A0             MOV      R8,R4
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable21_6
   \   00000016   0xEB09 0x0088      ADD      R0,R9,R8, LSL #+2
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \   00000020   0x42A0             CMP      R0,R4
   \   00000022   0xD01C             BEQ.N    ??buffer_segment_0
   \   00000024   0xEB09 0x0080      ADD      R0,R9,R0, LSL #+2
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0xF8D0 0xB010      LDR      R11,[R0, #+16]
   \   00000030   0x4658             MOV      R0,R11
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x6909             LDR      R1,[R1, #+16]
   \   00000036   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000003A   0xD010             BEQ.N    ??buffer_segment_0
   1559                position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
   \   0000003C   0xF8D9 0x004C      LDR      R0,[R9, #+76]
   \   00000040   0x.... 0x....      BL       __aeabi_i2f
   \   00000044   0x4659             MOV      R1,R11
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x9900             LDR      R1,[SP, #+0]
   \   0000004C   0x6A49             LDR      R1,[R1, #+36]
   \   0000004E   0x.... 0x....      BL       __aeabi_fmul
   \   00000052   0x.... 0x....      BL       lroundf
   \   00000056   0xF8C9 0x004C      STR      R0,[R9, #+76]
   1560                last_extruder = extruder;
   \   0000005A   0xF889 0x4002      STRB     R4,[R9, #+2]
   1561              }
   1562            #endif
   1563          
   1564            // The target position of the tool in absolute steps
   1565            // Calculate target position in absolute steps
   1566            const int32_t target[XYZE] = {
   \                     ??buffer_segment_0: (+1)
   \   0000005E   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000062   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x.... 0x....      BL       lroundf
   \   0000006E   0x9002             STR      R0,[SP, #+8]
   \   00000070   0xF10D 0x0A08      ADD      R10,SP,#+8
   \   00000074   0x6829             LDR      R1,[R5, #+0]
   \   00000076   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   0000007A   0x.... 0x....      BL       __aeabi_fmul
   \   0000007E   0x.... 0x....      BL       lroundf
   \   00000082   0xF8CA 0x0004      STR      R0,[R10, #+4]
   \   00000086   0x6831             LDR      R1,[R6, #+0]
   \   00000088   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   0000008C   0x.... 0x....      BL       __aeabi_fmul
   \   00000090   0x.... 0x....      BL       lroundf
   \   00000094   0xF8CA 0x0008      STR      R0,[R10, #+8]
   \   00000098   0x6839             LDR      R1,[R7, #+0]
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0x6900             LDR      R0,[R0, #+16]
   \   0000009E   0x.... 0x....      BL       __aeabi_fmul
   \   000000A2   0x.... 0x....      BL       lroundf
   \   000000A6   0x4605             MOV      R5,R0
   \   000000A8   0xF8CA 0x500C      STR      R5,[R10, #+12]
   1567              LROUND(a * axis_steps_per_mm[X_AXIS]),
   1568              LROUND(b * axis_steps_per_mm[Y_AXIS]),
   1569              LROUND(c * axis_steps_per_mm[Z_AXIS]),
   1570              LROUND(e * axis_steps_per_mm[E_AXIS_N])
   1571            };
   1572          
   1573            
   1574            if(MACHINETPYE & IS_KINEMATIC)
   \   000000AC   0x....             LDR.N    R2,??DataTable21_7
   \   000000AE   0x....             LDR.N    R0,??DataTable21_8
   \   000000B0   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   000000B4   0xF240 0x3102      MOVW     R1,#+770
   \   000000B8   0x4208             TST      R0,R1
   \   000000BA   0xF892 0x0148      LDRB     R0,[R2, #+328]
   \   000000BE   0xD00C             BEQ.N    ??buffer_segment_1
   1575            {
   1576              if (gCfgItems.breakpoint_reprint_flg == 1)
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD121             BNE.N    ??buffer_segment_2
   1577              {
   1578                  if(gCfgItems.had_breakpoint)
   \   000000C4   0xF502 0x70A4      ADD      R0,R2,#+328
   \   000000C8   0x7B01             LDRB     R1,[R0, #+12]
   \   000000CA   0x2900             CMP      R1,#+0
   \   000000CC   0xD01C             BEQ.N    ??buffer_segment_2
   1579                  {
   1580                      gCfgItems.had_breakpoint=0;
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0x7301             STRB     R1,[R0, #+12]
   1581                      position[E_AXIS] = gCfgItems.breakpoint_e_position;
   \   000000D2   0x6880             LDR      R0,[R0, #+8]
   \   000000D4   0xF8C9 0x004C      STR      R0,[R9, #+76]
   \   000000D8   0xE016             B.N      ??buffer_segment_2
   1582                  }
   1583              }
   1584            }
   1585            else
   1586            {
   1587          	if (gCfgItems.breakpoint_reprint_flg == 1) {
   \                     ??buffer_segment_1: (+1)
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD110             BNE.N    ??buffer_segment_3
   1588          		if (c < gCfgItems.breakpoint_z_pos) 
   \   000000DE   0x6830             LDR      R0,[R6, #+0]
   \   000000E0   0xF8D2 0x1298      LDR      R1,[R2, #+664]
   \   000000E4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E8   0xD20A             BCS.N    ??buffer_segment_3
   1589                  {
   1590                      position[E_AXIS] = target[E_AXIS_N];
   \   000000EA   0xA802             ADD      R0,SP,#+8
   \   000000EC   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   000000F0   0x68C0             LDR      R0,[R0, #+12]
   \   000000F2   0xF8C9 0x004C      STR      R0,[R9, #+76]
   1591                      gCfgItems.breakpoint_flg=1;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xF502 0x71A4      ADD      R1,R2,#+328
   \   000000FC   0x7348             STRB     R0,[R1, #+13]
   1592                      return;
   \   000000FE   0xE04A             B.N      ??buffer_segment_4
   1593                  }
   1594          	}
   1595              //gCfgItems.breakpoint_reprint_flg = 0;
   1596              gCfgItems.breakpoint_flg=0;
   \                     ??buffer_segment_3: (+1)
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xF502 0x71A4      ADD      R1,R2,#+328
   \   00000106   0x7348             STRB     R0,[R1, #+13]
   1597            }
   1598          
   1599            // DRYRUN prevents E moves from taking place
   1600            if (DEBUGGING(DRYRUN)) {
   \                     ??buffer_segment_2: (+1)
   \   00000108   0x....             LDR.N    R0,??DataTable21_9
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x0700             LSLS     R0,R0,#+28
   \   0000010E   0xD501             BPL.N    ??buffer_segment_5
   1601              position[E_AXIS] = target[E_AXIS];
   \   00000110   0xF8C9 0x504C      STR      R5,[R9, #+76]
   \                     ??buffer_segment_5: (+1)
   \   00000114   0x9E14             LDR      R6,[SP, #+80]
   1602              #if ENABLED(LIN_ADVANCE)
   1603                position_float[E_AXIS] = e;
   1604              #endif
   1605            }
   1606          
   1607            #if ENABLED(LIN_ADVANCE)
   1608              lin_dist_e = e - position_float[E_AXIS];
   1609            #endif
   1610          
   1611            // If LIN_ADVANCE is enabled then do E move prevention with floats
   1612            // Otherwise it's done in _buffer_steps.
   1613            #if ENABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
   1614              if (lin_dist_e) {
   1615                #if ENABLED(PREVENT_COLD_EXTRUSION)
   1616                  if (thermalManager.tooColdToExtrude(extruder)) {
   1617                    position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
   1618                    position[E_AXIS] = target[E_AXIS];
   1619                    lin_dist_e = 0;
   1620                    SERIAL_ECHO_START();
   1621                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   1622                  }
   1623                #endif // PREVENT_COLD_EXTRUSION
   1624                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
   1625                  if (lin_dist_e * e_factor[extruder] > (EXTRUDE_MAXLENGTH)) {
   1626                    position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
   1627                    position[E_AXIS] = target[E_AXIS];
   1628                    lin_dist_e = 0;
   1629                    SERIAL_ECHO_START();
   1630                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   1631                  }
   1632                #endif // PREVENT_LENGTHY_EXTRUDE
   1633              }
   1634            #endif // LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
   1635          
   1636            #if ENABLED(LIN_ADVANCE)
   1637              if (lin_dist_e > 0)
   1638                lin_dist_xy = HYPOT(a - position_float[X_AXIS], b - position_float[Y_AXIS]);
   1639            #endif
   1640          
   1641            /* <-- add a slash to enable
   1642              SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
   1643              #if IS_KINEMATIC
   1644                SERIAL_ECHOPAIR(" A:", a);
   1645                SERIAL_ECHOPAIR(" (", position[A_AXIS]);
   1646                SERIAL_ECHOPAIR("->", target[A_AXIS]);
   1647                SERIAL_ECHOPAIR(") B:", b);
   1648              #else
   1649                SERIAL_ECHOPAIR(" X:", a);
   1650                SERIAL_ECHOPAIR(" (", position[X_AXIS]);
   1651                SERIAL_ECHOPAIR("->", target[X_AXIS]);
   1652                SERIAL_ECHOPAIR(") Y:", b);
   1653              #endif
   1654              SERIAL_ECHOPAIR(" (", position[Y_AXIS]);
   1655              SERIAL_ECHOPAIR("->", target[Y_AXIS]);
   1656              #if ENABLED(DELTA)
   1657                SERIAL_ECHOPAIR(") C:", c);
   1658              #else
   1659                SERIAL_ECHOPAIR(") Z:", c);
   1660              #endif
   1661              SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
   1662              SERIAL_ECHOPAIR("->", target[Z_AXIS]);
   1663              SERIAL_ECHOPAIR(") E:", e);
   1664              SERIAL_ECHOPAIR(" (", position[E_AXIS]);
   1665              SERIAL_ECHOPAIR("->", target[E_AXIS]);
   1666              SERIAL_ECHOLNPGM(")");
   1667            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
   1668          
   1669            // Always split the first move into two (if not homing or probing)
   1670          
   1671            if (!blocks_queued()) {
   \   00000116   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD134             BNE.N    ??buffer_segment_6
   1672          
   1673              #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
   1674              const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
   \   0000011E   0xF8D9 0x0040      LDR      R0,[R9, #+64]
   \   00000122   0x9902             LDR      R1,[SP, #+8]
   \   00000124   0x1808             ADDS     R0,R1,R0
   \   00000126   0x1040             ASRS     R0,R0,#+1
   \   00000128   0x9006             STR      R0,[SP, #+24]
   \   0000012A   0xA806             ADD      R0,SP,#+24
   \   0000012C   0xF8D9 0x1044      LDR      R1,[R9, #+68]
   \   00000130   0xF8DA 0x2004      LDR      R2,[R10, #+4]
   \   00000134   0x1851             ADDS     R1,R2,R1
   \   00000136   0x1049             ASRS     R1,R1,#+1
   \   00000138   0x6041             STR      R1,[R0, #+4]
   \   0000013A   0xF8D9 0x1048      LDR      R1,[R9, #+72]
   \   0000013E   0xF8DA 0x2008      LDR      R2,[R10, #+8]
   \   00000142   0x1851             ADDS     R1,R2,R1
   \   00000144   0x1049             ASRS     R1,R1,#+1
   \   00000146   0x6081             STR      R1,[R0, #+8]
   \   00000148   0xF8D9 0x104C      LDR      R1,[R9, #+76]
   \   0000014C   0x1869             ADDS     R1,R5,R1
   \   0000014E   0x1049             ASRS     R1,R1,#+1
   \   00000150   0x60C1             STR      R1,[R0, #+12]
   1675              DISABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000152   0x....             LDR.N    R5,??DataTable21_10
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1676          
   1677              #if ENABLED(LIN_ADVANCE)
   1678                lin_dist_xy *= 0.5;
   1679                lin_dist_e *= 0.5;
   1680              #endif
   1681          
   1682              _buffer_steps(between, fr_mm_s, extruder);
   \   0000015A   0x4622             MOV      R2,R4
   \   0000015C   0x6831             LDR      R1,[R6, #+0]
   \   0000015E   0xA806             ADD      R0,SP,#+24
   \   00000160   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   1683          
   1684              #if ENABLED(LIN_ADVANCE)
   1685                position_float[X_AXIS] = (position_float[X_AXIS] + a) * 0.5;
   1686                position_float[Y_AXIS] = (position_float[Y_AXIS] + b) * 0.5;
   1687                //position_float[Z_AXIS] = (position_float[Z_AXIS] + c) * 0.5;
   1688                position_float[E_AXIS] = (position_float[E_AXIS] + e) * 0.5;
   1689              #endif
   1690          
   1691              const uint8_t next = block_buffer_head;
   \   00000164   0xF899 0x7000      LDRB     R7,[R9, #+0]
   1692              _buffer_steps(target, fr_mm_s, extruder);
   \   00000168   0x4622             MOV      R2,R4
   \   0000016A   0x6831             LDR      R1,[R6, #+0]
   \   0000016C   0xA802             ADD      R0,SP,#+8
   \   0000016E   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   1693              SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
   \   00000172   0x2054             MOVS     R0,#+84
   \   00000174   0x4378             MULS     R0,R0,R7
   \   00000176   0x....             LDR.N    R1,??DataTable21_11
   \   00000178   0x5C42             LDRB     R2,[R0, R1]
   \   0000017A   0xF042 0x0210      ORR      R2,R2,#0x10
   \   0000017E   0x5442             STRB     R2,[R0, R1]
   1694              ENABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000180   0x4628             MOV      R0,R5
   \   00000182   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   00000186   0xE004             B.N      ??buffer_segment_7
   1695            }
   1696            else
   1697          
   1698              _buffer_steps(target, fr_mm_s, extruder);
   \                     ??buffer_segment_6: (+1)
   \   00000188   0x4622             MOV      R2,R4
   \   0000018A   0x6831             LDR      R1,[R6, #+0]
   \   0000018C   0xA802             ADD      R0,SP,#+8
   \   0000018E   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   1699          
   1700            stepper.wake_up();
   \                     ??buffer_segment_7: (+1)
   \   00000192   0x.... 0x....      BL       _ZN7Stepper7wake_upEv
   1701          
   1702            #if ENABLED(LIN_ADVANCE)
   1703              position_float[X_AXIS] = a;
   1704              position_float[Y_AXIS] = b;
   1705              //position_float[Z_AXIS] = c;
   1706              position_float[E_AXIS] = e;
   1707            #endif
   1708          } // buffer_segment()
   \                     ??buffer_segment_4: (+1)
   \   00000196   0xB00B             ADD      SP,SP,#+44
   \   00000198   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1709          
   1710          /**
   1711           * Directly set the planner XYZ position (and stepper positions)
   1712           * converting mm (or angles for SCARA) into steps.
   1713           *
   1714           * On CORE machines stepper ABC will be translated from the given XYZ.
   1715           */
   1716          

   \                                 In section .text, align 2, keep-with-next
   1717          void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   \                     _ZN7Planner16_set_position_mmERKfS1_S1_S1_: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4692             MOV      R10,R2
   \   00000008   0x4698             MOV      R8,R3
   1718            #if ENABLED(DISTINCT_E_FACTORS)
   1719              #define _EINDEX (E_AXIS + active_extruder)
   1720              last_extruder = active_extruder;
   \   0000000A   0x....             LDR.N    R4,??DataTable21_6
   \   0000000C   0x.... 0x....      LDR.W    R9,??DataTable21_12
   \   00000010   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   00000014   0x70A1             STRB     R1,[R4, #+2]
   1721            #else
   1722              #define _EINDEX E_AXIS
   1723            #endif
   1724            const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       __aeabi_fmul
   \   0000001E   0x.... 0x....      BL       lroundf
   \   00000022   0x4607             MOV      R7,R0
   \   00000024   0x6427             STR      R7,[R4, #+64]
   1725                          nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x.... 0x....      BL       __aeabi_fmul
   \   0000002E   0x.... 0x....      BL       lroundf
   \   00000032   0x4606             MOV      R6,R0
   \   00000034   0x6466             STR      R6,[R4, #+68]
   1726                          nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
   \   00000036   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x.... 0x....      BL       __aeabi_fmul
   \   00000040   0x.... 0x....      BL       lroundf
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x64A5             STR      R5,[R4, #+72]
   1727                          ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   \   00000048   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   0000004C   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000050   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000054   0x6900             LDR      R0,[R0, #+16]
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x.... 0x....      BL       lroundf
   \   0000005E   0x64E0             STR      R0,[R4, #+76]
   1728            #if ENABLED(LIN_ADVANCE)
   1729              position_float[X_AXIS] = a;
   1730              position_float[Y_AXIS] = b;
   1731              //position_float[Z_AXIS] = c;
   1732              position_float[E_AXIS] = e;
   1733            #endif
   1734            stepper.set_position(na, nb, nc, ne);
   \   00000060   0x9703             STR      R7,[SP, #+12]
   \   00000062   0x9602             STR      R6,[SP, #+8]
   \   00000064   0x9501             STR      R5,[SP, #+4]
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xAB00             ADD      R3,SP,#+0
   \   0000006A   0xAA01             ADD      R2,SP,#+4
   \   0000006C   0xA902             ADD      R1,SP,#+8
   \   0000006E   0xA803             ADD      R0,SP,#+12
   \   00000070   0x.... 0x....      BL       _ZN7Stepper12set_positionERKlS1_S1_S1_
   1735            previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x67A0             STR      R0,[R4, #+120]
   1736            ZERO(previous_speed);
   \   00000078   0x2210             MOVS     R2,#+16
   \   0000007A   0x4601             MOV      R1,R0
   \   0000007C   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000080   0x.... 0x....      BL       memset
   1737          }
   \   00000084   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   1738          

   \                                 In section .text, align 2, keep-with-next
   1739          void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   \                     _ZN7Planner25set_position_mm_kinematicERA4_Kf: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   1740          	/*
   1741            #if PLANNER_LEVELING
   1742              float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
   1743              apply_leveling(raw);
   1744            #else
   1745              const float (&raw)[XYZE] = cart;
   1746            #endif
   1747          */
   1748            float raw[NUM_AXIS];
   1749            if(BED_LEVELING_METHOD&PLANNER_LEVELING)	{
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x....             LDR.N    R5,??DataTable21_8
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xF895 0x2040      LDRB     R2,[R5, #+64]
   \   00000010   0x232E             MOVS     R3,#+46
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x6048             STR      R0,[R1, #+4]
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x6088             STR      R0,[R1, #+8]
   \   0000001E   0xD005             BEQ.N    ??set_position_mm_kinematic_0
   1750            	raw[0] = cart[X_AXIS];
   1751            	raw[1] = cart[Y_AXIS];
   1752            	raw[2] = cart[Z_AXIS];
   1753          	apply_leveling(raw[0],raw[1],raw[2]);
   \   00000020   0xAA02             ADD      R2,SP,#+8
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \   0000002A   0xE001             B.N      ??set_position_mm_kinematic_1
   1754            	}
   1755            else
   1756            	{
   1757          	  raw[0] = cart[X_AXIS];
   1758          	  raw[1] = cart[Y_AXIS];
   1759          	  raw[2] = cart[Z_AXIS];
   1760          	  raw[3] = cart[3];
   \                     ??set_position_mm_kinematic_0: (+1)
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
   \                     ??set_position_mm_kinematic_1: (+1)
   \   00000030   0xF105 0x0040      ADD      R0,R5,#+64
   \   00000034   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \   00000038   0xF240 0x3102      MOVW     R1,#+770
   \   0000003C   0x4208             TST      R0,R1
   \   0000003E   0xD011             BEQ.N    ??set_position_mm_kinematic_2
   1761            	}
   1762            /*
   1763            #if IS_KINEMATIC
   1764              inverse_kinematics(raw);
   1765              _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   1766            #else
   1767              _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   1768            #endif
   1769            */
   1770            if(MACHINETPYE & IS_KINEMATIC)
   1771            	{
   1772            	
   1773          	if(MACHINETPYE == MORGAN_SCARA)
   \   00000040   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000044   0xA800             ADD      R0,SP,#+0
   \   00000046   0xD102             BNE.N    ??set_position_mm_kinematic_3
   1774          	  inverse_kinematics_MORGAN_SCARA(raw);
   \   00000048   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   0000004C   0xE001             B.N      ??set_position_mm_kinematic_4
   1775          	else
   1776          	  inverse_kinematics(raw);
   \                     ??set_position_mm_kinematic_3: (+1)
   \   0000004E   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   1777          	  
   1778          	  _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   \                     ??set_position_mm_kinematic_4: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable21_13
   \   00000054   0xF104 0x030C      ADD      R3,R4,#+12
   \   00000058   0xF100 0x0208      ADD      R2,R0,#+8
   \   0000005C   0x1D01             ADDS     R1,R0,#+4
   \   0000005E   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \   00000062   0xE006             B.N      ??set_position_mm_kinematic_5
   1779            	}
   1780            else
   1781            	{
   1782          	  _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   \                     ??set_position_mm_kinematic_2: (+1)
   \   00000064   0xF104 0x030C      ADD      R3,R4,#+12
   \   00000068   0xAA02             ADD      R2,SP,#+8
   \   0000006A   0xA901             ADD      R1,SP,#+4
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   1783            	}  
   1784          }
   \                     ??set_position_mm_kinematic_5: (+1)
   \   00000072   0xB005             ADD      SP,SP,#+20
   \   00000074   0xBD30             POP      {R4,R5,PC}       ;; return
   1785          
   1786          /**
   1787           * Sync from the stepper positions. (e.g., after an interrupted move)
   1788           */

   \                                 In section .text, align 2, keep-with-next
   1789          void Planner::sync_from_steppers() {
   \                     _ZN7Planner18sync_from_steppersEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1790            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE008             B.N      ??sync_from_steppers_0
   1791              position[i] = stepper.position((AxisEnum)i);
   \                     ??sync_from_steppers_1: (+1)
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   0000000E   0x....             LDR.N    R1,??DataTable21_6
   \   00000010   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   00000014   0x6408             STR      R0,[R1, #+64]
   1792              #if ENABLED(LIN_ADVANCE)
   1793                position_float[i] = position[i] * steps_to_mm[i
   1794                  #if ENABLED(DISTINCT_E_FACTORS)
   1795                    + (i == E_AXIS ? active_extruder : 0)
   1796                  #endif
   1797                ];
   1798              #endif
   1799            }
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??sync_from_steppers_0: (+1)
   \   00000018   0x2C04             CMP      R4,#+4
   \   0000001A   0xDBF4             BLT.N    ??sync_from_steppers_1
   1800          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1801          
   1802          /**
   1803           * Setters for planner position (also setting stepper position).
   1804           */

   \                                 In section .text, align 2, keep-with-next
   1805          void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   \                     _ZN7Planner15set_position_mmE8AxisEnumRKf: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
   1806            #if ENABLED(DISTINCT_E_FACTORS)
   1807              const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
   \   00000006   0x....             LDR.N    R0,??DataTable21_12
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   0000000E   0x2903             CMP      R1,#+3
   \   00000010   0xD101             BNE.N    ??set_position_mm_0
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0xE000             B.N      ??set_position_mm_1
   \                     ??set_position_mm_0: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \                     ??set_position_mm_1: (+1)
   \   00000018   0xF99D 0x2008      LDRSB    R2,[SP, #+8]
   \   0000001C   0x188A             ADDS     R2,R1,R2
   1808              last_extruder = active_extruder;
   \   0000001E   0x....             LDR.N    R5,??DataTable21_6
   \   00000020   0x70A8             STRB     R0,[R5, #+2]
   1809            #else
   1810              const uint8_t axis_index = axis;
   1811            #endif
   1812            position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x.... 0x....      BL       __aeabi_fmul
   \   00000030   0x.... 0x....      BL       lroundf
   \   00000034   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   00000038   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \   0000003C   0x6408             STR      R0,[R1, #+64]
   1813            #if ENABLED(LIN_ADVANCE)
   1814              position_float[axis] = v;
   1815            #endif
   1816            stepper.set_position(axis, v);
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       __aeabi_f2iz
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0xA802             ADD      R0,SP,#+8
   \   0000004A   0x.... 0x....      BL       _ZN7Stepper12set_positionERK8AxisEnumRKl
   1817            previous_speed[axis] = 0.0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   00000054   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \   00000058   0x6688             STR      R0,[R1, #+104]
   1818          }
   \   0000005A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1819          
   1820          // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2

   \                                 In section .text, align 2, keep-with-next
   1821          void Planner::reset_acceleration_rates() {
   \                     _ZN7Planner24reset_acceleration_ratesEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1822            #if ENABLED(DISTINCT_E_FACTORS)
   1823              #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   1824            #else
   1825              #define HIGHEST_CONDITION true
   1826            #endif
   1827            uint32_t highest_rate = 1;
   \   00000002   0x2401             MOVS     R4,#+1
   1828            LOOP_XYZE_N(i) {
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE018             B.N      ??reset_acceleration_rates_0
   1829              max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer

      FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
                                                   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",294  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",549  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \                     ??reset_acceleration_rates_1: (+1)
   \   00000008   0xEB00 0x0685      ADD      R6,R0,R5, LSL #+2
   \   0000000C   0x....             LDR.N    R0,??DataTable21_14
   \   0000000E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x6871             LDR      R1,[R6, #+4]
   \   00000018   0x.... 0x....      BL       __aeabi_fmul
   \   0000001C   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000020   0x62F0             STR      R0,[R6, #+44]
   1830              if (HIGHEST_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   \   00000022   0x2D03             CMP      R5,#+3
   \   00000024   0xDB04             BLT.N    ??reset_acceleration_rates_2
   \   00000026   0x....             LDR.N    R1,??DataTable21_12
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x1CC9             ADDS     R1,R1,#+3
   \   0000002C   0x428D             CMP      R5,R1
   \   0000002E   0xD102             BNE.N    ??reset_acceleration_rates_3
   \                     ??reset_acceleration_rates_2: (+1)
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD200             BCS.N    ??reset_acceleration_rates_3
   \   00000034   0x4604             MOV      R4,R0
   1831            }
   \                     ??reset_acceleration_rates_3: (+1)
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \   00000038   0xB2ED             UXTB     R5,R5
   \                     ??reset_acceleration_rates_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable21_6
   \   0000003C   0x2D05             CMP      R5,#+5
   \   0000003E   0xDBE3             BLT.N    ??reset_acceleration_rates_1
   1832            cutoff_long = 4294967295UL / highest_rate;
   \   00000040   0xF04F 0x31FF      MOV      R1,#-1
   \   00000044   0xFBB1 0xF1F4      UDIV     R1,R1,R4
   \   00000048   0x6641             STR      R1,[R0, #+100]
   1833          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   1834          
   1835          // Recalculate position, steps_to_mm if axis_steps_per_mm changes!

   \                                 In section .text, align 2, keep-with-next
   1836          void Planner::refresh_positioning() {
   \                     _ZN7Planner19refresh_positioningEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1837            LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE009             B.N      ??refresh_positioning_0
   \                     ??refresh_positioning_1: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable21_6
   \   00000008   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   0000000C   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000010   0x6869             LDR      R1,[R5, #+4]
   \   00000012   0x.... 0x....      BL       __aeabi_fdiv
   \   00000016   0x61A8             STR      R0,[R5, #+24]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??refresh_positioning_0: (+1)
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xDBF3             BLT.N    ??refresh_positioning_1
   1838            set_position_mm_kinematic(current_position);
   \   0000001E   0x....             LDR.N    R0,??DataTable21_15
   \   00000020   0x.... 0x....      BL       _ZN7Planner25set_position_mm_kinematicERA4_Kf
   1839            reset_acceleration_rates();
   \   00000024   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000028   0x....             B.N      _ZN7Planner24reset_acceleration_ratesEv
   1840          }
   1841          
   1842          #if ENABLED(AUTOTEMP)
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844            void Planner::autotemp_M104_M109() {
   \                     _ZN7Planner18autotemp_M104_M109Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1845              autotemp_enabled = parser.seen('F');
   \   00000002   0x2046             MOVS     R0,#+70
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x....             LDR.N    R4,??DataTable21_6
   \   0000000A   0x70E0             STRB     R0,[R4, #+3]
   1846              if (autotemp_enabled) autotemp_factor = parser.value_celsius_diff();
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ.N    ??autotemp_M104_M109_0
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser18value_celsius_diffEv
   \   00000014   0x6620             STR      R0,[R4, #+96]
   1847              if (parser.seen('S')) autotemp_min = parser.value_celsius();
   \                     ??autotemp_M104_M109_0: (+1)
   \   00000016   0x2053             MOVS     R0,#+83
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD002             BEQ.N    ??autotemp_M104_M109_1
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000024   0x65E0             STR      R0,[R4, #+92]
   1848              if (parser.seen('B')) autotemp_max = parser.value_celsius();
   \                     ??autotemp_M104_M109_1: (+1)
   \   00000026   0x2042             MOVS     R0,#+66
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??autotemp_M104_M109_2
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000034   0x65A0             STR      R0,[R4, #+88]
   1849            }
   \                     ??autotemp_M104_M109_2: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " cold extrusion preve...">`:
   \   00000000   0x20 0x63          DC8 " cold extrusion prevented\012"
   \              0x6F 0x6C    
   \              0x64 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " too long extrusion p...">`:
   \   00000000   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Planner::subobject Planner()
   \                     _ZN7PlannerC2Ev: (+1)
   \   00000000   0x....             B.N      _ZN7PlannerC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     _ZN7Planner23volumetric_area_nominalE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x3FF80000         DC32     0x3ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x47AE1480         DC32     0x47ae1480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x3F947AE1         DC32     0x3f947ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0xF5C28F5C         DC32     0xf5c28f5c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x3FEF5C28         DC32     0x3fef5c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x........         DC32     _ZN7Planner15flow_percentageE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     fanSpeeds

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     mksCfg+0x101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     _ZN7Planner23g_uc_extruder_last_moveE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0xA0B5ED8D         DC32     0xa0b5ed8d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x4020C6F7         DC32     0x4020c6f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x358637BE         DC32     0x358637be

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x3F7D70A4         DC32     0x3f7d70a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x3D4CCCCD         DC32     0x3d4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x........         DC32     marlin_debug_flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x........         DC32     active_extruder

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x........         DC32     delta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x........         DC32     _ZN7Planner26max_acceleration_mm_per_s2E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x........         DC32     current_position
   1850          
   1851          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CORESIGN(long)
       0   GCodeParser::seen(char)
       0   GCodeParser::value_celsius()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_celsius_diff()
         0   -> GCodeParser::value_float()
      16   GCodeParser::value_float()
         0   -> __aeabi_d2f
        16   -> __aeabi_d2f
        16   -> strtod
       8   Planner::Planner()
         8   -> Planner::init()
     112   Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
       112   -> CORESIGN(long)
       112   -> HAL_GPIO_WritePin
       112   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
       112   -> Planner::max_allowable_speed(float const &, float const &, float const &)
       112   -> Planner::movesplanned()
       112   -> Planner::next_block_index(int8_t)
       112   -> Planner::recalculate()
       112   -> Temperature::tooColdToExtrude(uint8_t)
       112   -> __aeabi_cfcmple
       112   -> __aeabi_cfrcmple
       112   -> __aeabi_d2f
       112   -> __aeabi_d2iz
       112   -> __aeabi_dadd
       112   -> __aeabi_ddiv
       112   -> __aeabi_dmul
       112   -> __aeabi_f2d
       112   -> __aeabi_f2iz
       112   -> __aeabi_f2uiz
       112   -> __aeabi_fadd
       112   -> __aeabi_fdiv
       112   -> __aeabi_fmul
       112   -> __aeabi_fsub
       112   -> __aeabi_i2f
       112   -> __aeabi_ui2d
       112   -> __aeabi_ui2f
       112   -> ceilf
       112   -> idle()
       112   -> labs
       112   -> lround
       112   -> memcpy
       112   -> serialprintPGM(char const *)
       112   -> sqrtf
      48   Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        48   -> Stepper::set_position(long const &, long const &, long const &, long const &)
        48   -> __aeabi_fmul
        48   -> lroundf
        48   -> memset
      72   Planner::apply_leveling(float &, float &, float &)
        56   -> __aeabi_fadd
        56   -> __aeabi_fmul
        72   -> __aeabi_memcpy4
        56   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
        56   -> bilinear_z_offset(float const *)
        56   -> mesh_bed_leveling::get_z(float const &, float const &, float const &)
        56   -> unified_bed_leveling::get_z_correction(float const &, float const &)
       8   Planner::autotemp_M104_M109()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_celsius()
         8   -> GCodeParser::value_celsius_diff()
       0   Planner::blocks_queued()
      80   Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
        80   -> HAL_TIM_Base_Start_IT
        80   -> HAL_TIM_Base_Stop_IT
        80   -> Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
        80   -> Planner::blocks_queued()
        80   -> Stepper::wake_up()
        80   -> __aeabi_cfcmpeq
        80   -> __aeabi_cfcmple
        80   -> __aeabi_fmul
        80   -> __aeabi_i2f
        80   -> lroundf
      64   Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        64   -> Planner::estimate_acceleration_distance(float const &, float const &, float const &)
        64   -> Planner::intersection_distance(float const &, float const &, float const &, float const &)
        64   -> __aeabi_f2iz
        64   -> __aeabi_f2uiz
        64   -> __aeabi_fmul
        64   -> __aeabi_i2f
        64   -> __aeabi_ui2f
        64   -> ceilf
        64   -> floorf
      16   Planner::calculate_volumetric_multipliers()
        16   -> Planner::refresh_e_factor(uint8_t)
        16   -> calculate_volumetric_multiplier(float const &)
       8   Planner::check_axes_activity()
         8   -> Planner::blocks_queued()
         0   -> Planner::getHighESpeed()
         8   -> Planner::next_block_index(int8_t)
      32   Planner::estimate_acceleration_distance(float const &, float const &, float const &)
        32   -> __aeabi_cfcmpeq
         0   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
      24   Planner::forward_pass()
         0   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::next_block_index(int8_t)
      24   Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::max_allowable_speed(float const &, float const &, float const &)
        24   -> __aeabi_cfcmpeq
        24   -> __aeabi_cfcmple
      32   Planner::getHighESpeed()
        32   -> Planner::next_block_index(int8_t)
        32   -> Temperature::degTargetHotend(uint8_t)
         0   -> Temperature::setTargetHotend(float, uint8_t)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
       8   Planner::init()
         0   -> matrix_3x3::set_to_identity()
         8   -> memset
      32   Planner::intersection_distance(float const &, float const &, float const &, float const &)
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_fadd
         0   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
      24   Planner::max_allowable_speed(float const &, float const &, float const &)
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
         0   -> sqrtf
       0   Planner::movesplanned()
       0   Planner::next_block_index(int8_t)
       0   Planner::prev_block_index(int8_t)
       8   Planner::recalculate()
         8   -> Planner::forward_pass()
         0   -> Planner::recalculate_trapezoids()
         8   -> Planner::reverse_pass()
      32   Planner::recalculate_trapezoids()
        32   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        32   -> Planner::next_block_index(int8_t)
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
      24   Planner::refresh_e_factor(uint8_t)
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_i2d
      16   Planner::refresh_positioning()
         0   -> Planner::reset_acceleration_rates()
        16   -> Planner::set_position_mm_kinematic(float const (&)[4])
        16   -> __aeabi_fdiv
      16   Planner::reset_acceleration_rates()
        16   -> __aeabi_f2uiz
        16   -> __aeabi_fmul
        16   -> __aeabi_ui2f
      32   Planner::reverse_pass()
        32   -> Planner::movesplanned()
        32   -> Planner::prev_block_index(int8_t)
        32   -> Planner::reverse_pass_kernel(block_t *, block_t const *)
      24   Planner::reverse_pass_kernel(block_t *, block_t const *)
        24   -> Planner::max_allowable_speed(float const &, float const &, float const &)
        24   -> __aeabi_cfcmpeq
        24   -> __aeabi_cfcmple
        24   -> __aeabi_cfrcmple
      24   Planner::set_position_mm(AxisEnum, float const &)
        24   -> Stepper::set_position(AxisEnum const &, long const &)
        24   -> __aeabi_f2iz
        24   -> __aeabi_fmul
        24   -> lroundf
      32   Planner::set_position_mm_kinematic(float const (&)[4])
        32   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        32   -> Planner::apply_leveling(float &, float &, float &)
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
       0   Planner::subobject Planner()
         0   -> Planner::Planner()
       8   Planner::sync_from_steppers()
         8   -> Stepper::position(AxisEnum)
     104   Planner::unapply_leveling(float *)
        88   -> __aeabi_fmul
        88   -> __aeabi_fsub
       100   -> __aeabi_memcpy4
       104   -> __aeabi_memcpy4
        88   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
        88   -> bilinear_z_offset(float const *)
        88   -> matrix_3x3::transpose(matrix_3x3)
        88   -> mesh_bed_leveling::get_z(float const &, float const &, float const &)
        88   -> unified_bed_leveling::get_z_correction(float const &, float const &)
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
      16   Temperature::tooColdToExtrude(uint8_t)
        16   -> Temperature::degHotend(uint8_t)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_i2f
      32   __sti__routine()
        32   -> Planner::Planner()
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
      24   calculate_volumetric_multiplier(float const &)
        24   -> __aeabi_cfcmpeq
         0   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
      24   mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
         0   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
      40   mesh_bed_leveling::cell_index_x(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   mesh_bed_leveling::cell_index_y(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      48   mesh_bed_leveling::get_z(float const &, float const &, float const &)
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
        48   -> mesh_bed_leveling::cell_index_x(float const &)
        48   -> mesh_bed_leveling::cell_index_y(float const &)
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
      24   unified_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
         0   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
      40   unified_bed_leveling::get_cell_index_x(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   unified_bed_leveling::get_cell_index_y(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      72   unified_bed_leveling::get_z_correction(float const &, float const &)
        72   -> __iar_FDtest
        72   -> unified_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
        72   -> unified_bed_leveling::get_cell_index_x(float const &)
        72   -> unified_bed_leveling::get_cell_index_y(float const &)
        72   -> unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        72   -> unified_bed_leveling::mesh_index_to_ypos(uint8_t)
      40   unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   unified_bed_leveling::mesh_index_to_ypos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant " cold extrusion preve...">
      32  ?<Constant " too long extrusion p...">
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable18
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      18  CORESIGN(long)
      76  GCodeParser::seen(char)
       4  GCodeParser::value_celsius()
       4  GCodeParser::value_celsius_diff()
      80  GCodeParser::value_float()
      12  Planner::Planner()
    3810  Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
     136  Planner::_set_position_mm(float const &, float const &, float const &, float const &)
     202  Planner::apply_leveling(float &, float &, float &)
      56  Planner::autotemp_M104_M109()
      36  Planner::bed_level_matrix
    1344  Planner::block_buffer
     128  Planner::block_buffer_head
          Planner::block_buffer_tail
          Planner::last_extruder
          Planner::autotemp_enabled
          Planner::axis_steps_per_mm
          Planner::steps_to_mm
          Planner::max_acceleration_steps_per_s2
          Planner::position
          Planner::e_factor
          Planner::autotemp_max
          Planner::autotemp_min
          Planner::autotemp_factor
          Planner::cutoff_long
          Planner::previous_speed
          Planner::previous_nominal_speed
          oldt
      24  Planner::blocks_queued()
     412  Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
     268  Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
      36  Planner::calculate_volumetric_multipliers()
      66  Planner::check_axes_activity()
     148  Planner::estimate_acceleration_distance(float const &, float const &, float const &)
      20  Planner::flow_percentage
          Planner::volumetric_multiplier
          Planner::filament_size
      62  Planner::forward_pass()
     108  Planner::forward_pass_kernel(block_t const *, block_t *)
      68  Planner::g_uc_extruder_last_move
          Planner::max_feedrate_mm_s
          Planner::min_segment_time_us
          Planner::min_feedrate_mm_s
          Planner::acceleration
          Planner::retract_acceleration
          Planner::travel_acceleration
          Planner::max_jerk
          Planner::min_travel_feedrate_mm_s
          previous_safe_speed
     252  Planner::getHighESpeed()
      52  Planner::init()
     174  Planner::intersection_distance(float const &, float const &, float const &, float const &)
       4  Planner::inverse_z_fade_height
       4  Planner::last_fade_z
       1  Planner::leveling_active
      20  Planner::max_acceleration_mm_per_s2
      78  Planner::max_allowable_speed(float const &, float const &, float const &)
      20  Planner::movesplanned()
       8  Planner::next_block_index(int8_t)
       8  Planner::prev_block_index(int8_t)
      16  Planner::recalculate()
     178  Planner::recalculate_trapezoids()
      76  Planner::refresh_e_factor(uint8_t)
      42  Planner::refresh_positioning()
      76  Planner::reset_acceleration_rates()
      90  Planner::reverse_pass()
     108  Planner::reverse_pass_kernel(block_t *, block_t const *)
      92  Planner::set_position_mm(AxisEnum, float const &)
     118  Planner::set_position_mm_kinematic(float const (&)[4])
       2  Planner::subobject Planner()
      30  Planner::sync_from_steppers()
     196  Planner::unapply_leveling(float *)
       8  Planner::volumetric_area_nominal
          planner
       4  Planner::z_fade_height
      12  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetHotend(uint8_t)
      28  Temperature::setTargetHotend(float, uint8_t)
      60  Temperature::tooColdToExtrude(uint8_t)
      98  __sti__routine()
     152  calculate_volumetric_multiplier(float const &)
      64  mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
     360  mesh_bed_leveling::cell_index_x(float const &)
     356  mesh_bed_leveling::cell_index_y(float const &)
     152  mesh_bed_leveling::get_z(float const &, float const &, float const &)
      28  serialprintPGM(char const *)
      66  unified_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
     360  unified_bed_leveling::get_cell_index_x(float const &)
     356  unified_bed_leveling::get_cell_index_y(float const &)
     248  unified_bed_leveling::get_z_correction(float const &, float const &)
     316  unified_bed_leveling::mesh_index_to_xpos(uint8_t)
     312  unified_bed_leveling::mesh_index_to_ypos(uint8_t)
       5  -- Other

 
  1 489 bytes in section .bss
    148 bytes in section .data
      4 bytes in section .init_array
     61 bytes in section .rodata
 10 282 bytes in section .text
 
 6 700 bytes of CODE  memory (+ 3 586 bytes shared)
    60 bytes of CONST memory (+     1 byte  shared)
 1 637 bytes of DATA  memory

Errors: none
Warnings: 53
