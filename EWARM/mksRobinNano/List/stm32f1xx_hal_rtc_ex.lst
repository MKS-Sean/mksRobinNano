###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:05
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_hal_rtc_ex.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_hal_rtc_ex.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_rtc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   Extended RTC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Real Time Clock (RTC) Extension peripheral:
     10            *           + RTC Tamper functions 
     11            *           + Extension Control functions
     12            *           + Extension RTC features functions    
     13            *         
     14            ******************************************************************************
     15            * @attention
     16            *
     17            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     18            *
     19            * Redistribution and use in source and binary forms, with or without modification,
     20            * are permitted provided that the following conditions are met:
     21            *   1. Redistributions of source code must retain the above copyright notice,
     22            *      this list of conditions and the following disclaimer.
     23            *   2. Redistributions in binary form must reproduce the above copyright notice,
     24            *      this list of conditions and the following disclaimer in the documentation
     25            *      and/or other materials provided with the distribution.
     26            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     27            *      may be used to endorse or promote products derived from this software
     28            *      without specific prior written permission.
     29            *
     30            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     31            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     32            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     33            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     34            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     35            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     36            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     37            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     38            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     39            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     40            *
     41            ******************************************************************************  
     42            */ 
     43          
     44          /* Includes ------------------------------------------------------------------*/
     45          #include "stm32f1xx_hal.h"
     46          
     47          /** @addtogroup STM32F1xx_HAL_Driver
     48            * @{
     49            */
     50            
     51          #ifdef HAL_RTC_MODULE_ENABLED
     52          
     53          /** @defgroup RTCEx RTCEx
     54            * @brief RTC Extended HAL module driver
     55            * @{
     56            */
     57            
     58          /* Private typedef -----------------------------------------------------------*/
     59          /* Private define ------------------------------------------------------------*/
     60          /* Private macro -------------------------------------------------------------*/
     61          /** @defgroup RTCEx_Private_Macros RTCEx Private Macros
     62            * @{
     63            */
     64          /**
     65            * @}
     66            */
     67            
     68          /* Private variables ---------------------------------------------------------*/
     69          /* Private function prototypes -----------------------------------------------*/
     70          /* Private functions ---------------------------------------------------------*/
     71          
     72          /** @defgroup RTCEx_Exported_Functions RTCEx Exported Functions
     73            * @{
     74            */
     75            
     76          /** @defgroup RTCEx_Exported_Functions_Group1 RTC Tamper functions
     77            * @brief    RTC Tamper functions
     78            *
     79          @verbatim   
     80           ===============================================================================
     81                           ##### RTC Tamper functions #####
     82           ===============================================================================  
     83           
     84           [..] This section provides functions allowing to configure Tamper feature
     85          
     86          @endverbatim
     87            * @{
     88            */
     89          
     90          /**
     91            * @brief  Sets Tamper
     92            * @note   By calling this API we disable the tamper interrupt for all tampers. 
     93            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
     94            *                the configuration information for RTC.
     95            * @param  sTamper: Pointer to Tamper Structure.
     96            * @note   Tamper can be enabled only if ASOE and CCO bit are reset
     97            * @retval HAL status
     98            */

   \                                 In section .text, align 2, keep-with-next
     99          HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
    100          {
   \                     HAL_RTCEx_SetTamper: (+1)
   \   00000000   0xB410             PUSH     {R4}
    101            /* Check input parameters */
    102            if((hrtc == NULL) || (sTamper == NULL))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??HAL_RTCEx_SetTamper_0
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE.N    ??HAL_RTCEx_SetTamper_1
    103            {
    104               return HAL_ERROR;
   \                     ??HAL_RTCEx_SetTamper_0: (+1)
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE021             B.N      ??HAL_RTCEx_SetTamper_2
    105            }
    106            
    107            /* Check the parameters */
    108            assert_param(IS_RTC_TAMPER(sTamper->Tamper));
    109            assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
    110          
    111            /* Process Locked */
    112            __HAL_LOCK(hrtc);
   \                     ??HAL_RTCEx_SetTamper_1: (+1)
   \   0000000E   0xF990 0x2010      LDRSB    R2,[R0, #+16]
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD101             BNE.N    ??HAL_RTCEx_SetTamper_3
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE01B             B.N      ??HAL_RTCEx_SetTamper_2
   \                     ??HAL_RTCEx_SetTamper_3: (+1)
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x7402             STRB     R2,[R0, #+16]
    113          
    114            hrtc->State = HAL_RTC_STATE_BUSY;
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x7442             STRB     R2,[R0, #+17]
    115            
    116            if (HAL_IS_BIT_SET(BKP->RTCCR,(BKP_RTCCR_CCO | BKP_RTCCR_ASOE)))
   \   00000022   0x....             LDR.N    R2,??DataTable7  ;; 0x40006c2c
   \   00000024   0x6813             LDR      R3,[R2, #+0]
   \   00000026   0xF413 0x7FC0      TST      R3,#0x180
   \   0000002A   0xD005             BEQ.N    ??HAL_RTCEx_SetTamper_4
    117            {
    118              hrtc->State = HAL_RTC_STATE_ERROR;
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x7441             STRB     R1,[R0, #+17]
    119              
    120              /* Process Unlocked */
    121              __HAL_UNLOCK(hrtc);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x7401             STRB     R1,[R0, #+16]
    122              
    123              return HAL_ERROR;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE00C             B.N      ??HAL_RTCEx_SetTamper_2
    124            }
    125          
    126            MODIFY_REG(BKP->CR, (BKP_CR_TPE | BKP_CR_TPAL), (sTamper->Tamper | (sTamper->Trigger)));
   \                     ??HAL_RTCEx_SetTamper_4: (+1)
   \   00000038   0x6853             LDR      R3,[R2, #+4]
   \   0000003A   0x089B             LSRS     R3,R3,#+2
   \   0000003C   0x684C             LDR      R4,[R1, #+4]
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x4321             ORRS     R1,R1,R4
   \   00000042   0xEA51 0x0183      ORRS     R1,R1,R3, LSL #+2
   \   00000046   0x6051             STR      R1,[R2, #+4]
    127          
    128            hrtc->State = HAL_RTC_STATE_READY; 
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x7441             STRB     R1,[R0, #+17]
    129          
    130            /* Process Unlocked */
    131            __HAL_UNLOCK(hrtc);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x7401             STRB     R1,[R0, #+16]
    132          
    133            return HAL_OK;
   \   00000050   0x4608             MOV      R0,R1
   \                     ??HAL_RTCEx_SetTamper_2: (+1)
   \   00000052   0xBC10             POP      {R4}
   \   00000054   0x4770             BX       LR               ;; return
    134          }
    135          
    136          /**
    137            * @brief  Sets Tamper with interrupt.
    138            * @note   By calling this API we force the tamper interrupt for all tampers.
    139            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    140            *                the configuration information for RTC.
    141            * @param  sTamper: Pointer to RTC Tamper.
    142            * @note   Tamper can be enabled only if ASOE and CCO bit are reset
    143            * @retval HAL status
    144            */

   \                                 In section .text, align 2, keep-with-next
    145          HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
    146          {
   \                     HAL_RTCEx_SetTamper_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
    147            /* Check input parameters */
    148            if((hrtc == NULL) || (sTamper == NULL))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??HAL_RTCEx_SetTamper_IT_0
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE.N    ??HAL_RTCEx_SetTamper_IT_1
    149            {
    150               return HAL_ERROR;
   \                     ??HAL_RTCEx_SetTamper_IT_0: (+1)
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE025             B.N      ??HAL_RTCEx_SetTamper_IT_2
    151            }
    152            
    153            /* Check the parameters */
    154            assert_param(IS_RTC_TAMPER(sTamper->Tamper)); 
    155            assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
    156          
    157            /* Process Locked */
    158            __HAL_LOCK(hrtc);
   \                     ??HAL_RTCEx_SetTamper_IT_1: (+1)
   \   0000000E   0xF990 0x2010      LDRSB    R2,[R0, #+16]
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD101             BNE.N    ??HAL_RTCEx_SetTamper_IT_3
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE01F             B.N      ??HAL_RTCEx_SetTamper_IT_2
   \                     ??HAL_RTCEx_SetTamper_IT_3: (+1)
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x7402             STRB     R2,[R0, #+16]
    159          
    160            hrtc->State = HAL_RTC_STATE_BUSY;
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x7442             STRB     R2,[R0, #+17]
    161          
    162            if (HAL_IS_BIT_SET(BKP->RTCCR,(BKP_RTCCR_CCO | BKP_RTCCR_ASOE)))
   \   00000022   0x....             LDR.N    R2,??DataTable7  ;; 0x40006c2c
   \   00000024   0x6813             LDR      R3,[R2, #+0]
   \   00000026   0xF413 0x7FC0      TST      R3,#0x180
   \   0000002A   0xD005             BEQ.N    ??HAL_RTCEx_SetTamper_IT_4
    163            {
    164              hrtc->State = HAL_RTC_STATE_ERROR;
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x7441             STRB     R1,[R0, #+17]
    165              
    166              /* Process Unlocked */
    167              __HAL_UNLOCK(hrtc);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x7401             STRB     R1,[R0, #+16]
    168              
    169              return HAL_ERROR;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE010             B.N      ??HAL_RTCEx_SetTamper_IT_2
    170            }
    171          
    172            MODIFY_REG(BKP->CR, (BKP_CR_TPE | BKP_CR_TPAL), (sTamper->Tamper | (sTamper->Trigger)));
   \                     ??HAL_RTCEx_SetTamper_IT_4: (+1)
   \   00000038   0x6853             LDR      R3,[R2, #+4]
   \   0000003A   0x089B             LSRS     R3,R3,#+2
   \   0000003C   0x684C             LDR      R4,[R1, #+4]
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x4321             ORRS     R1,R1,R4
   \   00000042   0xEA51 0x0183      ORRS     R1,R1,R3, LSL #+2
   \   00000046   0x6051             STR      R1,[R2, #+4]
    173          
    174            /* Configure the Tamper Interrupt in the BKP->CSR */
    175            __HAL_RTC_TAMPER_ENABLE_IT(hrtc, RTC_IT_TAMP1);
   \   00000048   0x6891             LDR      R1,[R2, #+8]
   \   0000004A   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004E   0x6091             STR      R1,[R2, #+8]
    176          
    177            hrtc->State = HAL_RTC_STATE_READY;
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x7441             STRB     R1,[R0, #+17]
    178          
    179            /* Process Unlocked */
    180            __HAL_UNLOCK(hrtc);
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x7401             STRB     R1,[R0, #+16]
    181          
    182            return HAL_OK;
   \   00000058   0x4608             MOV      R0,R1
   \                     ??HAL_RTCEx_SetTamper_IT_2: (+1)
   \   0000005A   0xBC10             POP      {R4}
   \   0000005C   0x4770             BX       LR               ;; return
    183          }
    184          
    185          /**
    186            * @brief  Deactivates Tamper.
    187            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    188            *                the configuration information for RTC.
    189            * @param  Tamper: Selected tamper pin.
    190            *          This parameter can be a value of @ref RTCEx_Tamper_Pins_Definitions
    191            * @retval HAL status
    192            */

   \                                 In section .text, align 2, keep-with-next
    193          HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
    194          {
    195            /* Check input parameters */
    196            if(hrtc == NULL)
   \                     HAL_RTCEx_DeactivateTamper: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??HAL_RTCEx_DeactivateTamper_0
    197            {
    198               return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x4770             BX       LR
    199            }
    200            
    201            assert_param(IS_RTC_TAMPER(Tamper));
    202          
    203            /* Process Locked */
    204            __HAL_LOCK(hrtc);
   \                     ??HAL_RTCEx_DeactivateTamper_0: (+1)
   \   00000008   0xF990 0x1010      LDRSB    R1,[R0, #+16]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_RTCEx_DeactivateTamper_1
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x4770             BX       LR
   \                     ??HAL_RTCEx_DeactivateTamper_1: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7401             STRB     R1,[R0, #+16]
    205          
    206            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x7441             STRB     R1,[R0, #+17]
    207          
    208            /* Disable the selected Tamper pin */
    209            CLEAR_BIT(BKP->CR, BKP_CR_TPE);
   \   0000001C   0x....             LDR.N    R1,??DataTable7_1  ;; 0x40006c30
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0852             LSRS     R2,R2,#+1
   \   00000022   0x0052             LSLS     R2,R2,#+1
   \   00000024   0x600A             STR      R2,[R1, #+0]
    210            
    211            /* Disable the Tamper Interrupt in the BKP->CSR */
    212            /* Configure the Tamper Interrupt in the BKP->CSR */
    213            __HAL_RTC_TAMPER_DISABLE_IT(hrtc, RTC_IT_TAMP1);
   \   00000026   0x684A             LDR      R2,[R1, #+4]
   \   00000028   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002C   0x604A             STR      R2,[R1, #+4]
    214            
    215            /* Clear the Tamper interrupt pending bit */
    216            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   \   00000030   0xF042 0x0203      ORR      R2,R2,#0x3
   \   00000034   0x604A             STR      R2,[R1, #+4]
    217            SET_BIT(BKP->CSR, BKP_CSR_CTE);
   \   00000036   0x684A             LDR      R2,[R1, #+4]
   \   00000038   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000003C   0x604A             STR      R2,[R1, #+4]
    218            
    219            hrtc->State = HAL_RTC_STATE_READY;
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x7441             STRB     R1,[R0, #+17]
    220          
    221            /* Process Unlocked */
    222            __HAL_UNLOCK(hrtc);
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x7401             STRB     R1,[R0, #+16]
    223          
    224            return HAL_OK;
   \   00000046   0x4608             MOV      R0,R1
   \   00000048   0x4770             BX       LR               ;; return
    225          }
    226          
    227          /**
    228            * @brief  This function handles Tamper interrupt request.
    229            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    230            *                the configuration information for RTC.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void HAL_RTCEx_TamperIRQHandler(RTC_HandleTypeDef *hrtc)
    234          {  
   \                     HAL_RTCEx_TamperIRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    235            /* Get the status of the Interrupt */
    236            if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP1))
   \   00000004   0x....             LDR.N    R5,??DataTable7_2  ;; 0x40006c34
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x0740             LSLS     R0,R0,#+29
   \   0000000A   0xD509             BPL.N    ??HAL_RTCEx_TamperIRQHandler_0
    237            {
    238              /* Get the TAMPER Interrupt enable bit and pending bit */
    239              if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != (uint32_t)RESET)
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x05C0             LSLS     R0,R0,#+23
   \   00000010   0xD506             BPL.N    ??HAL_RTCEx_TamperIRQHandler_0
    240              {
    241                /* Tamper callback */ 
    242                HAL_RTCEx_Tamper1EventCallback(hrtc);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_RTCEx_Tamper1EventCallback
    243            
    244                /* Clear the Tamper interrupt pending bit */
    245                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0xF040 0x0003      ORR      R0,R0,#0x3
   \   0000001E   0x6028             STR      R0,[R5, #+0]
    246              }
    247            }
    248          
    249            /* Change RTC state */
    250            hrtc->State = HAL_RTC_STATE_READY;
   \                     ??HAL_RTCEx_TamperIRQHandler_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7460             STRB     R0,[R4, #+17]
    251          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    252          
    253          /**
    254            * @brief  Tamper 1 callback. 
    255            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    256            *                the configuration information for RTC.
    257            * @retval None
    258            */

   \                                 In section .text, align 2, keep-with-next
    259          __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
    260          {
    261            /* Prevent unused argument(s) compilation warning */
    262            UNUSED(hrtc);
    263            /* NOTE : This function Should not be modified, when the callback is needed,
    264                      the HAL_RTCEx_Tamper1EventCallback could be implemented in the user file
    265             */
    266          }
   \                     HAL_RTCEx_Tamper1EventCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    267          
    268          /**
    269            * @brief  This function handles Tamper1 Polling.
    270            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    271            *                the configuration information for RTC.
    272            * @param  Timeout: Timeout duration
    273            * @retval HAL status
    274            */

   \                                 In section .text, align 2, keep-with-next
    275          HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    276          {  
   \                     HAL_RTCEx_PollForTamper1Event: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    277            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
    278          
    279            /* Check input parameters */
    280            if(hrtc == NULL)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_RTCEx_PollForTamper1Event_0
    281            {
    282               return HAL_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBD70             POP      {R4-R6,PC}
    283            }
    284            
    285            /* Get the status of the Interrupt */
    286            while(__HAL_RTC_TAMPER_GET_FLAG(hrtc,RTC_FLAG_TAMP1F)== RESET)
   \                     ??HAL_RTCEx_PollForTamper1Event_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable7_2  ;; 0x40006c34
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x05C9             LSLS     R1,R1,#+23
   \   0000001A   0xD40C             BMI.N    ??HAL_RTCEx_PollForTamper1Event_1
    287            {
    288              if(Timeout != HAL_MAX_DELAY)
   \   0000001C   0xF115 0x0F01      CMN      R5,#+1
   \   00000020   0xD0F8             BEQ.N    ??HAL_RTCEx_PollForTamper1Event_0
    289              {
    290                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD004             BEQ.N    ??HAL_RTCEx_PollForTamper1Event_2
   \   00000026   0x.... 0x....      BL       HAL_GetTick
   \   0000002A   0x1B80             SUBS     R0,R0,R6
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD2F1             BCS.N    ??HAL_RTCEx_PollForTamper1Event_0
    291                {
    292                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTCEx_PollForTamper1Event_2: (+1)
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x7460             STRB     R0,[R4, #+17]
    293                  return HAL_TIMEOUT;
   \   00000034   0xBD70             POP      {R4-R6,PC}
    294                }
    295              }
    296            }
    297          
    298            /* Clear the Tamper Flag */
    299            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
   \                     ??HAL_RTCEx_PollForTamper1Event_1: (+1)
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xF041 0x0103      ORR      R1,R1,#0x3
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    300          
    301            /* Change RTC state */
    302            hrtc->State = HAL_RTC_STATE_READY;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x7460             STRB     R0,[R4, #+17]
    303          
    304            return HAL_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    305          }
    306          
    307          /**
    308            * @}
    309            */
    310            
    311          /** @defgroup RTCEx_Exported_Functions_Group2 RTC Second functions
    312            * @brief    RTC Second functions
    313            *
    314          @verbatim   
    315           ===============================================================================
    316                           ##### RTC Second functions #####
    317           ===============================================================================  
    318           
    319           [..] This section provides functions implementing second interupt handlers
    320          
    321          @endverbatim
    322            * @{
    323            */
    324          
    325          /**
    326            * @brief  Sets Interrupt for second
    327            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    328            *                the configuration information for RTC.
    329            * @retval HAL status
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          HAL_StatusTypeDef HAL_RTCEx_SetSecond_IT(RTC_HandleTypeDef *hrtc)
    332          {
    333            /* Check input parameters */
    334            if(hrtc == NULL)
   \                     HAL_RTCEx_SetSecond_IT: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??HAL_RTCEx_SetSecond_IT_0
    335            {
    336               return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x4770             BX       LR
    337            }
    338            
    339            /* Process Locked */
    340            __HAL_LOCK(hrtc);
   \                     ??HAL_RTCEx_SetSecond_IT_0: (+1)
   \   00000008   0xF990 0x1010      LDRSB    R1,[R0, #+16]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_RTCEx_SetSecond_IT_1
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x4770             BX       LR
   \                     ??HAL_RTCEx_SetSecond_IT_1: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7401             STRB     R1,[R0, #+16]
    341          
    342            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x7441             STRB     R1,[R0, #+17]
    343          
    344            /* Enable Second interuption */
    345            __HAL_RTC_SECOND_ENABLE_IT(hrtc, RTC_IT_SEC);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000024   0x600A             STR      R2,[R1, #+0]
    346            
    347            hrtc->State = HAL_RTC_STATE_READY;
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x7441             STRB     R1,[R0, #+17]
    348          
    349            /* Process Unlocked */
    350            __HAL_UNLOCK(hrtc);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7401             STRB     R1,[R0, #+16]
    351          
    352            return HAL_OK;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x4770             BX       LR               ;; return
    353          }
    354          
    355          /**
    356            * @brief  Deactivates Second.
    357            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    358            *                the configuration information for RTC.
    359            * @retval HAL status
    360            */

   \                                 In section .text, align 2, keep-with-next
    361          HAL_StatusTypeDef HAL_RTCEx_DeactivateSecond(RTC_HandleTypeDef *hrtc)
    362          {
    363            /* Check input parameters */
    364            if(hrtc == NULL)
   \                     HAL_RTCEx_DeactivateSecond: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??HAL_RTCEx_DeactivateSecond_0
    365            {
    366               return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x4770             BX       LR
    367            }
    368            
    369            /* Process Locked */
    370            __HAL_LOCK(hrtc);
   \                     ??HAL_RTCEx_DeactivateSecond_0: (+1)
   \   00000008   0xF990 0x1010      LDRSB    R1,[R0, #+16]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_RTCEx_DeactivateSecond_1
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x4770             BX       LR
   \                     ??HAL_RTCEx_DeactivateSecond_1: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7401             STRB     R1,[R0, #+16]
    371          
    372            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x7441             STRB     R1,[R0, #+17]
    373          
    374            /* Deactivate Second interuption*/ 
    375            __HAL_RTC_SECOND_DISABLE_IT(hrtc, RTC_IT_SEC);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0852             LSRS     R2,R2,#+1
   \   00000022   0x0052             LSLS     R2,R2,#+1
   \   00000024   0x600A             STR      R2,[R1, #+0]
    376            
    377            hrtc->State = HAL_RTC_STATE_READY;
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x7441             STRB     R1,[R0, #+17]
    378          
    379            /* Process Unlocked */
    380            __HAL_UNLOCK(hrtc);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7401             STRB     R1,[R0, #+16]
    381          
    382            return HAL_OK;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x4770             BX       LR               ;; return
    383          }
    384          
    385          /**
    386            * @brief  This function handles second interrupt request.
    387            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    388            *                the configuration information for RTC.
    389            * @retval None
    390            */

   \                                 In section .text, align 2, keep-with-next
    391          void HAL_RTCEx_RTCIRQHandler(RTC_HandleTypeDef* hrtc)
    392          {
   \                     HAL_RTCEx_RTCIRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    393            if(__HAL_RTC_SECOND_GET_IT_SOURCE(hrtc, RTC_IT_SEC))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD517             BPL.N    ??HAL_RTCEx_RTCIRQHandler_0
    394            {
    395              /* Get the status of the Interrupt */
    396              if(__HAL_RTC_SECOND_GET_FLAG(hrtc, RTC_FLAG_SEC))
   \   0000000C   0x6841             LDR      R1,[R0, #+4]
   \   0000000E   0x07C9             LSLS     R1,R1,#+31
   \   00000010   0xD514             BPL.N    ??HAL_RTCEx_RTCIRQHandler_0
    397              {
    398                /* Check if Overrun occurred */
    399                if (__HAL_RTC_SECOND_GET_FLAG(hrtc, RTC_FLAG_OW))
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xD508             BPL.N    ??HAL_RTCEx_RTCIRQHandler_1
    400                {
    401                  /* Second error callback */ 
    402                  HAL_RTCEx_RTCEventErrorCallback(hrtc);
   \   0000001A   0x.... 0x....      BL       HAL_RTCEx_RTCEventErrorCallback
    403                  
    404                  /* Clear flag Second */
    405                  __HAL_RTC_OVERFLOW_CLEAR_FLAG(hrtc, RTC_FLAG_OW);
   \   0000001E   0xF06F 0x0004      MVN      R0,#+4
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6048             STR      R0,[R1, #+4]
    406                  
    407                  /* Change RTC state */
    408                  hrtc->State = HAL_RTC_STATE_ERROR; 
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x7460             STRB     R0,[R4, #+17]
   \   0000002A   0xE003             B.N      ??HAL_RTCEx_RTCIRQHandler_2
    409                }
    410                else 
    411                {
    412                  /* Second callback */ 
    413                  HAL_RTCEx_RTCEventCallback(hrtc);
   \                     ??HAL_RTCEx_RTCIRQHandler_1: (+1)
   \   0000002C   0x.... 0x....      BL       HAL_RTCEx_RTCEventCallback
    414                  
    415                  /* Change RTC state */
    416                  hrtc->State = HAL_RTC_STATE_READY; 
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7460             STRB     R0,[R4, #+17]
    417                }
    418                
    419                /* Clear flag Second */
    420                __HAL_RTC_SECOND_CLEAR_FLAG(hrtc, RTC_FLAG_SEC);
   \                     ??HAL_RTCEx_RTCIRQHandler_2: (+1)
   \   00000034   0xF06F 0x0001      MVN      R0,#+1
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6048             STR      R0,[R1, #+4]
    421              }
    422            }
    423          }
   \                     ??HAL_RTCEx_RTCIRQHandler_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    424          
    425          /**
    426            * @brief  Second event callback.
    427            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    428            *                the configuration information for RTC.
    429            * @retval None
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          __weak void HAL_RTCEx_RTCEventCallback(RTC_HandleTypeDef *hrtc)
    432          {
    433            /* Prevent unused argument(s) compilation warning */
    434            UNUSED(hrtc);
    435            /* NOTE : This function Should not be modified, when the callback is needed,
    436                      the HAL_RTCEx_RTCEventCallback could be implemented in the user file
    437             */
    438          }
   \                     HAL_RTCEx_RTCEventCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    439          
    440          /**
    441            * @brief  Second event error callback.
    442            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    443            *                the configuration information for RTC.
    444            * @retval None
    445            */

   \                                 In section .text, align 2, keep-with-next
    446          __weak void HAL_RTCEx_RTCEventErrorCallback(RTC_HandleTypeDef *hrtc)
    447          {
    448            /* Prevent unused argument(s) compilation warning */
    449            UNUSED(hrtc);
    450            /* NOTE : This function Should not be modified, when the callback is needed,
    451                      the HAL_RTCEx_RTCEventErrorCallback could be implemented in the user file
    452             */
    453          }
   \                     HAL_RTCEx_RTCEventErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    454          
    455          /**
    456            * @}
    457            */
    458            
    459          /** @defgroup RTCEx_Exported_Functions_Group3 Extended Peripheral Control functions
    460            * @brief    Extended Peripheral Control functions
    461            *
    462          @verbatim   
    463           ===============================================================================
    464                        ##### Extension Peripheral Control functions #####
    465           ===============================================================================  
    466              [..]
    467              This subsection provides functions allowing to
    468                (+) Writes a data in a specified RTC Backup data register
    469                (+) Read a data in a specified RTC Backup data register
    470                (+) Sets the Smooth calibration parameters.
    471          
    472          @endverbatim
    473            * @{
    474            */
    475          
    476          /**
    477            * @brief  Writes a data in a specified RTC Backup data register.
    478            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    479            *                the configuration information for RTC. 
    480            * @param  BackupRegister: RTC Backup data Register number.
    481            *          This parameter can be: RTC_BKP_DRx where x can be from 1 to 10 (or 42) to 
    482            *                                 specify the register (depending devices).
    483            * @param  Data: Data to be written in the specified RTC Backup data register.                     
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
    487          {
    488            uint32_t tmp = 0;
    489          
    490            /* Check the parameters */
    491            assert_param(IS_RTC_BKP(BackupRegister));
    492            
    493            tmp = (uint32_t)BKP_BASE; 
    494            tmp += (BackupRegister * 4);
    495          
    496            *(__IO uint32_t *) tmp = (Data & BKP_DR1_D);
   \                     HAL_RTCEx_BKUPWrite: (+1)
   \   00000000   0xB290             UXTH     R0,R2
   \   00000002   0x....             LDR.N    R2,??DataTable7_3  ;; 0x40006c00
   \   00000004   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    497          }
   \   00000008   0x4770             BX       LR               ;; return
    498          
    499          /**
    500            * @brief  Reads data from the specified RTC Backup data Register.
    501            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    502            *                the configuration information for RTC. 
    503            * @param  BackupRegister: RTC Backup data Register number.
    504            *          This parameter can be: RTC_BKP_DRx where x can be from 1 to 10 (or 42) to 
    505            *                                 specify the register (depending devices).
    506            * @retval Read value
    507            */

   \                                 In section .text, align 2, keep-with-next
    508          uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
    509          {
    510            uint32_t backupregister = 0;
    511            uint32_t pvalue = 0;
    512          
    513            /* Check the parameters */
    514            assert_param(IS_RTC_BKP(BackupRegister));
    515          
    516            backupregister = (uint32_t)BKP_BASE; 
    517            backupregister += (BackupRegister * 4);
    518            
    519            pvalue = (*(__IO uint32_t *)(backupregister)) & BKP_DR1_D;
   \                     HAL_RTCEx_BKUPRead: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_3  ;; 0x40006c00
   \   00000002   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000006   0xB280             UXTH     R0,R0
    520          
    521            /* Read the specified register */
    522            return pvalue;
   \   00000008   0x4770             BX       LR               ;; return
    523          }
    524          
    525          
    526          /**
    527            * @brief  Sets the Smooth calibration parameters.
    528            * @param  hrtc: RTC handle  
    529            * @param  SmoothCalibPeriod: Not used (only present for compatibility with another families)
    530            * @param  SmoothCalibPlusPulses: Not used (only present for compatibility with another families)
    531            * @param  SmouthCalibMinusPulsesValue: specifies the RTC Clock Calibration value.
    532            *          This parameter must be a number between 0 and 0x7F.
    533            * @retval HAL status
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue)
    536          {
    537            /* Check input parameters */
    538            if(hrtc == NULL)
   \                     HAL_RTCEx_SetSmoothCalib: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??HAL_RTCEx_SetSmoothCalib_0
    539            {
    540               return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x4770             BX       LR
    541            }
    542            
    543            /* Check the parameters */
    544            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmouthCalibMinusPulsesValue));
    545            
    546            /* Process Locked */
    547            __HAL_LOCK(hrtc);
   \                     ??HAL_RTCEx_SetSmoothCalib_0: (+1)
   \   00000008   0xF990 0x1010      LDRSB    R1,[R0, #+16]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_RTCEx_SetSmoothCalib_1
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x4770             BX       LR
   \                     ??HAL_RTCEx_SetSmoothCalib_1: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7401             STRB     R1,[R0, #+16]
    548          
    549            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x7441             STRB     R1,[R0, #+17]
    550          
    551            /* Sets RTC Clock Calibration value.*/
    552            MODIFY_REG(BKP->RTCCR, BKP_RTCCR_CAL, SmouthCalibMinusPulsesValue);
   \   0000001C   0x....             LDR.N    R1,??DataTable7  ;; 0x40006c2c
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x09D2             LSRS     R2,R2,#+7
   \   00000022   0xEA53 0x12C2      ORRS     R2,R3,R2, LSL #+7
   \   00000026   0x600A             STR      R2,[R1, #+0]
    553          
    554            /* Change RTC state */
    555            hrtc->State = HAL_RTC_STATE_READY;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x7441             STRB     R1,[R0, #+17]
    556          
    557            /* Process Unlocked */
    558            __HAL_UNLOCK(hrtc);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7401             STRB     R1,[R0, #+16]
    559          
    560            return HAL_OK;
   \   00000030   0x4608             MOV      R0,R1
   \   00000032   0x4770             BX       LR               ;; return
    561          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40006C2C         DC32     0x40006c2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x40006C30         DC32     0x40006c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40006C34         DC32     0x40006c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40006C00         DC32     0x40006c00
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          /**
    568            * @}
    569            */
    570            
    571          /**
    572            * @}
    573            */
    574          
    575          #endif /* HAL_RTC_MODULE_ENABLED */
    576          
    577          /**
    578            * @}
    579            */
    580          
    581          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    582          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RTCEx_BKUPRead
       0   HAL_RTCEx_BKUPWrite
       0   HAL_RTCEx_DeactivateSecond
       0   HAL_RTCEx_DeactivateTamper
      16   HAL_RTCEx_PollForTamper1Event
        16   -> HAL_GetTick
       0   HAL_RTCEx_RTCEventCallback
       0   HAL_RTCEx_RTCEventErrorCallback
       8   HAL_RTCEx_RTCIRQHandler
         8   -> HAL_RTCEx_RTCEventCallback
         8   -> HAL_RTCEx_RTCEventErrorCallback
       0   HAL_RTCEx_SetSecond_IT
       0   HAL_RTCEx_SetSmoothCalib
       4   HAL_RTCEx_SetTamper
       4   HAL_RTCEx_SetTamper_IT
       0   HAL_RTCEx_Tamper1EventCallback
      16   HAL_RTCEx_TamperIRQHandler
        16   -> HAL_RTCEx_Tamper1EventCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
      10  HAL_RTCEx_BKUPRead
      10  HAL_RTCEx_BKUPWrite
      50  HAL_RTCEx_DeactivateSecond
      74  HAL_RTCEx_DeactivateTamper
      70  HAL_RTCEx_PollForTamper1Event
       2  HAL_RTCEx_RTCEventCallback
       2  HAL_RTCEx_RTCEventErrorCallback
      62  HAL_RTCEx_RTCIRQHandler
      50  HAL_RTCEx_SetSecond_IT
      52  HAL_RTCEx_SetSmoothCalib
      86  HAL_RTCEx_SetTamper
      94  HAL_RTCEx_SetTamper_IT
       2  HAL_RTCEx_Tamper1EventCallback
      38  HAL_RTCEx_TamperIRQHandler

 
 618 bytes in section .text
 
 618 bytes of CODE memory

Errors: none
Warnings: none
