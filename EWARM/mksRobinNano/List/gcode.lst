###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\gcode.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\gcode.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\gcode.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\gcode.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\gcode.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * gcode.cpp - Parser for a GCode line, providing a parameter interface.
     25           */
     26          
     27          #include "gcode.h"

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

   \                                 In section .text, align 4
   \   __interwork __softfp void GCodeParser::set(char, char *)
   \                     _ZN11GCodeParser3setEcPc: (+1)
   \   00000000   0x3841             SUBS     R0,R0,#+65
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x281A             CMP      R0,#+26
   \   00000006   0xD300             BCC.N    ??set_0
   \   00000008   0x4770             BX       LR
   \                     ??set_0: (+1)
   \   0000000A   0xB470             PUSH     {R4-R6}
   \   0000000C   0x4A09             LDR.N    R2,??set_1
   \   0000000E   0xEB02 0x03E0      ADD      R3,R2,R0, ASR #+3
   \   00000012   0x791C             LDRB     R4,[R3, #+4]
   \   00000014   0x2501             MOVS     R5,#+1
   \   00000016   0xF000 0x0607      AND      R6,R0,#0x7
   \   0000001A   0x40B5             LSLS     R5,R5,R6
   \   0000001C   0x432C             ORRS     R4,R5,R4
   \   0000001E   0x711C             STRB     R4,[R3, #+4]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD002             BEQ.N    ??set_2
   \   00000024   0x6A53             LDR      R3,[R2, #+36]
   \   00000026   0x1AC9             SUBS     R1,R1,R3
   \   00000028   0xE000             B.N      ??set_3
   \                     ??set_2: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \                     ??set_3: (+1)
   \   0000002C   0x1880             ADDS     R0,R0,R2
   \   0000002E   0x7201             STRB     R1,[R0, #+8]
   \   00000030   0xBC70             POP      {R4-R6}
   \   00000032   0x4770             BX       LR               ;; return
   \                     ??set_1:
   \   00000034   0x........         DC32     _ZN11GCodeParser14command_letterE

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer
     28          
     29          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     30          #include "language.h"
     31          
     32          // Must be declared for allocation and to satisfy the linker
     33          // Zero values need no initialization.
     34          

   \                                 In section .bss, align 1
     35          bool GCodeParser::volumetric_enabled;
   \                     _ZN11GCodeParser18volumetric_enabledE:
   \   00000000                      DS8 1
     36          
     37          #if ENABLED(INCH_MODE_SUPPORT)
     38            float GCodeParser::linear_unit_factor, GCodeParser::volumetric_unit_factor;
     39          #endif
     40          
     41          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     42            TempUnit GCodeParser::input_temp_units;
     43          #endif
     44          

   \                                 In section .bss, align 4
     45          char *GCodeParser::command_ptr,
     46               *GCodeParser::string_arg,
     47               *GCodeParser::value_ptr;
     48          char GCodeParser::command_letter;
   \                     _ZN11GCodeParser14command_letterE:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
     49          int GCodeParser::codenum;
     50          #if USE_GCODE_SUBCODES
     51            uint8_t GCodeParser::subcode;
     52          #endif
     53          
     54          #if ENABLED(FASTER_GCODE_PARSER)
     55            // Optimized Parameters
     56            byte GCodeParser::codebits[4];   // found bits
   \                     _ZN11GCodeParser8codebitsE:
   \   00000004                      DS8 4
     57            uint8_t GCodeParser::param[26];  // parameter offsets from command_ptr
   \                     _ZN11GCodeParser5paramE:
   \   00000008                      DS8 28
   \                     _ZN11GCodeParser11command_ptrE:
   \   00000024                      DS8 4
   \                     _ZN11GCodeParser10string_argE:
   \   00000028                      DS8 4
   \                     _ZN11GCodeParser7codenumE:
   \   0000002C                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN11GCodeParser9value_ptrE:
   \   00000000                      DS8 4
     58          #else
     59            char *GCodeParser::command_args; // start of parameters
     60          #endif
     61          
     62          // Create a global instance of the GCode parser singleton

   \                                 In section .bss, align 4
     63          GCodeParser parser;
   \                     parser:
   \   00000000                      DS8 4
     64          
     65          /**
     66           * Clear all code-seen (and value pointers)
     67           *
     68           * Since each param is set/cleared on seen codes,
     69           * this may be optimized by commenting out ZERO(param)
     70           */

   \                                 In section .text, align 2, keep-with-next
     71          void GCodeParser::reset() {
     72            string_arg = NULL;                    // No whole line argument
   \                     _ZN11GCodeParser5resetEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6281             STR      R1,[R0, #+40]
     73            command_letter = '?';                 // No command letter
   \   00000006   0x213F             MOVS     R1,#+63
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     74            codenum = 0;                          // No command code
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x62C1             STR      R1,[R0, #+44]
     75            #if USE_GCODE_SUBCODES
     76              subcode = 0;                        // No command sub-code
     77            #endif
     78            #if ENABLED(FASTER_GCODE_PARSER)
     79              ZERO(codebits);                     // No codes yet
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x1D00             ADDS     R0,R0,#+4
   \   00000012   0x.... 0x....      B.W      memset
     80              //ZERO(param);                      // No parameters (should be safe to comment out this line)
     81            #endif
     82          }
     83          
     84          // Populate all fields by parsing a single line of GCode
     85          // 58 bytes of SRAM are used to speed up seen/value

   \                                 In section .text, align 2, keep-with-next
     86          void GCodeParser::parse(char *p) {
   \                     _ZN11GCodeParser5parseEPc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
     87          
     88            reset(); // No codes to report
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser5resetEv
   \   00000008   0xE000             B.N      ??parse_0
     89          
     90            // Skip spaces
     91            while (*p == ' ') ++p;
   \                     ??parse_1: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \                     ??parse_0: (+1)
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD0FA             BEQ.N    ??parse_1
     92          
     93            // Skip N[-0-9] if included in the command line
     94            if (*p == 'N' && NUMERIC_SIGNED(p[1])) {
   \   00000014   0x284E             CMP      R0,#+78
   \   00000016   0xD117             BNE.N    ??parse_2
   \   00000018   0xF994 0x0001      LDRSB    R0,[R4, #+1]
   \   0000001C   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000020   0x290A             CMP      R1,#+10
   \   00000022   0xD303             BCC.N    ??parse_3
   \   00000024   0x282D             CMP      R0,#+45
   \   00000026   0xD001             BEQ.N    ??parse_3
   \   00000028   0x282B             CMP      R0,#+43
   \   0000002A   0xD10D             BNE.N    ??parse_2
     95              #if ENABLED(FASTER_GCODE_PARSER)
     96                //set('N', p + 1);     // (optional) Set the 'N' parameter value
     97              #endif
     98              p += 2;                  // skip N[-0-9]
   \                     ??parse_3: (+1)
   \   0000002C   0x1CA4             ADDS     R4,R4,#+2
   \   0000002E   0xE000             B.N      ??parse_4
     99              while (NUMERIC(*p)) ++p; // skip [0-9]*
   \                     ??parse_5: (+1)
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \                     ??parse_4: (+1)
   \   00000032   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000036   0x3830             SUBS     R0,R0,#+48
   \   00000038   0x280A             CMP      R0,#+10
   \   0000003A   0xD3F9             BCC.N    ??parse_5
    100              while (*p == ' ')   ++p; // skip [ ]*
   \                     ??parse_6: (+1)
   \   0000003C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000040   0x2820             CMP      R0,#+32
   \   00000042   0xD101             BNE.N    ??parse_2
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \   00000046   0xE7F9             B.N      ??parse_6
    101            }
    102          
    103            // *p now points to the current command, which should be G, M, or T
    104            command_ptr = p;
   \                     ??parse_2: (+1)
   \   00000048   0x....             LDR.N    R5,??DataTable3
   \   0000004A   0x626C             STR      R4,[R5, #+36]
    105          
    106            // Get the command letter, which must be G, M, or T
    107            const char letter = *p++;
   \   0000004C   0xF914 0x6B01      LDRSB    R6,[R4], #+1
    108          
    109            // Nullify asterisk and trailing whitespace
    110            char *starpos = strchr(p, '*');
   \   00000050   0x212A             MOVS     R1,#+42
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       _Z6strchrPci
    111            if (starpos) {
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD008             BEQ.N    ??parse_7
    112              --starpos;                          // *
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0xE000             B.N      ??parse_8
    113              while (*starpos == ' ') --starpos;  // spaces...
   \                     ??parse_9: (+1)
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \                     ??parse_8: (+1)
   \   00000062   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000066   0x2920             CMP      R1,#+32
   \   00000068   0xD0FA             BEQ.N    ??parse_9
    114              starpos[1] = '\0';
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x7041             STRB     R1,[R0, #+1]
    115            }
    116          
    117            // Bail if the letter is not G, M, or T
    118            switch (letter) { case 'G': case 'M': case 'T': break; default: return; }
   \                     ??parse_7: (+1)
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x2847             CMP      R0,#+71
   \   00000072   0xD005             BEQ.N    ??parse_10
   \   00000074   0x284D             CMP      R0,#+77
   \   00000076   0xD003             BEQ.N    ??parse_10
   \   00000078   0x2854             CMP      R0,#+84
   \   0000007A   0xD001             BEQ.N    ??parse_10
   \   0000007C   0xBD70             POP      {R4-R6,PC}
    119          
    120            // Skip spaces to get the numeric part
    121            while (*p == ' ') p++;
   \                     ??parse_11: (+1)
   \   0000007E   0x1C64             ADDS     R4,R4,#+1
   \                     ??parse_10: (+1)
   \   00000080   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000084   0x2820             CMP      R0,#+32
   \   00000086   0xD0FA             BEQ.N    ??parse_11
    122          
    123            // Bail if there's no command code number
    124            if (!NUMERIC(*p)) return;
   \   00000088   0x3830             SUBS     R0,R0,#+48
   \   0000008A   0x280A             CMP      R0,#+10
   \   0000008C   0xF080 0x8098      BCS.W    ??parse_12
    125          
    126            // Save the command letter at this point
    127            // A '?' signifies an unknown command
    128            command_letter = letter;
   \   00000090   0x702E             STRB     R6,[R5, #+0]
    129          
    130            // Get the code number - integer digits only
    131            codenum = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x62E8             STR      R0,[R5, #+44]
    132            do {
    133              codenum *= 10, codenum += *p++ - '0';
   \                     ??parse_13: (+1)
   \   00000096   0x6AE8             LDR      R0,[R5, #+44]
   \   00000098   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   0000009C   0x0048             LSLS     R0,R1,#+1
   \   0000009E   0x62E8             STR      R0,[R5, #+44]
   \   000000A0   0xF994 0x1000      LDRSB    R1,[R4, #+0]
   \   000000A4   0x3930             SUBS     R1,R1,#+48
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x62E8             STR      R0,[R5, #+44]
    134            } while (NUMERIC(*p));
   \   000000AA   0xF914 0x0F01      LDRSB    R0,[R4, #+1]!
   \   000000AE   0x3830             SUBS     R0,R0,#+48
   \   000000B0   0x280A             CMP      R0,#+10
   \   000000B2   0xD3F0             BCC.N    ??parse_13
    135          
    136            // Allow for decimal point in command
    137            #if USE_GCODE_SUBCODES
    138              if (*p == '.') {
    139                p++;
    140                while (NUMERIC(*p))
    141                  subcode *= 10, subcode += *p++ - '0';
    142              }
    143            #endif
    144          
    145            // Skip all spaces to get to the first argument, or nul
    146            while (*p == ' ') p++;
   \                     ??parse_14: (+1)
   \   000000B4   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   000000B8   0x2820             CMP      R0,#+32
   \   000000BA   0xD101             BNE.N    ??parse_15
   \   000000BC   0x1C64             ADDS     R4,R4,#+1
   \   000000BE   0xE7F9             B.N      ??parse_14
    147          
    148            // The command parameters (if any) start here, for sure!
    149          
    150            #if DISABLED(FASTER_GCODE_PARSER)
    151              command_args = p; // Scan for parameters in seen()
    152            #endif
    153          
    154            // Only use string_arg for these M codes
    155            if (letter == 'M') switch (codenum) { case 23: case 28: case 30: case 117: case 928: string_arg = p; return; default: break; }
   \                     ??parse_15: (+1)
   \   000000C0   0x2E4D             CMP      R6,#+77
   \   000000C2   0xD10D             BNE.N    ??parse_16
   \   000000C4   0x6AE8             LDR      R0,[R5, #+44]
   \   000000C6   0x2817             CMP      R0,#+23
   \   000000C8   0xD008             BEQ.N    ??parse_17
   \   000000CA   0x281C             CMP      R0,#+28
   \   000000CC   0xD006             BEQ.N    ??parse_17
   \   000000CE   0x281E             CMP      R0,#+30
   \   000000D0   0xD004             BEQ.N    ??parse_17
   \   000000D2   0x2875             CMP      R0,#+117
   \   000000D4   0xD002             BEQ.N    ??parse_17
   \   000000D6   0xF5B0 0x7F68      CMP      R0,#+928
   \   000000DA   0xD101             BNE.N    ??parse_16
   \                     ??parse_17: (+1)
   \   000000DC   0x62AC             STR      R4,[R5, #+40]
   \   000000DE   0xBD70             POP      {R4-R6,PC}
    156          
    157            #if ENABLED(DEBUG_GCODE_PARSER)
    158              const bool debug = codenum == 800;
    159            #endif
    160          
    161            /**
    162             * Find all parameters, set flags and pointers for fast parsing
    163             *
    164             * Most codes ignore 'string_arg', but those that want a string will get the right pointer.
    165             * The following loop assigns the first "parameter" having no numeric value to 'string_arg'.
    166             * This allows M0/M1 with expire time to work: "M0 S5 You Win!"
    167             * For 'M118' you must use 'E1' and 'A1' rather than just 'E' or 'A'
    168             */
    169            string_arg = NULL;
   \                     ??parse_16: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x62A8             STR      R0,[R5, #+40]
    170            while (const char code = *p++) {                    // Get the next parameter. A NUL ends the loop
   \                     ??parse_18: (+1)
   \   000000E4   0xF914 0x0B01      LDRSB    R0,[R4], #+1
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD069             BEQ.N    ??parse_12
    171          
    172              // Special handling for M32 [P] !/path/to/file.g#
    173              // The path must be the last parameter
    174              if (code == '!' && letter == 'M' && codenum == 32) {
   \   000000EC   0x2821             CMP      R0,#+33
   \   000000EE   0xD10E             BNE.N    ??parse_19
   \   000000F0   0x2E4D             CMP      R6,#+77
   \   000000F2   0xD10C             BNE.N    ??parse_19
   \   000000F4   0x6AE9             LDR      R1,[R5, #+44]
   \   000000F6   0x2920             CMP      R1,#+32
   \   000000F8   0xD109             BNE.N    ??parse_19
    175                string_arg = p;                           // Name starts after '!'
   \   000000FA   0x62AC             STR      R4,[R5, #+40]
    176                char * const lb = strchr(p, '#');         // Already seen '#' as SD char (to pause buffering)
   \   000000FC   0x2123             MOVS     R1,#+35
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       _Z6strchrPci
    177                if (lb) *lb = '\0';                       // Safe to mark the end of the filename
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD05B             BEQ.N    ??parse_12
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0x7001             STRB     R1,[R0, #+0]
    178                return;
   \   0000010C   0xBD70             POP      {R4-R6,PC}
    179              }
    180          
    181              // Arguments MUST be uppercase for fast GCode parsing
    182              #if ENABLED(FASTER_GCODE_PARSER)
    183                #define PARAM_TEST WITHIN(code, 'A', 'Z')
    184              #else
    185                #define PARAM_TEST true
    186              #endif
    187          
    188              if (PARAM_TEST) {
   \                     ??parse_19: (+1)
   \   0000010E   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000112   0x291A             CMP      R1,#+26
   \   00000114   0xD30B             BCC.N    ??parse_20
    189          
    190                while (*p == ' ') p++;                    // Skip spaces between parameters & values
    191          
    192                const bool has_num = NUMERIC(p[0])                            // [0-9]
    193                                  || (p[0] == '.' && NUMERIC(p[1]))           // .[0-9]
    194                                  || (
    195                                        (p[0] == '-' || p[0] == '+') && (     // [-+]
    196                                          NUMERIC(p[1])                       //     [0-9]
    197                                          || (p[1] == '.' && NUMERIC(p[2]))   //     .[0-9]
    198                                        )
    199                                      );
    200          
    201                #if ENABLED(DEBUG_GCODE_PARSER)
    202                  if (debug) {
    203                    SERIAL_ECHOPAIR("Got letter ", code);
    204                    SERIAL_ECHOPAIR(" at index ", (int)(p - command_ptr - 1));
    205                    if (has_num) SERIAL_ECHOPGM(" (has_num)");
    206                  }
    207                #endif
    208          
    209                if (!has_num && !string_arg) {            // No value? First time, keep as string_arg
    210                  string_arg = p - 1;
    211                  #if ENABLED(DEBUG_GCODE_PARSER)
    212                    if (debug) SERIAL_ECHOPAIR(" string_arg: ", hex_address((void*)string_arg)); // DEBUG
    213                  #endif
    214                }
    215          
    216                #if ENABLED(DEBUG_GCODE_PARSER)
    217                  if (debug) SERIAL_EOL();
    218                #endif
    219          
    220                #if ENABLED(FASTER_GCODE_PARSER)
    221                {
    222                  set(code, has_num ? p : NULL            // Set parameter exists and pointer (NULL for no number)
    223                    #if ENABLED(DEBUG_GCODE_PARSER)
    224                      , debug
    225                    #endif
    226                  );
    227                }
    228                #endif
    229              }
    230              else if (!string_arg) {                     // Not A-Z? First time, keep as the string_arg
   \   00000116   0x6AA8             LDR      R0,[R5, #+40]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD101             BNE.N    ??parse_21
    231                string_arg = p - 1;
   \   0000011C   0x1E60             SUBS     R0,R4,#+1
   \   0000011E   0x62A8             STR      R0,[R5, #+40]
    232                #if ENABLED(DEBUG_GCODE_PARSER)
    233                  if (debug) SERIAL_ECHOPAIR(" string_arg: ", hex_address((void*)string_arg)); // DEBUG
    234                #endif
    235              }
    236          
    237              if (!WITHIN(*p, 'A', 'Z')) {                // Another parameter right away?
   \                     ??parse_21: (+1)
   \   00000120   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000124   0x3841             SUBS     R0,R0,#+65
   \   00000126   0x281A             CMP      R0,#+26
   \   00000128   0xD3DC             BCC.N    ??parse_18
   \   0000012A   0xE035             B.N      ??parse_22
   \                     ??parse_23: (+1)
   \   0000012C   0x1C64             ADDS     R4,R4,#+1
   \                     ??parse_20: (+1)
   \   0000012E   0xF994 0x1000      LDRSB    R1,[R4, #+0]
   \   00000132   0x2920             CMP      R1,#+32
   \   00000134   0xD0FA             BEQ.N    ??parse_23
   \   00000136   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   0000013A   0x2A0A             CMP      R2,#+10
   \   0000013C   0xD319             BCC.N    ??parse_24
   \   0000013E   0x292E             CMP      R1,#+46
   \   00000140   0xD104             BNE.N    ??parse_25
   \   00000142   0xF994 0x2001      LDRSB    R2,[R4, #+1]
   \   00000146   0x3A30             SUBS     R2,R2,#+48
   \   00000148   0x2A0A             CMP      R2,#+10
   \   0000014A   0xD312             BCC.N    ??parse_24
   \                     ??parse_25: (+1)
   \   0000014C   0x292D             CMP      R1,#+45
   \   0000014E   0xD001             BEQ.N    ??parse_26
   \   00000150   0x292B             CMP      R1,#+43
   \   00000152   0xD110             BNE.N    ??parse_27
   \                     ??parse_26: (+1)
   \   00000154   0xF994 0x1001      LDRSB    R1,[R4, #+1]
   \   00000158   0xF1A1 0x0230      SUB      R2,R1,#+48
   \   0000015C   0x2A0A             CMP      R2,#+10
   \   0000015E   0xD308             BCC.N    ??parse_24
   \   00000160   0x292E             CMP      R1,#+46
   \   00000162   0xD108             BNE.N    ??parse_27
   \   00000164   0xF994 0x1002      LDRSB    R1,[R4, #+2]
   \   00000168   0x3930             SUBS     R1,R1,#+48
   \   0000016A   0x290A             CMP      R1,#+10
   \   0000016C   0x4189             SBCS     R1,R1,R1
   \   0000016E   0x0FC9             LSRS     R1,R1,#+31
   \   00000170   0xE002             B.N      ??parse_28
   \                     ??parse_24: (+1)
   \   00000172   0x2101             MOVS     R1,#+1
   \   00000174   0xE000             B.N      ??parse_28
   \                     ??parse_27: (+1)
   \   00000176   0x2100             MOVS     R1,#+0
   \                     ??parse_28: (+1)
   \   00000178   0x2900             CMP      R1,#+0
   \   0000017A   0xD104             BNE.N    ??parse_29
   \   0000017C   0x6AAA             LDR      R2,[R5, #+40]
   \   0000017E   0x2A00             CMP      R2,#+0
   \   00000180   0xD101             BNE.N    ??parse_29
   \   00000182   0x1E62             SUBS     R2,R4,#+1
   \   00000184   0x62AA             STR      R2,[R5, #+40]
   \                     ??parse_29: (+1)
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD001             BEQ.N    ??parse_30
   \   0000018A   0x4621             MOV      R1,R4
   \   0000018C   0xE000             B.N      ??parse_31
   \                     ??parse_30: (+1)
   \   0000018E   0x2100             MOVS     R1,#+0
   \                     ??parse_31: (+1)
   \   00000190   0x.... 0x....      BL       _ZN11GCodeParser3setEcPc
   \   00000194   0xE7C4             B.N      ??parse_21
    238                while (*p && DECIMAL_SIGNED(*p)) p++;     // Skip over the value section of a parameter
   \                     ??parse_32: (+1)
   \   00000196   0x1C64             ADDS     R4,R4,#+1
   \                     ??parse_22: (+1)
   \   00000198   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000019C   0x2800             CMP      R0,#+0
   \   0000019E   0xD009             BEQ.N    ??parse_33
   \   000001A0   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   000001A4   0x290A             CMP      R1,#+10
   \   000001A6   0xD3F6             BCC.N    ??parse_32
   \   000001A8   0x282E             CMP      R0,#+46
   \   000001AA   0xD0F4             BEQ.N    ??parse_32
   \   000001AC   0x282D             CMP      R0,#+45
   \   000001AE   0xD0F2             BEQ.N    ??parse_32
   \   000001B0   0x282B             CMP      R0,#+43
   \   000001B2   0xD0F0             BEQ.N    ??parse_32
    239                while (*p == ' ') p++;                    // Skip over all spaces
   \                     ??parse_33: (+1)
   \   000001B4   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   000001B8   0x2820             CMP      R0,#+32
   \   000001BA   0xD193             BNE.N    ??parse_18
   \   000001BC   0x1C64             ADDS     R4,R4,#+1
   \   000001BE   0xE7F9             B.N      ??parse_33
    240              }
    241            }
    242          }
   \                     ??parse_12: (+1)
   \   000001C0   0xBD70             POP      {R4-R6,PC}       ;; return
    243          
    244          #if ENABLED(CNC_COORDINATE_SYSTEMS)
    245          
    246            // Parse the next parameter as a new command
    247            bool GCodeParser::chain() {
    248              #if ENABLED(FASTER_GCODE_PARSER)
    249                char *next_command = command_ptr;
    250                if (next_command) {
    251                  while (*next_command && *next_command != ' ') ++next_command;
    252                  while (*next_command == ' ') ++next_command;
    253                  if (!*next_command) next_command = NULL;
    254                }
    255              #else
    256                const char *next_command = command_args;
    257              #endif
    258              if (next_command) parse(next_command);
    259              return !!next_command;
    260            }
    261          
    262          #endif // CNC_COORDINATE_SYSTEMS
    263          

   \                                 In section .text, align 2, keep-with-next
    264          void GCodeParser::unknown_command_error() {
   \                     _ZN11GCodeParser21unknown_command_errorEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    265            SERIAL_ECHO_START();
   \   00000002   0x....             LDR.N    R0,??DataTable3_1
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
    266            SERIAL_ECHOPAIR(MSG_UNKNOWN_COMMAND, command_ptr);
   \   00000008   0x....             LDR.N    R0,??DataTable3
   \   0000000A   0x6A41             LDR      R1,[R0, #+36]
   \   0000000C   0x.... 0x....      ADR.W    R0,`?<Constant "Unknown command: \\"">`
   \   00000010   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    267            SERIAL_CHAR('"');
   \   00000014   0x....             LDR.N    R4,??DataTable3_2
   \   00000016   0x2122             MOVS     R1,#+34
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    268            SERIAL_EOL();
   \   0000001E   0x210A             MOVS     R1,#+10
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    269          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     _ZN11GCodeParser14command_letterE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Unknown command: \\"">`:
   \   00000000   0x55 0x6E          DC8 "Unknown command: \""
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \              0x20 0x22    
   \              0x00         
   \   00000013   0x00               DC8 0
    270          
    271          #if ENABLED(DEBUG_GCODE_PARSER)
    272          
    273            void GCodeParser::debug() {
    274              SERIAL_ECHOPAIR("Command: ", command_ptr);
    275              SERIAL_ECHOPAIR(" (", command_letter);
    276              SERIAL_ECHO(codenum);
    277              SERIAL_ECHOLNPGM(")");
    278              #if ENABLED(FASTER_GCODE_PARSER)
    279                SERIAL_ECHO(" args: \"");
    280                for (char c = 'A'; c <= 'Z'; ++c)
    281                  if (seen(c)) { SERIAL_CHAR(c); SERIAL_CHAR(' '); }
    282              #else
    283                SERIAL_ECHOPAIR(" args: \"", command_args);
    284              #endif
    285              SERIAL_ECHOPGM("\"");
    286              if (string_arg) {
    287                SERIAL_ECHOPGM(" string: \"");
    288                SERIAL_ECHO(string_arg);
    289                SERIAL_CHAR('"');
    290              }
    291              SERIAL_ECHOPGM("\n\n");
    292              for (char c = 'A'; c <= 'Z'; ++c) {
    293                if (seen(c)) {
    294                  SERIAL_ECHOPAIR("Code '", c); SERIAL_ECHOPGM("':");
    295                  if (has_value()) {
    296                    SERIAL_ECHOPAIR("\n    float: ", value_float());
    297                    SERIAL_ECHOPAIR("\n     long: ", value_long());
    298                    SERIAL_ECHOPAIR("\n    ulong: ", value_ulong());
    299                    SERIAL_ECHOPAIR("\n   millis: ", value_millis());
    300                    SERIAL_ECHOPAIR("\n   sec-ms: ", value_millis_from_seconds());
    301                    SERIAL_ECHOPAIR("\n      int: ", value_int());
    302                    SERIAL_ECHOPAIR("\n   ushort: ", value_ushort());
    303                    SERIAL_ECHOPAIR("\n     byte: ", (int)value_byte());
    304                    SERIAL_ECHOPAIR("\n     bool: ", (int)value_bool());
    305                    SERIAL_ECHOPAIR("\n   linear: ", value_linear_units());
    306                    SERIAL_ECHOPAIR("\n  celsius: ", value_celsius());
    307                  }
    308                  else
    309                    SERIAL_ECHOPGM(" (no value)");
    310                  SERIAL_ECHOPGM("\n\n");
    311                }
    312              }
    313            }
    314          
    315          #endif // DEBUG_GCODE_PARSER

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GCodeParser::parse(char *)
        16   -> GCodeParser::reset()
        16   -> GCodeParser::set(char, char *)
        16   -> strchr(char *, int)
       0   GCodeParser::reset()
         0   -> memset
      12   GCodeParser::set(char, char *)
       8   GCodeParser::unknown_command_error()
         0   -> USARTClass::write(uint8_t)
         8   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, char const *)
         8   -> serialprintPGM(char const *)
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   strchr(char *, int)
         0   -> __iar_Strchr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "Unknown command: \"">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      48  GCodeParser::command_letter
          GCodeParser::codebits
          GCodeParser::param
          GCodeParser::command_ptr
          GCodeParser::string_arg
          GCodeParser::codenum
     450  GCodeParser::parse(char *)
      22  GCodeParser::reset()
      56  GCodeParser::set(char, char *)
      42  GCodeParser::unknown_command_error()
       4  GCodeParser::value_ptr
       1  GCodeParser::volumetric_enabled
       4  parser
      28  serialprintPGM(char const *)
       4  strchr(char *, int)
       1  -- Other

 
  57 bytes in section .bss
   1 byte  in section .rodata
 634 bytes in section .text
 
 546 bytes of CODE  memory (+ 88 bytes shared)
   0 bytes of CONST memory (+  1 byte  shared)
  57 bytes of DATA  memory

Errors: none
Warnings: 8
