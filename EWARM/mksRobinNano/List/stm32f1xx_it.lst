###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:10
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\stm32f1xx_it.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\stm32f1xx_it.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_it.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_it.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\stm32f1xx_it.cpp
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_it.c
      4            * @brief   Interrupt Service Routines.
      5            ******************************************************************************
      6            *
      7            * COPYRIGHT(c) 2018 STMicroelectronics
      8            *
      9            * Redistribution and use in source and binary forms, with or without modification,
     10            * are permitted provided that the following conditions are met:
     11            *   1. Redistributions of source code must retain the above copyright notice,
     12            *      this list of conditions and the following disclaimer.
     13            *   2. Redistributions in binary form must reproduce the above copyright notice,
     14            *      this list of conditions and the following disclaimer in the documentation
     15            *      and/or other materials provided with the distribution.
     16            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     17            *      may be used to endorse or promote products derived from this software
     18            *      without specific prior written permission.
     19            *
     20            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     21            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     22            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     23            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     24            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     25            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     26            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     27            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     28            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     29            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     30            *
     31            ******************************************************************************
     32            */
     33          /* Includes ------------------------------------------------------------------*/
     34          #include "stm32f1xx_hal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SystemReset()
   \                     _Z16NVIC_SystemResetv: (+1)
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0xe000ed0c
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF401 0x61E0      AND      R1,R1,#0x700
   \   0000000C   0x....             LDR.N    R2,??DataTable10_1  ;; 0x5fa0004
   \   0000000E   0x4311             ORRS     R1,R2,R1
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0xF3BF 0x8F4F      DSB      
   \                     ??NVIC_SystemReset_0: (+1)
   \   00000016   0xBF00             Nop      
   \   00000018   0xE7FD             B.N      ??NVIC_SystemReset_0
     35          #include "stm32f1xx.h"
     36          #include "stm32f1xx_it.h"
     37          
     38          /* USER CODE BEGIN 0 */
     39          #include "tim.h"
     40          #include "serial.h"   

  #define UNUSED(x) (void) (x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\macros.h",101  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 87 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")
     41          #include "mks_test.h"

  #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION_MODE" (declared
          at line 466 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",146  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          459 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",158  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 488 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          496 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          504 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          512 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 521 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 535 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",408  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",409  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",425  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 558 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #else defined(MKS_ROBIN_NANO)
        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.h",40  Warning[Pe014]: 
          extra text after expected end of preprocessing directive
     42          
     43          extern void SysTick_Handler_User();
     44          /* USER CODE END 0 */
     45          //extern char dma1_5_IRQ_sel;
     46          
     47          /* External variables --------------------------------------------------------*/
     48          extern DMA_HandleTypeDef hdma_adc1;
     49          extern ADC_HandleTypeDef hadc1;
     50          //extern DMA_HandleTypeDef hdma_sdio;
     51          extern SD_HandleTypeDef hsd;
     52          extern DMA_HandleTypeDef hdma_spi2_rx;
     53          extern DMA_HandleTypeDef hdma_spi2_tx;
     54          extern SPI_HandleTypeDef hspi2;
     55          extern TIM_HandleTypeDef htim1;
     56          extern TIM_HandleTypeDef htim2;
     57          extern TIM_HandleTypeDef htim3;
     58          extern TIM_HandleTypeDef htim4;
     59          extern UART_HandleTypeDef huart1;
     60          extern UART_HandleTypeDef huart3;
     61          
     62          /******************************************************************************/
     63          /*            Cortex-M3 Processor Interruption and Exception Handlers         */ 
     64          /******************************************************************************/
     65          
     66          /**
     67          * @brief This function handles Non maskable interrupt.
     68          */

   \                                 In section .text, align 2, keep-with-next
     69          void NMI_Handler(void)
     70          {
     71            /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
     72          
     73            /* USER CODE END NonMaskableInt_IRQn 0 */
     74            /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
     75          
     76            /* USER CODE END NonMaskableInt_IRQn 1 */
     77          }
   \                     NMI_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     78          
     79          /**
     80          * @brief This function handles Hard fault interrupt.
     81          */

   \                                 In section .text, align 2, keep-with-next
     82          void HardFault_Handler(void)
     83          {
   \                     HardFault_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     84            /* USER CODE BEGIN HardFault_IRQn 0 */
     85          
     86            /* USER CODE END HardFault_IRQn 0 */
     87            while (1)
     88            {
     89            __set_FAULTMASK(1);
   \                     ??HardFault_Handler_0: (+1)
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0xF380 0x8813      MSR      FAULTMASK,R0
     90              NVIC_SystemReset();
   \   00000008   0x.... 0x....      BL       _Z16NVIC_SystemResetv
   \   0000000C   0xE7F9             B.N      ??HardFault_Handler_0
     91            }
     92            /* USER CODE BEGIN HardFault_IRQn 1 */
     93          
     94            /* USER CODE END HardFault_IRQn 1 */
     95          }
     96          
     97          /**
     98          * @brief This function handles Memory management fault.
     99          */

   \                                 In section .text, align 2, keep-with-next
    100          void MemManage_Handler(void)
    101          {
    102            /* USER CODE BEGIN MemoryManagement_IRQn 0 */
    103          
    104            /* USER CODE END MemoryManagement_IRQn 0 */
    105            while (1)
   \                     MemManage_Handler: (+1)
   \                     ??MemManage_Handler_0: (+1)
   \   00000000   0xE7FE             B.N      ??MemManage_Handler_0
    106            {
    107            }
    108            /* USER CODE BEGIN MemoryManagement_IRQn 1 */
    109          
    110            /* USER CODE END MemoryManagement_IRQn 1 */
    111          }
    112          
    113          /**
    114          * @brief This function handles Prefetch fault, memory access fault.
    115          */

   \                                 In section .text, align 2, keep-with-next
    116          void BusFault_Handler(void)
    117          {
    118            /* USER CODE BEGIN BusFault_IRQn 0 */
    119          
    120            /* USER CODE END BusFault_IRQn 0 */
    121            while (1)
   \                     BusFault_Handler: (+1)
   \                     ??BusFault_Handler_0: (+1)
   \   00000000   0xE7FE             B.N      ??BusFault_Handler_0
    122            {
    123            }
    124            /* USER CODE BEGIN BusFault_IRQn 1 */
    125          
    126            /* USER CODE END BusFault_IRQn 1 */
    127          }
    128          
    129          /**
    130          * @brief This function handles Undefined instruction or illegal state.
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          void UsageFault_Handler(void)
    133          {
    134            /* USER CODE BEGIN UsageFault_IRQn 0 */
    135          
    136            /* USER CODE END UsageFault_IRQn 0 */
    137            while (1)
   \                     UsageFault_Handler: (+1)
   \                     ??UsageFault_Handler_0: (+1)
   \   00000000   0xE7FE             B.N      ??UsageFault_Handler_0
    138            {
    139            }
    140            /* USER CODE BEGIN UsageFault_IRQn 1 */
    141          
    142            /* USER CODE END UsageFault_IRQn 1 */
    143          }
    144          
    145          /**
    146          * @brief This function handles System service call via SWI instruction.
    147          */

   \                                 In section .text, align 2, keep-with-next
    148          void SVC_Handler(void)
    149          {
    150            /* USER CODE BEGIN SVCall_IRQn 0 */
    151          
    152            /* USER CODE END SVCall_IRQn 0 */
    153            /* USER CODE BEGIN SVCall_IRQn 1 */
    154          
    155            /* USER CODE END SVCall_IRQn 1 */
    156          }
   \                     SVC_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    157          
    158          /**
    159          * @brief This function handles Debug monitor.
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          void DebugMon_Handler(void)
    162          {
    163            /* USER CODE BEGIN DebugMonitor_IRQn 0 */
    164          
    165            /* USER CODE END DebugMonitor_IRQn 0 */
    166            /* USER CODE BEGIN DebugMonitor_IRQn 1 */
    167          
    168            /* USER CODE END DebugMonitor_IRQn 1 */
    169          }
   \                     DebugMon_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    170          
    171          /**
    172          * @brief This function handles Pendable request for system service.
    173          */

   \                                 In section .text, align 2, keep-with-next
    174          void PendSV_Handler(void)
    175          {
    176            /* USER CODE BEGIN PendSV_IRQn 0 */
    177          
    178            /* USER CODE END PendSV_IRQn 0 */
    179            /* USER CODE BEGIN PendSV_IRQn 1 */
    180          
    181            /* USER CODE END PendSV_IRQn 1 */
    182          }
   \                     PendSV_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    183          
    184          /**
    185          * @brief This function handles System tick timer.
    186          */

   \                                 In section .text, align 2, keep-with-next
    187          void SysTick_Handler(void)
    188          {
   \                     SysTick_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    189            /* USER CODE BEGIN SysTick_IRQn 0 */
    190          	_dwTickCount++;
   \   00000002   0x....             LDR.N    R0,??DataTable10_2
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    191            /* USER CODE END SysTick_IRQn 0 */
    192            HAL_IncTick();
   \   0000000A   0x.... 0x....      BL       HAL_IncTick
    193            HAL_SYSTICK_IRQHandler();
   \   0000000E   0x.... 0x....      BL       HAL_SYSTICK_IRQHandler
    194            /* USER CODE BEGIN SysTick_IRQn 1 */
    195          SysTick_Handler_User();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x.... 0x....      B.W      _Z20SysTick_Handler_Userv
    196            /* USER CODE END SysTick_IRQn 1 */
    197          }
    198          
    199          /******************************************************************************/
    200          /* STM32F1xx Peripheral Interrupt Handlers                                    */
    201          /* Add here the Interrupt Handlers for the used peripherals.                  */
    202          /* For the available peripheral interrupt handler names,                      */
    203          /* please refer to the startup file (startup_stm32f1xx.s).                    */
    204          /******************************************************************************/
    205          
    206          /**
    207          * @brief This function handles DMA1 channel1 global interrupt.
    208          */

   \                                 In section .text, align 2, keep-with-next
    209          void DMA1_Channel1_IRQHandler(void)
    210          {
    211            /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */
    212          
    213            /* USER CODE END DMA1_Channel1_IRQn 0 */
    214            HAL_DMA_IRQHandler(&hdma_adc1);
   \                     DMA1_Channel1_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    215            /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */
    216          
    217            /* USER CODE END DMA1_Channel1_IRQn 1 */
    218          }
    219          
    220          /**
    221          * @brief This function handles DMA1 channel4 global interrupt.
    222          */

   \                                 In section .text, align 2, keep-with-next
    223          void DMA1_Channel4_IRQHandler(void)
    224          {
    225            /* USER CODE BEGIN DMA1_Channel4_IRQn 0 */
    226          
    227            /* USER CODE END DMA1_Channel4_IRQn 0 */
    228            HAL_DMA_IRQHandler(&hdma_spi2_rx);
   \                     DMA1_Channel4_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_4
   \   00000002   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    229            /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */
    230          
    231            /* USER CODE END DMA1_Channel4_IRQn 1 */
    232          }
    233          
    234          /**
    235          * @brief This function handles DMA1 channel5 global interrupt.
    236          */
    237          #if 0
    238          void DMA1_Channel5_IRQHandler(void)
    239          {
    240            /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */
    241          
    242            /* USER CODE END DMA1_Channel5_IRQn 0 */
    243            //if(dma1_5_IRQ_sel == 1)
    244            //  USART1_DMA1_5_IRQ();
    245            //else
    246              HAL_DMA_IRQHandler(&hdma_spi2_tx);
    247            /* USER CODE BEGIN DMA1_Channel5_IRQn 1 */
    248          
    249            /* USER CODE END DMA1_Channel5_IRQn 1 */
    250          }
    251          #endif
    252          /**
    253          * @brief This function handles ADC1 and ADC2 global interrupts.
    254          */

   \                                 In section .text, align 2, keep-with-next
    255          void ADC1_2_IRQHandler(void)
    256          {
    257            /* USER CODE BEGIN ADC1_2_IRQn 0 */
    258          
    259            /* USER CODE END ADC1_2_IRQn 0 */
    260            HAL_ADC_IRQHandler(&hadc1);
   \                     ADC1_2_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_5
   \   00000002   0x.... 0x....      B.W      HAL_ADC_IRQHandler
    261            /* USER CODE BEGIN ADC1_2_IRQn 1 */
    262          
    263            /* USER CODE END ADC1_2_IRQn 1 */
    264          }
    265          
    266          /**
    267          * @brief This function handles TIM1 break interrupt.
    268          */

   \                                 In section .text, align 2, keep-with-next
    269          void TIM1_BRK_IRQHandler(void)
    270          {
    271            /* USER CODE BEGIN TIM1_BRK_IRQn 0 */
    272          
    273            /* USER CODE END TIM1_BRK_IRQn 0 */
    274            HAL_TIM_IRQHandler(&htim1);
   \                     TIM1_BRK_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_6
   \   00000002   0x.... 0x....      B.W      HAL_TIM_IRQHandler
    275            /* USER CODE BEGIN TIM1_BRK_IRQn 1 */
    276          
    277            /* USER CODE END TIM1_BRK_IRQn 1 */
    278          }
    279          
    280          /**
    281          * @brief This function handles TIM2 global interrupt.
    282          */

   \                                 In section .text, align 2, keep-with-next
    283          void TIM2_IRQHandler(void)
    284          {
   \                     TIM2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    285            /* USER CODE BEGIN TIM2_IRQn 0 */
    286          
    287            /* USER CODE END TIM2_IRQn 0 */
    288            HAL_TIM_IRQHandler(&htim2);
   \   00000002   0x....             LDR.N    R0,??DataTable10_7
   \   00000004   0x.... 0x....      BL       HAL_TIM_IRQHandler
    289            /* USER CODE BEGIN TIM2_IRQn 1 */
    290            if(mksTmp.cfg_hardware_test_enable)
   \   00000008   0x....             LDR.N    R0,??DataTable10_8
   \   0000000A   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??TIM2_IRQHandler_0
    291              mksStepperTest();
   \   00000010   0xE8BD 0x4001      POP      {R0,LR}
   \   00000014   0x.... 0x....      B.W      mksStepperTest
    292            else
    293              IsrStepperHandler();
   \                     ??TIM2_IRQHandler_0: (+1)
   \   00000018   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001C   0x.... 0x....      B.W      IsrStepperHandler
    294          
    295            /* USER CODE END TIM2_IRQn 1 */
    296          }
    297          
    298          /**
    299          * @brief This function handles TIM3 global interrupt.
    300          */

   \                                 In section .text, align 2, keep-with-next
    301          void TIM3_IRQHandler(void)
    302          {
    303            /* USER CODE BEGIN TIM3_IRQn 0 */
    304          
    305            /* USER CODE END TIM3_IRQn 0 */
    306            HAL_TIM_IRQHandler(&htim3);
   \                     TIM3_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_9
   \   00000002   0x.... 0x....      B.W      HAL_TIM_IRQHandler
    307            /* USER CODE BEGIN TIM3_IRQn 1 */
    308          
    309            /* USER CODE END TIM3_IRQn 1 */
    310          }
    311          
    312          /**
    313          * @brief This function handles TIM4 global interrupt.
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          void TIM4_IRQHandler(void)
    316          {
   \                     TIM4_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    317            /* USER CODE BEGIN TIM4_IRQn 0 */
    318          
    319            /* USER CODE END TIM4_IRQn 0 */
    320            HAL_TIM_IRQHandler(&htim4);
   \   00000002   0x....             LDR.N    R0,??DataTable10_10
   \   00000004   0x.... 0x....      BL       HAL_TIM_IRQHandler
    321            /* USER CODE BEGIN TIM4_IRQn 1 */
    322            IsrTemperatureHandler();
   \   00000008   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000C   0x.... 0x....      B.W      IsrTemperatureHandler
    323          
    324            /* USER CODE END TIM4_IRQn 1 */
    325          }
    326          
    327          /**
    328          * @brief This function handles SPI2 global interrupt.
    329          */

   \                                 In section .text, align 2, keep-with-next
    330          void SPI2_IRQHandler(void)
    331          {
    332            /* USER CODE BEGIN SPI2_IRQn 0 */
    333          
    334            /* USER CODE END SPI2_IRQn 0 */
    335            HAL_SPI_IRQHandler(&hspi2);
   \                     SPI2_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_11
   \   00000002   0x.... 0x....      B.W      HAL_SPI_IRQHandler
    336            /* USER CODE BEGIN SPI2_IRQn 1 */
    337          
    338            /* USER CODE END SPI2_IRQn 1 */
    339          }
    340          #if 0
    341          /**
    342          * @brief This function handles USART1 global interrupt.
    343          */
    344          void USART1_IRQHandler(void)
    345          {
    346            /* USER CODE BEGIN USART1_IRQn 0 */
    347          
    348            /* USER CODE END USART1_IRQn 0 */
    349            HAL_UART_IRQHandler(&huart1);
    350            /* USER CODE BEGIN USART1_IRQn 1 */
    351          
    352            /* USER CODE END USART1_IRQn 1 */
    353          }
    354          #endif
    355          /**
    356          * @brief This function handles USART3 global interrupt.
    357          */

   \                                 In section .text, align 2, keep-with-next
    358          void USART3_IRQHandler(void)
    359          {
    360            /* USER CODE BEGIN USART3_IRQn 0 */
    361          
    362            /* USER CODE END USART3_IRQn 0 */
    363            //HAL_UART_IRQHandler(&huart3);
    364            MYSERIAL.IrqHandler();
   \                     USART3_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_12
   \   00000002   0x.... 0x....      B.W      _ZN10USARTClass10IrqHandlerEv
    365            /* USER CODE BEGIN USART3_IRQn 1 */
    366          
    367            /* USER CODE END USART3_IRQn 1 */
    368          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     _dwTickCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     hdma_adc1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     hdma_spi2_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     hadc1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     htim1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     htim3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     hspi2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     Serial3
    369          
    370          /**
    371          * @brief This function handles SDIO global interrupt.
    372          */
    373          #if 0
    374          void SDIO_IRQHandler(void)
    375          {
    376            /* USER CODE BEGIN SDIO_IRQn 0 */
    377          
    378            /* USER CODE END SDIO_IRQn 0 */
    379            HAL_SD_IRQHandler(&hsd);
    380            /* USER CODE BEGIN SDIO_IRQn 1 */
    381          
    382            /* USER CODE END SDIO_IRQn 1 */
    383          }
    384          
    385          /**
    386          * @brief This function handles DMA2 channel4 and channel5 global interrupts.
    387          */
    388          void DMA2_Channel4_5_IRQHandler(void)
    389          {
    390            /* USER CODE BEGIN DMA2_Channel4_5_IRQn 0 */
    391          
    392            /* USER CODE END DMA2_Channel4_5_IRQn 0 */
    393            HAL_DMA_IRQHandler(&hdma_sdio);
    394            /* USER CODE BEGIN DMA2_Channel4_5_IRQn 1 */
    395          
    396            /* USER CODE END DMA2_Channel4_5_IRQn 1 */
    397          }
    398          #endif
    399          
    400          /* USER CODE BEGIN 1 */
    401          
    402          /* USER CODE END 1 */
    403          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC1_2_IRQHandler
         0   -> HAL_ADC_IRQHandler
       0   BusFault_Handler
       0   DMA1_Channel1_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   DMA1_Channel4_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   DebugMon_Handler
       8   HardFault_Handler
         8   -> NVIC_SystemReset()
       0   MemManage_Handler
       0   NMI_Handler
       0   NVIC_SystemReset()
       0   PendSV_Handler
       0   SPI2_IRQHandler
         0   -> HAL_SPI_IRQHandler
       0   SVC_Handler
       8   SysTick_Handler
         8   -> HAL_IncTick
         8   -> HAL_SYSTICK_IRQHandler
         0   -> SysTick_Handler_User()
       0   TIM1_BRK_IRQHandler
         0   -> HAL_TIM_IRQHandler
       8   TIM2_IRQHandler
         8   -> HAL_TIM_IRQHandler
         0   -> IsrStepperHandler
         0   -> mksStepperTest
       0   TIM3_IRQHandler
         0   -> HAL_TIM_IRQHandler
       8   TIM4_IRQHandler
         8   -> HAL_TIM_IRQHandler
         0   -> IsrTemperatureHandler
       0   USART3_IRQHandler
         0   -> USARTClass::IrqHandler()
       0   UsageFault_Handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       6  ADC1_2_IRQHandler
       2  BusFault_Handler
       6  DMA1_Channel1_IRQHandler
       6  DMA1_Channel4_IRQHandler
       2  DebugMon_Handler
      14  HardFault_Handler
       2  MemManage_Handler
       2  NMI_Handler
      26  NVIC_SystemReset()
       2  PendSV_Handler
       6  SPI2_IRQHandler
       2  SVC_Handler
      26  SysTick_Handler
       6  TIM1_BRK_IRQHandler
      32  TIM2_IRQHandler
       6  TIM3_IRQHandler
      16  TIM4_IRQHandler
       6  USART3_IRQHandler
       2  UsageFault_Handler
       1  -- Other

 
   1 byte  in section .rodata
 222 bytes in section .text
 
 222 bytes of CODE  memory
   0 bytes of CONST memory (+ 1 byte shared)

Errors: none
Warnings: 18
