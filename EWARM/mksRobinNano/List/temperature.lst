###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:14
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\temperature.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\temperature.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * temperature.cpp - temperature control
     25           */
     26          
     27          #include "Marlin.h"

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \   00000000   0x4801             LDR.N    R0,??IsRunning_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??IsRunning_0:
   \   00000008   0x........         DC32     Running

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     28          #include "temperature.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute short const temptable_1[64][2]
   \                     temptable_1:
   \   00000000   0x0170 0x0122      DC16 368, 290, 400, 285, 432, 280, 448, 275, 496, 270, 528, 265, 560
   \              0x0190 0x011D
   \              0x01B0 0x0118
   \              0x01C0 0x0113
   \              0x01F0 0x010E
   \              0x0210 0x0109
   \              0x0230       
   \   0000001A   0x0104 0x0260      DC16 260, 608, 255, 656, 250, 704, 245, 768, 240, 832, 235, 896, 230
   \              0x00FF 0x0290
   \              0x00FA 0x02C0
   \              0x00F5 0x0300
   \              0x00F0 0x0340
   \              0x00EB 0x0380
   \              0x00E6       
   \   00000034   0x03D0 0x00E1      DC16 976, 225, 1056, 220, 1136, 215, 1248, 210, 1344, 205, 1472, 200
   \              0x0420 0x00DC
   \              0x0470 0x00D7
   \              0x04E0 0x00D2
   \              0x0540 0x00CD
   \              0x05C0 0x00C8
   \   0000004C   0x0640 0x00C3      DC16 1600, 195, 1744, 190, 1920, 185, 2096, 180, 2288, 175, 2496, 170
   \              0x06D0 0x00BE
   \              0x0780 0x00B9
   \              0x0830 0x00B4
   \              0x08F0 0x00AF
   \              0x09C0 0x00AA
   \   00000064   0x0AB0 0x00A5      DC16 2736, 165, 2992, 160, 3280, 155, 3584, 150, 3920, 145, 4288, 140
   \              0x0BB0 0x00A0
   \              0x0CD0 0x009B
   \              0x0E00 0x0096
   \              0x0F50 0x0091
   \              0x10C0 0x008C
   \   0000007C   0x1250 0x0087      DC16 4688, 135, 5120, 130, 5568, 125, 6064, 120, 6576, 115, 7120, 110
   \              0x1400 0x0082
   \              0x15C0 0x007D
   \              0x17B0 0x0078
   \              0x19B0 0x0073
   \              0x1BD0 0x006E
   \   00000094   0x1E00 0x0069      DC16 7680, 105, 8256, 100, 8848, 95, 9456, 90, 10048, 85, 10640, 80
   \              0x2040 0x0064
   \              0x2290 0x005F
   \              0x24F0 0x005A
   \              0x2740 0x0055
   \              0x2990 0x0050
   \   000000AC   0x2BE0 0x004B      DC16 11232, 75, 11792, 70, 12320, 65, 12816, 60, 13280, 55, 13712, 50
   \              0x2E10 0x0046
   \              0x3020 0x0041
   \              0x3210 0x003C
   \              0x33E0 0x0037
   \              0x3590 0x0032
   \   000000C4   0x3710 0x002D      DC16 14096, 45, 14448, 40, 14752, 35, 15024, 30, 15264, 25, 15456, 20
   \              0x3870 0x0028
   \              0x39A0 0x0023
   \              0x3AB0 0x001E
   \              0x3BA0 0x0019
   \              0x3C60 0x0014
   \   000000DC   0x3D10 0x000F      DC16 15632, 15, 15760, 10, 15888, 5, 15984, 0, 16064, -5, 16128, -10
   \              0x3D90 0x000A
   \              0x3E10 0x0005
   \              0x3E70 0x0000
   \              0x3EC0 0xFFFB
   \              0x3F00 0xFFF6
   \   000000F4   0x3F40 0xFFF1      DC16 16192, -15, 16256, -20, 16320, -25
   \              0x3F80 0xFFEC
   \              0x3FC0 0xFFE7

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4902             LDR.N    R1,??degHotend_0
   \   00000002   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000006   0x6BC0             LDR      R0,[R0, #+60]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??degHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degBed()
   \                     _ZN11Temperature6degBedEv: (+1)
   \   00000000   0x4801             LDR.N    R0,??degBed_0
   \   00000002   0x6C40             LDR      R0,[R0, #+68]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??degBed_0:
   \   00000008   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4902             LDR.N    R1,??degTargetHotend_0
   \   00000002   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000006   0x6C80             LDR      R0,[R0, #+72]
   \   00000008   0x.... 0x....      B.W      __aeabi_i2f
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetBed()
   \                     _ZN11Temperature12degTargetBedEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetBed_0
   \   00000002   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000006   0x.... 0x....      B.W      __aeabi_i2f
   \   0000000A   0xBF00             Nop      
   \                     ??degTargetBed_0:
   \   0000000C   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000004   0x.... 0x....      BL       __aeabi_f2iz
   \   00000008   0x4904             LDR.N    R1,??setTargetHotend_0
   \   0000000A   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   0000000E   0x6488             STR      R0,[R1, #+72]
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \   0000001A   0xBF00             Nop      
   \                     ??setTargetHotend_0:
   \   0000001C   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4809             LDR.N    R0,??setTargetBed_0
   \   00000006   0xF9B0 0x5032      LDRSH    R5,[R0, #+50]
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       __aeabi_i2f
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD202             BCS.N    ??setTargetBed_1
   \   0000001A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000001E   0x4605             MOV      R5,R0
   \                     ??setTargetBed_1: (+1)
   \   00000020   0x4803             LDR.N    R0,??setTargetBed_0+0x4
   \   00000022   0x8485             STRH     R5,[R0, #+36]

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000024   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      _ZN11Temperature18start_watching_bedEv
   \                     ??setTargetBed_0:
   \   0000002C   0x........         DC32     mksCfg
   \   00000030   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 2
   \   __interwork __softfp void Temperature::updatePID()
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     29          #include "thermistortables.h"
     30          #include "ultralcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_update()
   \                     _Z10lcd_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_buttons_update()
   \                     _Z18lcd_buttons_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     31          #include "planner.h"

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless
     32          #include "language.h"
     33          #include "adc.h"
     34          #include "tim.h"
     35          #include "spi.h"
     36          #if ENABLED(HEATER_0_USES_MAX6675)
     37            //#include "MarlinSPI.h"
     38          #endif
     39          
     40          #if ENABLED(BABYSTEPPING)
     41            #include "stepper.h"
     42          #endif
     43          
     44          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     45            #include "endstops.h"
     46          #endif
     47          
     48          #if ENABLED(USE_WATCHDOG)
     49            #include "watchdog.h"
     50          #endif
     51          
     52          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     53            static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     54            static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
     55          #else

   \                                 In section .data, align 4
     56            static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     57            static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   \                     heater_ttbllen_map:
   \   00000000   0x40 0x40          DC8 64, 64
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 temptable_1, temptable_1
   \              0x........   
     58          #endif
     59          
     60          extern volatile uint8_t temper_error_type;
     61          

   \                                 In section .bss, align 4
     62          Temperature thermalManager;
   \                     thermalManager:
   \   00000000                      DS8 4
     63          extern volatile uint8_t loop_start;
     64          // public:
     65          
     66          float Temperature::current_temperature[HOTENDS] = { 0.0 },
     67                Temperature::current_temperature_bed = 0.0;
     68          int Temperature::current_temperature_raw[HOTENDS] = { 0 },
     69                  Temperature::target_temperature[HOTENDS] = { 0 },
     70                  Temperature::current_temperature_bed_raw = 0;
     71          
     72          #if HAS_HEATER_BED
     73            int16_t Temperature::target_temperature_bed = 0;
     74          #endif
     75          
     76          // Initialized by settings.load()
     77          #if 1//ENABLED(PIDTEMP)
     78            #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     79              float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
     80              #if ENABLED(PID_EXTRUSION_SCALING)
     81                float Temperature::Kc[HOTENDS];
     82              #endif
     83            #else
     84              float Temperature::Kp, Temperature::Ki, Temperature::Kd;
     85              #if ENABLED(PID_EXTRUSION_SCALING)
     86                float Temperature::Kc;
     87              #endif
     88            #endif
     89          #endif
     90          
     91          // Initialized by settings.load()
     92          #if 1//ENABLED(PIDTEMPBED)
     93            float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd;
     94          #endif
     95          
     96          #if ENABLED(BABYSTEPPING)
     97            volatile int Temperature::babystepsTodo[XYZ] = { 0 };
     98          #endif
     99          
    100          #if WATCH_HOTENDS
    101            uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
    102            millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
    103          #endif
    104          
    105          #if WATCH_THE_BED
    106            uint16_t Temperature::watch_target_bed_temp = 0;
    107            millis_t Temperature::watch_bed_next_ms = 0;
    108          #endif
    109          
    110          #if ENABLED(PREVENT_COLD_EXTRUSION)

   \                                 In section .bss, align 1
    111            bool Temperature::allow_cold_extrude = false;
   \                     _ZN11Temperature18allow_cold_extrudeE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    112            int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
                                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     _ZN11Temperature16extrude_min_tempE:
   \   00000000                      DS8 2
    113          #endif
    114          
    115          // private:
    116          
    117          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    118            uint16_t Temperature::redundant_temperature_raw = 0;
    119            float Temperature::redundant_temperature = 0.0;
    120          #endif
    121          
    122          volatile bool Temperature::temp_meas_ready = false;
    123          
    124          #if 1//ENABLED(PIDTEMP)

   \                                 In section .bss, align 4
    125            float Temperature::temp_iState[HOTENDS] = { 0 },
    126                  Temperature::temp_dState[HOTENDS] = { 0 },
    127                  Temperature::pTerm[HOTENDS],
    128                  Temperature::iTerm[HOTENDS],
    129                  Temperature::dTerm[HOTENDS];
    130          
    131            #if ENABLED(PID_EXTRUSION_SCALING)
    132              float Temperature::cTerm[HOTENDS];
    133              long Temperature::last_e_position;
    134              long Temperature::lpq[LPQ_MAX_LEN];
    135              int Temperature::lpq_ptr = 0;
    136            #endif
    137          
    138            float Temperature::pid_error[HOTENDS];
    139            bool Temperature::pid_reset[HOTENDS];
   \                     _ZN11Temperature9pid_resetE:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     _ZN11Temperature11temp_iStateE:
   \   00000004                      DS8 8
   \                     _ZN11Temperature11temp_dStateE:
   \   0000000C                      DS8 8
   \                     _ZN11Temperature5pTermE:
   \   00000014                      DS8 8
   \                     _ZN11Temperature5iTermE:
   \   0000001C                      DS8 8
   \                     _ZN11Temperature5dTermE:
   \   00000024                      DS8 8
   \                     _ZN11Temperature9pid_errorE:
   \   0000002C                      DS8 8
    140          #endif
    141          #if 0
    142          #if ENABLED(PIDTEMPBED)
    143            float Temperature::temp_iState_bed = { 0 },
    144                  Temperature::temp_dState_bed = { 0 },
    145                  Temperature::pTerm_bed,
    146                  Temperature::iTerm_bed,
    147                  Temperature::dTerm_bed,
    148                  Temperature::pid_error_bed;
    149          #else
    150            millis_t Temperature::next_bed_check_ms;
    151          #endif
    152          #endif

   \                                 In section .bss, align 4
    153          float Temperature::temp_iState_bed = { 0 },
   \                     _ZN11Temperature15temp_iState_bedE:
   \   00000000                      DS8 4
    154          	  Temperature::temp_dState_bed = { 0 },
   \                     _ZN11Temperature15temp_dState_bedE:
   \   00000004                      DS8 4
    155          	  Temperature::pTerm_bed,
   \                     _ZN11Temperature9pTerm_bedE:
   \   00000008                      DS8 4
    156          	  Temperature::iTerm_bed,
   \                     _ZN11Temperature9iTerm_bedE:
   \   0000000C                      DS8 4
    157          	  Temperature::dTerm_bed,
   \                     _ZN11Temperature9dTerm_bedE:
   \   00000010                      DS8 4
    158          	  Temperature::pid_error_bed;
   \                     _ZN11Temperature13pid_error_bedE:
   \   00000014                      DS8 4
    159          millis_t Temperature::next_bed_check_ms;
    160          
    161          
    162          uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
    163                   Temperature::raw_temp_bed_value = 0;
    164          
    165          // Init min and max temp with extreme values to prevent false errors during startup
    166          int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
    167                  Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
    168                  Temperature::minttemp[HOTENDS] = { 0 },
    169                  Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
    170          
    171          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
    172            uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
    173          #endif
    174          
    175          #ifdef MILLISECONDS_PREHEAT_TIME
    176            millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
    177          #endif
    178          
    179          #ifdef BED_MINTEMP
    180            int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
    181          #endif
    182          
    183          #ifdef BED_MAXTEMP
    184            int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
    185          #endif
    186          
    187          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    188            int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
    189          #endif
    190          
    191          #if HAS_AUTO_FAN
    192            millis_t Temperature::next_auto_fan_check_ms = 0;
    193          #endif
    194          
    195          uint8_t Temperature::soft_pwm_amount[HOTENDS],
    196                  Temperature::soft_pwm_amount_bed;
    197          
    198          #if ENABLED(FAN_SOFT_PWM)
    199            uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
    200                    Temperature::soft_pwm_count_fan[FAN_COUNT];
    201          #endif
    202          
    203          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    204            uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
    205          #endif
    206          
    207          #if ENABLED(PROBING_HEATERS_OFF)
    208            bool Temperature::paused;
    209          #endif
    210          
    211          #if HEATER_IDLE_HANDLER
    212            millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
    213            bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
    214            #if 1//HAS_TEMP_BED
    215              millis_t Temperature::bed_idle_timeout_ms = 0;
    216              bool Temperature::bed_idle_timeout_exceeded = false;
    217            #endif
    218          #endif
    219          
    220          #if ENABLED(ADC_KEYPAD)
    221            uint32_t Temperature::current_ADCKey_raw = 0;
    222            uint8_t Temperature::ADCKey_count = 0;
    223          #endif
    224          
    225          #if 1//HAS_PID_HEATING
    226          
    227            /**
    228             * PID Autotuning (M303)
    229             *
    230             * Alternately heat and cool the nozzle, observing its behavior to
    231             * determine the best PID values to achieve a stable temperature.
    232             */

   \                                 In section .text, align 2, keep-with-next
    233            void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
   \                     _ZN11Temperature12PID_autotuneEfaab: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
    234              float input = 0.0;
   \   00000006   0xF04F 0x0A00      MOV      R10,#+0
    235              int cycles = 0;
   \   0000000A   0x4650             MOV      R0,R10
   \   0000000C   0x9004             STR      R0,[SP, #+16]
    236              bool heating = true;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0020      STRB     R0,[SP, #+32]
    237          
    238              millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x9003             STR      R0,[SP, #+12]
   \   0000001A   0x900C             STR      R0,[SP, #+48]
   \   0000001C   0x9803             LDR      R0,[SP, #+12]
   \   0000001E   0x900B             STR      R0,[SP, #+44]
    239              long t_high = 0, t_low = 0;
   \   00000020   0x4650             MOV      R0,R10
   \   00000022   0x900A             STR      R0,[SP, #+40]
    240          
    241              long bias, d;
    242              float Ku, Tu,
    243                    workKp = 0, workKi = 0, workKd = 0,
   \   00000024   0x4680             MOV      R8,R0
   \   00000026   0x4681             MOV      R9,R0
   \   00000028   0x4683             MOV      R11,R0
    244                    max = 0, min = 10000;
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable57_1  ;; 0x461c4000
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable57_2
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0x7844             LDRB     R4,[R0, #+1]
   \   0000003A   0x.... 0x....      LDR.W    R5,??DataTable57_3
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD016             BEQ.N    ??PID_autotune_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00000046   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD010             BEQ.N    ??PID_autotune_0
    245          
    246              #if WATCH_THE_BED || WATCH_HOTENDS
    247                float watch_temp_target ;//= temp -
    248                  #if ENABLED(THERMAL_PROTECTION_BED) /*&& ENABLED(PIDTEMPBED) */&& ENABLED(THERMAL_PROTECTION_HOTENDS) /*&& ENABLED(PIDTEMP)*/
    249                      if((PIDTEMPBED)&&(PIDTEMP))
    250                          watch_temp_target = temp - (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1));
   \   0000004E   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD502             BPL.N    ??PID_autotune_1
   \   00000056   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000058   0x1CC0             ADDS     R0,R0,#+3
   \   0000005A   0xE001             B.N      ??PID_autotune_2
   \                     ??PID_autotune_1: (+1)
   \   0000005C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005E   0x1CC0             ADDS     R0,R0,#+3
   \                     ??PID_autotune_2: (+1)
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x9811             LDR      R0,[SP, #+68]
   \   00000068   0x.... 0x....      BL       __aeabi_fsub
   \   0000006C   0x9009             STR      R0,[SP, #+36]
   \   0000006E   0xE014             B.N      ??PID_autotune_3
    251                      else
    252                      {
    253                       #if ENABLED(THERMAL_PROTECTION_BED) /*&& ENABLED(PIDTEMPBED)*/
    254                          if(PIDTEMPBED)
   \                     ??PID_autotune_0: (+1)
   \   00000070   0x2C00             CMP      R4,#+0
   \   00000072   0xD009             BEQ.N    ??PID_autotune_4
    255                              watch_temp_target = temp - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
   \   00000074   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000076   0x1CC0             ADDS     R0,R0,#+3
   \   00000078   0x.... 0x....      BL       __aeabi_i2f
   \   0000007C   0x4601             MOV      R1,R0
   \   0000007E   0x9811             LDR      R0,[SP, #+68]
   \   00000080   0x.... 0x....      BL       __aeabi_fsub
   \   00000084   0x9009             STR      R0,[SP, #+36]
   \   00000086   0xE008             B.N      ??PID_autotune_3
    256                          else
    257                              watch_temp_target = temp - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
   \                     ??PID_autotune_4: (+1)
   \   00000088   0x78A8             LDRB     R0,[R5, #+2]
   \   0000008A   0x1CC0             ADDS     R0,R0,#+3
   \   0000008C   0x.... 0x....      BL       __aeabi_i2f
   \   00000090   0x4601             MOV      R1,R0
   \   00000092   0x9811             LDR      R0,[SP, #+68]
   \   00000094   0x.... 0x....      BL       __aeabi_fsub
   \   00000098   0x9009             STR      R0,[SP, #+36]
    258                       #else
    259                          watch_temp_target = temp - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
    260                       #endif
    261                      }
    262                  #endif
    263                
    264               // int8_t watch_temp_period;// =
    265                   uint32_t watch_temp_period;
    266                  #if ENABLED(THERMAL_PROTECTION_BED)/* && ENABLED(PIDTEMPBED)*/ && ENABLED(THERMAL_PROTECTION_HOTENDS) /*&& ENABLED(PIDTEMP)*/
    267                      if((PIDTEMPBED)&&(PIDTEMP))
   \                     ??PID_autotune_3: (+1)
   \   0000009A   0x2C00             CMP      R4,#+0
   \   0000009C   0xD012             BEQ.N    ??PID_autotune_5
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000000A2   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD00C             BEQ.N    ??PID_autotune_5
    268                      {
    269                          watch_temp_period = hotend < 0 ? WATCH_BED_TEMP_PERIOD : WATCH_TEMP_PERIOD;
   \   000000AA   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD502             BPL.N    ??PID_autotune_6
   \   000000B2   0xF9B5 0x0008      LDRSH    R0,[R5, #+8]
   \   000000B6   0xE003             B.N      ??PID_autotune_7
   \                     ??PID_autotune_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000000BC   0xF9B0 0x00E4      LDRSH    R0,[R0, #+228]
   \                     ??PID_autotune_7: (+1)
   \   000000C0   0x9007             STR      R0,[SP, #+28]
   \   000000C2   0xE00A             B.N      ??PID_autotune_8
    270                      }
    271                      else
    272                      {
    273                          #if ENABLED(THERMAL_PROTECTION_BED)/* && ENABLED(PIDTEMPBED)*/
    274                              if(PIDTEMPBED)
   \                     ??PID_autotune_5: (+1)
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD003             BEQ.N    ??PID_autotune_9
    275                                watch_temp_period = WATCH_BED_TEMP_PERIOD;
   \   000000C8   0xF9B5 0x0008      LDRSH    R0,[R5, #+8]
   \   000000CC   0x9007             STR      R0,[SP, #+28]
   \   000000CE   0xE004             B.N      ??PID_autotune_8
    276                              else
    277                                watch_temp_period = WATCH_TEMP_PERIOD;  
   \                     ??PID_autotune_9: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000000D4   0xF9B0 0x00E4      LDRSH    R0,[R0, #+228]
   \   000000D8   0x9007             STR      R0,[SP, #+28]
    278                          #else
    279                              watch_temp_period = WATCH_TEMP_PERIOD;
    280                          #endif
    281                      }
    282                  #endif
    283                int8_t watch_temp_increase; //=
    284                  #if ENABLED(THERMAL_PROTECTION_BED) /*&& ENABLED(PIDTEMPBED) */&& ENABLED(THERMAL_PROTECTION_HOTENDS) /*&& ENABLED(PIDTEMP)*/
    285                      if((PIDTEMPBED)&&(PIDTEMP))
   \                     ??PID_autotune_8: (+1)
   \   000000DA   0x2C00             CMP      R4,#+0
   \   000000DC   0xD011             BEQ.N    ??PID_autotune_10
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000000E2   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD00B             BEQ.N    ??PID_autotune_10
    286                      {
    287                          watch_temp_increase = hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE;
   \   000000EA   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD503             BPL.N    ??PID_autotune_11
   \   000000F2   0xF995 0x000A      LDRSB    R0,[R5, #+10]
   \   000000F6   0x9006             STR      R0,[SP, #+24]
   \   000000F8   0xE00C             B.N      ??PID_autotune_12
   \                     ??PID_autotune_11: (+1)
   \   000000FA   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   000000FE   0x9006             STR      R0,[SP, #+24]
   \   00000100   0xE008             B.N      ??PID_autotune_12
    288                      }
    289                      else
    290                      {
    291                          #if ENABLED(THERMAL_PROTECTION_BED)
    292                              if(PIDTEMPBED)
   \                     ??PID_autotune_10: (+1)
   \   00000102   0x2C00             CMP      R4,#+0
   \   00000104   0xD003             BEQ.N    ??PID_autotune_13
    293                                  watch_temp_increase = WATCH_BED_TEMP_INCREASE;
   \   00000106   0xF995 0x000A      LDRSB    R0,[R5, #+10]
   \   0000010A   0x9006             STR      R0,[SP, #+24]
   \   0000010C   0xE002             B.N      ??PID_autotune_12
    294                               else
    295                                  watch_temp_increase = WATCH_TEMP_INCREASE;
   \                     ??PID_autotune_13: (+1)
   \   0000010E   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   00000112   0x9006             STR      R0,[SP, #+24]
   \                     ??PID_autotune_12: (+1)
   \   00000114   0x9803             LDR      R0,[SP, #+12]
   \   00000116   0x9907             LDR      R1,[SP, #+28]
   \   00000118   0xF44F 0x727A      MOV      R2,#+1000
   \   0000011C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000120   0x900F             STR      R0,[SP, #+60]
    296                          #else
    297                              watch_temp_increase = WATCH_TEMP_INCREASE;
    298                          #endif
    299                      }
    300                #endif
    301                millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
    302                float next_watch_temp = 0.0;
   \   00000122   0x4640             MOV      R0,R8
   \   00000124   0x900E             STR      R0,[SP, #+56]
    303                bool heated = false;
   \   00000126   0x9005             STR      R0,[SP, #+20]
    304              #endif
    305          
    306              #if HAS_AUTO_FAN
    307                next_auto_fan_check_ms = next_temp_ms + 2500UL;
    308              #endif
    309          #if 0
    310              #if ENABLED(PIDTEMP)
    311                #define _TOP_HOTEND HOTENDS - 1
    312              #else
    313                #define _TOP_HOTEND -1
    314              #endif
    315              #if ENABLED(PIDTEMPBED)
    316                #define _BOT_HOTEND -1
    317              #else
    318                #define _BOT_HOTEND 0
    319              #endif
    320          
    321          
    322          
    323              if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
    324                SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
    325                return;
    326              }
    327          #endif	
    328          	if(PIDTEMP == 0 && PIDTEMPBED == 0) if(hotend >= 0 || hotend < 0) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable56
   \   0000012C   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD106             BNE.N    ??PID_autotune_14
   \   00000134   0x2C00             CMP      R4,#+0
   \   00000136   0xD104             BNE.N    ??PID_autotune_14
   \   00000138   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   0000013C   0x2900             CMP      R1,#+0
   \   0000013E   0xD519             BPL.N    ??PID_autotune_15
   \   00000140   0xD418             BMI.N    ??PID_autotune_15
    329          	if(PIDTEMP == 0 && PIDTEMPBED == 1) if(hotend >= 0 || hotend < -1) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_14: (+1)
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD105             BNE.N    ??PID_autotune_16
   \   00000146   0x2C01             CMP      R4,#+1
   \   00000148   0xD103             BNE.N    ??PID_autotune_16
   \   0000014A   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   0000014E   0x1C49             ADDS     R1,R1,#+1
   \   00000150   0xD110             BNE.N    ??PID_autotune_15
    330          	if(PIDTEMP == 1 && PIDTEMPBED == 0) if(hotend >= HOTENDS|| hotend < 0) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_16: (+1)
   \   00000152   0x2801             CMP      R0,#+1
   \   00000154   0xD105             BNE.N    ??PID_autotune_17
   \   00000156   0x2C00             CMP      R4,#+0
   \   00000158   0xD103             BNE.N    ??PID_autotune_17
   \   0000015A   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   0000015E   0x2902             CMP      R1,#+2
   \   00000160   0xD208             BCS.N    ??PID_autotune_15
    331          	if(PIDTEMP == 1 && PIDTEMPBED == 1) if(hotend >= HOTENDS|| hotend < -1) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_17: (+1)
   \   00000162   0x2801             CMP      R0,#+1
   \   00000164   0xD114             BNE.N    ??PID_autotune_18
   \   00000166   0x2C01             CMP      R4,#+1
   \   00000168   0xD112             BNE.N    ??PID_autotune_18
   \   0000016A   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   0000016E   0x1C40             ADDS     R0,R0,#+1
   \   00000170   0x2803             CMP      R0,#+3
   \   00000172   0xD30D             BCC.N    ??PID_autotune_18
   \                     ??PID_autotune_15: (+1)
   \   00000174   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune failed! ...">`
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   0000017C   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000180   0x210A             MOVS     R1,#+10
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   00000186   0xB015             ADD      SP,SP,#+84
   \   00000188   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000018C   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??PID_autotune_18: (+1)
   \   00000190   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune start">`
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable57_4
    332          
    333              SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
   \   00000198   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000019C   0x210A             MOVS     R1,#+10
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000001A2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    334          
    335              disable_all_heaters(); // switch off all heaters.
   \   000001A6   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
    336          #if 0
    337              #if HAS_PID_FOR_BOTH
    338                if (hotend < 0)
    339                  soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    340                else
    341                  soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
    342              #elif ENABLED(PIDTEMP)
    343                soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
    344              #else
    345                soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    346              #endif
    347          #endif
    348          	if (HAS_PID_FOR_BOTH) {
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000001AE   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD013             BEQ.N    ??PID_autotune_19
   \   000001B6   0x9900             LDR      R1,[SP, #+0]
   \   000001B8   0x7849             LDRB     R1,[R1, #+1]
   \   000001BA   0x2900             CMP      R1,#+0
   \   000001BC   0xD00F             BEQ.N    ??PID_autotune_19
    349                if (hotend < 0)
   \   000001BE   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   000001C2   0x.... 0x....      LDR.W    R4,??DataTable58
   \   000001C6   0x2900             CMP      R1,#+0
   \   000001C8   0xD504             BPL.N    ??PID_autotune_20
    350                  soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
   \   000001CA   0x257F             MOVS     R5,#+127
   \   000001CC   0x462E             MOV      R6,R5
   \   000001CE   0x4628             MOV      R0,R5
   \   000001D0   0x70E0             STRB     R0,[R4, #+3]
   \   000001D2   0xE013             B.N      ??PID_autotune_21
    351                else
    352                  soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;}
   \                     ??PID_autotune_20: (+1)
   \   000001D4   0x257F             MOVS     R5,#+127
   \   000001D6   0x462E             MOV      R6,R5
   \   000001D8   0x4628             MOV      R0,R5
   \   000001DA   0x5508             STRB     R0,[R1, R4]
   \   000001DC   0xE00E             B.N      ??PID_autotune_21
    353          	else if(PIDTEMP)	soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
   \                     ??PID_autotune_19: (+1)
   \   000001DE   0x.... 0x....      LDR.W    R4,??DataTable58
   \   000001E2   0x2800             CMP      R0,#+0
   \   000001E4   0xD006             BEQ.N    ??PID_autotune_22
   \   000001E6   0x257F             MOVS     R5,#+127
   \   000001E8   0x462E             MOV      R6,R5
   \   000001EA   0x4628             MOV      R0,R5
   \   000001EC   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   000001F0   0x5508             STRB     R0,[R1, R4]
   \   000001F2   0xE003             B.N      ??PID_autotune_21
    354          	else soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
   \                     ??PID_autotune_22: (+1)
   \   000001F4   0x257F             MOVS     R5,#+127
   \   000001F6   0x462E             MOV      R6,R5
   \   000001F8   0x4628             MOV      R0,R5
   \   000001FA   0x70E0             STRB     R0,[R4, #+3]
   \                     ??PID_autotune_21: (+1)
   \   000001FC   0x2001             MOVS     R0,#+1
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable57_5
   \   00000202   0x7008             STRB     R0,[R1, #+0]
   \   00000204   0xE001             B.N      ??PID_autotune_23
    355          
    356              wait_for_heatup = true;
    357          
    358              // PID Tuning loop
    359              while (wait_for_heatup) {
    360          
    361                const millis_t ms = millis();
    362          
    363                if (temp_meas_ready) { // temp sample ready
    364                  updateTemperaturesFromRawValues();
    365          #if 0
    366                  input =
    367                    #if HAS_PID_FOR_BOTH
    368                      hotend < 0 ? current_temperature_bed : current_temperature[hotend]
    369                    #elif ENABLED(PIDTEMP)
    370                      current_temperature[hotend]
    371                    #else
    372                      current_temperature_bed
    373                    #endif
    374                  ;
    375          #endif
    376          		if(HAS_PID_FOR_BOTH) 	input = hotend < 0 ? current_temperature_bed : current_temperature[hotend];
    377          		else if(PIDTEMP) 		input = current_temperature[hotend];
    378          		else					input = current_temperature_bed;
    379          
    380                  NOLESS(max, input);
    381                  NOMORE(min, input);
    382          
    383                  #if HAS_AUTO_FAN
    384                    if (ELAPSED(ms, next_auto_fan_check_ms)) {
    385                      checkExtruderAutoFans();
    386                      next_auto_fan_check_ms = ms + 2500UL;
    387                    }
    388                  #endif
    389          
    390                  if (heating && input > temp) {
    391                    if (ELAPSED(ms, t2 + 5000UL)) {
    392                      heating = false;
    393          			#if 0
    394                      #if HAS_PID_FOR_BOTH
    395                        if (hotend < 0)
    396                          soft_pwm_amount_bed = (bias - d) >> 1;
    397                        else
    398                          soft_pwm_amount[hotend] = (bias - d) >> 1;
    399                      #elif ENABLED(PIDTEMP)
    400                        soft_pwm_amount[hotend] = (bias - d) >> 1;
    401                      #elif ENABLED(PIDTEMPBED)
    402                        soft_pwm_amount_bed = (bias - d) >> 1;
    403                      #endif
    404          			#endif
    405          			if(HAS_PID_FOR_BOTH)	{if (hotend < 0) soft_pwm_amount_bed = (bias - d) >> 1; else soft_pwm_amount[hotend] = (bias - d) >> 1;}
    406          			else if(PIDTEMP)		soft_pwm_amount[hotend] = (bias - d) >> 1;
    407          			else					soft_pwm_amount_bed = (bias - d) >> 1;
    408          			
    409                      t1 = ms;
    410                      t_high = t1 - t2;
    411                      max = temp;
    412                    }
    413                  }
    414          
    415                  if (!heating && input < temp) {
    416                    if (ELAPSED(ms, t1 + 5000UL)) {
    417                      heating = true;
    418                      t2 = ms;
    419                      t_low = t2 - t1;
    420                      if (cycles > 0) {
    421          			  #if 0
    422                        long max_pow =
    423                          #if HAS_PID_FOR_BOTH
    424                            hotend < 0 ? MAX_BED_POWER : PID_MAX
    425                          #elif ENABLED(PIDTEMP)
    426                            PID_MAX
    427                          #else
    428                            MAX_BED_POWER
    429                          #endif
    430          				
    431                        ;
    432          			  #endif
    433                        long max_pow;
    434                        if(HAS_PID_FOR_BOTH)	 max_pow = hotend < 0 ? MAX_BED_POWER : PID_MAX;
    435                        else if(PIDTEMP)	 max_pow = PID_MAX;
    436                        else 			 max_pow = MAX_BED_POWER;
    437          			  
    438                        bias += (d * (t_high - t_low)) / (t_low + t_high);
    439                        bias = constrain(bias, 20, max_pow - 20);
    440                        d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
    441          
    442                        SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
    443                        SERIAL_PROTOCOLPAIR(MSG_D, d);
    444                        SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
    445                        SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
    446                        if (cycles > 2) {
    447                          Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
    448                          Tu = ((float)(t_low + t_high) * 0.001);
    449                          SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
    450                          SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
    451                          workKp = 0.6 * Ku;
    452                          workKi = 2 * workKp / Tu;
    453                          workKd = workKp * Tu * 0.125;
    454                          SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
    455                          SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
    456                          SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
    457                          SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
    458                          /**
    459                          workKp = 0.33*Ku;
    460                          workKi = workKp/Tu;
    461                          workKd = workKp*Tu/3;
    462                          SERIAL_PROTOCOLLNPGM(" Some overshoot");
    463                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    464                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    465                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    466                          workKp = 0.2*Ku;
    467                          workKi = 2*workKp/Tu;
    468                          workKd = workKp*Tu/3;
    469                          SERIAL_PROTOCOLLNPGM(" No overshoot");
    470                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    471                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    472                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    473                          */
    474                        }
    475                      }
    476          			/*
    477                      #if HAS_PID_FOR_BOTH
    478                        if (hotend < 0)
    479                          soft_pwm_amount_bed = (bias + d) >> 1;
    480                        else
    481                          soft_pwm_amount[hotend] = (bias + d) >> 1;
    482                      #elif ENABLED(PIDTEMP)
    483                        soft_pwm_amount[hotend] = (bias + d) >> 1;
    484                      #else
    485                        soft_pwm_amount_bed = (bias + d) >> 1;
    486                      #endif
    487                      */
    488          		if(HAS_PID_FOR_BOTH)	{if (hotend < 0) soft_pwm_amount_bed = (bias + d) >> 1; else soft_pwm_amount[hotend] = (bias + d) >> 1;}
    489          		else if(PIDTEMP)		soft_pwm_amount[hotend] = (bias + d) >> 1;
    490          		else					soft_pwm_amount_bed = (bias + d) >> 1;            
    491                      cycles++;
    492                      min = temp;
    493                    }
    494                  }
    495                }
    496                #define MAX_OVERSHOOT_PID_AUTOTUNE 20
    497                if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
    498                  SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
    499                  break;
    500                }
    501                // Every 2 seconds...
    502                if (ELAPSED(ms, next_temp_ms)) {
    503                  #if HAS_TEMP_HOTEND //|| HAS_TEMP_BED
    504                    print_heaterstates();
    505                    SERIAL_EOL();
    506                  #endif
    507          
    508                  next_temp_ms = ms + 2000UL;
    509          
    510                  #if WATCH_THE_BED || WATCH_HOTENDS
    511                    if (!heated && input > next_watch_temp) {
    512                      if (input > watch_temp_target) heated = true;
    513                      next_watch_temp = input + watch_temp_increase;
    514                      temp_change_ms = ms + watch_temp_period * 1000UL;
    515                    }
    516                    else if (!heated && ELAPSED(ms, temp_change_ms))
    517                      _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    518                    else if (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE)
    519                      _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
    520                  #endif
    521                } // every 2 seconds
    522                // Timeout after 20 minutes since the last undershoot/overshoot cycle
    523                if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
    524                  SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
    525                  break;
    526                }
    527                if (cycles > ncycles) {
    528                  SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
    529          /*
    530                  #if HAS_PID_FOR_BOTH
    531                    const char* estring = hotend < 0 ? "bed" : "";
    532                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
    533                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
    534                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
    535                  #elif ENABLED(PIDTEMP)
    536                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
    537                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
    538                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
    539                  #else
    540                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
    541                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
    542                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
    543                  #endif
    544          */
    545          		if(HAS_PID_FOR_BOTH)
    546          		{
    547          			const char* estring = hotend < 0 ? "bed" : "";
    548          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
    549          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
    550          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
    551          		}
    552          		else if(PIDTEMP)
    553          		{
    554          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
    555          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
    556          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
    557          		}
    558          		else
    559          		{
    560          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
    561          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
    562          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
    563          		}
    564          
    565                  #define _SET_BED_PID() do { \
    566                    bedKp = workKp; \
    567                    bedKi = scalePID_i(workKi); \
    568                    bedKd = scalePID_d(workKd); \
    569                    }while(0)
    570          
    571                  #define _SET_EXTRUDER_PID() do { \
    572                    PID_PARAM(Kp, hotend) = workKp; \
    573                    PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
    574                    PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
    575                    updatePID(); }while(0)
    576          
    577                  // Use the result? (As with "M303 U1")
    578                  if (set_result) {
    579          			/*
    580                    #if HAS_PID_FOR_BOTH
    581                      if (hotend < 0)
    582                        _SET_BED_PID();
    583                      else
    584                        _SET_EXTRUDER_PID();
    585                    #elif ENABLED(PIDTEMP)
    586                      _SET_EXTRUDER_PID();
    587                    #else
    588                      _SET_BED_PID();
    589                    #endif
    590                    */
    591          			if(HAS_PID_FOR_BOTH)	if (set_result) {if (hotend < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();}
    592          			else if(PIDTEMP)		if (set_result)  _SET_EXTRUDER_PID();
    593          			else 					if (set_result)  _SET_BED_PID();          
    594                  }
    595                  return;
    596                }
    597                lcd_update();
   \                     ??PID_autotune_24: (+1)
   \   00000206   0x.... 0x....      BL       _Z10lcd_updatev
   \                     ??PID_autotune_23: (+1)
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable57_5
   \   0000020E   0x7800             LDRB     R0,[R0, #+0]
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xF000 0x8140      BEQ.W    ??PID_autotune_25
   \   00000216   0x.... 0x....      BL       HAL_GetTick
   \   0000021A   0x4607             MOV      R7,R0
   \   0000021C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000021E   0x2800             CMP      R0,#+0
   \   00000220   0xF000 0x812C      BEQ.W    ??PID_autotune_26
   \   00000224   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable56
   \   0000022C   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000230   0x2A00             CMP      R2,#+0
   \   00000232   0xD00F             BEQ.N    ??PID_autotune_27
   \   00000234   0x9800             LDR      R0,[SP, #+0]
   \   00000236   0x7840             LDRB     R0,[R0, #+1]
   \   00000238   0x2800             CMP      R0,#+0
   \   0000023A   0xD00B             BEQ.N    ??PID_autotune_27
   \   0000023C   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   00000240   0x2900             CMP      R1,#+0
   \   00000242   0xD502             BPL.N    ??PID_autotune_28
   \   00000244   0xF8D4 0xA044      LDR      R10,[R4, #+68]
   \   00000248   0xE00F             B.N      ??PID_autotune_29
   \                     ??PID_autotune_28: (+1)
   \   0000024A   0xEB04 0x0081      ADD      R0,R4,R1, LSL #+2
   \   0000024E   0xF8D0 0xA03C      LDR      R10,[R0, #+60]
   \   00000252   0xE00A             B.N      ??PID_autotune_29
   \                     ??PID_autotune_27: (+1)
   \   00000254   0x2A00             CMP      R2,#+0
   \   00000256   0xD006             BEQ.N    ??PID_autotune_30
   \   00000258   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   0000025C   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000260   0xF8D0 0xA03C      LDR      R10,[R0, #+60]
   \   00000264   0xE001             B.N      ??PID_autotune_29
   \                     ??PID_autotune_30: (+1)
   \   00000266   0xF8D4 0xA044      LDR      R10,[R4, #+68]
   \                     ??PID_autotune_29: (+1)
   \   0000026A   0x9802             LDR      R0,[SP, #+8]
   \   0000026C   0x4651             MOV      R1,R10
   \   0000026E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000272   0xD201             BCS.N    ??PID_autotune_31
   \   00000274   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \                     ??PID_autotune_31: (+1)
   \   00000278   0x4650             MOV      R0,R10
   \   0000027A   0x9901             LDR      R1,[SP, #+4]
   \   0000027C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000280   0xD201             BCS.N    ??PID_autotune_32
   \   00000282   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \                     ??PID_autotune_32: (+1)
   \   00000286   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   0000028A   0x2800             CMP      R0,#+0
   \   0000028C   0xD01E             BEQ.N    ??PID_autotune_33
   \   0000028E   0x9811             LDR      R0,[SP, #+68]
   \   00000290   0x4651             MOV      R1,R10
   \   00000292   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000296   0xD219             BCS.N    ??PID_autotune_33
   \   00000298   0x980B             LDR      R0,[SP, #+44]
   \   0000029A   0x1A38             SUBS     R0,R7,R0
   \   0000029C   0x.... 0x....      LDR.W    R1,??DataTable58_1  ;; 0xffffec78
   \   000002A0   0x1809             ADDS     R1,R1,R0
   \   000002A2   0xD413             BMI.N    ??PID_autotune_33
   \   000002A4   0x2100             MOVS     R1,#+0
   \   000002A6   0xF88D 0x1020      STRB     R1,[SP, #+32]
   \   000002AA   0x2A00             CMP      R2,#+0
   \   000002AC   0xD036             BEQ.N    ??PID_autotune_34
   \   000002AE   0x9900             LDR      R1,[SP, #+0]
   \   000002B0   0x7849             LDRB     R1,[R1, #+1]
   \   000002B2   0x2900             CMP      R1,#+0
   \   000002B4   0xD032             BEQ.N    ??PID_autotune_34
   \   000002B6   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   000002BA   0x2900             CMP      R1,#+0
   \   000002BC   0xD530             BPL.N    ??PID_autotune_35
   \                     ??PID_autotune_36: (+1)
   \   000002BE   0x1B71             SUBS     R1,R6,R5
   \   000002C0   0x1049             ASRS     R1,R1,#+1
   \   000002C2   0x70E1             STRB     R1,[R4, #+3]
   \                     ??PID_autotune_37: (+1)
   \   000002C4   0x970C             STR      R7,[SP, #+48]
   \   000002C6   0x900A             STR      R0,[SP, #+40]
   \   000002C8   0x9811             LDR      R0,[SP, #+68]
   \   000002CA   0x9002             STR      R0,[SP, #+8]
   \                     ??PID_autotune_33: (+1)
   \   000002CC   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   000002D0   0x2800             CMP      R0,#+0
   \   000002D2   0xF040 0x80D3      BNE.W    ??PID_autotune_26
   \   000002D6   0x4650             MOV      R0,R10
   \   000002D8   0x9911             LDR      R1,[SP, #+68]
   \   000002DA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000002DE   0xF080 0x80CD      BCS.W    ??PID_autotune_26
   \   000002E2   0x980C             LDR      R0,[SP, #+48]
   \   000002E4   0x1A38             SUBS     R0,R7,R0
   \   000002E6   0x.... 0x....      LDR.W    R1,??DataTable58_1  ;; 0xffffec78
   \   000002EA   0x1809             ADDS     R1,R1,R0
   \   000002EC   0xF100 0x80C6      BMI.W    ??PID_autotune_26
   \   000002F0   0x2101             MOVS     R1,#+1
   \   000002F2   0xF88D 0x1020      STRB     R1,[SP, #+32]
   \   000002F6   0x970B             STR      R7,[SP, #+44]
   \   000002F8   0x9904             LDR      R1,[SP, #+16]
   \   000002FA   0x2901             CMP      R1,#+1
   \   000002FC   0xF2C0 0x80A8      BLT.W    ??PID_autotune_38
   \   00000300   0x990A             LDR      R1,[SP, #+40]
   \   00000302   0x1809             ADDS     R1,R1,R0
   \   00000304   0x910D             STR      R1,[SP, #+52]
   \   00000306   0x990A             LDR      R1,[SP, #+40]
   \   00000308   0x1A08             SUBS     R0,R1,R0
   \   0000030A   0x4368             MULS     R0,R0,R5
   \   0000030C   0x990D             LDR      R1,[SP, #+52]
   \   0000030E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000312   0x1986             ADDS     R6,R0,R6
   \   00000314   0x2E14             CMP      R6,#+20
   \   00000316   0xDA09             BGE.N    ??PID_autotune_39
   \   00000318   0x2614             MOVS     R6,#+20
   \   0000031A   0xE00A             B.N      ??PID_autotune_40
   \                     ??PID_autotune_34: (+1)
   \   0000031C   0x2A00             CMP      R2,#+0
   \   0000031E   0xD0CE             BEQ.N    ??PID_autotune_36
   \                     ??PID_autotune_35: (+1)
   \   00000320   0x1B71             SUBS     R1,R6,R5
   \   00000322   0x1049             ASRS     R1,R1,#+1
   \   00000324   0xF99D 0x2048      LDRSB    R2,[SP, #+72]
   \   00000328   0x5511             STRB     R1,[R2, R4]
   \   0000032A   0xE7CB             B.N      ??PID_autotune_37
   \                     ??PID_autotune_39: (+1)
   \   0000032C   0x2EEC             CMP      R6,#+236
   \   0000032E   0xDB00             BLT.N    ??PID_autotune_40
   \   00000330   0x26EB             MOVS     R6,#+235
   \                     ??PID_autotune_40: (+1)
   \   00000332   0x2E80             CMP      R6,#+128
   \   00000334   0xDB02             BLT.N    ??PID_autotune_41
   \   00000336   0xF1C6 0x05FE      RSB      R5,R6,#+254
   \   0000033A   0xE000             B.N      ??PID_autotune_42
   \                     ??PID_autotune_41: (+1)
   \   0000033C   0x4635             MOV      R5,R6
   \                     ??PID_autotune_42: (+1)
   \   0000033E   0x4631             MOV      R1,R6
   \   00000340   0x.... 0x....      ADR.W    R0,`?<Constant " bias: ">`
   \   00000344   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \   00000348   0x4629             MOV      R1,R5
   \   0000034A   0x.... 0x....      ADR.W    R0,`?<Constant " d: ">`
   \   0000034E   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \   00000352   0x9901             LDR      R1,[SP, #+4]
   \   00000354   0x.... 0x....      ADR.W    R0,`?<Constant " min: ">`
   \   00000358   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000035C   0x9902             LDR      R1,[SP, #+8]
   \   0000035E   0x.... 0x....      ADR.W    R0,`?<Constant " max: ">`
   \   00000362   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000366   0x9804             LDR      R0,[SP, #+16]
   \   00000368   0x2803             CMP      R0,#+3
   \   0000036A   0xDB71             BLT.N    ??PID_autotune_38
   \   0000036C   0x4628             MOV      R0,R5
   \   0000036E   0x.... 0x....      BL       __aeabi_i2d
   \   00000372   0x2200             MOVS     R2,#+0
   \   00000374   0x.... 0x....      LDR.W    R3,??DataTable58_2  ;; 0x40100000
   \   00000378   0x.... 0x....      BL       __aeabi_dmul
   \   0000037C   0x4680             MOV      R8,R0
   \   0000037E   0x4689             MOV      R9,R1
   \   00000380   0x9802             LDR      R0,[SP, #+8]
   \   00000382   0x9901             LDR      R1,[SP, #+4]
   \   00000384   0x.... 0x....      BL       __aeabi_fsub
   \   00000388   0x.... 0x....      BL       __aeabi_f2d
   \   0000038C   0x.... 0x....      LDR.W    R2,??DataTable58_3  ;; 0x54442d18
   \   00000390   0x.... 0x....      LDR.W    R3,??DataTable58_4  ;; 0x400921fb
   \   00000394   0x.... 0x....      BL       __aeabi_dmul
   \   00000398   0x2200             MOVS     R2,#+0
   \   0000039A   0x.... 0x....      LDR.W    R3,??DataTable59  ;; 0x3fe00000
   \   0000039E   0x.... 0x....      BL       __aeabi_dmul
   \   000003A2   0x4602             MOV      R2,R0
   \   000003A4   0x460B             MOV      R3,R1
   \   000003A6   0x4640             MOV      R0,R8
   \   000003A8   0x4649             MOV      R1,R9
   \   000003AA   0x.... 0x....      BL       __aeabi_ddiv
   \   000003AE   0x.... 0x....      BL       __aeabi_d2f
   \   000003B2   0x4680             MOV      R8,R0
   \   000003B4   0x980D             LDR      R0,[SP, #+52]
   \   000003B6   0x.... 0x....      BL       __aeabi_i2f
   \   000003BA   0x.... 0x....      BL       __aeabi_f2d
   \   000003BE   0x.... 0x....      LDR.W    R2,??DataTable59_1  ;; 0xd2f1a9fc
   \   000003C2   0x.... 0x....      LDR.W    R3,??DataTable59_2  ;; 0x3f50624d
   \   000003C6   0x.... 0x....      BL       __aeabi_dmul
   \   000003CA   0x.... 0x....      BL       __aeabi_d2f
   \   000003CE   0x4683             MOV      R11,R0
   \   000003D0   0x4641             MOV      R1,R8
   \   000003D2   0x.... 0x....      ADR.W    R0,`?<Constant " Ku: ">`
   \   000003D6   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003DA   0x4659             MOV      R1,R11
   \   000003DC   0x.... 0x....      ADR.W    R0,`?<Constant " Tu: ">`
   \   000003E0   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003E4   0x4640             MOV      R0,R8
   \   000003E6   0x.... 0x....      BL       __aeabi_f2d
   \   000003EA   0xF04F 0x3233      MOV      R2,#+858993459
   \   000003EE   0x.... 0x....      LDR.W    R3,??DataTable59_3  ;; 0x3fe33333
   \   000003F2   0x.... 0x....      BL       __aeabi_dmul
   \   000003F6   0x.... 0x....      BL       __aeabi_d2f
   \   000003FA   0x4680             MOV      R8,R0
   \   000003FC   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000400   0x4641             MOV      R1,R8
   \   00000402   0x.... 0x....      BL       __aeabi_fmul
   \   00000406   0x4659             MOV      R1,R11
   \   00000408   0x.... 0x....      BL       __aeabi_fdiv
   \   0000040C   0x4681             MOV      R9,R0
   \   0000040E   0x4640             MOV      R0,R8
   \   00000410   0x4659             MOV      R1,R11
   \   00000412   0x.... 0x....      BL       __aeabi_fmul
   \   00000416   0xF04F 0x5178      MOV      R1,#+1040187392
   \   0000041A   0x.... 0x....      BL       __aeabi_fmul
   \   0000041E   0x4683             MOV      R11,R0
   \   00000420   0x.... 0x....      ADR.W    R0,`?<Constant "\\n Classic PID \\n">`
   \   00000424   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000428   0x4641             MOV      R1,R8
   \   0000042A   0x.... 0x....      ADR.W    R0,`?<Constant " Kp: ">`
   \   0000042E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000432   0x4649             MOV      R1,R9
   \   00000434   0x.... 0x....      ADR.W    R0,`?<Constant " Ki: ">`
   \   00000438   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000043C   0x4659             MOV      R1,R11
   \   0000043E   0x.... 0x....      ADR.W    R0,`?<Constant " Kd: ">`
   \   00000442   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000446   0x210A             MOVS     R1,#+10
   \   00000448   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   0000044C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??PID_autotune_38: (+1)
   \   00000450   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00000454   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000458   0x2800             CMP      R0,#+0
   \   0000045A   0xD024             BEQ.N    ??PID_autotune_43
   \   0000045C   0x9900             LDR      R1,[SP, #+0]
   \   0000045E   0x7849             LDRB     R1,[R1, #+1]
   \   00000460   0x2900             CMP      R1,#+0
   \   00000462   0xD020             BEQ.N    ??PID_autotune_43
   \   00000464   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   00000468   0x2800             CMP      R0,#+0
   \   0000046A   0xD51E             BPL.N    ??PID_autotune_44
   \                     ??PID_autotune_45: (+1)
   \   0000046C   0x19A8             ADDS     R0,R5,R6
   \   0000046E   0x1040             ASRS     R0,R0,#+1
   \   00000470   0x70E0             STRB     R0,[R4, #+3]
   \                     ??PID_autotune_46: (+1)
   \   00000472   0x9804             LDR      R0,[SP, #+16]
   \   00000474   0x1C40             ADDS     R0,R0,#+1
   \   00000476   0x9004             STR      R0,[SP, #+16]
   \   00000478   0x9811             LDR      R0,[SP, #+68]
   \   0000047A   0x9001             STR      R0,[SP, #+4]
   \                     ??PID_autotune_26: (+1)
   \   0000047C   0x9811             LDR      R0,[SP, #+68]
   \   0000047E   0x.... 0x....      LDR.W    R1,??DataTable61  ;; 0x41a00000
   \   00000482   0x.... 0x....      BL       __aeabi_fadd
   \   00000486   0x4651             MOV      R1,R10
   \   00000488   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000048C   0xD213             BCS.N    ??PID_autotune_47
   \   0000048E   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune failed! ...">_1`
   \   00000492   0x.... 0x....      BL       _Z14serialprintPGMPKc
    598              }
    599              disable_all_heaters();
   \                     ??PID_autotune_25: (+1)
   \   00000496   0xB015             ADD      SP,SP,#+84
   \   00000498   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000049C   0x.... 0x....      B.W      _ZN11Temperature19disable_all_heatersEv
   \                     ??PID_autotune_48: (+1)
   \   000004A0   0xB015             ADD      SP,SP,#+84
   \   000004A2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??PID_autotune_43: (+1)
   \   000004A6   0x2800             CMP      R0,#+0
   \   000004A8   0xD0E0             BEQ.N    ??PID_autotune_45
   \                     ??PID_autotune_44: (+1)
   \   000004AA   0x19A8             ADDS     R0,R5,R6
   \   000004AC   0x1040             ASRS     R0,R0,#+1
   \   000004AE   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   000004B2   0x5508             STRB     R0,[R1, R4]
   \   000004B4   0xE7DD             B.N      ??PID_autotune_46
   \                     ??PID_autotune_47: (+1)
   \   000004B6   0x9803             LDR      R0,[SP, #+12]
   \   000004B8   0x1A38             SUBS     R0,R7,R0
   \   000004BA   0xD44A             BMI.N    ??PID_autotune_49
   \   000004BC   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   \   000004C0   0x210A             MOVS     R1,#+10
   \   000004C2   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000004C6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000004CA   0xF507 0x60FA      ADD      R0,R7,#+2000
   \   000004CE   0x9003             STR      R0,[SP, #+12]
   \   000004D0   0x9805             LDR      R0,[SP, #+20]
   \   000004D2   0x2800             CMP      R0,#+0
   \   000004D4   0xD11A             BNE.N    ??PID_autotune_50
   \   000004D6   0x980E             LDR      R0,[SP, #+56]
   \   000004D8   0x4651             MOV      R1,R10
   \   000004DA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000004DE   0xD215             BCS.N    ??PID_autotune_50
   \   000004E0   0x9809             LDR      R0,[SP, #+36]
   \   000004E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000004E6   0xD201             BCS.N    ??PID_autotune_51
   \   000004E8   0x2001             MOVS     R0,#+1
   \   000004EA   0x9005             STR      R0,[SP, #+20]
   \                     ??PID_autotune_51: (+1)
   \   000004EC   0xA806             ADD      R0,SP,#+24
   \   000004EE   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000004F2   0x.... 0x....      BL       __aeabi_i2f
   \   000004F6   0x4651             MOV      R1,R10
   \   000004F8   0x.... 0x....      BL       __aeabi_fadd
   \   000004FC   0x900E             STR      R0,[SP, #+56]
   \   000004FE   0x9807             LDR      R0,[SP, #+28]
   \   00000500   0xF44F 0x717A      MOV      R1,#+1000
   \   00000504   0xFB01 0x7000      MLA      R0,R1,R0,R7
   \   00000508   0x900F             STR      R0,[SP, #+60]
   \   0000050A   0xE022             B.N      ??PID_autotune_49
   \                     ??PID_autotune_50: (+1)
   \   0000050C   0x9805             LDR      R0,[SP, #+20]
   \   0000050E   0x2800             CMP      R0,#+0
   \   00000510   0xD10A             BNE.N    ??PID_autotune_52
   \   00000512   0x980F             LDR      R0,[SP, #+60]
   \   00000514   0x1A38             SUBS     R0,R7,R0
   \   00000516   0xD407             BMI.N    ??PID_autotune_52
   \   00000518   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   0000051C   0x460A             MOV      R2,R1
   \   0000051E   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   00000522   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   00000526   0xE014             B.N      ??PID_autotune_49
   \                     ??PID_autotune_52: (+1)
   \   00000528   0x9805             LDR      R0,[SP, #+20]
   \   0000052A   0x2800             CMP      R0,#+0
   \   0000052C   0xD011             BEQ.N    ??PID_autotune_49
   \   0000052E   0x9811             LDR      R0,[SP, #+68]
   \   00000530   0x.... 0x....      LDR.W    R1,??DataTable61_1  ;; 0xc1a00000
   \   00000534   0x.... 0x....      BL       __aeabi_fadd
   \   00000538   0x4601             MOV      R1,R0
   \   0000053A   0x4650             MOV      R0,R10
   \   0000053C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000540   0xD207             BCS.N    ??PID_autotune_49
   \   00000542   0x.... 0x....      LDR.W    R2,??DataTable61_2
   \   00000546   0x.... 0x....      LDR.W    R1,??DataTable61_3
   \   0000054A   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   0000054E   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \                     ??PID_autotune_49: (+1)
   \   00000552   0x980C             LDR      R0,[SP, #+48]
   \   00000554   0xEBC0 0x0047      RSB      R0,R0,R7, LSL #+1
   \   00000558   0x990B             LDR      R1,[SP, #+44]
   \   0000055A   0x1A40             SUBS     R0,R0,R1
   \   0000055C   0x.... 0x....      LDR.W    R1,??DataTable61_4  ;; 0x124f81
   \   00000560   0x4288             CMP      R0,R1
   \   00000562   0xD304             BCC.N    ??PID_autotune_53
   \   00000564   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune failed! ...">_2`
   \   00000568   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000056C   0xE793             B.N      ??PID_autotune_25
   \                     ??PID_autotune_53: (+1)
   \   0000056E   0xF99D 0x004C      LDRSB    R0,[SP, #+76]
   \   00000572   0x9904             LDR      R1,[SP, #+16]
   \   00000574   0x4288             CMP      R0,R1
   \   00000576   0xF6BF 0xAE46      BGE.W    ??PID_autotune_24
   \   0000057A   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune finished...">`
   \   0000057E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000582   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00000586   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   0000058A   0x2800             CMP      R0,#+0
   \   0000058C   0xD034             BEQ.N    ??PID_autotune_54
   \   0000058E   0x9900             LDR      R1,[SP, #+0]
   \   00000590   0x7849             LDRB     R1,[R1, #+1]
   \   00000592   0x2900             CMP      R1,#+0
   \   00000594   0xD030             BEQ.N    ??PID_autotune_54
   \   00000596   0xF99D 0x0048      LDRSB    R0,[SP, #+72]
   \   0000059A   0x2800             CMP      R0,#+0
   \   0000059C   0xD501             BPL.N    ??PID_autotune_55
   \   0000059E   0x....             ADR.N    R5,??DataTable52  ;; "bed"
   \   000005A0   0xE000             B.N      ??PID_autotune_56
   \                     ??PID_autotune_55: (+1)
   \   000005A2   0x....             ADR.N    R5,??DataTable52_1  ;; ""
   \                     ??PID_autotune_56: (+1)
   \   000005A4   0x.... 0x....      ADR.W    R6,`?<Constant "#define  DEFAULT_">`
   \   000005A8   0x4629             MOV      R1,R5
   \   000005AA   0x4630             MOV      R0,R6
   \   000005AC   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   000005B0   0x4641             MOV      R1,R8
   \   000005B2   0x....             ADR.N    R0,??DataTable52_2  ;; "Kp "
   \   000005B4   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000005B8   0x210A             MOVS     R1,#+10
   \   000005BA   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000005BE   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000005C2   0x4629             MOV      R1,R5
   \   000005C4   0x4630             MOV      R0,R6
   \   000005C6   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   000005CA   0x4649             MOV      R1,R9
   \   000005CC   0x....             ADR.N    R0,??DataTable52_3  ;; "Ki "
   \   000005CE   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000005D2   0x210A             MOVS     R1,#+10
   \   000005D4   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000005D8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000005DC   0x4629             MOV      R1,R5
   \   000005DE   0x4630             MOV      R0,R6
   \   000005E0   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   000005E4   0x4659             MOV      R1,R11
   \   000005E6   0x....             ADR.N    R0,??DataTable53  ;; "Kd "
   \   000005E8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000005EC   0x210A             MOVS     R1,#+10
   \   000005EE   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000005F2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000005F6   0xE03D             B.N      ??PID_autotune_57
   \                     ??PID_autotune_54: (+1)
   \   000005F8   0x2800             CMP      R0,#+0
   \   000005FA   0x4641             MOV      R1,R8
   \   000005FC   0xD01D             BEQ.N    ??PID_autotune_58
   \   000005FE   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kp ">`
   \   00000602   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000606   0x210A             MOVS     R1,#+10
   \   00000608   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   0000060C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000610   0x4649             MOV      R1,R9
   \   00000612   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Ki ">`
   \   00000616   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000061A   0x210A             MOVS     R1,#+10
   \   0000061C   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   00000620   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000624   0x4659             MOV      R1,R11
   \   00000626   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kd ">`
   \   0000062A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000062E   0x210A             MOVS     R1,#+10
   \   00000630   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   00000634   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000638   0xE01C             B.N      ??PID_autotune_57
   \                     ??PID_autotune_58: (+1)
   \   0000063A   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_bedKp ">`
   \   0000063E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000642   0x210A             MOVS     R1,#+10
   \   00000644   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   00000648   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000064C   0x4649             MOV      R1,R9
   \   0000064E   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_bedKi ">`
   \   00000652   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000656   0x210A             MOVS     R1,#+10
   \   00000658   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   0000065C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000660   0x4659             MOV      R1,R11
   \   00000662   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_bedKd ">`
   \   00000666   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000066A   0x210A             MOVS     R1,#+10
   \   0000066C   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   00000670   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??PID_autotune_57: (+1)
   \   00000674   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \   00000678   0x2800             CMP      R0,#+0
   \   0000067A   0xF43F 0xAF11      BEQ.W    ??PID_autotune_48
   \   0000067E   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00000682   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000686   0x2800             CMP      R0,#+0
   \   00000688   0xF43F 0xAF0A      BEQ.W    ??PID_autotune_48
   \   0000068C   0x9800             LDR      R0,[SP, #+0]
   \   0000068E   0x7840             LDRB     R0,[R0, #+1]
   \   00000690   0x2800             CMP      R0,#+0
   \   00000692   0xF43F 0xAF05      BEQ.W    ??PID_autotune_48
   \   00000696   0xF89D 0x0050      LDRB     R0,[SP, #+80]
   \   0000069A   0x2800             CMP      R0,#+0
   \   0000069C   0xF43F 0xAF00      BEQ.W    ??PID_autotune_48
   \   000006A0   0x4658             MOV      R0,R11
   \   000006A2   0x.... 0x....      BL       __aeabi_f2d
   \   000006A6   0x.... 0x....      LDR.W    R2,??DataTable64  ;; 0x88e368f1
   \   000006AA   0x.... 0x....      LDR.W    R3,??DataTable65  ;; 0x3fc4f8b5
   \   000006AE   0x.... 0x....      BL       __aeabi_ddiv
   \   000006B2   0x.... 0x....      BL       __aeabi_d2f
   \   000006B6   0x4605             MOV      R5,R0
   \   000006B8   0x4648             MOV      R0,R9
   \   000006BA   0x.... 0x....      BL       __aeabi_f2d
   \   000006BE   0x.... 0x....      LDR.W    R2,??DataTable64  ;; 0x88e368f1
   \   000006C2   0x.... 0x....      LDR.W    R3,??DataTable65  ;; 0x3fc4f8b5
   \   000006C6   0x.... 0x....      BL       __aeabi_dmul
   \   000006CA   0x.... 0x....      BL       __aeabi_d2f
   \   000006CE   0xF99D 0x1048      LDRSB    R1,[SP, #+72]
   \   000006D2   0x2900             CMP      R1,#+0
   \   000006D4   0xD408             BMI.N    ??PID_autotune_59
   \   000006D6   0xF8C4 0x8054      STR      R8,[R4, #+84]
   \   000006DA   0x65A0             STR      R0,[R4, #+88]
   \   000006DC   0x65E5             STR      R5,[R4, #+92]
   \   000006DE   0xB015             ADD      SP,SP,#+84
   \   000006E0   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000006E4   0x.... 0x....      B.W      _ZN11Temperature9updatePIDEv
   \                     ??PID_autotune_59: (+1)
   \   000006E8   0xF8C4 0x8060      STR      R8,[R4, #+96]
   \   000006EC   0x6660             STR      R0,[R4, #+100]
   \   000006EE   0x66A5             STR      R5,[R4, #+104]
   \   000006F0   0xE6D6             B.N      ??PID_autotune_48
    600            }
    601          
    602          #endif // HAS_PID_HEATING
    603          
    604          /**
    605           * Class and Instance Methods
    606           */
    607          

   \                                 In section .text, align 2, keep-with-next
    608          Temperature::Temperature() { }
   \                     _ZN11TemperatureC1Ev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    609          

   \                                 In section .text, align 2, keep-with-next
    610          int Temperature::getHeaterPower(int heater) {
    611            return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
   \                     _ZN11Temperature14getHeaterPowerEi: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable58
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD501             BPL.N    ??getHeaterPower_0
   \   00000008   0x78C8             LDRB     R0,[R1, #+3]
   \   0000000A   0x4770             BX       LR
   \                     ??getHeaterPower_0: (+1)
   \   0000000C   0x5C40             LDRB     R0,[R0, R1]
   \   0000000E   0x4770             BX       LR               ;; return
    612          }
    613          
    614          #if HAS_AUTO_FAN
    615          
    616            void Temperature::checkExtruderAutoFans() {
    617              static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
    618              static const uint8_t fanBit[] PROGMEM = {
    619                              0,
    620                AUTO_1_IS_0 ? 0 :               1,
    621                AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
    622                AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
    623                AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
    624              };
    625              uint8_t fanState = 0;
    626          
    627              HOTEND_LOOP()
    628                if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
    629                  SBI(fanState, pgm_read_byte(&fanBit[e]));
    630          
    631              uint8_t fanDone = 0;
    632              for (uint8_t f = 0; f < COUNT(fanPin); f++) {
    633                int8_t pin = pgm_read_byte(&fanPin[f]);
    634                const uint8_t bit = pgm_read_byte(&fanBit[f]);
    635                if (pin >= 0 && !TEST(fanDone, bit)) {
    636                  uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
    637                  // this idiom allows both digital and PWM fan outputs (see M42 handling).
    638                  digitalWrite(pin, newFanSpeed);
    639                  analogWrite(pin, newFanSpeed);
    640                  SBI(fanDone, bit);
    641                }
    642              }
    643            }
    644          
    645          #endif // HAS_AUTO_FAN
    646          
    647          #if 1
    648          extern void temper_error_kill();
    649          #endif//
    650          //
    651          // Temperature Error Handlers
    652          //

   \                                 In section .text, align 2, keep-with-next
    653          void Temperature::_temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg) {
   \                     _ZN11Temperature11_temp_errorEaPKcS1_: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    654            static bool killed = false;
    655            if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01C             BEQ.N    ??_temp_error_0
    656              SERIAL_ERROR_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable66
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
    657              serialprintPGM(serial_msg);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
    658              SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
   \   0000001C   0x.... 0x....      ADR.W    R0,`?<Constant ", system stopped! Hea...">`
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
    659              if (e >= 0) {SERIAL_ERRORLN((int)e);} else {SERIAL_ERRORLNPGM(MSG_HEATER_BED);}
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD40B             BMI.N    ??_temp_error_1
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable57_4
   \   0000002C   0x220A             MOVS     R2,#+10
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000036   0x210A             MOVS     R1,#+10
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000003E   0xE003             B.N      ??_temp_error_0
   \                     ??_temp_error_1: (+1)
   \   00000040   0x.... 0x....      ADR.W    R0,`?<Constant "bed\\n">`
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
    660            }
    661            #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
    662              if (!killed) {
   \                     ??_temp_error_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable68
   \   0000004C   0x7801             LDRB     R1,[R0, #+0]
   \   0000004E   0x2900             CMP      R1,#+0
   \   00000050   0xD109             BNE.N    ??_temp_error_2
    663                Running = false;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable68_1
   \   00000058   0x7011             STRB     R1,[R2, #+0]
    664                killed = true;
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    665                //kill(lcd_msg);
    666                #if 1
    667                temper_error_kill();
   \   0000005E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000062   0x.... 0x....      B.W      _Z17temper_error_killv
    668                #endif
    669              }
    670              else
    671                disable_all_heaters(); // paranoia
   \                     ??_temp_error_2: (+1)
   \   00000066   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000006A   0x.... 0x....      B.W      _ZN11Temperature19disable_all_heatersEv
    672            #endif
    673          }

   \                                 In section .bss, align 1
   \                     ??killed:
   \   00000000                      DS8 1
    674          

   \                                 In section .text, align 2, keep-with-next
    675          void Temperature::max_temp_error(const int8_t e) {
   \                     _ZN11Temperature14max_temp_errorEa: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    676            //#if HAS_TEMP_BED
    677            if(HAS_TEMP_BED)
   \   00000002   0x....             LDR.N    R1,??DataTable56
   \   00000004   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD00F             BEQ.N    ??max_temp_error_0
    678            {
    679              _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD402             BMI.N    ??max_temp_error_1
   \   00000010   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP">`
   \   00000014   0xE001             B.N      ??max_temp_error_2
   \                     ??max_temp_error_1: (+1)
   \   00000016   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP BED">`
   \                     ??max_temp_error_2: (+1)
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "MAXTEMP triggered">`
   \   0000001E   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    680              temper_error_type=1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0xBD01             POP      {R0,PC}
    681            }
    682            //#else
    683            else
    684            {
    685              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
   \                     ??max_temp_error_0: (+1)
   \   0000002C   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP">`
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant "MAXTEMP triggered">`
   \   00000034   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    686              #if HOTENDS == 1
    687                UNUSED(e);
    688              #endif
    689              temper_error_type=2;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    690             }
    691            //#endif
    692          }
   \   00000040   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    693          void Temperature::min_temp_error(const int8_t e) {
   \                     _ZN11Temperature14min_temp_errorEa: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    694            //#if HAS_TEMP_BED
    695            if(HAS_TEMP_BED)
   \   00000002   0x....             LDR.N    R1,??DataTable56
   \   00000004   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD00F             BEQ.N    ??min_temp_error_0
    696            {
    697              _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD402             BMI.N    ??min_temp_error_1
   \   00000010   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MINTEMP">`
   \   00000014   0xE001             B.N      ??min_temp_error_2
   \                     ??min_temp_error_1: (+1)
   \   00000016   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MINTEMP BED">`
   \                     ??min_temp_error_2: (+1)
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "MINTEMP triggered">`
   \   0000001E   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    698              temper_error_type=3;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0xBD01             POP      {R0,PC}
    699            }
    700            //#else
    701            else
    702            {
    703              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
   \                     ??min_temp_error_0: (+1)
   \   0000002C   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MINTEMP">`
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant "MINTEMP triggered">`
   \   00000034   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    704              #if HOTENDS == 1
    705                UNUSED(e);
    706              #endif
    707              temper_error_type=4;
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    708            }
    709            //#endif
    710          }
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    711          

   \                                 In section .text, align 2, keep-with-next
    712          float Temperature::get_pid_output(const int8_t e) {
   \                     _ZN11Temperature14get_pid_outputEa: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
    713            #if HOTENDS == 1
    714              UNUSED(e);
    715              #define _HOTEND_TEST     true
    716            #else
    717              #define _HOTEND_TEST     e == active_extruder
    718            #endif
    719            float pid_output;
    720            //#if ENABLED(PIDTEMP)
    721            if(PIDTEMP) {
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable58
   \   0000000C   0xEB09 0x0584      ADD      R5,R9,R4, LSL #+2
   \   00000010   0xF8D5 0xA048      LDR      R10,[R5, #+72]
   \   00000014   0x4650             MOV      R0,R10
   \   00000016   0x.... 0x....      BL       __aeabi_i2f
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0xF8D5 0x803C      LDR      R8,[R5, #+60]
   \   00000020   0x....             LDR.N    R0,??DataTable56
   \   00000022   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF000 0x808E      BEQ.W    ??get_pid_output_0
    722              #if DISABLED(PID_OPENLOOP)
    723                pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x4641             MOV      R1,R8
   \   00000030   0x.... 0x....      BL       __aeabi_fsub
   \   00000034   0x4605             MOV      R5,R0
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable68_3
   \   0000003A   0xEB06 0x0784      ADD      R7,R6,R4, LSL #+2
   \   0000003E   0x62FD             STR      R5,[R7, #+44]
    724                dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + PID_K1 * dTerm[HOTEND_INDEX];
   \   00000040   0xF8D9 0x005C      LDR      R0,[R9, #+92]
   \   00000044   0x.... 0x....      BL       __aeabi_f2d
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable68_4  ;; 0x999999a0
   \   0000004C   0x.... 0x....      LDR.W    R3,??DataTable68_5  ;; 0x3fa99999
   \   00000050   0x.... 0x....      BL       __aeabi_dmul
   \   00000054   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x68F9             LDR      R1,[R7, #+12]
   \   0000005C   0x.... 0x....      BL       __aeabi_fsub
   \   00000060   0x.... 0x....      BL       __aeabi_f2d
   \   00000064   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000068   0x.... 0x....      BL       __aeabi_dmul
   \   0000006C   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000070   0x6A78             LDR      R0,[R7, #+36]
   \   00000072   0x.... 0x....      BL       __aeabi_f2d
   \   00000076   0xF04F 0x3266      MOV      R2,#+1717986918
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable68_6  ;; 0x3fee6666
   \   0000007E   0x.... 0x....      BL       __aeabi_dmul
   \   00000082   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000086   0x.... 0x....      BL       __aeabi_dadd
   \   0000008A   0x.... 0x....      BL       __aeabi_d2f
   \   0000008E   0x4683             MOV      R11,R0
   \   00000090   0xF8C7 0xB024      STR      R11,[R7, #+36]
    725                temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
   \   00000094   0xF8C7 0x800C      STR      R8,[R7, #+12]
    726                #if HEATER_IDLE_HANDLER
    727                  if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
    728                    pid_output = 0;
    729                    pid_reset[HOTEND_INDEX] = true;
    730                  }
    731                  else
    732                #endif
    733                if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
   \   00000098   0x4628             MOV      R0,R5
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable68_7  ;; 0x42200001
   \   0000009E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000A2   0xD804             BHI.N    ??get_pid_output_1
    734                  pid_output = BANG_MAX;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable68_8  ;; 0x437f0000
    735                  pid_reset[HOTEND_INDEX] = true;
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x55A1             STRB     R1,[R4, R6]
   \   000000AC   0xE054             B.N      ??get_pid_output_2
    736                }
    737                else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
    738                  #if HEATER_IDLE_HANDLER
    739                    || heater_idle_timeout_exceeded[HOTEND_INDEX]
    740                  #endif
    741                  ) {
   \                     ??get_pid_output_1: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable68_9  ;; 0xc2200000
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B6   0xD302             BCC.N    ??get_pid_output_3
   \   000000B8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000BC   0xD103             BNE.N    ??get_pid_output_4
    742                  pid_output = 0;
   \                     ??get_pid_output_3: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
    743                  pid_reset[HOTEND_INDEX] = true;
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0x55A1             STRB     R1,[R4, R6]
   \   000000C4   0xE048             B.N      ??get_pid_output_2
    744                }
    745                else {
    746                  if (pid_reset[HOTEND_INDEX]) {
   \                     ??get_pid_output_4: (+1)
   \   000000C6   0x5DA0             LDRB     R0,[R4, R6]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD002             BEQ.N    ??get_pid_output_5
    747                    temp_iState[HOTEND_INDEX] = 0.0;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x6078             STR      R0,[R7, #+4]
    748                    pid_reset[HOTEND_INDEX] = false;
   \   000000D0   0x55A0             STRB     R0,[R4, R6]
    749                  }
    750                  pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
   \                     ??get_pid_output_5: (+1)
   \   000000D2   0xF8D9 0x0054      LDR      R0,[R9, #+84]
   \   000000D6   0x4629             MOV      R1,R5
   \   000000D8   0x.... 0x....      BL       __aeabi_fmul
   \   000000DC   0x4604             MOV      R4,R0
   \   000000DE   0x617C             STR      R4,[R7, #+20]
    751                  temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
   \   000000E0   0x6878             LDR      R0,[R7, #+4]
   \   000000E2   0x4629             MOV      R1,R5
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x4606             MOV      R6,R0
   \   000000EA   0x607E             STR      R6,[R7, #+4]
    752                  iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
   \   000000EC   0xF8D9 0x0058      LDR      R0,[R9, #+88]
   \   000000F0   0x4631             MOV      R1,R6
   \   000000F2   0x.... 0x....      BL       __aeabi_fmul
   \   000000F6   0x4601             MOV      R1,R0
   \   000000F8   0x61F9             STR      R1,[R7, #+28]
    753          
    754                  pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       __aeabi_fadd
   \   00000100   0x4659             MOV      R1,R11
   \   00000102   0x.... 0x....      BL       __aeabi_fsub
    755          
    756                  #if ENABLED(PID_EXTRUSION_SCALING)
    757                    cTerm[HOTEND_INDEX] = 0;
    758                    if (_HOTEND_TEST) {
    759                      long e_position = stepper.position(E_AXIS);
    760                      if (e_position > last_e_position) {
    761                        lpq[lpq_ptr] = e_position - last_e_position;
    762                        last_e_position = e_position;
    763                      }
    764                      else {
    765                        lpq[lpq_ptr] = 0;
    766                      }
    767                      if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
    768                      cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
    769                      pid_output += cTerm[HOTEND_INDEX];
    770                    }
    771                  #endif // PID_EXTRUSION_SCALING
    772          
    773                  if (pid_output > PID_MAX) {
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable68_10  ;; 0x437f0001
   \   0000010A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000010E   0xD80C             BHI.N    ??get_pid_output_6
    774                    if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \   00000110   0x4628             MOV      R0,R5
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000118   0xD204             BCS.N    ??get_pid_output_7
   \   0000011A   0x4630             MOV      R0,R6
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x.... 0x....      BL       __aeabi_fsub
   \   00000122   0x6078             STR      R0,[R7, #+4]
    775                    pid_output = PID_MAX;
   \                     ??get_pid_output_7: (+1)
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable68_8  ;; 0x437f0000
   \   00000128   0xE016             B.N      ??get_pid_output_2
    776                  }
    777                  else if (pid_output < 0) {
   \                     ??get_pid_output_6: (+1)
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000130   0xD212             BCS.N    ??get_pid_output_2
    778                    if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \   00000132   0x4628             MOV      R0,R5
   \   00000134   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000138   0xD204             BCS.N    ??get_pid_output_8
   \   0000013A   0x4630             MOV      R0,R6
   \   0000013C   0x4629             MOV      R1,R5
   \   0000013E   0x.... 0x....      BL       __aeabi_fsub
   \   00000142   0x6078             STR      R0,[R7, #+4]
    779                    pid_output = 0;
   \                     ??get_pid_output_8: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE007             B.N      ??get_pid_output_2
    780                  }
    781                }
    782            	}
    783              #else
    784                pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
    785              #endif // PID_OPENLOOP
    786          
    787              #if ENABLED(PID_DEBUG)
    788                SERIAL_ECHO_START();
    789                SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
    790                SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
    791                SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
    792                SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
    793                SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
    794                SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
    795                #if ENABLED(PID_EXTRUSION_SCALING)
    796                  SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
    797                #endif
    798                SERIAL_EOL();
    799              #endif // PID_DEBUG
    800          
    801            //#else /* PID off */
    802            else
    803            {
    804              #if HEATER_IDLE_HANDLER
    805                if (heater_idle_timeout_exceeded[HOTEND_INDEX])
    806                  pid_output = 0;
    807                else
    808              #endif
    809              pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
   \                     ??get_pid_output_0: (+1)
   \   00000148   0x4640             MOV      R0,R8
   \   0000014A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000014E   0xD202             BCS.N    ??get_pid_output_9
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable68_8  ;; 0x437f0000
   \   00000154   0xE000             B.N      ??get_pid_output_2
   \                     ??get_pid_output_9: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
    810            }
    811            //#endif
    812          
    813            return pid_output;
   \                     ??get_pid_output_2: (+1)
   \   00000158   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    814          }
    815          
    816          #if 1//ENABLED(PIDTEMPBED)

   \                                 In section .text, align 2, keep-with-next
    817            float Temperature::get_pid_output_bed() {
   \                     _ZN11Temperature18get_pid_output_bedEv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    818              float pid_output;
    819              #if DISABLED(PID_OPENLOOP)
    820                pid_error_bed = target_temperature_bed - current_temperature_bed;
   \   00000004   0x.... 0x....      LDR.W    R10,??DataTable58
   \   00000008   0xF8DA 0x8044      LDR      R8,[R10, #+68]
   \   0000000C   0xF9BA 0x0024      LDRSH    R0,[R10, #+36]
   \   00000010   0x.... 0x....      BL       __aeabi_i2f
   \   00000014   0x4641             MOV      R1,R8
   \   00000016   0x.... 0x....      BL       __aeabi_fsub
   \   0000001A   0x4604             MOV      R4,R0
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable68_11
   \   00000020   0x616C             STR      R4,[R5, #+20]
    821                pTerm_bed = bedKp * pid_error_bed;
   \   00000022   0xF8DA 0x0060      LDR      R0,[R10, #+96]
   \   00000026   0x4621             MOV      R1,R4
   \   00000028   0x.... 0x....      BL       __aeabi_fmul
   \   0000002C   0x4606             MOV      R6,R0
   \   0000002E   0x60AE             STR      R6,[R5, #+8]
    822                temp_iState_bed += pid_error_bed;
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x4621             MOV      R1,R4
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4607             MOV      R7,R0
   \   0000003A   0x602F             STR      R7,[R5, #+0]
    823                iTerm_bed = bedKi * temp_iState_bed;
   \   0000003C   0xF8DA 0x0064      LDR      R0,[R10, #+100]
   \   00000040   0x4639             MOV      R1,R7
   \   00000042   0x.... 0x....      BL       __aeabi_fmul
   \   00000046   0x4681             MOV      R9,R0
   \   00000048   0xF8C5 0x900C      STR      R9,[R5, #+12]
    824          
    825                dTerm_bed = PID_K2 * bedKd * (current_temperature_bed - temp_dState_bed) + PID_K1 * dTerm_bed;
   \   0000004C   0xF8DA 0x0068      LDR      R0,[R10, #+104]
   \   00000050   0x.... 0x....      BL       __aeabi_f2d
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable68_4  ;; 0x999999a0
   \   00000058   0x.... 0x....      LDR.W    R3,??DataTable68_5  ;; 0x3fa99999
   \   0000005C   0x.... 0x....      BL       __aeabi_dmul
   \   00000060   0x4682             MOV      R10,R0
   \   00000062   0x468B             MOV      R11,R1
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0x6869             LDR      R1,[R5, #+4]
   \   00000068   0x.... 0x....      BL       __aeabi_fsub
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x4652             MOV      R2,R10
   \   00000072   0x465B             MOV      R3,R11
   \   00000074   0x.... 0x....      BL       __aeabi_dmul
   \   00000078   0x4682             MOV      R10,R0
   \   0000007A   0x468B             MOV      R11,R1
   \   0000007C   0x6928             LDR      R0,[R5, #+16]
   \   0000007E   0x.... 0x....      BL       __aeabi_f2d
   \   00000082   0xF04F 0x3266      MOV      R2,#+1717986918
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable68_6  ;; 0x3fee6666
   \   0000008A   0x.... 0x....      BL       __aeabi_dmul
   \   0000008E   0x4652             MOV      R2,R10
   \   00000090   0x465B             MOV      R3,R11
   \   00000092   0x.... 0x....      BL       __aeabi_dadd
   \   00000096   0x.... 0x....      BL       __aeabi_d2f
   \   0000009A   0x4682             MOV      R10,R0
   \   0000009C   0xF8C5 0xA010      STR      R10,[R5, #+16]
    826                temp_dState_bed = current_temperature_bed;
   \   000000A0   0xF8C5 0x8004      STR      R8,[R5, #+4]
    827          
    828                pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
   \   000000A4   0x4630             MOV      R0,R6
   \   000000A6   0x4649             MOV      R1,R9
   \   000000A8   0x.... 0x....      BL       __aeabi_fadd
   \   000000AC   0x4651             MOV      R1,R10
   \   000000AE   0x.... 0x....      BL       __aeabi_fsub
    829                if (pid_output > MAX_BED_POWER) {
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable68_10  ;; 0x437f0001
   \   000000B6   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000BA   0xD80C             BHI.N    ??get_pid_output_bed_0
    830                  if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
   \   000000BC   0x4620             MOV      R0,R4
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000C4   0xD204             BCS.N    ??get_pid_output_bed_1
   \   000000C6   0x4638             MOV      R0,R7
   \   000000C8   0x4621             MOV      R1,R4
   \   000000CA   0x.... 0x....      BL       __aeabi_fsub
   \   000000CE   0x6028             STR      R0,[R5, #+0]
    831                  pid_output = MAX_BED_POWER;
   \                     ??get_pid_output_bed_1: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable68_8  ;; 0x437f0000
   \   000000D4   0xE00D             B.N      ??get_pid_output_bed_2
    832                }
    833                else if (pid_output < 0) {
   \                     ??get_pid_output_bed_0: (+1)
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000DC   0xD209             BCS.N    ??get_pid_output_bed_2
    834                  if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E4   0xD204             BCS.N    ??get_pid_output_bed_3
   \   000000E6   0x4638             MOV      R0,R7
   \   000000E8   0x4621             MOV      R1,R4
   \   000000EA   0x.... 0x....      BL       __aeabi_fsub
   \   000000EE   0x6028             STR      R0,[R5, #+0]
    835                  pid_output = 0;
   \                     ??get_pid_output_bed_3: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
    836                }
    837              #else
    838                pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    839              #endif // PID_OPENLOOP
    840          
    841              #if ENABLED(PID_BED_DEBUG)
    842                SERIAL_ECHO_START();
    843                SERIAL_ECHOPGM(" PID_BED_DEBUG ");
    844                SERIAL_ECHOPGM(": Input ");
    845                SERIAL_ECHO(current_temperature_bed);
    846                SERIAL_ECHOPGM(" Output ");
    847                SERIAL_ECHO(pid_output);
    848                SERIAL_ECHOPGM(" pTerm ");
    849                SERIAL_ECHO(pTerm_bed);
    850                SERIAL_ECHOPGM(" iTerm ");
    851                SERIAL_ECHO(iTerm_bed);
    852                SERIAL_ECHOPGM(" dTerm ");
    853                SERIAL_ECHOLN(dTerm_bed);
    854              #endif // PID_BED_DEBUG
    855          
    856              return pid_output;
   \                     ??get_pid_output_bed_2: (+1)
   \   000000F2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    857            }
    858          #endif // PIDTEMPBED
    859          
    860          /**
    861           * Manage heating activities for extruder hot-ends and a heated bed
    862           *  - Acquire updated temperature readings
    863           *    - Also resets the watchdog timer
    864           *  - Invoke thermal runaway protection
    865           *  - Manage extruder auto-fan
    866           *  - Apply filament width to the extrusion rate (may move)
    867           *  - Update the heated bed PID output value
    868           */
    869          static float current_temper_bak;
    870          

   \                                 In section .text, align 2, keep-with-next
    871          void Temperature::manage_heater() {
   \                     _ZN11Temperature13manage_heaterEv: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
    872          
    873            if (!temp_meas_ready) return;
   \   00000004   0x....             LDR.N    R6,??DataTable58
   \   00000006   0x78B0             LDRB     R0,[R6, #+2]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xF000 0x813F      BEQ.W    ??manage_heater_0
    874          
    875            updateTemperaturesFromRawValues(); // also resets the watchdog
   \   0000000E   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
    876          
    877            //#if ENABLED(HEATER_0_USES_MAX6675)
    878             if(TEMP_SENSOR_0 == sensors_MAX31855)
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable72
   \   00000016   0xF107 0x08E0      ADD      R8,R7,#+224
   \   0000001A   0xF998 0x0016      LDRSB    R0,[R8, #+22]
   \   0000001E   0xF110 0x0F03      CMN      R0,#+3
   \   00000022   0xD13F             BNE.N    ??manage_heater_1
    879             {
    880              if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) 
   \   00000024   0xF9B7 0x0030      LDRSH    R0,[R7, #+48]
   \   00000028   0xF240 0x7107      MOVW     R1,#+1799
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xDA04             BGE.N    ??manage_heater_2
   \   00000030   0x.... 0x....      BL       __aeabi_i2d
   \   00000034   0x4604             MOV      R4,R0
   \   00000036   0x460D             MOV      R5,R1
   \   00000038   0xE002             B.N      ??manage_heater_3
   \                     ??manage_heater_2: (+1)
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0x.... 0x....      LDR.W    R5,??DataTable70  ;; 0x409c1c00
   \                     ??manage_heater_3: (+1)
   \   00000040   0xF8D6 0x903C      LDR      R9,[R6, #+60]
   \   00000044   0x4648             MOV      R0,R9
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x4602             MOV      R2,R0
   \   0000004C   0x460B             MOV      R3,R1
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000056   0xD20B             BCS.N    ??manage_heater_4
    881              {
    882                  if(current_temperature[0] == 1800)
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable70_1  ;; 0x44e10000
   \   0000005E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000062   0xD102             BNE.N    ??manage_heater_5
    883                  {
    884                     current_temperature[0] = current_temper_bak;
   \   00000064   0x6FF0             LDR      R0,[R6, #+124]
   \   00000066   0x63F0             STR      R0,[R6, #+60]
   \   00000068   0xE002             B.N      ??manage_heater_4
    885                  }
    886                  else
    887                  {
    888                      max_temp_error(0);
   \                     ??manage_heater_5: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
    889                  }
    890              }
    891              if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
   \                     ??manage_heater_4: (+1)
   \   00000070   0xF9B8 0x0010      LDRSH    R0,[R8, #+16]
   \   00000074   0xF46F 0x7186      MVN      R1,#+268
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xDB04             BLT.N    ??manage_heater_6
   \   0000007C   0x.... 0x....      BL       __aeabi_i2d
   \   00000080   0x4604             MOV      R4,R0
   \   00000082   0x460D             MOV      R5,R1
   \   00000084   0xE003             B.N      ??manage_heater_7
   \                     ??manage_heater_6: (+1)
   \   00000086   0x.... 0x....      LDR.W    R4,??DataTable70_2  ;; 0xa3d70a4
   \   0000008A   0x.... 0x....      LDR.W    R5,??DataTable70_3  ;; 0xc070dfd7
   \                     ??manage_heater_7: (+1)
   \   0000008E   0x6BF0             LDR      R0,[R6, #+60]
   \   00000090   0x.... 0x....      BL       __aeabi_f2d
   \   00000094   0x4622             MOV      R2,R4
   \   00000096   0x462B             MOV      R3,R5
   \   00000098   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000009C   0xD202             BCS.N    ??manage_heater_1
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
    892             }
    893             current_temper_bak = current_temperature[0];
   \                     ??manage_heater_1: (+1)
   \   000000A4   0x6BF0             LDR      R0,[R6, #+60]
   \   000000A6   0x67F0             STR      R0,[R6, #+124]
    894            //#endif
    895          
    896            //#if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
    897              millis_t ms = millis();
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0x4604             MOV      R4,R0
    898            //#endif
    899          
    900            HOTEND_LOOP() {
   \   000000AE   0x2500             MOVS     R5,#+0
   \   000000B0   0xE005             B.N      ??manage_heater_8
    901          
    902              #if HEATER_IDLE_HANDLER
    903                if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
    904                  heater_idle_timeout_exceeded[e] = true;
    905              #endif
    906          
    907              #if ENABLED(THERMAL_PROTECTION_HOTENDS)
    908                // Check for thermal runaway
    909                thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
    910              #endif
    911          
    912              soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
    913          
    914              #if WATCH_HOTENDS
    915          
    916                // Make sure temperature is increasing
    917                if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
    918                  if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
    919                  {
    920                    _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    921                    temper_error_type=5;
    922                  }
    923                  else                                                                 // Start again if the target is still far off
    924                    start_watching_heater(e);
   \                     ??manage_heater_9: (+1)
   \   000000B2   0x4628             MOV      R0,R5
   \   000000B4   0xB2C0             UXTB     R0,R0
   \   000000B6   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \                     ??manage_heater_10: (+1)
   \   000000BA   0x1C6D             ADDS     R5,R5,#+1
   \   000000BC   0xB26D             SXTB     R5,R5
   \                     ??manage_heater_8: (+1)
   \   000000BE   0xF898 0x0017      LDRB     R0,[R8, #+23]
   \   000000C2   0x4285             CMP      R5,R0
   \   000000C4   0xDA53             BGE.N    ??manage_heater_11
   \   000000C6   0xEB06 0x0985      ADD      R9,R6,R5, LSL #+2
   \   000000CA   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   000000CE   0x9002             STR      R0,[SP, #+8]
   \   000000D0   0xF8B7 0x00E0      LDRH     R0,[R7, #+224]
   \   000000D4   0x9001             STR      R0,[SP, #+4]
   \   000000D6   0x4628             MOV      R0,R5
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0xF8D9 0x0048      LDR      R0,[R9, #+72]
   \   000000DE   0x.... 0x....      BL       __aeabi_i2f
   \   000000E2   0x4603             MOV      R3,R0
   \   000000E4   0xF8D9 0x203C      LDR      R2,[R9, #+60]
   \   000000E8   0xF109 0x0184      ADD      R1,R9,#+132
   \   000000EC   0x19A8             ADDS     R0,R5,R6
   \   000000EE   0x3082             ADDS     R0,R0,#+130
   \   000000F0   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt
   \   000000F4   0xF8D9 0xB03C      LDR      R11,[R9, #+60]
   \   000000F8   0xEB06 0x0A45      ADD      R10,R6,R5, LSL #+1
   \   000000FC   0xF9BA 0x001C      LDRSH    R0,[R10, #+28]
   \   00000100   0x.... 0x....      BL       __aeabi_i2f
   \   00000104   0x4659             MOV      R1,R11
   \   00000106   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010A   0xD20F             BCS.N    ??manage_heater_12
   \   0000010C   0xF9BA 0x0020      LDRSH    R0,[R10, #+32]
   \   00000110   0x.... 0x....      BL       __aeabi_i2f
   \   00000114   0x4601             MOV      R1,R0
   \   00000116   0x4658             MOV      R0,R11
   \   00000118   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011C   0xD206             BCS.N    ??manage_heater_12
   \   0000011E   0x4628             MOV      R0,R5
   \   00000120   0x.... 0x....      BL       _ZN11Temperature14get_pid_outputEa
   \   00000124   0x.... 0x....      BL       __aeabi_f2iz
   \   00000128   0x1040             ASRS     R0,R0,#+1
   \   0000012A   0xE000             B.N      ??manage_heater_13
   \                     ??manage_heater_12: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_13: (+1)
   \   0000012E   0x55A8             STRB     R0,[R5, R6]
   \   00000130   0xF8D9 0x006C      LDR      R0,[R9, #+108]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD0C0             BEQ.N    ??manage_heater_10
   \   00000138   0x1A20             SUBS     R0,R4,R0
   \   0000013A   0xD4BE             BMI.N    ??manage_heater_10
   \   0000013C   0xF8BA 0x0030      LDRH     R0,[R10, #+48]
   \   00000140   0x.... 0x....      BL       __aeabi_ui2f
   \   00000144   0x4601             MOV      R1,R0
   \   00000146   0x4689             MOV      R9,R1
   \   00000148   0x4628             MOV      R0,R5
   \   0000014A   0xB2C0             UXTB     R0,R0
   \   0000014C   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000150   0x4649             MOV      R1,R9
   \   00000152   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000156   0xD2AC             BCS.N    ??manage_heater_9
   \   00000158   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   0000015C   0x460A             MOV      R2,R1
   \   0000015E   0x4628             MOV      R0,R5
   \   00000160   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   00000164   0x2005             MOVS     R0,#+5
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   0000016A   0x7008             STRB     R0,[R1, #+0]
   \   0000016C   0xE7A5             B.N      ??manage_heater_10
    925                }
    926                
    927              #endif
    928          
    929              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    930                // Make sure measured temperatures are close together
    931                if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
    932                  _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
    933              #endif
    934          
    935            } // HOTEND_LOOP
    936          
    937            #if HAS_AUTO_FAN
    938              if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
    939                checkExtruderAutoFans();
    940                next_auto_fan_check_ms = ms + 2500UL;
    941              }
    942            #endif
    943          
    944            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    945              /**
    946               * Filament Width Sensor dynamically sets the volumetric multiplier
    947               * based on a delayed measurement of the filament diameter.
    948               */
    949              if (filament_sensor) {
    950                meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
    951                if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
    952                meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
    953                planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
    954              }
    955            #endif // FILAMENT_WIDTH_SENSOR
    956          
    957            #if WATCH_THE_BED
    958              // Make sure temperature is increasing
    959              if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
   \                     ??manage_heater_11: (+1)
   \   0000016E   0x6F70             LDR      R0,[R6, #+116]
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD01A             BEQ.N    ??manage_heater_14
   \   00000174   0x1A20             SUBS     R0,R4,R0
   \   00000176   0xD418             BMI.N    ??manage_heater_14
    960                if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
   \   00000178   0x8CF0             LDRH     R0,[R6, #+38]
   \   0000017A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000017E   0x4601             MOV      R1,R0
   \   00000180   0x460D             MOV      R5,R1
   \   00000182   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \   00000186   0x4629             MOV      R1,R5
   \   00000188   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000018C   0xD20B             BCS.N    ??manage_heater_15
    961                {
    962                  _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
   \   0000018E   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   00000192   0x460A             MOV      R2,R1
   \   00000194   0xF04F 0x30FF      MOV      R0,#-1
   \   00000198   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
    963                  temper_error_type=6;
   \   0000019C   0x2006             MOVS     R0,#+6
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   000001A2   0x7008             STRB     R0,[R1, #+0]
   \   000001A4   0xE001             B.N      ??manage_heater_14
    964                }
    965                else                                                            // Start again if the target is still far off
    966                  start_watching_bed();
   \                     ??manage_heater_15: (+1)
   \   000001A6   0x.... 0x....      BL       _ZN11Temperature18start_watching_bedEv
    967              }
    968            #endif // WATCH_THE_BED
    969          
    970            //#if DISABLED(PIDTEMPBED)
    971          	if(PIDTEMPBED == 0) {  
   \                     ??manage_heater_14: (+1)
   \   000001AA   0xF107 0x0530      ADD      R5,R7,#+48
   \   000001AE   0x7968             LDRB     R0,[R5, #+5]
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD106             BNE.N    ??manage_heater_16
    972              	if (PENDING(ms, next_bed_check_ms)) return;
   \   000001B4   0x6FB0             LDR      R0,[R6, #+120]
   \   000001B6   0x1A20             SUBS     R0,R4,R0
   \   000001B8   0xD468             BMI.N    ??manage_heater_0
    973              	next_bed_check_ms = ms + BED_CHECK_INTERVAL;
   \   000001BA   0xF504 0x5098      ADD      R0,R4,#+4864
   \   000001BE   0x3088             ADDS     R0,R0,#+136
   \   000001C0   0x67B0             STR      R0,[R6, #+120]
    974          	}
    975            //#endif
    976          
    977            //#if HAS_TEMP_BED
    978            if (HAS_TEMP_BED)
   \                     ??manage_heater_16: (+1)
   \   000001C2   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C4   0x2800             CMP      R0,#+0
   \   000001C6   0xD061             BEQ.N    ??manage_heater_0
    979            	{
    980              #if HEATER_IDLE_HANDLER
    981                if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
    982                  bed_idle_timeout_exceeded = true;
    983              #endif
    984          
    985              #if HAS_THERMALLY_PROTECTED_BED
    986          	if(HAS_TEMP_BED)
   \   000001C8   0xD014             BEQ.N    ??manage_heater_17
    987                thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
   \   000001CA   0xF898 0x000A      LDRB     R0,[R8, #+10]
   \   000001CE   0x9002             STR      R0,[SP, #+8]
   \   000001D0   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   000001D4   0x9001             STR      R0,[SP, #+4]
   \   000001D6   0xF04F 0x30FF      MOV      R0,#-1
   \   000001DA   0x9000             STR      R0,[SP, #+0]
   \   000001DC   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \   000001E0   0x.... 0x....      BL       __aeabi_i2f
   \   000001E4   0x4603             MOV      R3,R0
   \   000001E6   0x6C72             LDR      R2,[R6, #+68]
   \   000001E8   0xF106 0x018C      ADD      R1,R6,#+140
   \   000001EC   0xF106 0x0080      ADD      R0,R6,#+128
   \   000001F0   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt
    988              #endif
    989          
    990              #if HEATER_IDLE_HANDLER
    991                if (bed_idle_timeout_exceeded)
    992                {
    993                  soft_pwm_amount_bed = 0;
    994          
    995                  //#if DISABLED(PIDTEMPBED)
    996                  if(PIDTEMPBED == 0)
    997                  {
    998                    WRITE_HEATER_BED(LOW);
    999                  }
   1000                  //#endif
   1001                }
   1002                else
   1003              #endif
   1004              {
   1005              #if 0
   1006                #if ENABLED(PIDTEMPBED)
   1007                  soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
   1008          
   1009                #elif ENABLED(BED_LIMIT_SWITCHING)
   1010                  // Check if temperature is within the correct band
   1011                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
   1012                    if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
   1013                      soft_pwm_amount_bed = 0;
   1014                    else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
   1015                      soft_pwm_amount_bed = MAX_BED_POWER >> 1;
   1016                  }
   1017                  else {
   1018                    soft_pwm_amount_bed = 0;
   1019                    WRITE_HEATER_BED(LOW);
   1020                  }
   1021                #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
   1022                  // Check if temperature is within the correct range
   1023                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
   1024                    soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
   1025                  }
   1026                  else {
   1027                    soft_pwm_amount_bed = 0;
   1028                    WRITE_HEATER_BED(LOW);
   1029                  }
   1030                #endif
   1031          	  #endif
   1032          		if(PIDTEMPBED)
   \                     ??manage_heater_17: (+1)
   \   000001F4   0x6C74             LDR      R4,[R6, #+68]
   \   000001F6   0x.... 0x....      LDR.W    R7,??DataTable72_1  ;; 0x40a00000
   \   000001FA   0x7968             LDRB     R0,[R5, #+5]
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD017             BEQ.N    ??manage_heater_18
   1033          		{
   1034          			float pid_output = get_pid_output_bed();
   \   00000200   0x.... 0x....      BL       _ZN11Temperature18get_pid_output_bedEv
   \   00000204   0x4680             MOV      R8,R0
   1035          			soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)pid_output >> 1 : 0;
   \   00000206   0x4620             MOV      R0,R4
   \   00000208   0x4639             MOV      R1,R7
   \   0000020A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000020E   0xD80C             BHI.N    ??manage_heater_19
   \   00000210   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   00000214   0x.... 0x....      BL       __aeabi_i2f
   \   00000218   0x4621             MOV      R1,R4
   \   0000021A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000021E   0xD804             BHI.N    ??manage_heater_19
   \   00000220   0x4640             MOV      R0,R8
   \   00000222   0x.... 0x....      BL       __aeabi_f2iz
   \   00000226   0x1040             ASRS     R0,R0,#+1
   \   00000228   0xE000             B.N      ??manage_heater_20
   \                     ??manage_heater_19: (+1)
   \   0000022A   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_20: (+1)
   \   0000022C   0x70F0             STRB     R0,[R6, #+3]
   \   0000022E   0xE02D             B.N      ??manage_heater_0
   1036          		}
   1037          		else
   1038          		{
   1039          			// Check if temperature is within the correct range
   1040          			if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) 
   \                     ??manage_heater_18: (+1)
   \   00000230   0x4620             MOV      R0,R4
   \   00000232   0x4639             MOV      R1,R7
   \   00000234   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000238   0xD815             BHI.N    ??manage_heater_21
   \   0000023A   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   0000023E   0x.... 0x....      BL       __aeabi_i2f
   \   00000242   0x4621             MOV      R1,R4
   \   00000244   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000248   0xD80D             BHI.N    ??manage_heater_21
   1041          			{
   1042          		  		soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
   \   0000024A   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \   0000024E   0x.... 0x....      BL       __aeabi_i2f
   \   00000252   0x4601             MOV      R1,R0
   \   00000254   0x4620             MOV      R0,R4
   \   00000256   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000025A   0xD201             BCS.N    ??manage_heater_22
   \   0000025C   0x207F             MOVS     R0,#+127
   \   0000025E   0xE000             B.N      ??manage_heater_23
   \                     ??manage_heater_22: (+1)
   \   00000260   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_23: (+1)
   \   00000262   0x70F0             STRB     R0,[R6, #+3]
   \   00000264   0xE012             B.N      ??manage_heater_0
   1043          			}
   1044          			else 
   1045          			{
   1046          		  		soft_pwm_amount_bed = 0;
   \                     ??manage_heater_21: (+1)
   \   00000266   0x2000             MOVS     R0,#+0
   \   00000268   0x70F0             STRB     R0,[R6, #+3]
   1047          		  		WRITE_HEATER_BED(LOW);
   \   0000026A   0x.... 0x....      LDR.W    R0,??DataTable72_3
   \   0000026E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000270   0x2800             CMP      R0,#+0
   \   00000272   0xD10B             BNE.N    ??manage_heater_0
   \   00000274   0x2200             MOVS     R2,#+0
   \   00000276   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   0000027A   0x8D41             LDRH     R1,[R0, #+42]
   \   0000027C   0x.... 0x....      LDR.W    R0,??DataTable72_5
   \   00000280   0x6D40             LDR      R0,[R0, #+84]
   \   00000282   0xB003             ADD      SP,SP,#+12
   \   00000284   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000288   0x.... 0x....      B.W      HAL_GPIO_WritePin
   1048          			}
   1049          		}	  
   1050              }
   1051            }
   1052            //#endif // HAS_TEMP_BED
   1053          }
   \                     ??manage_heater_0: (+1)
   \   0000028C   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   1054          
   1055          //#define PGM_RD_W(x)   (short)pgm_read_word(&x)
   1056          #define PGM_RD_W(x)   (short)(x)
   1057          
   1058          // Derived from RepRap FiveD extruder::getTemperature()
   1059          // For hot end temperature measurement.

   \                                 In section .text, align 2, keep-with-next
   1060          float Temperature::analog2temp(const int raw, const uint8_t e) {
   \                     _ZN11Temperature11analog2tempEih: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   1061            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1062              if (e > HOTENDS)
   1063            #else
   1064              if (e >= HOTENDS)
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0xF1B9 0x0F02      CMP      R9,#+2
   \   0000000C   0xDB13             BLT.N    ??analog2temp_0
   1065            #endif
   1066              {
   1067                SERIAL_ERROR_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable66
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1068                SERIAL_ERROR((int)e);
   \   00000016   0x220A             MOVS     R2,#+10
   \   00000018   0x4649             MOV      R1,R9
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable72_8
   \   0000001E   0x.... 0x....      BL       _ZN5Print5printEii
   1069                SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant " - Invalid extruder n...">`
   \   00000026   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1070                kill(PSTR(MSG_KILLED));
   \   0000002A   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   0000002E   0x.... 0x....      BL       _Z4killPKc
   1071                return 0.0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE065             B.N      ??analog2temp_1
   1072              }
   1073          
   1074            //#if ENABLED(HEATER_0_USES_MAX6675)
   1075            if(TEMP_SENSOR_0 == sensors_MAX31855)
   \                     ??analog2temp_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable72
   \   0000003A   0xF990 0x00F6      LDRSB    R0,[R0, #+246]
   \   0000003E   0xF110 0x0F03      CMN      R0,#+3
   \   00000042   0xD10D             BNE.N    ??analog2temp_2
   1076              if (e == 0) return 0.25 * raw;
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD10B             BNE.N    ??analog2temp_2
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       __aeabi_i2d
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable72_9  ;; 0x3fd00000
   \   00000054   0x.... 0x....      BL       __aeabi_dmul
   \   00000058   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   0000005C   0x.... 0x....      B.W      __aeabi_d2f
   1077            //#endif
   1078          
   1079            if (heater_ttbl_map[e] != NULL) {
   \                     ??analog2temp_2: (+1)
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable72_10
   \   00000064   0xEB01 0x0089      ADD      R0,R1,R9, LSL #+2
   \   00000068   0x6845             LDR      R5,[R0, #+4]
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD03D             BEQ.N    ??analog2temp_3
   1080              float celsius = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   1081              uint8_t i;
   1082              short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
   1083          
   1084              for (i = 1; i < heater_ttbllen_map[e]; i++) {
   \   00000070   0x2601             MOVS     R6,#+1
   \   00000072   0xE001             B.N      ??analog2temp_4
   \                     ??analog2temp_5: (+1)
   \   00000074   0x1C76             ADDS     R6,R6,#+1
   \   00000076   0xB2F6             UXTB     R6,R6
   \                     ??analog2temp_4: (+1)
   \   00000078   0xF819 0x7001      LDRB     R7,[R9, R1]
   \   0000007C   0x42BE             CMP      R6,R7
   \   0000007E   0xDA29             BGE.N    ??analog2temp_6
   \   00000080   0xF935 0x8026      LDRSH    R8,[R5, R6, LSL #+2]
   \   00000084   0x4544             CMP      R4,R8
   \   00000086   0xDAF5             BGE.N    ??analog2temp_5
   1085                if (PGM_RD_W((*tt)[i][0]) > raw) {
   1086                  celsius = PGM_RD_W((*tt)[i - 1][1]) +
   1087                            (raw - PGM_RD_W((*tt)[i - 1][0])) *
   1088                            (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
   1089                            (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
   \   00000088   0xEB05 0x0986      ADD      R9,R5,R6, LSL #+2
   \   0000008C   0xF939 0xAC04      LDRSH    R10,[R9, #-4]
   \   00000090   0xF1A9 0x0004      SUB      R0,R9,#+4
   \   00000094   0xF9B0 0xB002      LDRSH    R11,[R0, #+2]
   \   00000098   0x4658             MOV      R0,R11
   \   0000009A   0x.... 0x....      BL       __aeabi_i2f
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0xEBA4 0x000A      SUB      R0,R4,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_i2f
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF9B9 0x0002      LDRSH    R0,[R9, #+2]
   \   000000AE   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000B2   0x.... 0x....      BL       __aeabi_i2f
   \   000000B6   0x4621             MOV      R1,R4
   \   000000B8   0x.... 0x....      BL       __aeabi_fmul
   \   000000BC   0x4604             MOV      R4,R0
   \   000000BE   0xEBA8 0x000A      SUB      R0,R8,R10
   \   000000C2   0x.... 0x....      BL       __aeabi_i2f
   \   000000C6   0x4601             MOV      R1,R0
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000CE   0x9900             LDR      R1,[SP, #+0]
   \   000000D0   0x.... 0x....      BL       __aeabi_fadd
   1090                  break;
   1091                }
   1092              }
   1093          
   1094              // Overflow: Set to last value in the table
   1095              if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
   \                     ??analog2temp_6: (+1)
   \   000000D4   0x42BE             CMP      R6,R7
   \   000000D6   0xD114             BNE.N    ??analog2temp_1
   \   000000D8   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   000000DC   0x1F00             SUBS     R0,R0,#+4
   \   000000DE   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000E2   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   000000E6   0x.... 0x....      B.W      __aeabi_i2f
   1096          
   1097              return celsius;
   1098            }
   1099            return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   \                     ??analog2temp_3: (+1)
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       __aeabi_i2d
   \   000000F0   0x2200             MOVS     R2,#+0
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable72_11  ;; 0x3f9f4000
   \   000000F6   0x.... 0x....      BL       __aeabi_dmul
   \   000000FA   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   000000FE   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??analog2temp_1: (+1)
   \   00000102   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1100          }
   1101          
   1102          #if 1//HAS_TEMP_BED
   1103            // Derived from RepRap FiveD extruder::getTemperature()
   1104            // For bed temperature measurement.

   \                                 In section .text, align 2, keep-with-next
   1105            float Temperature::analog2tempBed(const int raw) {
   \                     _ZN11Temperature14analog2tempBedEi: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   1106              #if ENABLED(BED_USES_THERMISTOR)
   1107                float celsius = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   1108                byte i;
   1109          
   1110                for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0x.... 0x....      ADR.W    R5,temptable_1
   \   0000000E   0xE001             B.N      ??analog2tempBed_0
   \                     ??analog2tempBed_1: (+1)
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \   00000012   0xB2E4             UXTB     R4,R4
   \                     ??analog2tempBed_0: (+1)
   \   00000014   0x2C40             CMP      R4,#+64
   \   00000016   0xD22B             BCS.N    ??analog2tempBed_2
   1111                  if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
   \   00000018   0xF935 0x1024      LDRSH    R1,[R5, R4, LSL #+2]
   \   0000001C   0x4589             CMP      R9,R1
   \   0000001E   0xDAF7             BGE.N    ??analog2tempBed_1
   1112                    celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
   1113                               (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
   1114                               (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
   1115                               (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
   \   00000020   0xEB05 0x0684      ADD      R6,R5,R4, LSL #+2
   \   00000024   0x1F37             SUBS     R7,R6,#+4
   \   00000026   0xF9B7 0x0002      LDRSH    R0,[R7, #+2]
   \   0000002A   0x.... 0x....      BL       __aeabi_i2f
   \   0000002E   0x4680             MOV      R8,R0
   \   00000030   0xF936 0x0C04      LDRSH    R0,[R6, #-4]
   \   00000034   0xEBA9 0x0000      SUB      R0,R9,R0
   \   00000038   0x.... 0x....      BL       __aeabi_i2f
   \   0000003C   0x4681             MOV      R9,R0
   \   0000003E   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000042   0xF9B7 0x1002      LDRSH    R1,[R7, #+2]
   \   00000046   0x1A40             SUBS     R0,R0,R1
   \   00000048   0x.... 0x....      BL       __aeabi_i2f
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fmul
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF935 0x0024      LDRSH    R0,[R5, R4, LSL #+2]
   \   00000058   0xF936 0x1C04      LDRSH    R1,[R6, #-4]
   \   0000005C   0x1A40             SUBS     R0,R0,R1
   \   0000005E   0x.... 0x....      BL       __aeabi_i2f
   \   00000062   0x4601             MOV      R1,R0
   \   00000064   0x4638             MOV      R0,R7
   \   00000066   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006A   0x4641             MOV      R1,R8
   \   0000006C   0x.... 0x....      BL       __aeabi_fadd
   1116                    break;
   1117                  }
   1118                }
   1119          
   1120                // Overflow: Set to last value in the table
   1121                if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
   \                     ??analog2tempBed_2: (+1)
   \   00000070   0x2C40             CMP      R4,#+64
   \   00000072   0xD101             BNE.N    ??analog2tempBed_3
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable72_12  ;; 0xc1c80000
   1122          
   1123                return celsius;
   \                     ??analog2tempBed_3: (+1)
   \   00000078   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1124          
   1125              #elif defined(BED_USES_AD595)
   1126          
   1127                return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   1128          
   1129              #else
   1130          
   1131                UNUSED(raw);
   1132                return 0;
   1133          
   1134              #endif
   1135            }
   1136          #endif // HAS_TEMP_BED
   1137          
   1138          /**
   1139           * Get the raw values into the actual temperatures.
   1140           * The raw values are created in interrupt context,
   1141           * and this function is called from normal context
   1142           * as it would block the stepper routine.
   1143           */

   \                                 In section .text, align 4, keep-with-next
   1144          void Temperature::updateTemperaturesFromRawValues() {
   \                     _ZN11Temperature31updateTemperaturesFromRawValuesEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1145            //#if ENABLED(HEATER_0_USES_MAX6675)
   1146          	if(TEMP_SENSOR_0 == sensors_MAX31855)
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable72
   \   00000006   0xF994 0x00F6      LDRSB    R0,[R4, #+246]
   \   0000000A   0xF110 0x0F03      CMN      R0,#+3
   \   0000000E   0xD104             BNE.N    ??updateTemperaturesFromRawValues_0
   1147          	{
   1148              	current_temperature_raw[0] = read_max6675();
   \   00000010   0x.... 0x....      BL       _ZN11Temperature12read_max6675Ev
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable72_13
   \   00000018   0x6348             STR      R0,[R1, #+52]
   1149          	}
   1150            //#endif
   1151            HOTEND_LOOP()
   \                     ??updateTemperaturesFromRawValues_0: (+1)
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE009             B.N      ??updateTemperaturesFromRawValues_1
   1152              current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   \                     ??updateTemperaturesFromRawValues_2: (+1)
   \   0000001E   0xEB06 0x0685      ADD      R6,R6,R5, LSL #+2
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x6B70             LDR      R0,[R6, #+52]
   \   00000028   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   0000002C   0x63F0             STR      R0,[R6, #+60]
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \   00000030   0xB26D             SXTB     R5,R5
   \                     ??updateTemperaturesFromRawValues_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable72_13
   \   00000036   0xF894 0x00F7      LDRB     R0,[R4, #+247]
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xDBEF             BLT.N    ??updateTemperaturesFromRawValues_2
   1153            //#if HAS_TEMP_BED
   1154            if(HAS_TEMP_BED)
   \   0000003E   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??updateTemperaturesFromRawValues_3
   1155            {
   1156              current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
   \   00000046   0x6D30             LDR      R0,[R6, #+80]
   \   00000048   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \   0000004C   0x6470             STR      R0,[R6, #+68]
   1157            }
   1158            //#endif
   1159            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1160              redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   1161            #endif
   1162            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1163              filament_width_meas = analog2widthFil();
   1164            #endif
   1165          
   1166            #if ENABLED(USE_WATCHDOG)
   1167              // Reset the watchdog after we know we have a temperature measurement.
   1168              watchdog_reset();
   1169            #endif
   1170          
   1171            CRITICAL_SECTION_START;
   \                     ??updateTemperaturesFromRawValues_3: (+1)
   \   0000004E   0xB672             cpsid i
   1172            temp_meas_ready = false;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x70B0             STRB     R0,[R6, #+2]
   1173            CRITICAL_SECTION_END;
   \   00000054   0xB662             cpsie i
   1174          }
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   1175          
   1176          
   1177          #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1178          
   1179            // Convert raw Filament Width to millimeters
   1180            float Temperature::analog2widthFil() {
   1181              return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
   1182            }
   1183          
   1184            /**
   1185             * Convert Filament Width (mm) to a simple ratio
   1186             * and reduce to an 8 bit value.
   1187             *
   1188             * A nominal width of 1.75 and measured width of 1.73
   1189             * gives (100 * 1.75 / 1.73) for a ratio of 101 and
   1190             * a return value of 1.
   1191             */
   1192            int8_t Temperature::widthFil_to_size_ratio() {
   1193              if (FABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
   1194                return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
   1195              return 0;
   1196            }
   1197          
   1198          #endif
   1199          
   1200          #if 0//ENABLED(HEATER_0_USES_MAX6675)
   1201            #ifndef MAX6675_SCK_PIN
   1202              #define MAX6675_SCK_PIN SCK_PIN
   1203            #endif
   1204            #ifndef MAX6675_DO_PIN
   1205              #define MAX6675_DO_PIN MISO_PIN
   1206            #endif
   1207            SPI<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
   1208          #endif
   1209          
   1210          /**
   1211           * Initialize the temperature manager
   1212           * The manager is implemented by periodic calls to manage_heater()
   1213           */

   \                                 In section .text, align 2, keep-with-next
   1214          void Temperature::init() {
   \                     _ZN11Temperature4initEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1215          
   1216            #if 0//MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
   1217              // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
   1218              MCUCR = _BV(JTD);
   1219              MCUCR = _BV(JTD);
   1220            #endif
   1221          
   1222            // Finish init of mult hotend arrays
   1223            HOTEND_LOOP() maxttemp[e] = maxttemp[0];
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable68_12
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable72
   \   0000000C   0xF105 0x06F0      ADD      R6,R5,#+240
   \   00000010   0xE005             B.N      ??init_0
   \                     ??init_1: (+1)
   \   00000012   0x8C21             LDRH     R1,[R4, #+32]
   \   00000014   0xB240             SXTB     R0,R0
   \   00000016   0xEB04 0x0240      ADD      R2,R4,R0, LSL #+1
   \   0000001A   0x8411             STRH     R1,[R2, #+32]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \                     ??init_0: (+1)
   \   0000001E   0x4601             MOV      R1,R0
   \   00000020   0xB249             SXTB     R1,R1
   \   00000022   0x79F2             LDRB     R2,[R6, #+7]
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xDBF4             BLT.N    ??init_1
   1224          
   1225            #if 0//ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
   1226              last_e_position = 0;
   1227            #endif
   1228          
   1229            #if HAS_HEATER_0
   1230              SET_OUTPUT(HEATER_0_PIN);
   1231            #endif
   1232            #if HAS_HEATER_1
   1233              SET_OUTPUT(HEATER_1_PIN);
   1234            #endif
   1235            #if HAS_HEATER_2
   1236              SET_OUTPUT(HEATER_2_PIN);
   1237            #endif
   1238            #if HAS_HEATER_3
   1239              SET_OUTPUT(HEATER_3_PIN);
   1240            #endif
   1241            #if HAS_HEATER_4
   1242              SET_OUTPUT(HEATER_3_PIN);
   1243            #endif
   1244            #if HAS_HEATER_BED
   1245              SET_OUTPUT(HEATER_BED_PIN);
   1246            #endif
   1247          
   1248            #if HAS_FAN0
   1249              SET_OUTPUT(FAN_PIN);
   1250              #if ENABLED(FAST_PWM_FAN)
   1251                setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1252              #endif
   1253            #endif
   1254          
   1255            #if HAS_FAN1
   1256              SET_OUTPUT(FAN1_PIN);
   1257              #if ENABLED(FAST_PWM_FAN)
   1258                setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1259              #endif
   1260            #endif
   1261          
   1262            #if HAS_FAN2
   1263              SET_OUTPUT(FAN2_PIN);
   1264              #if ENABLED(FAST_PWM_FAN)
   1265                setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1266              #endif
   1267            #endif
   1268          
   1269            #if 0//ENABLED(HEATER_0_USES_MAX6675)
   1270          
   1271              OUT_WRITE(SCK_PIN, LOW);
   1272              OUT_WRITE(MOSI_PIN, HIGH);
   1273              SET_INPUT_PULLUP(MISO_PIN);
   1274          
   1275              max6675_spi.init();
   1276          
   1277              OUT_WRITE(SS_PIN, HIGH);
   1278              OUT_WRITE(MAX6675_SS, HIGH);
   1279          
   1280            #endif // HEATER_0_USES_MAX6675
   1281          
   1282            #ifdef DIDR2
   1283              #define ANALOG_SELECT(pin) do{ if (pin < 8) SBI(DIDR0, pin); else SBI(DIDR2, pin - 8); }while(0)
   1284            #else
   1285              #define ANALOG_SELECT(pin) do{ SBI(DIDR0, pin); }while(0)
   1286            #endif
   1287          #if 0
   1288            // Set analog inputs
   1289            ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
   1290            DIDR0 = 0;
   1291            #ifdef DIDR2
   1292              DIDR2 = 0;
   1293            #endif
   1294            #if HAS_TEMP_0
   1295              ANALOG_SELECT(TEMP_0_PIN);
   1296            #endif
   1297            #if HAS_TEMP_1
   1298              ANALOG_SELECT(TEMP_1_PIN);
   1299            #endif
   1300            #if HAS_TEMP_2
   1301              ANALOG_SELECT(TEMP_2_PIN);
   1302            #endif
   1303            #if HAS_TEMP_3
   1304              ANALOG_SELECT(TEMP_3_PIN);
   1305            #endif
   1306            #if HAS_TEMP_4
   1307              ANALOG_SELECT(TEMP_4_PIN);
   1308            #endif
   1309            #if HAS_TEMP_BED
   1310              ANALOG_SELECT(TEMP_BED_PIN);
   1311            #endif
   1312            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1313              ANALOG_SELECT(FILWIDTH_PIN);
   1314            #endif
   1315          
   1316            #if HAS_AUTO_FAN_0
   1317              #if E0_AUTO_FAN_PIN == FAN1_PIN
   1318                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1319                #if ENABLED(FAST_PWM_FAN)
   1320                  setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1321                #endif
   1322              #else
   1323                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1324              #endif
   1325            #endif
   1326            #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
   1327              #if E1_AUTO_FAN_PIN == FAN1_PIN
   1328                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1329                #if ENABLED(FAST_PWM_FAN)
   1330                  setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1331                #endif
   1332              #else
   1333                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1334              #endif
   1335            #endif
   1336            #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
   1337              #if E2_AUTO_FAN_PIN == FAN1_PIN
   1338                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1339                #if ENABLED(FAST_PWM_FAN)
   1340                  setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1341                #endif
   1342              #else
   1343                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1344              #endif
   1345            #endif
   1346            #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
   1347              #if E3_AUTO_FAN_PIN == FAN1_PIN
   1348                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1349                #if ENABLED(FAST_PWM_FAN)
   1350                  setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1351                #endif
   1352              #else
   1353                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1354              #endif
   1355            #endif
   1356            #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
   1357              #if E4_AUTO_FAN_PIN == FAN1_PIN
   1358                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1359                #if ENABLED(FAST_PWM_FAN)
   1360                  setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1361                #endif
   1362              #else
   1363                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1364              #endif
   1365            #endif
   1366          
   1367            // Use timer0 for temperature measurement
   1368            // Interleave temperature interrupt with millies interrupt
   1369            OCR0B = 128;
   1370            SBI(TIMSK0, OCIE0B);
   1371          
   1372            // Wait for temperature measurement to settle
   1373            delay(250);
   1374          #endif
   1375            #define TEMP_MIN_ROUTINE(NR) \
   1376              minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
   1377              while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
   1378                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1379                  minttemp_raw[NR] += OVERSAMPLENR; \
   1380                else \
   1381                  minttemp_raw[NR] -= OVERSAMPLENR; \
   1382              }
   1383            #define TEMP_MAX_ROUTINE(NR) \
   1384              maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
   1385              while (analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
   1386                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1387                  maxttemp_raw[NR] -= OVERSAMPLENR; \
   1388                else \
   1389                  maxttemp_raw[NR] += OVERSAMPLENR; \
   1390              }
   1391          
   1392            #ifdef HEATER_0_MINTEMP
   1393              TEMP_MIN_ROUTINE(0);
   \   00000028   0xF8B5 0x00F0      LDRH     R0,[R5, #+240]
   \   0000002C   0x83A0             STRH     R0,[R4, #+28]
   \   0000002E   0xE002             B.N      ??init_2
   \                     ??init_3: (+1)
   \   00000030   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000032   0x3810             SUBS     R0,R0,#+16
   \   00000034   0x82A0             STRH     R0,[R4, #+20]
   \                     ??init_2: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF9B4 0x0014      LDRSH    R0,[R4, #+20]
   \   0000003C   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000040   0x4607             MOV      R7,R0
   \   00000042   0xF9B5 0x00F0      LDRSH    R0,[R5, #+240]
   \   00000046   0x.... 0x....      BL       __aeabi_i2f
   \   0000004A   0x4601             MOV      R1,R0
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000052   0xD3ED             BCC.N    ??init_3
   1394            #endif
   1395            #ifdef HEATER_0_MAXTEMP
   1396              TEMP_MAX_ROUTINE(0);
   \   00000054   0x8E28             LDRH     R0,[R5, #+48]
   \   00000056   0x8420             STRH     R0,[R4, #+32]
   \   00000058   0xE002             B.N      ??init_4
   \                     ??init_5: (+1)
   \   0000005A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000005C   0x3010             ADDS     R0,R0,#+16
   \   0000005E   0x8320             STRH     R0,[R4, #+24]
   \                     ??init_4: (+1)
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xF9B4 0x0018      LDRSH    R0,[R4, #+24]
   \   00000066   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   0000006A   0x4607             MOV      R7,R0
   \   0000006C   0xF9B5 0x0030      LDRSH    R0,[R5, #+48]
   \   00000070   0x.... 0x....      BL       __aeabi_i2f
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007A   0xD3EE             BCC.N    ??init_5
   1397            #endif
   1398            #if HOTENDS > 1
   1399              #ifdef HEATER_1_MINTEMP
   1400                TEMP_MIN_ROUTINE(1);
   \   0000007C   0xF996 0x0002      LDRSB    R0,[R6, #+2]
   \   00000080   0x83E0             STRH     R0,[R4, #+30]
   \   00000082   0xE002             B.N      ??init_6
   \                     ??init_7: (+1)
   \   00000084   0x8AE0             LDRH     R0,[R4, #+22]
   \   00000086   0x3810             SUBS     R0,R0,#+16
   \   00000088   0x82E0             STRH     R0,[R4, #+22]
   \                     ??init_6: (+1)
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0xF9B4 0x0016      LDRSH    R0,[R4, #+22]
   \   00000090   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000094   0x4607             MOV      R7,R0
   \   00000096   0xF996 0x0002      LDRSB    R0,[R6, #+2]
   \   0000009A   0x.... 0x....      BL       __aeabi_i2f
   \   0000009E   0x4601             MOV      R1,R0
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000A6   0xD3ED             BCC.N    ??init_7
   1401              #endif
   1402              #ifdef HEATER_1_MAXTEMP
   1403                TEMP_MAX_ROUTINE(1);
   \   000000A8   0x88B0             LDRH     R0,[R6, #+4]
   \   000000AA   0x8460             STRH     R0,[R4, #+34]
   \   000000AC   0xE002             B.N      ??init_8
   \                     ??init_9: (+1)
   \   000000AE   0x8B60             LDRH     R0,[R4, #+26]
   \   000000B0   0x3010             ADDS     R0,R0,#+16
   \   000000B2   0x8360             STRH     R0,[R4, #+26]
   \                     ??init_8: (+1)
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0xF9B4 0x001A      LDRSH    R0,[R4, #+26]
   \   000000BA   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   000000BE   0x4607             MOV      R7,R0
   \   000000C0   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000C4   0x.... 0x....      BL       __aeabi_i2f
   \   000000C8   0x4639             MOV      R1,R7
   \   000000CA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CE   0xD3EE             BCC.N    ??init_9
   1404              #endif
   1405              #if HOTENDS > 2
   1406                #ifdef HEATER_2_MINTEMP
   1407                  TEMP_MIN_ROUTINE(2);
   1408                #endif
   1409                #ifdef HEATER_2_MAXTEMP
   1410                  TEMP_MAX_ROUTINE(2);
   1411                #endif
   1412                #if HOTENDS > 3
   1413                  #ifdef HEATER_3_MINTEMP
   1414                    TEMP_MIN_ROUTINE(3);
   1415                  #endif
   1416                  #ifdef HEATER_3_MAXTEMP
   1417                    TEMP_MAX_ROUTINE(3);
   1418                  #endif
   1419                  #if HOTENDS > 4
   1420                    #ifdef HEATER_4_MINTEMP
   1421                      TEMP_MIN_ROUTINE(4);
   1422                    #endif
   1423                    #ifdef HEATER_4_MAXTEMP
   1424                      TEMP_MAX_ROUTINE(4);
   1425                    #endif
   1426                  #endif // HOTENDS > 4
   1427                #endif // HOTENDS > 3
   1428              #endif // HOTENDS > 2
   1429            #endif // HOTENDS > 1
   1430          
   1431            //#if HAS_TEMP_BED
   1432            if(HAS_TEMP_BED)
   \   000000D0   0x3530             ADDS     R5,R5,#+48
   \   000000D2   0x79A8             LDRB     R0,[R5, #+6]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD103             BNE.N    ??init_10
   \   000000D8   0xBDF1             POP      {R0,R4-R7,PC}
   1433              {
   1434              #ifdef BED_MINTEMP
   1435                while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
   1436                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1437                    bed_minttemp_raw += OVERSAMPLENR;
   1438                  #else
   1439                    bed_minttemp_raw -= OVERSAMPLENR;
   \                     ??init_11: (+1)
   \   000000DA   0xF1A6 0x0010      SUB      R0,R6,#+16
   \   000000DE   0x8560             STRH     R0,[R4, #+42]
   1440                  #endif
   1441                }
   \                     ??init_10: (+1)
   \   000000E0   0xF9B4 0x602A      LDRSH    R6,[R4, #+42]
   \   000000E4   0x4630             MOV      R0,R6
   \   000000E6   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable72_1  ;; 0x40a00000
   \   000000EE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F2   0xD3F2             BCC.N    ??init_11
   1442              #endif // BED_MINTEMP
   1443              //#ifdef BED_MAXTEMP
   1444              if(BED_MAXTEMP)
   \   000000F4   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD103             BNE.N    ??init_12
   \   000000FC   0xBDF1             POP      {R0,R4-R7,PC}
   1445              {
   1446                while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
   1447                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1448                    bed_maxttemp_raw -= OVERSAMPLENR;
   1449                  #else
   1450                    bed_maxttemp_raw += OVERSAMPLENR;
   \                     ??init_13: (+1)
   \   000000FE   0xF106 0x0010      ADD      R0,R6,#+16
   \   00000102   0x85A0             STRH     R0,[R4, #+44]
   1451                  #endif
   1452                }
   \                     ??init_12: (+1)
   \   00000104   0xF9B4 0x602C      LDRSH    R6,[R4, #+44]
   \   00000108   0x4630             MOV      R0,R6
   \   0000010A   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \   0000010E   0x4607             MOV      R7,R0
   \   00000110   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   00000114   0x.... 0x....      BL       __aeabi_i2f
   \   00000118   0x4639             MOV      R1,R7
   \   0000011A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011E   0xD3EE             BCC.N    ??init_13
   1453              }
   1454              //#endif // BED_MAXTEMP
   1455              }
   1456            //#endif //HAS_TEMP_BED
   1457          
   1458            #if ENABLED(PROBING_HEATERS_OFF)
   1459              paused = false;
   1460            #endif
   1461          }
   \   00000120   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1462          
   1463          #if WATCH_HOTENDS
   1464            /**
   1465             * Start Heating Sanity Check for hotends that are below
   1466             * their target temperature by a configurable margin.
   1467             * This is called when the temperature is set. (M104, M109)
   1468             */

   \                                 In section .text, align 2, keep-with-next
   1469            void Temperature::start_watching_heater(const uint8_t e) {
   \                     _ZN11Temperature21start_watching_heaterEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   1470              #if HOTENDS == 1
   1471                UNUSED(e);
   1472              #endif
   1473              if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
   \   00000006   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   0000000A   0x4605             MOV      R5,R0
   \   0000000C   0x4626             MOV      R6,R4
   \   0000000E   0x....             LDR.N    R7,??DataTable68_12
   \   00000010   0xEB07 0x0886      ADD      R8,R7,R6, LSL #+2
   \   00000014   0x.... 0x....      LDR.W    R9,??DataTable72
   \   00000018   0xF109 0x00E4      ADD      R0,R9,#+228
   \   0000001C   0xF890 0xA002      LDRB     R10,[R0, #+2]
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000026   0x4683             MOV      R11,R0
   \   00000028   0xF10A 0x0003      ADD      R0,R10,#+3
   \   0000002C   0x.... 0x....      BL       __aeabi_i2f
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x4658             MOV      R0,R11
   \   00000034   0x.... 0x....      BL       __aeabi_fsub
   \   00000038   0x4601             MOV      R1,R0
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000040   0xD219             BCS.N    ??start_watching_heater_0
   1474                watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000042   0x4650             MOV      R0,R10
   \   00000044   0x.... 0x....      BL       __aeabi_ui2f
   \   00000048   0x4605             MOV      R5,R0
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x.... 0x....      BL       __aeabi_fadd
   \   00000056   0x.... 0x....      BL       __aeabi_f2iz
   \   0000005A   0xEB07 0x0146      ADD      R1,R7,R6, LSL #+1
   \   0000005E   0x8608             STRH     R0,[R1, #+48]
   1475                watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0xF9B9 0x10E4      LDRSH    R1,[R9, #+228]
   \   00000068   0xF44F 0x727A      MOV      R2,#+1000
   \   0000006C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000070   0xF8C8 0x006C      STR      R0,[R8, #+108]
   \   00000074   0xE002             B.N      ??start_watching_heater_1
   1476              }
   1477              else
   1478                watch_heater_next_ms[HOTEND_INDEX] = 0;
   \                     ??start_watching_heater_0: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF8C8 0x006C      STR      R0,[R8, #+108]
   1479            }
   \                     ??start_watching_heater_1: (+1)
   \   0000007C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   1480          #endif
   1481          
   1482          #if WATCH_THE_BED
   1483            /**
   1484             * Start Heating Sanity Check for hotends that are below
   1485             * their target temperature by a configurable margin.
   1486             * This is called when the temperature is set. (M140, M190)
   1487             */

   \                                 In section .text, align 2, keep-with-next
   1488            void Temperature::start_watching_bed() {
   \                     _ZN11Temperature18start_watching_bedEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1489              if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
   \   00000004   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable72
   \   0000000E   0xF106 0x00EC      ADD      R0,R6,#+236
   \   00000012   0x7887             LDRB     R7,[R0, #+2]
   \   00000014   0x.... 0x....      LDR.W    R4,??DataTable72_13
   \   00000018   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \   0000001C   0x4680             MOV      R8,R0
   \   0000001E   0x1CF8             ADDS     R0,R7,#+3
   \   00000020   0x.... 0x....      BL       __aeabi_i2f
   \   00000024   0x4601             MOV      R1,R0
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fsub
   \   0000002C   0x4601             MOV      R1,R0
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000034   0xD215             BCS.N    ??start_watching_bed_0
   1490                watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003C   0x4605             MOV      R5,R0
   \   0000003E   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0x.... 0x....      BL       __aeabi_fadd
   \   00000048   0x.... 0x....      BL       __aeabi_f2iz
   \   0000004C   0x84E0             STRH     R0,[R4, #+38]
   1491                watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
   \   0000004E   0x.... 0x....      BL       HAL_GetTick
   \   00000052   0xF9B6 0x10EC      LDRSH    R1,[R6, #+236]
   \   00000056   0xF44F 0x727A      MOV      R2,#+1000
   \   0000005A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000005E   0x6760             STR      R0,[R4, #+116]
   \   00000060   0xE001             B.N      ??start_watching_bed_1
   1492              }
   1493              else
   1494                watch_bed_next_ms = 0;
   \                     ??start_watching_bed_0: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6760             STR      R0,[R4, #+116]
   1495            }
   \                     ??start_watching_bed_1: (+1)
   \   00000066   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1496          #endif
   1497          
   1498          #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
   1499          
   1500            #if ENABLED(THERMAL_PROTECTION_HOTENDS)
   1501              Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
   1502              millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   1503            #endif
   1504          
   1505            #if HAS_THERMALLY_PROTECTED_BED
   1506              Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
   1507              millis_t Temperature::thermal_runaway_bed_timer;
   1508            #endif
   1509          

   \                                 In section .text, align 2, keep-with-next
   1510            void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
   \                     _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0xF99D 0x7020      LDRSB    R7,[SP, #+32]
   1511          
   1512              static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
   1513          
   1514              /**
   1515                  SERIAL_ECHO_START();
   1516                  SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
   1517                  if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
   1518                  SERIAL_ECHOPAIR(" ;  State:", *state);
   1519                  SERIAL_ECHOPAIR(" ;  Timer:", *timer);
   1520                  SERIAL_ECHOPAIR(" ;  Temperature:", current);
   1521                  SERIAL_ECHOPAIR(" ;  Target Temp:", target);
   1522                  if (heater_id >= 0)
   1523                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
   1524                  else
   1525                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
   1526                  SERIAL_EOL();
   1527              */
   1528          
   1529              const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
   \   0000000E   0x46B9             MOV      R9,R7
   \   00000010   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000014   0xD501             BPL.N    ??thermal_runaway_protection_0
   \   00000016   0xF04F 0x0902      MOV      R9,#+2
   1530          
   1531              #if HEATER_IDLE_HANDLER
   1532                // If the heater idle timeout expires, restart
   1533                if (heater_id >= 0 && heater_idle_timeout_exceeded[heater_id]) {
   1534                  *state = TRInactive;
   1535                  tr_target_temperature[heater_index] = 0;
   1536                }
   1537                #if HAS_TEMP_BED
   1538                  else if (heater_id < 0 && bed_idle_timeout_exceeded) {
   1539                    *state = TRInactive;
   1540                    tr_target_temperature[heater_index] = 0;
   1541                  }
   1542                #endif
   1543                else
   1544              #endif
   1545              // If the target temperature changes, restart
   1546              if (tr_target_temperature[heater_index] != target) {
   \                     ??thermal_runaway_protection_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R8,??DataTable72_14
   \   0000001E   0xF858 0x0029      LDR      R0,[R8, R9, LSL #+2]
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000028   0xD00A             BEQ.N    ??thermal_runaway_protection_1
   1547                tr_target_temperature[heater_index] = target;
   \   0000002A   0xF848 0x3029      STR      R3,[R8, R9, LSL #+2]
   1548                *state = target > 0 ? TRFirstHeating : TRInactive;
   \   0000002E   0x4618             MOV      R0,R3
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000036   0xD201             BCS.N    ??thermal_runaway_protection_2
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE000             B.N      ??thermal_runaway_protection_3
   \                     ??thermal_runaway_protection_2: (+1)
   \   0000003C   0x4608             MOV      R0,R1
   \                     ??thermal_runaway_protection_3: (+1)
   \   0000003E   0x7028             STRB     R0,[R5, #+0]
   1549              }
   1550          
   1551              switch (*state) {
   \                     ??thermal_runaway_protection_1: (+1)
   \   00000040   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD004             BEQ.N    ??thermal_runaway_protection_4
   \   00000048   0xD332             BCC.N    ??thermal_runaway_protection_5
   \   0000004A   0x2803             CMP      R0,#+3
   \   0000004C   0xD026             BEQ.N    ??thermal_runaway_protection_6
   \   0000004E   0xD308             BCC.N    ??thermal_runaway_protection_7
   \   00000050   0xE02E             B.N      ??thermal_runaway_protection_5
   1552                // Inactive state waits for a target temperature to be set
   1553                case TRInactive: break;
   1554                // When first heating, wait for the temperature to be reached then go to Stable state
   1555                case TRFirstHeating:
   1556                  if (current < tr_target_temperature[heater_index]) break;
   \                     ??thermal_runaway_protection_4: (+1)
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0xF858 0x1029      LDR      R1,[R8, R9, LSL #+2]
   \   00000058   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000005C   0xD328             BCC.N    ??thermal_runaway_protection_5
   1557                  *state = TRStable;
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x7028             STRB     R0,[R5, #+0]
   1558                // While the temperature is stable watch for a bad temperature
   1559                case TRStable:
   1560                  if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
   \                     ??thermal_runaway_protection_7: (+1)
   \   00000062   0x980A             LDR      R0,[SP, #+40]
   \   00000064   0x.... 0x....      BL       __aeabi_ui2f
   \   00000068   0x4601             MOV      R1,R0
   \   0000006A   0xF858 0x0029      LDR      R0,[R8, R9, LSL #+2]
   \   0000006E   0x.... 0x....      BL       __aeabi_fsub
   \   00000072   0x4601             MOV      R1,R0
   \   00000074   0x4630             MOV      R0,R6
   \   00000076   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000007A   0xD808             BHI.N    ??thermal_runaway_protection_8
   1561                    *timer = millis() + period_seconds * 1000UL;
   \   0000007C   0x.... 0x....      BL       HAL_GetTick
   \   00000080   0x9909             LDR      R1,[SP, #+36]
   \   00000082   0xF44F 0x727A      MOV      R2,#+1000
   \   00000086   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000008A   0x6020             STR      R0,[R4, #+0]
   1562                    break;
   \   0000008C   0xE010             B.N      ??thermal_runaway_protection_5
   1563                  }
   1564                  else if (PENDING(millis(), *timer)) break;
   \                     ??thermal_runaway_protection_8: (+1)
   \   0000008E   0x.... 0x....      BL       HAL_GetTick
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x1A40             SUBS     R0,R0,R1
   \   00000096   0xD40B             BMI.N    ??thermal_runaway_protection_5
   1565                  *state = TRRunaway;
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0x7028             STRB     R0,[R5, #+0]
   1566                case TRRunaway:
   1567                  _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
   \                     ??thermal_runaway_protection_6: (+1)
   \   0000009C   0x.... 0x....      ADR.W    R2,`?<Constant "THERMAL RUNAWAY">`
   \   000000A0   0x.... 0x....      ADR.W    R1,`?<Constant "Thermal Runaway">`
   \   000000A4   0x4638             MOV      R0,R7
   \   000000A6   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   1568                  temper_error_type=7;
   \   000000AA   0x2007             MOVS     R0,#+7
   \   000000AC   0x....             LDR.N    R1,??DataTable68_2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   1569              }
   1570            }
   \                     ??thermal_runaway_protection_5: (+1)
   \   000000B0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??tr_target_temperature:
   \   00000000                      DS8 12
   1571          
   1572          #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
   1573          

   \                                 In section .text, align 2, keep-with-next
   1574          void Temperature::disable_all_heaters() {
   \                     _ZN11Temperature19disable_all_heatersEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1575          
   1576            #if ENABLED(AUTOTEMP)
   1577              planner.autotemp_enabled = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable72_15
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
   1578            #endif
   1579          
   1580            HOTEND_LOOP() setTargetHotend(0, e);
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable72
   \   00000012   0xE005             B.N      ??disable_all_heaters_0
   \                     ??disable_all_heaters_1: (+1)
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0xB2C9             UXTB     R1,R1
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??disable_all_heaters_0: (+1)
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0xB240             SXTB     R0,R0
   \   00000024   0xF894 0x10F7      LDRB     R1,[R4, #+247]
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xDBF3             BLT.N    ??disable_all_heaters_1
   1581            setTargetBed(0);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   1582          
   1583            // Unpause and reset everything
   1584            #if ENABLED(PROBING_HEATERS_OFF)
   1585              pause(false);
   1586            #endif
   1587          
   1588            // If all heaters go down then for sure our print job has stopped
   1589            print_job_timer.stop();
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable72_16
   \   00000036   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   1590          
   1591            #define DISABLE_HEATER(NR) { \
   1592              setTargetHotend(0, NR); \
   1593              soft_pwm_amount[NR] = 0; \
   1594              WRITE_HEATER_ ##NR (LOW); \
   1595            }
   1596          
   1597            #if HAS_TEMP_HOTEND
   1598              DISABLE_HEATER(0);
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x4608             MOV      R0,R1
   \   0000003E   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \   00000042   0x....             LDR.N    R5,??DataTable68_12
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x7028             STRB     R0,[R5, #+0]
   \   00000048   0x.... 0x....      LDR.W    R6,??DataTable72_5
   \   0000004C   0x.... 0x....      LDR.W    R7,??DataTable72_4
   \   00000050   0x.... 0x....      LDR.W    R8,??DataTable72_3
   \   00000054   0xF898 0x0013      LDRB     R0,[R8, #+19]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD104             BNE.N    ??disable_all_heaters_2
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x8DB9             LDRH     R1,[R7, #+44]
   \   00000060   0x6DB0             LDR      R0,[R6, #+88]
   \   00000062   0x.... 0x....      BL       HAL_GPIO_WritePin
   1599              #if HOTENDS > 1
   1600                DISABLE_HEATER(1);
   \                     ??disable_all_heaters_2: (+1)
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x7068             STRB     R0,[R5, #+1]
   \   00000072   0x4602             MOV      R2,R0
   \   00000074   0x8DF9             LDRH     R1,[R7, #+46]
   \   00000076   0x6DF0             LDR      R0,[R6, #+92]
   \   00000078   0x.... 0x....      BL       HAL_GPIO_WritePin
   1601                #if HOTENDS > 2
   1602                  DISABLE_HEATER(2);
   1603                  #if HOTENDS > 3
   1604                    DISABLE_HEATER(3);
   1605                    #if HOTENDS > 4
   1606                      DISABLE_HEATER(4);
   1607                    #endif // HOTENDS > 4
   1608                  #endif // HOTENDS > 3
   1609                #endif // HOTENDS > 2
   1610              #endif // HOTENDS > 1
   1611            #endif
   1612          
   1613            //#if HAS_TEMP_BED
   1614            if(HAS_TEMP_BED) {
   \   0000007C   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD00D             BEQ.N    ??disable_all_heaters_3
   1615              target_temperature_bed = 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x84A8             STRH     R0,[R5, #+36]
   1616              soft_pwm_amount_bed = 0;
   \   00000088   0x70E8             STRB     R0,[R5, #+3]
   1617              #if HAS_HEATER_BED
   1618                WRITE_HEATER_BED(LOW);
   \   0000008A   0xF898 0x0013      LDRB     R0,[R8, #+19]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD106             BNE.N    ??disable_all_heaters_3
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x8D79             LDRH     R1,[R7, #+42]
   \   00000096   0x6D70             LDR      R0,[R6, #+84]
   \   00000098   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000009C   0x.... 0x....      B.W      HAL_GPIO_WritePin
   1619              #endif
   1620            	}
   1621            //#endif
   1622          }
   \                     ??disable_all_heaters_3: (+1)
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1623          
   1624          #if ENABLED(PROBING_HEATERS_OFF)
   1625          
   1626            void Temperature::pause(const bool p) {
   1627              if (p != paused) {
   1628                paused = p;
   1629                if (p) {
   1630                  HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
   1631                  //#if HAS_TEMP_BED
   1632          		if(HAS_TEMP_BED) {
   1633                    start_bed_idle_timer(0); // timeout immediately
   1634          		}
   1635                  //#endif
   1636                }
   1637                else {
   1638                  HOTEND_LOOP() reset_heater_idle_timer(e);
   1639                  //#if HAS_TEMP_BED
   1640                  if(HAS_TEMP_BED) {
   1641                    reset_bed_idle_timer();
   1642                  }
   1643                  //#endif
   1644                }
   1645              }
   1646            }
   1647          
   1648          #endif // PROBING_HEATERS_OFF
   1649          
   1650          #if 1//ENABLED(HEATER_0_USES_MAX6675)
   1651          
   1652            #define MAX6675_HEAT_INTERVAL 250u
   1653          
   1654            #if ENABLED(MAX6675_IS_MAX31855)
   1655              uint32_t max6675_temp = 2000;
   1656              #define MAX6675_ERROR_MASK 7
   1657              #define MAX6675_DISCARD_BITS 18
   1658              #define MAX6675_SPEED_BITS (_BV(SPR1)) // clock 梅 64
   1659            #else
   1660              uint16_t max6675_temp = 2000;
   1661              #define MAX6675_ERROR_MASK 4
   1662              #define MAX6675_DISCARD_BITS 3
   1663              #define MAX6675_SPEED_BITS (_BV(SPR0)) // clock 梅 16
   1664            #endif
   1665          

   \                                 In section .text, align 4, keep-with-next
   1666            int Temperature::read_max6675() {
   \                     _ZN11Temperature12read_max6675Ev: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1667          
   1668              static millis_t next_max6675_ms = 0;
   1669          
   1670              millis_t ms = millis();
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   1671          
   1672              if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable72_17
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0x1A41             SUBS     R1,R0,R1
   \   0000000E   0xD44D             BMI.N    ??read_max6675_0
   1673          
   1674              next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
   \   00000010   0x30FA             ADDS     R0,R0,#+250
   \   00000012   0x6060             STR      R0,[R4, #+4]
   1675          #if 0
   1676              CBI(
   1677                #ifdef PRR
   1678                  PRR
   1679                #elif defined(PRR0)
   1680                  PRR0
   1681                #endif
   1682                  , PRSPI);
   1683              SPCR = _BV(MSTR) | _BV(SPE) | MAX6675_SPEED_BITS;
   1684          #endif
   1685              //WRITE(MAX6675_SS, 0); // enable TT_MAX6675
   1686          	TC1_CS_OP = 0;
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable72_18  ;; 0x42230194
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6028             STR      R0,[R5, #+0]
   1687          
   1688              // ensure 100ns delay - a bit extra is fine
   1689              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   \   0000001C   0xBF00             nop
   1690              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   \   0000001E   0xBF00             nop
   1691          
   1692              // Read a big-endian temperature value
   1693              max6675_temp = 0;
   \   00000020   0x6020             STR      R0,[R4, #+0]
   1694              for (uint8_t i = sizeof(max6675_temp); i--;) {
   \   00000022   0x2604             MOVS     R6,#+4
   \   00000024   0xE00A             B.N      ??read_max6675_1
   1695                //max6675_temp |= max6675_spi.receive();
   1696                max6675_temp |= SPI2_ReadWriteByte(0x00);
   \                     ??read_max6675_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       SPI2_ReadWriteByte
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x4308             ORRS     R0,R0,R1
   \   00000030   0x6020             STR      R0,[R4, #+0]
   1697                if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
   \   00000032   0xB2F6             UXTB     R6,R6
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD001             BEQ.N    ??read_max6675_1
   \   00000038   0x0200             LSLS     R0,R0,#+8
   \   0000003A   0x6020             STR      R0,[R4, #+0]
   1698              }
   \                     ??read_max6675_1: (+1)
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x1E46             SUBS     R6,R0,#+1
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD1F0             BNE.N    ??read_max6675_2
   1699          
   1700              //WRITE(MAX6675_SS, 1); // disable TT_MAX6675
   1701          	TC1_CS_OP = 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x6028             STR      R0,[R5, #+0]
   1702          
   1703              if (max6675_temp & MAX6675_ERROR_MASK) {
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0xF010 0x0F07      TST      R0,#0x7
   \   0000004E   0xD024             BEQ.N    ??read_max6675_3
   1704                SERIAL_ERROR_START();
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable72_19
   \   00000054   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1705                SERIAL_ERRORPGM("Temp measurement error! ");
   \   00000058   0x.... 0x....      ADR.W    R0,`?<Constant "Temp measurement error! ">`
   \   0000005C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1706                #if MAX6675_ERROR_MASK == 7
   1707                  SERIAL_ERRORPGM("MAX31855 ");
   \   00000060   0x.... 0x....      ADR.W    R0,`?<Constant "MAX31855 ">`
   \   00000064   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1708                  if (max6675_temp & 1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x07C1             LSLS     R1,R0,#+31
   \   0000006C   0xD504             BPL.N    ??read_max6675_4
   1709                    SERIAL_ERRORLNPGM("Open Circuit");
   \   0000006E   0x.... 0x....      ADR.W    R0,`?<Constant "Open Circuit\\n">`
   \   00000072   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000076   0xE00C             B.N      ??read_max6675_5
   1710                  else if (max6675_temp & 2)
   \                     ??read_max6675_4: (+1)
   \   00000078   0x0781             LSLS     R1,R0,#+30
   \   0000007A   0xD504             BPL.N    ??read_max6675_6
   1711                    SERIAL_ERRORLNPGM("Short to GND");
   \   0000007C   0x.... 0x....      ADR.W    R0,`?<Constant "Short to GND\\n">`
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000084   0xE005             B.N      ??read_max6675_5
   1712                  else if (max6675_temp & 4)
   \                     ??read_max6675_6: (+1)
   \   00000086   0x0740             LSLS     R0,R0,#+29
   \   00000088   0xD503             BPL.N    ??read_max6675_5
   1713                    SERIAL_ERRORLNPGM("Short to VCC");
   \   0000008A   0x.... 0x....      ADR.W    R0,`?<Constant "Short to VCC\\n">`
   \   0000008E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1714                #else
   1715                  SERIAL_ERRORLNPGM("MAX6675");
   1716                #endif
   1717                max6675_temp = MAX6675_TMAX * 4; // thermocouple open
   \                     ??read_max6675_5: (+1)
   \   00000092   0xF44F 0x50E1      MOV      R0,#+7200
   \   00000096   0x6020             STR      R0,[R4, #+0]
   \   00000098   0xE001             B.N      ??read_max6675_7
   1718              }
   1719              else
   1720                max6675_temp >>= MAX6675_DISCARD_BITS;
   \                     ??read_max6675_3: (+1)
   \   0000009A   0x0C80             LSRS     R0,R0,#+18
   \   0000009C   0x6020             STR      R0,[R4, #+0]
   1721                #if ENABLED(MAX6675_IS_MAX31855)
   1722                  // Support negative temperature
   1723                  if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
   \                     ??read_max6675_7: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x0481             LSLS     R1,R0,#+18
   \   000000A2   0xD503             BPL.N    ??read_max6675_0
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable72_20  ;; 0xffffc000
   \   000000A8   0x4308             ORRS     R0,R1,R0
   \   000000AA   0x6020             STR      R0,[R4, #+0]
   1724                #endif
   1725          
   1726              return (int)max6675_temp;
   \                     ??read_max6675_0: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
   1727            }
   1728          
   1729          #endif // HEATER_0_USES_MAX6675
   1730          
   1731          /**
   1732           * Get raw temperatures
   1733           */

   \                                 In section .text, align 2, keep-with-next
   1734          void Temperature::set_current_temp_raw() {
   1735            //#if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
   1736            if(TEMP_SENSOR_0 == sensors_100k)
   \                     _ZN11Temperature20set_current_temp_rawEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable68_12
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable72
   \   00000006   0xF991 0x10F6      LDRSB    R1,[R1, #+246]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD101             BNE.N    ??set_current_temp_raw_0
   1737              current_temperature_raw[0] = raw_temp_value[0];
   \   0000000E   0x8A01             LDRH     R1,[R0, #+16]
   \   00000010   0x6341             STR      R1,[R0, #+52]
   1738            //#endif
   1739            #if HAS_TEMP_1
   1740              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1741                redundant_temperature_raw = raw_temp_value[1];
   1742              #else
   1743                current_temperature_raw[1] = raw_temp_value[1];
   \                     ??set_current_temp_raw_0: (+1)
   \   00000012   0x8A41             LDRH     R1,[R0, #+18]
   \   00000014   0x6381             STR      R1,[R0, #+56]
   1744              #endif
   1745              #if HAS_TEMP_2
   1746                current_temperature_raw[2] = raw_temp_value[2];
   1747                #if HAS_TEMP_3
   1748                  current_temperature_raw[3] = raw_temp_value[3];
   1749                  #if HAS_TEMP_4
   1750                    current_temperature_raw[4] = raw_temp_value[4];
   1751                  #endif
   1752                #endif
   1753              #endif
   1754            #endif
   1755            current_temperature_bed_raw = raw_temp_bed_value;
   \   00000016   0x8D01             LDRH     R1,[R0, #+40]
   \   00000018   0x6501             STR      R1,[R0, #+80]
   1756            temp_meas_ready = true;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
   1757          }
   \   0000001E   0x4770             BX       LR               ;; return
   1758          
   1759          #if ENABLED(PINS_DEBUGGING)
   1760            /**
   1761             * monitors endstops & Z probe for changes
   1762             *
   1763             * If a change is detected then the LED is toggled and
   1764             * a message is sent out the serial port
   1765             *
   1766             * Yes, we could miss a rapid back & forth change but
   1767             * that won't matter because this is all manual.
   1768             *
   1769             */
   1770            void endstop_monitor() {
   1771              static uint16_t old_endstop_bits_local = 0;
   1772              static uint8_t local_LED_status = 0;
   1773              uint16_t current_endstop_bits_local = 0;
   1774              #if HAS_X_MIN	if(mksCfg.use_xmin_plug)
   1775                if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
   1776              #endif
   1777              #if HAS_X_MAX	if(mksCfg.use_xmax_plug)
   1778                if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
   1779              #endif
   1780              #if HAS_Y_MIN	if(mksCfg.use_ymin_plug)
   1781                if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
   1782              #endif
   1783              #if HAS_Y_MAX	if(mksCfg.use_ymax_plug)
   1784                if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
   1785              #endif
   1786              #if HAS_Z_MIN	if(mksCfg.use_zmin_plug)
   1787                if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
   1788              #endif
   1789              #if HAS_Z_MAX
   1790          	if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   1791          	{
   1792          		if(mksCfg.use_zmax_plug)	
   1793                		if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
   1794          	}
   1795              #endif
   1796              #if HAS_Z_MIN_PROBE_PIN
   1797                if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
   1798              #endif
   1799              #if HAS_Z2_MIN
   1800                if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
   1801              #endif
   1802              #if HAS_Z2_MAX
   1803                if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
   1804              #endif
   1805          
   1806              uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
   1807          
   1808              if (endstop_change) {
   1809                #if HAS_X_MIN	if(mksCfg.use_xmin_plug)
   1810                  if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
   1811                #endif
   1812                #if HAS_X_MAX	if(mksCfg.use_xmax_plug)
   1813                  if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
   1814                #endif
   1815                #if HAS_Y_MIN	if(mksCfg.use_ymin_plug)
   1816                  if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
   1817                #endif
   1818                #if HAS_Y_MAX	if(mksCfg.use_ymax_plug)
   1819                  if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
   1820                #endif
   1821                #if HAS_Z_MIN	if(mksCfg.use_zmin_plug)
   1822                  if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
   1823                #endif
   1824                #if HAS_Z_MAX
   1825          	  if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   1826          	  	{
   1827          	 	 	if(mksCfg.use_zmax_plug)	 
   1828          	 	 	{
   1829                  		if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
   1830          	 	 	}
   1831          	  	}
   1832                #endif
   1833                #if HAS_Z_MIN_PROBE_PIN
   1834                  if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
   1835                #endif
   1836                #if HAS_Z2_MIN
   1837                  if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
   1838                #endif
   1839                #if HAS_Z2_MAX
   1840                  if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
   1841                #endif
   1842                SERIAL_PROTOCOLPGM("\n\n");
   1843                analogWrite(LED_PIN, local_LED_status);
   1844                local_LED_status ^= 255;
   1845                old_endstop_bits_local = current_endstop_bits_local;
   1846              }
   1847            }
   1848          #endif // PINS_DEBUGGING
   1849          
   1850          /**
   1851           * Timer 0 is shared with millies so don't change the prescaler.
   1852           *
   1853           * This ISR uses the compare method so it runs at the base
   1854           * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
   1855           * in OCR0B above (128 or halfway between OVFs).
   1856           *
   1857           *  - Manage PWM to all the heaters and fan
   1858           *  - Prepare or Measure one of the raw ADC sensor values
   1859           *  - Check new temperature values for MIN/MAX errors (kill on error)
   1860           *  - Step the babysteps value for each axis towards 0
   1861           *  - For PINS_DEBUGGING, monitor and report endstop pins
   1862           *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
   1863           */
   1864          //ISR(TIMER0_COMPB_vect) { Temperature::isr(); }
   1865          
   1866          volatile bool Temperature::in_temp_isr = false;
   1867          
   1868          //void Temperature::isr() {

   \                                 In section .text, align 2, keep-with-next
   1869            void IsrTemperatureHandler() { Temperature::TemperatureHandler(); }
   \                     IsrTemperatureHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN11Temperature18TemperatureHandlerEv
   \   00000002                      ;; // Fall through to label Temperature::TemperatureHandler()

   \                                 In section .text, align 2, keep-with-next
   1870            void Temperature::TemperatureHandler(void)  {
   \                     _ZN11Temperature18TemperatureHandlerEv: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   1871          
   1872            // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
   1873            // at the end of its run, potentially causing re-entry. This flag prevents it.
   1874            if (in_temp_isr) return;
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable72_13
   \   0000000A   0x7920             LDRB     R0,[R4, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF040 0x8150      BNE.W    ??TemperatureHandler_0
   1875            in_temp_isr = true;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7120             STRB     R0,[R4, #+4]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable72_21
   1876          
   1877            // Allow UART and stepper ISRs
   1878            //CBI(TIMSK0, OCIE0B); //Disable Temperature ISR
   1879            //sei();
   1880            HAL_TIM_Base_Stop_IT(&htim4);
   \   0000001A   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1881          
   1882            static int8_t temp_count = -1;
   1883            static ADCSensorState adc_sensor_state = StartupDelay;
   1884            static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   1885            // avoid multiple loads of pwm_count
   1886            uint8_t pwm_count_tmp = pwm_count;
   \   0000001E   0x79E5             LDRB     R5,[R4, #+7]
   1887            #if ENABLED(ADC_KEYPAD)
   1888              static unsigned int raw_ADCKey_value = 0;
   1889            #endif
   1890          
   1891            // Static members for each heater
   1892            #if ENABLED(SLOW_PWM_HEATERS)
   1893              static uint8_t slow_pwm_count = 0;
   1894              #define ISR_STATICS(n) \
   1895                static uint8_t soft_pwm_count_ ## n, \
   1896                               state_heater_ ## n = 0, \
   1897                               state_timer_heater_ ## n = 0
   1898            #else
   1899              #define ISR_STATICS(n) static uint8_t soft_pwm_count_ ## n = 0
   1900            #endif
   1901          
   1902            // Statics per heater
   1903            ISR_STATICS(0);
   1904            #if HOTENDS > 1
   1905              ISR_STATICS(1);
   1906              #if HOTENDS > 2
   1907                ISR_STATICS(2);
   1908                #if HOTENDS > 3
   1909                  ISR_STATICS(3);
   1910                  #if HOTENDS > 4
   1911                    ISR_STATICS(4);
   1912                  #endif // HOTENDS > 4
   1913                #endif // HOTENDS > 3
   1914              #endif // HOTENDS > 2
   1915            #endif // HOTENDS > 1
   1916            #if HAS_HEATER_BED
   1917              ISR_STATICS(BED);
   1918            #endif
   1919          
   1920            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1921              static unsigned long raw_filwidth_value = 0;
   1922            #endif
   1923          
   1924            #if DISABLED(SLOW_PWM_HEATERS)
   1925              constexpr uint8_t pwm_mask =
   1926                #if ENABLED(SOFT_PWM_DITHER)
   1927                  _BV(SOFT_PWM_SCALE) - 1
   1928                #else
   1929                  0
   1930                #endif
   1931              ;
   1932          
   1933              /**
   1934               * Standard PWM modulation
   1935               */
   1936              if (pwm_count_tmp >= 127) {
   \   00000020   0x2D7F             CMP      R5,#+127
   \   00000022   0xDB32             BLT.N    ??TemperatureHandler_1
   1937                pwm_count_tmp -= 127;
   \   00000024   0x3D7F             SUBS     R5,R5,#+127
   \   00000026   0xB2ED             UXTB     R5,R5
   1938                soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
   \   00000028   0x7820             LDRB     R0,[R4, #+0]
   \   0000002A   0x7220             STRB     R0,[R4, #+8]
   1939                //WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
   1940          	  if(soft_pwm_count_0 > pwm_mask) WRITE_HEATER_0(HIGH);
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00D             BEQ.N    ??TemperatureHandler_2
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable72_3
   \   00000034   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable72_5
   \   0000003A   0x.... 0x....      LDR.W    R7,??DataTable72_4
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD104             BNE.N    ??TemperatureHandler_2
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x8DB9             LDRH     R1,[R7, #+44]
   \   00000046   0x6DB0             LDR      R0,[R6, #+88]
   \   00000048   0x.... 0x....      BL       HAL_GPIO_WritePin
   1941          	  else WRITE_HEATER_0(LOW);      
   1942                #if HOTENDS > 1
   1943                  soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
   \                     ??TemperatureHandler_2: (+1)
   \   0000004C   0x7860             LDRB     R0,[R4, #+1]
   \   0000004E   0x7260             STRB     R0,[R4, #+9]
   1944                  WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
   \   00000050   0xB240             SXTB     R0,R0
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xDB01             BLT.N    ??TemperatureHandler_3
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0xE000             B.N      ??TemperatureHandler_4
   \                     ??TemperatureHandler_3: (+1)
   \   0000005A   0x2200             MOVS     R2,#+0
   \                     ??TemperatureHandler_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R6,??DataTable72_5
   \   00000060   0x.... 0x....      LDR.W    R7,??DataTable72_4
   \   00000064   0x8DF9             LDRH     R1,[R7, #+46]
   \   00000066   0x6DF0             LDR      R0,[R6, #+92]
   \   00000068   0x.... 0x....      BL       HAL_GPIO_WritePin
   1945                  #if HOTENDS > 2
   1946                    soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
   1947                    WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
   1948                    #if HOTENDS > 3
   1949                      soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
   1950                      WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
   1951                      #if HOTENDS > 4
   1952                        soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
   1953                        WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
   1954                      #endif // HOTENDS > 4
   1955                    #endif // HOTENDS > 3
   1956                  #endif // HOTENDS > 2
   1957                #endif // HOTENDS > 1
   1958          
   1959                #if HAS_HEATER_BED
   1960                  soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
   \   0000006C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000006E   0x72A0             STRB     R0,[R4, #+10]
   1961                  //WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
   1962          		if(soft_pwm_count_BED > pwm_mask) WRITE_HEATER_BED(HIGH);
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD038             BEQ.N    ??TemperatureHandler_5
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable72_3
   \   00000078   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD125             BNE.N    ??TemperatureHandler_6
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x8D79             LDRH     R1,[R7, #+42]
   \   00000082   0x6D70             LDR      R0,[R6, #+84]
   \   00000084   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000088   0xE02D             B.N      ??TemperatureHandler_5
   1963          		else WRITE_HEATER_BED(LOW);        
   1964                #endif
   1965          
   1966                #if ENABLED(FAN_SOFT_PWM)
   1967                  #if HAS_FAN0
   1968                    soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
   1969                    WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
   1970                  #endif
   1971                  #if HAS_FAN1
   1972                    soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + (soft_pwm_amount_fan[1] >> 1);
   1973                    WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
   1974                  #endif
   1975                  #if HAS_FAN2
   1976                    soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + (soft_pwm_amount_fan[2] >> 1);
   1977                    WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
   1978                  #endif
   1979                #endif
   1980              }
   1981              else {
   1982                if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
   \                     ??TemperatureHandler_1: (+1)
   \   0000008A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000008C   0x4285             CMP      R5,R0
   \   0000008E   0xDB0D             BLT.N    ??TemperatureHandler_7
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable72_3
   \   00000094   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD108             BNE.N    ??TemperatureHandler_7
   \   0000009A   0x2200             MOVS     R2,#+0
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   000000A0   0x8D81             LDRH     R1,[R0, #+44]
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable72_5
   \   000000A6   0x6D80             LDR      R0,[R0, #+88]
   \   000000A8   0x.... 0x....      BL       HAL_GPIO_WritePin
   1983                #if HOTENDS > 1
   1984                  if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
   \                     ??TemperatureHandler_7: (+1)
   \   000000AC   0x7A60             LDRB     R0,[R4, #+9]
   \   000000AE   0x4285             CMP      R5,R0
   \   000000B0   0xDB08             BLT.N    ??TemperatureHandler_8
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   000000B8   0x8DC1             LDRH     R1,[R0, #+46]
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable72_5
   \   000000BE   0x6DC0             LDR      R0,[R0, #+92]
   \   000000C0   0x.... 0x....      BL       HAL_GPIO_WritePin
   1985                  #if HOTENDS > 2
   1986                    if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
   1987                    #if HOTENDS > 3
   1988                      if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
   1989                      #if HOTENDS > 4
   1990                        if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
   1991                      #endif // HOTENDS > 4
   1992                    #endif // HOTENDS > 3
   1993                  #endif // HOTENDS > 2
   1994                #endif // HOTENDS > 1
   1995          
   1996                #if HAS_HEATER_BED
   1997                  if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
   \                     ??TemperatureHandler_8: (+1)
   \   000000C4   0x7AA0             LDRB     R0,[R4, #+10]
   \   000000C6   0x4285             CMP      R5,R0
   \   000000C8   0xDB0D             BLT.N    ??TemperatureHandler_5
   \                     ??TemperatureHandler_6: (+1)
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable72_3
   \   000000CE   0x7CC0             LDRB     R0,[R0, #+19]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD108             BNE.N    ??TemperatureHandler_5
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   000000DA   0x8D41             LDRH     R1,[R0, #+42]
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable72_5
   \   000000E0   0x6D40             LDR      R0,[R0, #+84]
   \   000000E2   0x.... 0x....      BL       HAL_GPIO_WritePin
   1998                #endif
   1999          
   2000                #if ENABLED(FAN_SOFT_PWM)
   2001                  #if HAS_FAN0
   2002                    if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   2003                  #endif
   2004                  #if HAS_FAN1
   2005                    if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   2006                  #endif
   2007                  #if HAS_FAN2
   2008                    if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   2009                  #endif
   2010                #endif
   2011              }
   2012          
   2013              // SOFT_PWM_SCALE to frequency:
   2014              //
   2015              // 0: 16000000/64/256/128 =   7.6294 Hz
   2016              // 1:                / 64 =  15.2588 Hz
   2017              // 2:                / 32 =  30.5176 Hz
   2018              // 3:                / 16 =  61.0352 Hz
   2019              // 4:                /  8 = 122.0703 Hz
   2020              // 5:                /  4 = 244.1406 Hz
   2021              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   \                     ??TemperatureHandler_5: (+1)
   \   000000E6   0x1C68             ADDS     R0,R5,#+1
   \   000000E8   0x71E0             STRB     R0,[R4, #+7]
   2022          
   2023            #else // SLOW_PWM_HEATERS
   2024          
   2025              /**
   2026               * SLOW PWM HEATERS
   2027               *
   2028               * For relay-driven heaters
   2029               */
   2030              #ifndef MIN_STATE_TIME
   2031                #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
   2032              #endif
   2033          
   2034              // Macros for Slow PWM timer logic
   2035              #define _SLOW_PWM_ROUTINE(NR, src) \
   2036                soft_pwm_count_ ##NR = src; \
   2037                if (soft_pwm_count_ ##NR > 0) { \
   2038                  if (state_timer_heater_ ##NR == 0) { \
   2039                    if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   2040                    state_heater_ ##NR = 1; \
   2041                    WRITE_HEATER_ ##NR(1); \
   2042                  } \
   2043                } \
   2044                else { \
   2045                  if (state_timer_heater_ ##NR == 0) { \
   2046                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   2047                    state_heater_ ##NR = 0; \
   2048                    WRITE_HEATER_ ##NR(0); \
   2049                  } \
   2050                }
   2051              #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
   2052          
   2053              #define PWM_OFF_ROUTINE(NR) \
   2054                if (soft_pwm_count_ ##NR < slow_pwm_count) { \
   2055                  if (state_timer_heater_ ##NR == 0) { \
   2056                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   2057                    state_heater_ ##NR = 0; \
   2058                    WRITE_HEATER_ ##NR (0); \
   2059                  } \
   2060                }
   2061          
   2062              if (slow_pwm_count == 0) {
   2063          
   2064                SLOW_PWM_ROUTINE(0);
   2065                #if HOTENDS > 1
   2066                  SLOW_PWM_ROUTINE(1);
   2067                  #if HOTENDS > 2
   2068                    SLOW_PWM_ROUTINE(2);
   2069                    #if HOTENDS > 3
   2070                      SLOW_PWM_ROUTINE(3);
   2071                      #if HOTENDS > 4
   2072                        SLOW_PWM_ROUTINE(4);
   2073                      #endif // HOTENDS > 4
   2074                    #endif // HOTENDS > 3
   2075                  #endif // HOTENDS > 2
   2076                #endif // HOTENDS > 1
   2077                #if HAS_HEATER_BED
   2078                  _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
   2079                #endif
   2080          
   2081              } // slow_pwm_count == 0
   2082          
   2083              PWM_OFF_ROUTINE(0);
   2084              #if HOTENDS > 1
   2085                PWM_OFF_ROUTINE(1);
   2086                #if HOTENDS > 2
   2087                  PWM_OFF_ROUTINE(2);
   2088                  #if HOTENDS > 3
   2089                    PWM_OFF_ROUTINE(3);
   2090                    #if HOTENDS > 4
   2091                      PWM_OFF_ROUTINE(4);
   2092                    #endif // HOTENDS > 4
   2093                  #endif // HOTENDS > 3
   2094                #endif // HOTENDS > 2
   2095              #endif // HOTENDS > 1
   2096              #if HAS_HEATER_BED
   2097                PWM_OFF_ROUTINE(BED); // BED
   2098              #endif
   2099          
   2100              #if ENABLED(FAN_SOFT_PWM)
   2101                if (pwm_count_tmp >= 127) {
   2102                  pwm_count_tmp = 0;
   2103                  #if HAS_FAN0
   2104                    soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
   2105                    WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
   2106                  #endif
   2107                  #if HAS_FAN1
   2108                    soft_pwm_count_fan[1] = soft_pwm_amount_fan[1] >> 1;
   2109                    WRITE_FAN1(soft_pwm_count_fan[1] > 0 ? HIGH : LOW);
   2110                  #endif
   2111                  #if HAS_FAN2
   2112                    soft_pwm_count_fan[2] = soft_pwm_amount_fan[2] >> 1;
   2113                    WRITE_FAN2(soft_pwm_count_fan[2] > 0 ? HIGH : LOW);
   2114                  #endif
   2115                }
   2116                #if HAS_FAN0
   2117                  if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   2118                #endif
   2119                #if HAS_FAN1
   2120                  if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   2121                #endif
   2122                #if HAS_FAN2
   2123                  if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   2124                #endif
   2125              #endif // FAN_SOFT_PWM
   2126          
   2127              // SOFT_PWM_SCALE to frequency:
   2128              //
   2129              // 0: 16000000/64/256/128 =   7.6294 Hz
   2130              // 1:                / 64 =  15.2588 Hz
   2131              // 2:                / 32 =  30.5176 Hz
   2132              // 3:                / 16 =  61.0352 Hz
   2133              // 4:                /  8 = 122.0703 Hz
   2134              // 5:                /  4 = 244.1406 Hz
   2135              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   2136          
   2137              // increment slow_pwm_count only every 64th pwm_count,
   2138              // i.e. yielding a PWM frequency of 16/128 Hz (8s).
   2139              if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
   2140                slow_pwm_count++;
   2141                slow_pwm_count &= 0x7F;
   2142          
   2143                if (state_timer_heater_0 > 0) state_timer_heater_0--;
   2144                #if HOTENDS > 1
   2145                  if (state_timer_heater_1 > 0) state_timer_heater_1--;
   2146                  #if HOTENDS > 2
   2147                    if (state_timer_heater_2 > 0) state_timer_heater_2--;
   2148                    #if HOTENDS > 3
   2149                      if (state_timer_heater_3 > 0) state_timer_heater_3--;
   2150                      #if HOTENDS > 4
   2151                        if (state_timer_heater_4 > 0) state_timer_heater_4--;
   2152                      #endif // HOTENDS > 4
   2153                    #endif // HOTENDS > 3
   2154                  #endif // HOTENDS > 2
   2155                #endif // HOTENDS > 1
   2156                #if HAS_HEATER_BED
   2157                  if (state_timer_heater_BED > 0) state_timer_heater_BED--;
   2158                #endif
   2159              } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
   2160          
   2161            #endif // SLOW_PWM_HEATERS
   2162          
   2163            //
   2164            // Update lcd buttons 488 times per second
   2165            //
   2166            static bool do_buttons;
   2167            if ((do_buttons ^= true)) lcd_buttons_update();
   \   000000EA   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000EC   0xF080 0x0001      EOR      R0,R0,#0x1
   \   000000F0   0x1E40             SUBS     R0,R0,#+1
   \   000000F2   0x4180             SBCS     R0,R0,R0
   \   000000F4   0x43C0             MVNS     R0,R0
   \   000000F6   0x0FC0             LSRS     R0,R0,#+31
   \   000000F8   0x72E0             STRB     R0,[R4, #+11]
   \   000000FA   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD001             BEQ.N    ??TemperatureHandler_9
   \   00000100   0x.... 0x....      BL       _Z18lcd_buttons_updatev
   2168          
   2169            /**
   2170             * One sensor is sampled on every other call of the ISR.
   2171             * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
   2172             *
   2173             * On each Prepare pass, ADC is started for a sensor pin.
   2174             * On the next pass, the ADC value is read and accumulated.
   2175             *
   2176             * This gives each ADC 0.9765ms to charge up.
   2177             */
   2178          #if 0
   2179            #define SET_ADMUX_ADCSRA(pin) ADMUX = _BV(REFS0) | (pin & 0x07); SBI(ADCSRA, ADSC)
   2180            #ifdef MUX5
   2181              #define START_ADC(pin) if (pin > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   2182            #else
   2183              #define START_ADC(pin) ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   2184            #endif
   2185          #endif
   2186            switch (adc_sensor_state) {
   \                     ??TemperatureHandler_9: (+1)
   \   00000104   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xD013             BEQ.N    ??TemperatureHandler_10
   \   0000010C   0x2803             CMP      R0,#+3
   \   0000010E   0xD01F             BEQ.N    ??TemperatureHandler_11
   \   00000110   0x2805             CMP      R0,#+5
   \   00000112   0xD016             BEQ.N    ??TemperatureHandler_12
   \   00000114   0x2806             CMP      R0,#+6
   \   00000116   0xD12B             BNE.N    ??TemperatureHandler_13
   2187          
   2188              case SensorsReady: {
   2189                // All sensors have been read. Stay in this state for a few
   2190                // ISRs to save on calls to temp update/checking code below.
   2191                constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
   2192                static uint8_t delay_count = 0;
   2193                if (extra_loops > 0) {
   2194                  if (delay_count == 0) delay_count = extra_loops;   // Init this delay
   \   00000118   0x7B20             LDRB     R0,[R4, #+12]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD101             BNE.N    ??TemperatureHandler_14
   \   0000011E   0x2004             MOVS     R0,#+4
   \   00000120   0x7320             STRB     R0,[R4, #+12]
   2195                  if (--delay_count)                                 // While delaying...
   \                     ??TemperatureHandler_14: (+1)
   \   00000122   0x7B20             LDRB     R0,[R4, #+12]
   \   00000124   0x1E40             SUBS     R0,R0,#+1
   \   00000126   0x7320             STRB     R0,[R4, #+12]
   \   00000128   0xB2C0             UXTB     R0,R0
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD020             BEQ.N    ??TemperatureHandler_13
   2196                    adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
   \   0000012E   0x2005             MOVS     R0,#+5
   \   00000130   0x71A0             STRB     R0,[R4, #+6]
   \   00000132   0xE01D             B.N      ??TemperatureHandler_13
   2197                  break;
   2198                }
   2199                else
   2200                  adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
   2201              }
   2202          
   2203              #if HAS_TEMP_0
   2204                case PrepareTemp_0:
   2205                  //START_ADC(TEMP_0_PIN);
   2206                  break;
   2207                case MeasureTemp_0:
   2208          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)|| defined(MKS_ROBIN_NANO)
   2209          			raw_temp_value[0] += uhADCxConvertedValue[1]>>2;	//TH1
   \                     ??TemperatureHandler_10: (+1)
   \   00000134   0x8A20             LDRH     R0,[R4, #+16]
   \   00000136   0x....             LDR.N    R1,??DataTable72_22
   \   00000138   0x8849             LDRH     R1,[R1, #+2]
   \   0000013A   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   0000013E   0x8220             STRH     R0,[R4, #+16]
   2210          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2211          			raw_temp_value[0] += uhADCxConvertedValue[1];   	//TH1
   2212          		#endif 
   2213          
   2214                  break;
   \   00000140   0xE016             B.N      ??TemperatureHandler_13
   2215              #endif
   2216          
   2217              #if 1//HAS_TEMP_BED
   2218                case PrepareTemp_BED:
   2219                  //START_ADC(TEMP_BED_PIN);
   2220                  break;
   2221                case MeasureTemp_BED:
   2222          			#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)|| defined(MKS_ROBIN_NANO)
   2223          				raw_temp_bed_value += uhADCxConvertedValue[0]>>2;	//TB
   \                     ??TemperatureHandler_12: (+1)
   \   00000142   0x8D20             LDRH     R0,[R4, #+40]
   \   00000144   0x....             LDR.N    R1,??DataTable72_22
   \   00000146   0x8809             LDRH     R1,[R1, #+0]
   \   00000148   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   0000014C   0x8520             STRH     R0,[R4, #+40]
   2224          			#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2225          				raw_temp_bed_value += uhADCxConvertedValue[0];	//TB
   2226          			#endif 		
   2227                  break;
   \   0000014E   0xE00F             B.N      ??TemperatureHandler_13
   2228              #endif
   2229          
   2230              #if HAS_TEMP_1
   2231                case PrepareTemp_1:
   2232                  //START_ADC(TEMP_1_PIN);
   2233                  break;
   2234                case MeasureTemp_1:
   2235          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)|| defined(MKS_ROBIN_NANO)
   2236          			
   2237          			if(gCfgItems.singleNozzle == 1)
   \                     ??TemperatureHandler_11: (+1)
   \   00000150   0x8A60             LDRH     R0,[R4, #+18]
   \   00000152   0x....             LDR.N    R1,??DataTable72_22
   \   00000154   0x....             LDR.N    R2,??DataTable72_23
   \   00000156   0xF892 0x22A2      LDRB     R2,[R2, #+674]
   \   0000015A   0x2A01             CMP      R2,#+1
   \   0000015C   0xD104             BNE.N    ??TemperatureHandler_15
   2238          				raw_temp_value[1] += uhADCxConvertedValue[1]>>2;		//TH2
   \   0000015E   0x8849             LDRH     R1,[R1, #+2]
   \   00000160   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   00000164   0x8260             STRH     R0,[R4, #+18]
   \   00000166   0xE003             B.N      ??TemperatureHandler_13
   2239          			else
   2240          				raw_temp_value[1] += uhADCxConvertedValue[2]>>2;		//TH2
   \                     ??TemperatureHandler_15: (+1)
   \   00000168   0x8889             LDRH     R1,[R1, #+4]
   \   0000016A   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \   0000016E   0x8260             STRH     R0,[R4, #+18]
   2241          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2242          			raw_temp_value[1] += uhADCxConvertedValue[2];   //TH2
   2243          		#endif 
   2244          
   2245                  break;
   2246              #endif
   2247          
   2248              #if HAS_TEMP_2
   2249                case PrepareTemp_2:
   2250                  START_ADC(TEMP_2_PIN);
   2251                  break;
   2252                case MeasureTemp_2:
   2253                  raw_temp_value[2] += ADC;
   2254                  break;
   2255              #endif
   2256          
   2257              #if HAS_TEMP_3
   2258                case PrepareTemp_3:
   2259                  START_ADC(TEMP_3_PIN);
   2260                  break;
   2261                case MeasureTemp_3:
   2262                  raw_temp_value[3] += ADC;
   2263                  break;
   2264              #endif
   2265          
   2266              #if HAS_TEMP_4
   2267                case PrepareTemp_4:
   2268                  START_ADC(TEMP_4_PIN);
   2269                  break;
   2270                case MeasureTemp_4:
   2271                  raw_temp_value[4] += ADC;
   2272                  break;
   2273              #endif
   2274          
   2275              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2276                case Prepare_FILWIDTH:
   2277                  START_ADC(FILWIDTH_PIN);
   2278                break;
   2279                case Measure_FILWIDTH:
   2280                  if (ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
   2281                    raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
   2282                    raw_filwidth_value += ((unsigned long)ADC << 7); // Add new ADC reading, scaled by 128
   2283                  }
   2284                break;
   2285              #endif
   2286          
   2287              #if ENABLED(ADC_KEYPAD)
   2288                case Prepare_ADC_KEY:
   2289                  START_ADC(ADC_KEYPAD_PIN);
   2290                  break;
   2291                case Measure_ADC_KEY:
   2292                  if (ADCKey_count < 16) {
   2293                    raw_ADCKey_value = ADC;
   2294                    if (raw_ADCKey_value > 900) {
   2295                      //ADC Key release
   2296                      ADCKey_count = 0;
   2297                      current_ADCKey_raw = 0;
   2298                    }
   2299                    else {
   2300                      current_ADCKey_raw += raw_ADCKey_value;
   2301                      ADCKey_count++;
   2302                    }
   2303                  }
   2304                  break;
   2305              #endif // ADC_KEYPAD
   2306          
   2307              case StartupDelay: break;
   2308          
   2309            } // switch(adc_sensor_state)
   2310          
   2311            if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
   \                     ??TemperatureHandler_13: (+1)
   \   00000170   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xF040 0x808F      BNE.W    ??TemperatureHandler_16
   \   0000017A   0x7960             LDRB     R0,[R4, #+5]
   \   0000017C   0x1C40             ADDS     R0,R0,#+1
   \   0000017E   0x7160             STRB     R0,[R4, #+5]
   \   00000180   0xB240             SXTB     R0,R0
   \   00000182   0x2810             CMP      R0,#+16
   \   00000184   0xF2C0 0x8088      BLT.W    ??TemperatureHandler_16
   2312          
   2313              temp_count = 0;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x7160             STRB     R0,[R4, #+5]
   2314          
   2315              // Update the raw values if they've been read. Else we could be updating them during reading.
   2316              if (!temp_meas_ready) set_current_temp_raw();
   \   0000018C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD101             BNE.N    ??TemperatureHandler_17
   \   00000192   0x.... 0x....      BL       _ZN11Temperature20set_current_temp_rawEv
   2317          
   2318              // Filament Sensor - can be read any time since IIR filtering is used
   2319              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2320                current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   2321              #endif
   2322          
   2323              ZERO(raw_temp_value);
   \                     ??TemperatureHandler_17: (+1)
   \   00000196   0x2204             MOVS     R2,#+4
   \   00000198   0x2100             MOVS     R1,#+0
   \   0000019A   0xF104 0x0010      ADD      R0,R4,#+16
   \   0000019E   0x.... 0x....      BL       memset
   2324              raw_temp_bed_value = 0;
   \   000001A2   0x2000             MOVS     R0,#+0
   \   000001A4   0x8520             STRH     R0,[R4, #+40]
   2325          
   2326              #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
   2327          #if 0
   2328              int constexpr temp_dir[] = {
   2329                #if ENABLED(HEATER_0_USES_MAX6675)
   2330                   0
   2331                #else
   2332                  TEMPDIR(0)
   2333                #endif
   2334                #if HOTENDS > 1
   2335                  , TEMPDIR(1)
   2336                  #if HOTENDS > 2
   2337                    , TEMPDIR(2)
   2338                    #if HOTENDS > 3
   2339                      , TEMPDIR(3)
   2340                      #if HOTENDS > 4
   2341                        , TEMPDIR(4)
   2342                      #endif // HOTENDS > 4
   2343                    #endif // HOTENDS > 3
   2344                  #endif // HOTENDS > 2
   2345                #endif // HOTENDS > 1
   2346              };
   2347          #endif
   2348          	int  temp_dir[2];
   2349          	if(TEMP_SENSOR_0 == sensors_MAX31855)
   \   000001A6   0xF04F 0x30FF      MOV      R0,#-1
   \   000001AA   0x....             LDR.N    R5,??DataTable72
   \   000001AC   0xAE00             ADD      R6,SP,#+0
   \   000001AE   0xF995 0x10F6      LDRSB    R1,[R5, #+246]
   \   000001B2   0xF111 0x0F03      CMN      R1,#+3
   \   000001B6   0xD103             BNE.N    ??TemperatureHandler_18
   2350          		{
   2351          		temp_dir[0]=0;
   \   000001B8   0x2100             MOVS     R1,#+0
   \   000001BA   0x9100             STR      R1,[SP, #+0]
   2352          		temp_dir[1]=TEMPDIR(1);       //mks_TC
   \   000001BC   0x6070             STR      R0,[R6, #+4]
   \   000001BE   0xE001             B.N      ??TemperatureHandler_19
   2353          		}
   2354          	else
   2355          		{
   2356          		temp_dir[0]=TEMPDIR(0);
   \                     ??TemperatureHandler_18: (+1)
   \   000001C0   0x9000             STR      R0,[SP, #+0]
   2357          		temp_dir[1]=TEMPDIR(1);       //mks_TC
   \   000001C2   0x6070             STR      R0,[R6, #+4]
   2358          		}
   2359          	
   2360          
   2361              for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
   \                     ??TemperatureHandler_19: (+1)
   \   000001C4   0x2700             MOVS     R7,#+0
   \   000001C6   0xE01F             B.N      ??TemperatureHandler_20
   2362                const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
   2363                //const 
   2364                 bool heater_on; //= 0 <
   2365                  /*
   2366                  #if ENABLED(PIDTEMP)
   2367                    soft_pwm_amount[e]
   2368                  #else
   2369                    target_temperature[e]
   2370                  #endif
   2371                ;
   2372                */
   2373                if(PIDTEMP)
   2374                  heater_on = 0 < soft_pwm_amount[e];
   2375                else
   2376                  heater_on = 0 < target_temperature[e];
   \                     ??TemperatureHandler_21: (+1)
   \   000001C8   0xF04F 0x0A00      MOV      R10,#+0
   2377                
   2378                //if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
   2379                if (rawtemp > maxttemp_raw[e] * tdir && loop_start) max_temp_error(e);
   \                     ??TemperatureHandler_22: (+1)
   \   000001CC   0xEB04 0x0B47      ADD      R11,R4,R7, LSL #+1
   \   000001D0   0xF9BB 0x0018      LDRSH    R0,[R11, #+24]
   \   000001D4   0xFB08 0xF000      MUL      R0,R8,R0
   \   000001D8   0x4548             CMP      R0,R9
   \   000001DA   0xDA07             BGE.N    ??TemperatureHandler_23
   \   000001DC   0x....             LDR.N    R0,??DataTable72_24
   \   000001DE   0x7800             LDRB     R0,[R0, #+0]
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD003             BEQ.N    ??TemperatureHandler_23
   \   000001E4   0x4638             MOV      R0,R7
   \   000001E6   0xB240             SXTB     R0,R0
   \   000001E8   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
   2380                if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
   \                     ??TemperatureHandler_23: (+1)
   \   000001EC   0xF9BB 0x0014      LDRSH    R0,[R11, #+20]
   \   000001F0   0xFB08 0xF000      MUL      R0,R8,R0
   \   000001F4   0x4581             CMP      R9,R0
   \   000001F6   0xDA06             BGE.N    ??TemperatureHandler_24
   \   000001F8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001FC   0xD003             BEQ.N    ??TemperatureHandler_24
   2381                  #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2382                    if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
   2383                  #endif
   2384                      min_temp_error(e);
   \   000001FE   0x4638             MOV      R0,R7
   \   00000200   0xB240             SXTB     R0,R0
   \   00000202   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
   2385                }
   \                     ??TemperatureHandler_24: (+1)
   \   00000206   0x1C7F             ADDS     R7,R7,#+1
   \                     ??TemperatureHandler_20: (+1)
   \   00000208   0x2F02             CMP      R7,#+2
   \   0000020A   0xD21C             BCS.N    ??TemperatureHandler_25
   \   0000020C   0xF936 0x8027      LDRSH    R8,[R6, R7, LSL #+2]
   \   00000210   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \   00000214   0x6B41             LDR      R1,[R0, #+52]
   \   00000216   0xFB08 0xF901      MUL      R9,R8,R1
   \   0000021A   0xFA0F 0xF989      SXTH     R9,R9
   \   0000021E   0xF895 0x1034      LDRB     R1,[R5, #+52]
   \   00000222   0x2900             CMP      R1,#+0
   \   00000224   0xD009             BEQ.N    ??TemperatureHandler_26
   \   00000226   0x5D38             LDRB     R0,[R7, R4]
   \   00000228   0xF1B0 0x0A01      SUBS     R10,R0,#+1
   \   0000022C   0xEB6A 0x0A0A      SBC      R10,R10,R10
   \   00000230   0xEA6F 0x0A0A      MVN      R10,R10
   \   00000234   0xEA4F 0x7ADA      LSR      R10,R10,#+31
   \   00000238   0xE7C8             B.N      ??TemperatureHandler_22
   \                     ??TemperatureHandler_26: (+1)
   \   0000023A   0x6C80             LDR      R0,[R0, #+72]
   \   0000023C   0x2801             CMP      R0,#+1
   \   0000023E   0xDBC3             BLT.N    ??TemperatureHandler_21
   \   00000240   0xF04F 0x0A01      MOV      R10,#+1
   \   00000244   0xE7C2             B.N      ??TemperatureHandler_22
   2386                #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2387                  else
   2388                    consecutive_low_temperature_error[e] = 0;
   2389                #endif
   2390              }
   2391          
   2392              #if 1//HAS_TEMP_BED
   2393                #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
   2394                  #define GEBED <=
   2395                #else
   2396                  #define GEBED >=
   2397                #endif
   2398                //const 
   2399                bool bed_on;// = 0 <
   2400                /*
   2401                  #if ENABLED(PIDTEMPBED)
   2402                    soft_pwm_amount_bed
   2403                  #else
   2404                    target_temperature_bed
   2405                  #endif
   2406                ;
   2407                */
   2408                if(PIDTEMPBED)
   \                     ??TemperatureHandler_25: (+1)
   \   00000246   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   0000024A   0x2800             CMP      R0,#+0
   \   0000024C   0xD005             BEQ.N    ??TemperatureHandler_27
   2409                  bed_on = 0 < soft_pwm_amount_bed;
   \   0000024E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000250   0x1E45             SUBS     R5,R0,#+1
   \   00000252   0x41AD             SBCS     R5,R5,R5
   \   00000254   0x43ED             MVNS     R5,R5
   \   00000256   0x0FED             LSRS     R5,R5,#+31
   \   00000258   0xE006             B.N      ??TemperatureHandler_28
   2410                else
   2411                  bed_on = 0 < target_temperature_bed;
   \                     ??TemperatureHandler_27: (+1)
   \   0000025A   0xF9B4 0x0024      LDRSH    R0,[R4, #+36]
   \   0000025E   0x2801             CMP      R0,#+1
   \   00000260   0xDB01             BLT.N    ??TemperatureHandler_29
   \   00000262   0x2501             MOVS     R5,#+1
   \   00000264   0xE000             B.N      ??TemperatureHandler_28
   \                     ??TemperatureHandler_29: (+1)
   \   00000266   0x2500             MOVS     R5,#+0
   2412                
   2413                //if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
   2414                if (current_temperature_bed_raw GEBED bed_maxttemp_raw && loop_start) max_temp_error(-1);
   \                     ??TemperatureHandler_28: (+1)
   \   00000268   0xF9B4 0x002C      LDRSH    R0,[R4, #+44]
   \   0000026C   0x6D21             LDR      R1,[R4, #+80]
   \   0000026E   0x4288             CMP      R0,R1
   \   00000270   0xDB07             BLT.N    ??TemperatureHandler_30
   \   00000272   0x....             LDR.N    R0,??DataTable72_24
   \   00000274   0x7800             LDRB     R0,[R0, #+0]
   \   00000276   0x2800             CMP      R0,#+0
   \   00000278   0xD003             BEQ.N    ??TemperatureHandler_30
   \   0000027A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000027E   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
   2415                if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
   \                     ??TemperatureHandler_30: (+1)
   \   00000282   0x6D20             LDR      R0,[R4, #+80]
   \   00000284   0xF9B4 0x102A      LDRSH    R1,[R4, #+42]
   \   00000288   0x4288             CMP      R0,R1
   \   0000028A   0xDB05             BLT.N    ??TemperatureHandler_16
   \   0000028C   0x2D00             CMP      R5,#+0
   \   0000028E   0xD003             BEQ.N    ??TemperatureHandler_16
   \   00000290   0xF04F 0x30FF      MOV      R0,#-1
   \   00000294   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
   2416              #endif
   2417          
   2418            } // temp_count >= OVERSAMPLENR
   2419          
   2420            // Go to the next state, up to SensorsReady
   2421            adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
   \                     ??TemperatureHandler_16: (+1)
   \   00000298   0x79A0             LDRB     R0,[R4, #+6]
   \   0000029A   0x1C40             ADDS     R0,R0,#+1
   \   0000029C   0x71A0             STRB     R0,[R4, #+6]
   2422            if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
   \   0000029E   0xB240             SXTB     R0,R0
   \   000002A0   0x2807             CMP      R0,#+7
   \   000002A2   0xDB01             BLT.N    ??TemperatureHandler_31
   \   000002A4   0x2000             MOVS     R0,#+0
   \   000002A6   0x71A0             STRB     R0,[R4, #+6]
   2423          
   2424            #if ENABLED(BABYSTEPPING)
   2425              LOOP_XYZ(axis) {
   2426                const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
   2427                if (curTodo) {
   2428                  stepper.babystep((AxisEnum)axis, curTodo > 0);
   2429                  if (curTodo > 0) babystepsTodo[axis]--;
   2430                              else babystepsTodo[axis]++;
   2431                }
   2432              }
   2433            #endif // BABYSTEPPING
   2434          
   2435            #if ENABLED(PINS_DEBUGGING)
   2436              extern bool endstop_monitor_flag;
   2437              // run the endstop monitor at 15Hz
   2438              static uint8_t endstop_monitor_count = 16;  // offset this check from the others
   2439              if (endstop_monitor_flag) {
   2440                endstop_monitor_count += _BV(1);  //  15 Hz
   2441                endstop_monitor_count &= 0x7F;
   2442                if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
   2443              }
   2444            #endif
   2445          
   2446            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   2447          
   2448              extern volatile uint8_t e_hit;
   2449          
   2450              if (e_hit && ENDSTOPS_ENABLED) {
   2451                endstops.update();  // call endstop update routine
   2452                e_hit--;
   2453              }
   2454            #endif
   2455          
   2456            //cli();
   2457            in_temp_isr = false;
   \                     ??TemperatureHandler_31: (+1)
   \   000002A8   0x2000             MOVS     R0,#+0
   \   000002AA   0x7120             STRB     R0,[R4, #+4]
   2458            //SBI(TIMSK0, OCIE0B); //re-enable Temperature ISR
   2459            HAL_TIM_Base_Start_IT(&htim4);
   \   000002AC   0x....             LDR.N    R0,??DataTable72_21
   \   000002AE   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   2460          }
   \                     ??TemperatureHandler_0: (+1)
   \   000002B2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .data, align 4
   \                     _ZN11Temperature15soft_pwm_amountE:
   \   00000000   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature15temp_meas_readyE:
   \   00000002   0x00               DC8 0
   \                     _ZN11Temperature19soft_pwm_amount_bedE:
   \   00000003   0x00               DC8 0
   \                     _ZN11Temperature11in_temp_isrE:
   \   00000004   0x00               DC8 0
   \   00000005   0xFF               DC8 -1
   \   00000006   0x07               DC8 7
   \   00000007   0x01               DC8 1
   \   00000008   0x00               DC8 0
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \   0000000C   0x00               DC8 0
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     _ZN11Temperature14raw_temp_valueE:
   \   00000010   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature12minttemp_rawE:
   \   00000014   0x3FFF 0x3FFF      DC16 16383, 16383
   \                     _ZN11Temperature12maxttemp_rawE:
   \   00000018   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature8minttempE:
   \   0000001C   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature8maxttempE:
   \   00000020   0x3FFF 0x3FFF      DC16 16383, 16383
   \                     _ZN11Temperature22target_temperature_bedE:
   \   00000024   0x0000             DC16 0
   \                     _ZN11Temperature21watch_target_bed_tempE:
   \   00000026   0x0000             DC16 0
   \                     _ZN11Temperature18raw_temp_bed_valueE:
   \   00000028   0x0000             DC16 0
   \                     _ZN11Temperature16bed_minttemp_rawE:
   \   0000002A   0x3FFF             DC16 16383
   \                     _ZN11Temperature16bed_maxttemp_rawE:
   \   0000002C   0x0000             DC16 0
   \   0000002E   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature17watch_target_tempE:
   \   00000030   0x0000 0x0000      DC16 0, 0
   \                     _ZN11Temperature23current_temperature_rawE:
   \   00000034   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature19current_temperatureE:
   \   0000003C   0x00000000         DC32 0H
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature23current_temperature_bedE:
   \   00000044   0x00000000         DC32 0H
   \                     _ZN11Temperature18target_temperatureE:
   \   00000048   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature27current_temperature_bed_rawE:
   \   00000050   0x00000000         DC32 0
   \                     _ZN11Temperature2KpE:
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KiE:
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KdE:
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5bedKpE:
   \   00000060   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5bedKiE:
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5bedKdE:
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature20watch_heater_next_msE:
   \   0000006C   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature17watch_bed_next_msE:
   \   00000074   0x00000000         DC32 0
   \                     _ZN11Temperature17next_bed_check_msE:
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000007C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature33thermal_runaway_bed_state_machineE:
   \   00000080   0x00               DC8 0
   \   00000081   0x00               DC8 0
   \                     _ZN11Temperature29thermal_runaway_state_machineE:
   \   00000082   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature21thermal_runaway_timerE:
   \   00000084   0x00000000         DC32 0, 0
   \              0x00000000   
   \                     _ZN11Temperature25thermal_runaway_bed_timerE:
   \   0000008C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     max6675_temp:
   \   00000000   0x000007D0         DC32 2000
   \   00000004   0x00000000         DC32 0
   2461          
   2462          #if 1//HAS_TEMP_HOTEND || HAS_TEMP_BED
   2463          

   \                                 In section .text, align 2, keep-with-next
   2464            void print_heater_state(const float &c, const float &t,
   2465              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2466                const float r,
   2467              #endif
   2468              const int8_t e=-2
   2469            ) {
   \                     _Z18print_heater_stateRKfS0_a: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4617             MOV      R7,R2
   2470              //#if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
   2471              // UNUSED(e);
   2472              //#endif
   2473              if(!(HAS_TEMP_BED))
   2474              {
   2475                  #if !(HAS_TEMP_HOTEND) && HOTENDS <= 1
   2476                  UNUSED(e);
   2477                  #endif
   2478              }
   2479              
   2480              SERIAL_PROTOCOLCHAR(' ');
   \   0000000C   0x....             LDR.N    R5,??DataTable72_8
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2481              /*
   2482              SERIAL_PROTOCOLCHAR(
   2483                #if HAS_TEMP_BED && HAS_TEMP_HOTEND
   2484                  e == -1 ? 'B' : 'T'
   2485                #elif HAS_TEMP_HOTEND
   2486                  'T'
   2487                #else
   2488                  'B'
   2489                #endif
   2490                );
   2491                */
   2492                #if HAS_TEMP_HOTEND
   2493                    if(HAS_TEMP_BED)
   \   00000016   0x46B8             MOV      R8,R7
   \   00000018   0x....             LDR.N    R0,??DataTable72
   \   0000001A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD009             BEQ.N    ??print_heater_state_0
   2494                      SERIAL_PROTOCOLCHAR(e == -1 ? 'B' : 'T');
   \   00000022   0xF118 0x0F01      CMN      R8,#+1
   \   00000026   0xD101             BNE.N    ??print_heater_state_1
   \   00000028   0x2142             MOVS     R1,#+66
   \   0000002A   0xE000             B.N      ??print_heater_state_2
   \                     ??print_heater_state_1: (+1)
   \   0000002C   0x2154             MOVS     R1,#+84
   \                     ??print_heater_state_2: (+1)
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000034   0xE003             B.N      ??print_heater_state_3
   2495                    else
   2496                    {
   2497                      SERIAL_PROTOCOLCHAR('T');
   \                     ??print_heater_state_0: (+1)
   \   00000036   0x2154             MOVS     R1,#+84
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2498                    }
   2499                #else
   2500                    SERIAL_PROTOCOLCHAR('B');
   2501                #endif
   2502              
   2503              #if HOTENDS > 1
   2504                if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
   \                     ??print_heater_state_3: (+1)
   \   0000003E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000042   0xD405             BMI.N    ??print_heater_state_4
   \   00000044   0xF107 0x0130      ADD      R1,R7,#+48
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2505              #endif
   2506              SERIAL_PROTOCOLCHAR(':');
   \                     ??print_heater_state_4: (+1)
   \   00000050   0x213A             MOVS     R1,#+58
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2507              SERIAL_PROTOCOL(c);
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x6830             LDR      R0,[R6, #+0]
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x4602             MOV      R2,R0
   \   00000064   0x460B             MOV      R3,R1
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       _ZN5Print5printEdi
   2508              SERIAL_PROTOCOLPAIR(" /" , t);
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x....             ADR.N    R0,??DataTable72_2  ;; 0x20, 0x2F, 0x00, 0x00
   \   00000070   0xE8BD 0x41FC      POP      {R2-R8,LR}
   \   00000074   0x.... 0x....      B.W      _Z17serial_echopair_PPKcf
   2509              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2510                SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
   2511                SERIAL_PROTOCOLCHAR(')');
   2512              #endif
   2513            }
   2514          
   2515            extern uint8_t target_extruder;
   2516          

   \                                 In section .text, align 2, keep-with-next
   2517            void Temperature::print_heaterstates() {
   \                     _ZN11Temperature18print_heaterstatesEv: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   2518              #if HAS_TEMP_HOTEND
   2519                print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
   2520                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2521                    , rawHotendTemp(target_extruder)
   2522                  #endif
   2523                );
   \   00000002   0x....             LDR.N    R4,??DataTable72_25
   \   00000004   0x7825             LDRB     R5,[R4, #+0]
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0xF06F 0x0201      MVN      R2,#+1
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x.... 0x....      BL       _Z18print_heater_stateRKfS0_a
   2524              #endif
   2525              //#if HAS_TEMP_BED
   2526              if(HAS_TEMP_BED)
   \   00000022   0x....             LDR.N    R5,??DataTable72
   \   00000024   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD00B             BEQ.N    ??print_heaterstates_0
   2527              {
   2528                print_heater_state(degBed(), degTargetBed()
   2529                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2530                    , rawBedTemp()
   2531                  #endif
   2532                  , -1 // BED
   2533                );
   \   0000002C   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0xF04F 0x32FF      MOV      R2,#-1
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       _Z18print_heater_stateRKfS0_a
   2534              }
   2535              //#endif
   2536              #if HOTENDS > 1
   2537                HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
   \                     ??print_heaterstates_0: (+1)
   \   00000044   0x2600             MOVS     R6,#+0
   \   00000046   0xE010             B.N      ??print_heaterstates_1
   2538                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2539                    , rawHotendTemp(e)
   2540                  #endif
   2541                  , e
   2542                );
   \                     ??print_heaterstates_2: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0xB2C0             UXTB     R0,R0
   \   0000004C   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000050   0x9001             STR      R0,[SP, #+4]
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x4632             MOV      R2,R6
   \   0000005E   0xB252             SXTB     R2,R2
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0xA801             ADD      R0,SP,#+4
   \   00000064   0x.... 0x....      BL       _Z18print_heater_stateRKfS0_a
   \   00000068   0x1C76             ADDS     R6,R6,#+1
   \                     ??print_heaterstates_1: (+1)
   \   0000006A   0x4630             MOV      R0,R6
   \   0000006C   0xB240             SXTB     R0,R0
   \   0000006E   0xF895 0x10F7      LDRB     R1,[R5, #+247]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xDBE8             BLT.N    ??print_heaterstates_2
   2543              #endif
   2544              SERIAL_PROTOCOLPGM(" @:");
   \   00000076   0x....             ADR.N    R0,??DataTable72_6  ;; " @:"
   \   00000078   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2545              SERIAL_PROTOCOL(getHeaterPower(target_extruder));
   \   0000007C   0x7820             LDRB     R0,[R4, #+0]
   \   0000007E   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \   00000082   0x4601             MOV      R1,R0
   \   00000084   0x....             LDR.N    R4,??DataTable72_8
   \   00000086   0x220A             MOVS     R2,#+10
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       _ZN5Print5printEii
   2546              //#if HAS_TEMP_BED
   2547              if(HAS_TEMP_BED)
   \   0000008E   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD00C             BEQ.N    ??print_heaterstates_3
   2548              {
   2549                SERIAL_PROTOCOLPGM(" B@:");
   \   00000096   0x.... 0x....      ADR.W    R0,`?<Constant " B@:">`
   \   0000009A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2550                SERIAL_PROTOCOL(getHeaterPower(-1));
   \   0000009E   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A2   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \   000000A6   0x220A             MOVS     R2,#+10
   \   000000A8   0x4601             MOV      R1,R0
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _ZN5Print5printEii
   2551              }
   2552              //#endif
   2553              #if HOTENDS > 1
   2554                HOTEND_LOOP() {
   \                     ??print_heaterstates_3: (+1)
   \   000000B0   0x2600             MOVS     R6,#+0
   \   000000B2   0xE011             B.N      ??print_heaterstates_4
   2555                  SERIAL_PROTOCOLPAIR(" @", e);
   \                     ??print_heaterstates_5: (+1)
   \   000000B4   0x4631             MOV      R1,R6
   \   000000B6   0x....             ADR.N    R0,??DataTable72_7  ;; 0x20, 0x40, 0x00, 0x00
   \   000000B8   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   2556                  SERIAL_PROTOCOLCHAR(':');
   \   000000BC   0x213A             MOVS     R1,#+58
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2557                  SERIAL_PROTOCOL(getHeaterPower(e));
   \   000000C4   0x4630             MOV      R0,R6
   \   000000C6   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \   000000CA   0x220A             MOVS     R2,#+10
   \   000000CC   0x4601             MOV      R1,R0
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       _ZN5Print5printEii
   2558                }
   \   000000D4   0x1C76             ADDS     R6,R6,#+1
   \   000000D6   0xB276             SXTB     R6,R6
   \                     ??print_heaterstates_4: (+1)
   \   000000D8   0xF895 0x00F7      LDRB     R0,[R5, #+247]
   \   000000DC   0x4286             CMP      R6,R0
   \   000000DE   0xDBE9             BLT.N    ??print_heaterstates_5
   2559              #endif
   2560            }
   \   000000E0   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   2561          
   2562            #if ENABLED(AUTO_REPORT_TEMPERATURES)
   2563          

   \                                 In section .bss, align 4
   2564              uint8_t Temperature::auto_report_temp_interval;
   \                     _ZN11Temperature25auto_report_temp_intervalE:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   2565              millis_t Temperature::next_temp_report_ms;
   \                     _ZN11Temperature19next_temp_report_msE:
   \   00000004                      DS8 4
   2566          

   \                                 In section .text, align 2, keep-with-next
   2567              void Temperature::auto_report_temperatures() {
   \                     _ZN11Temperature24auto_report_temperaturesEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2568                if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
   \   00000002   0x....             LDR.N    R4,??DataTable72_26
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD014             BEQ.N    ??auto_report_temperatures_0
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x6861             LDR      R1,[R4, #+4]
   \   00000010   0x1A40             SUBS     R0,R0,R1
   \   00000012   0xD40F             BMI.N    ??auto_report_temperatures_0
   2569                  next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x7821             LDRB     R1,[R4, #+0]
   \   0000001A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000001E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000022   0x6060             STR      R0,[R4, #+4]
   2570                  print_heaterstates();
   \   00000024   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   2571                  SERIAL_EOL();
   \   00000028   0x210A             MOVS     R1,#+10
   \   0000002A   0x....             LDR.N    R0,??DataTable72_8
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   2572                }
   2573              }
   \                     ??auto_report_temperatures_0: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " /">`:
   \   00000000   0x20 0x2F          DC8 " /"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "bed">`:
   \   00000000   0x62 0x65          DC8 "bed"
   \              0x64 0x00    

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Kp ">`:
   \   00000000   0x4B 0x70          DC8 "Kp "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Ki ">`:
   \   00000000   0x4B 0x69          DC8 "Ki "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Kd ">`:
   \   00000000   0x4B 0x64          DC8 "Kd "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " @:">`:
   \   00000000   0x20 0x40          DC8 " @:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " @">`:
   \   00000000   0x20 0x40          DC8 " @"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Temperature::subobject Temperature()
   \                     _ZN11TemperatureC2Ev: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11TemperatureC1Ev

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00000006   0x6AC0             LDR      R0,[R0, #+44]
   \   00000008   0x.... 0x....      BL       __aeabi_f2iz
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable57
   \   00000010   0x8008             STRH     R0,[R1, #+0]
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Bad extruder number"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x42    
   \              0x61 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune start">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune start"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " bias: ">`:
   \   00000000   0x20 0x62          DC8 " bias: "
   \              0x69 0x61    
   \              0x73 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " d: ">`:
   \   00000000   0x20 0x64          DC8 " d: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " min: ">`:
   \   00000000   0x20 0x6D          DC8 " min: "
   \              0x69 0x6E    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " max: ">`:
   \   00000000   0x20 0x6D          DC8 " max: "
   \              0x61 0x78    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ku: ">`:
   \   00000000   0x20 0x4B          DC8 " Ku: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Tu: ">`:
   \   00000000   0x20 0x54          DC8 " Tu: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n Classic PID \\n">`:
   \   00000000   0x0A 0x20          DC8 "\012 Classic PID \012"
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x63 0x20    
   \              0x50 0x49    
   \              0x44 0x20    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kp: ">`:
   \   00000000   0x20 0x4B          DC8 " Kp: "
   \              0x70 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ki: ">`:
   \   00000000   0x20 0x4B          DC8 " Ki: "
   \              0x69 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kd: ">`:
   \   00000000   0x20 0x4B          DC8 " Kd: "
   \              0x64 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_1`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Temperature too high\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x54    
   \              0x65 0x6D    
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x68    
   \              0x69 0x67    
   \              0x68 0x0A    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_2`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! timeout\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune finished...">`:
   \   00000000   0x50 0x49          DC8 50H, 49H, 44H, 20H, 41H, 75H, 74H, 6FH
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \   00000008   0x74 0x75          DC8 74H, 75H, 6EH, 65H, 20H, 66H, 69H, 6EH
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x69 0x6E    
   \   00000010   0x69 0x73          DC8 69H, 73H, 68H, 65H, 64H, 21H, 20H, 50H
   \              0x68 0x65    
   \              0x64 0x21    
   \              0x20 0x50    
   \   00000018   0x75 0x74          DC8 75H, 74H, 20H, 74H, 68H, 65H, 20H, 6CH
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6C    
   \   00000020   0x61 0x73          DC8 61H, 73H, 74H, 20H, 4BH, 70H, 2CH, 20H
   \              0x74 0x20    
   \              0x4B 0x70    
   \              0x2C 0x20    
   \   00000028   0x4B 0x69          DC8 4BH, 69H, 20H, 61H, 6EH, 64H, 20H, 4BH
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x4B    
   \   00000030   0x64 0x20          DC8 64H, 20H, 63H, 6FH, 6EH, 73H, 74H, 61H
   \              0x63 0x6F    
   \              0x6E 0x73    
   \              0x74 0x61    
   \   00000038   0x6E 0x74          DC8 6EH, 74H, 73H, 20H, 66H, 72H, 6FH, 6DH
   \              0x73 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \   00000040   0x20 0x62          DC8 20H, 62H, 65H, 6CH, 6FH, 77H, 20H, 69H
   \              0x65 0x6C    
   \              0x6F 0x77    
   \              0x20 0x69    
   \   00000048   0x6E 0x74          DC8 6EH, 74H, 6FH, 20H, 43H, 6FH, 6EH, 66H
   \              0x6F 0x20    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \   00000050   0x69 0x67          DC8 69H, 67H, 75H, 72H, 61H, 74H, 69H, 6FH
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \   00000058   0x6E 0x2E          DC8 6EH, 2EH, 68H, 0AH, 0
   \              0x68 0x0A    
   \              0x00         
   \   0000005D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_"
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kp ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Ki ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Ki "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x69 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kd ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x64 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_bedKp ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_bedKp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x70    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_bedKi ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_bedKi "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x69    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_bedKd ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_bedKd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x64    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \   00000000   0x62 0x65          DC8      "bed"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_1:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_2:
   \   00000000   0x4B 0x70          DC8      "Kp "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_3:
   \   00000000   0x4B 0x69          DC8      "Ki "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \   00000000   0x4B 0x64          DC8      "Kd "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ", system stopped! Hea...">`:
   \   00000000   0x2C 0x20          DC8 ", system stopped! Heater_ID: "
   \              0x73 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x21 0x20    
   \              0x48 0x65    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x5F 0x49    
   \              0x44 0x3A    
   \              0x20 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "bed\\n">`:
   \   00000000   0x62 0x65          DC8 "bed\012"
   \              0x64 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MAXTEMP BED">`:
   \   00000000   0x45 0x72          DC8 "Err: MAXTEMP BED"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x20 0x42    
   \              0x45 0x44    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MAXTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MAXTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MAXTEMP triggered">`:
   \   00000000   0x4D 0x41          DC8 "MAXTEMP triggered"
   \              0x58 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MINTEMP BED">`:
   \   00000000   0x45 0x72          DC8 "Err: MINTEMP BED"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x20 0x42    
   \              0x45 0x44    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MINTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MINTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MINTEMP triggered">`:
   \   00000000   0x4D 0x49          DC8 "MINTEMP triggered"
   \              0x4E 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \   00000000   0x........         DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_1:
   \   00000000   0x461C4000         DC32     0x461c4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_2:
   \   00000000   0x........         DC32     mksCfg+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_3:
   \   00000000   0x........         DC32     mksCfg+0xE4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_4:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_5:
   \   00000000   0x........         DC32     wait_for_heatup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_1:
   \   00000000   0xFFFFEC78         DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_2:
   \   00000000   0x40100000         DC32     0x40100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_3:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_4:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Heating failed">`:
   \   00000000   0x48 0x65          DC8 "Heating failed"
   \              0x61 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_1:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_2:
   \   00000000   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_3:
   \   00000000   0x3FE33333         DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61:
   \   00000000   0x41A00000         DC32     0x41a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_1:
   \   00000000   0xC1A00000         DC32     0xc1a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_2:
   \   00000000   0x........         DC32     `?<Constant "THERMAL RUNAWAY">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_3:
   \   00000000   0x........         DC32     `?<Constant "Thermal Runaway">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_4:
   \   00000000   0x00124F81         DC32     0x124f81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64:
   \   00000000   0x88E368F1         DC32     0x88e368f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65:
   \   00000000   0x3FC4F8B5         DC32     0x3fc4f8b5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68:
   \   00000000   0x........         DC32     ??killed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_1:
   \   00000000   0x........         DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_2:
   \   00000000   0x........         DC32     temper_error_type

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_3:
   \   00000000   0x........         DC32     _ZN11Temperature9pid_resetE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_4:
   \   00000000   0x999999A0         DC32     0x999999a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_5:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_6:
   \   00000000   0x3FEE6666         DC32     0x3fee6666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_7:
   \   00000000   0x42200001         DC32     0x42200001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_8:
   \   00000000   0x437F0000         DC32     0x437f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_9:
   \   00000000   0xC2200000         DC32     0xc2200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_10:
   \   00000000   0x437F0001         DC32     0x437f0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_11:
   \   00000000   0x........         DC32     _ZN11Temperature15temp_iState_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_12:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70:
   \   00000000   0x409C1C00         DC32     0x409c1c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_1:
   \   00000000   0x44E10000         DC32     0x44e10000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_2:
   \   00000000   0x0A3D70A4         DC32     0xa3d70a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable70_3:
   \   00000000   0xC070DFD7         DC32     0xc070dfd7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_1:
   \   00000000   0x40A00000         DC32     0x40a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_2:
   \   00000000   0x20 0x2F          DC8      0x20, 0x2F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_3:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_4:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_5:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_6:
   \   00000000   0x20 0x40          DC8      " @:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_7:
   \   00000000   0x20 0x40          DC8      0x20, 0x40, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_8:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_9:
   \   00000000   0x3FD00000         DC32     0x3fd00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_10:
   \   00000000   0x........         DC32     heater_ttbllen_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_11:
   \   00000000   0x3F9F4000         DC32     0x3f9f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_12:
   \   00000000   0xC1C80000         DC32     0xc1c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_13:
   \   00000000   0x........         DC32     _ZN11Temperature15soft_pwm_amountE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_14:
   \   00000000   0x........         DC32     ??tr_target_temperature

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_15:
   \   00000000   0x........         DC32     _ZN7Planner16autotemp_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_16:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_17:
   \   00000000   0x........         DC32     max6675_temp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_18:
   \   00000000   0x42230194         DC32     0x42230194

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_19:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_20:
   \   00000000   0xFFFFC000         DC32     0xffffc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_21:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_22:
   \   00000000   0x........         DC32     uhADCxConvertedValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_23:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_24:
   \   00000000   0x........         DC32     loop_start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_25:
   \   00000000   0x........         DC32     target_extruder

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_26:
   \   00000000   0x........         DC32     _ZN11Temperature25auto_report_temp_intervalE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " - Invalid extruder n...">`:
   \   00000000   0x20 0x2D          DC8 " - Invalid extruder number !\012"
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x21    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Thermal Runaway">`:
   \   00000000   0x54 0x68          DC8 "Thermal Runaway"
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x6C 0x20    
   \              0x52 0x75    
   \              0x6E 0x61    
   \              0x77 0x61    
   \              0x79 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "THERMAL RUNAWAY">`:
   \   00000000   0x54 0x48          DC8 "THERMAL RUNAWAY"
   \              0x45 0x52    
   \              0x4D 0x41    
   \              0x4C 0x20    
   \              0x52 0x55    
   \              0x4E 0x41    
   \              0x57 0x41    
   \              0x59 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " B@:">`:
   \   00000000   0x20 0x42          DC8 " B@:"
   \              0x40 0x3A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Temp measurement error! ">`:
   \   00000000   0x54 0x65          DC8 "Temp measurement error! "
   \              0x6D 0x70    
   \              0x20 0x6D    
   \              0x65 0x61    
   \              0x73 0x75    
   \              0x72 0x65    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x21 0x20    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MAX31855 ">`:
   \   00000000   0x4D 0x41          DC8 "MAX31855 "
   \              0x58 0x33    
   \              0x31 0x38    
   \              0x35 0x35    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Open Circuit\\n">`:
   \   00000000   0x4F 0x70          DC8 "Open Circuit\012"
   \              0x65 0x6E    
   \              0x20 0x43    
   \              0x69 0x72    
   \              0x63 0x75    
   \              0x69 0x74    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Short to GND\\n">`:
   \   00000000   0x53 0x68          DC8 "Short to GND\012"
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x74 0x6F    
   \              0x20 0x47    
   \              0x4E 0x44    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Short to VCC\\n">`:
   \   00000000   0x53 0x68          DC8 "Short to VCC\012"
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x74 0x6F    
   \              0x20 0x56    
   \              0x43 0x43    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
   2574          
   2575            #endif // AUTO_REPORT_TEMPERATURES
   2576          
   2577          #endif // HAS_TEMP_HOTEND || HAS_TEMP_BED

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IsRunning()
       0   IsrTemperatureHandler
         0   -> Temperature::TemperatureHandler()
     120   Temperature::PID_autotune(float, int8_t, int8_t, bool)
       120   -> HAL_GetTick
       120   -> Print::print(char const *)
       120   -> Temperature::_temp_error(int8_t, char const *, char const *)
         0   -> Temperature::disable_all_heaters()
       120   -> Temperature::disable_all_heaters()
       120   -> Temperature::print_heaterstates()
         0   -> Temperature::updatePID()
       120   -> Temperature::updateTemperaturesFromRawValues()
         0   -> USARTClass::write(uint8_t)
       120   -> USARTClass::write(uint8_t)
       120   -> __aeabi_cfcmple
       120   -> __aeabi_d2f
       120   -> __aeabi_ddiv
       120   -> __aeabi_dmul
       120   -> __aeabi_f2d
       120   -> __aeabi_fadd
       120   -> __aeabi_fdiv
       120   -> __aeabi_fmul
       120   -> __aeabi_fsub
       120   -> __aeabi_i2d
       120   -> __aeabi_i2f
       120   -> lcd_update()
       120   -> serial_echopair_P(char const *, char const *)
       120   -> serial_echopair_P(char const *, float)
       120   -> serial_echopair_P(char const *, long)
       120   -> serialprintPGM(char const *)
       0   Temperature::Temperature()
      48   Temperature::TemperatureHandler()
        48   -> HAL_GPIO_WritePin
        48   -> HAL_TIM_Base_Start_IT
        48   -> HAL_TIM_Base_Stop_IT
        48   -> Temperature::max_temp_error(int8_t)
        48   -> Temperature::min_temp_error(int8_t)
        48   -> Temperature::set_current_temp_raw()
        48   -> lcd_buttons_update()
        48   -> memset
      16   Temperature::_temp_error(int8_t, char const *, char const *)
        16   -> IsRunning()
        16   -> Print::print(int, int)
         0   -> Temperature::disable_all_heaters()
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
         0   -> temper_error_kill()
      40   Temperature::analog2temp(int, uint8_t)
        40   -> Print::print(int, int)
         0   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
         0   -> __aeabi_i2f
        40   -> __aeabi_i2f
        40   -> kill(char const *)
        40   -> serialprintPGM(char const *)
      32   Temperature::analog2tempBed(int)
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
       8   Temperature::auto_report_temperatures()
         8   -> HAL_GetTick
         8   -> Temperature::print_heaterstates()
         0   -> USARTClass::write(uint8_t)
       0   Temperature::degBed()
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetBed()
         0   -> __aeabi_i2f
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
      24   Temperature::disable_all_heaters()
         0   -> HAL_GPIO_WritePin
        24   -> HAL_GPIO_WritePin
        24   -> Stopwatch::stop()
        24   -> Temperature::setTargetBed(float)
        24   -> Temperature::setTargetHotend(float, uint8_t)
       0   Temperature::getHeaterPower(int)
      48   Temperature::get_pid_output(int8_t)
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_d2f
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
      40   Temperature::get_pid_output_bed()
        40   -> __aeabi_cfcmple
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_d2f
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
      24   Temperature::init()
        24   -> Temperature::analog2temp(int, uint8_t)
        24   -> Temperature::analog2tempBed(int)
        24   -> __aeabi_cfcmple
        24   -> __aeabi_i2f
      48   Temperature::manage_heater()
         0   -> HAL_GPIO_WritePin
        48   -> HAL_GetTick
        48   -> Temperature::_temp_error(int8_t, char const *, char const *)
        48   -> Temperature::degBed()
        48   -> Temperature::degHotend(uint8_t)
        48   -> Temperature::get_pid_output(int8_t)
        48   -> Temperature::get_pid_output_bed()
        48   -> Temperature::max_temp_error(int8_t)
        48   -> Temperature::min_temp_error(int8_t)
        48   -> Temperature::start_watching_bed()
        48   -> Temperature::start_watching_heater(uint8_t)
        48   -> Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        48   -> Temperature::updateTemperaturesFromRawValues()
        48   -> __aeabi_cdcmple
        48   -> __aeabi_cfcmpeq
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_f2d
        48   -> __aeabi_f2iz
        48   -> __aeabi_i2d
        48   -> __aeabi_i2f
        48   -> __aeabi_ui2f
       8   Temperature::max_temp_error(int8_t)
         8   -> Temperature::_temp_error(int8_t, char const *, char const *)
       8   Temperature::min_temp_error(int8_t)
         8   -> Temperature::_temp_error(int8_t, char const *, char const *)
      24   Temperature::print_heaterstates()
        24   -> Print::print(int, int)
        24   -> Temperature::degBed()
        24   -> Temperature::degHotend(uint8_t)
        24   -> Temperature::degTargetBed()
        24   -> Temperature::degTargetHotend(uint8_t)
        24   -> Temperature::getHeaterPower(int)
        24   -> USARTClass::write(uint8_t)
        24   -> print_heater_state(float const &, float const &, int8_t)
        24   -> serial_echopair_P(char const *, int)
        24   -> serialprintPGM(char const *)
      16   Temperature::read_max6675()
        16   -> HAL_GetTick
        16   -> SPI2_ReadWriteByte
        16   -> serialprintPGM(char const *)
      16   Temperature::setTargetBed(float)
         0   -> Temperature::start_watching_bed()
        16   -> __aeabi_cfcmple
        16   -> __aeabi_f2iz
        16   -> __aeabi_i2f
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
       0   Temperature::set_current_temp_raw()
      24   Temperature::start_watching_bed()
        24   -> HAL_GetTick
        24   -> Temperature::degBed()
        24   -> Temperature::degTargetBed()
        24   -> __aeabi_cfcmple
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
      40   Temperature::start_watching_heater(uint8_t)
        40   -> HAL_GetTick
        40   -> Temperature::degHotend(uint8_t)
        40   -> Temperature::degTargetHotend(uint8_t)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_f2iz
        40   -> __aeabi_fadd
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
       0   Temperature::subobject Temperature()
         0   -> Temperature::Temperature()
      32   Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        32   -> HAL_GetTick
        32   -> Temperature::_temp_error(int8_t, char const *, char const *)
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_cfcmple
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fsub
        32   -> __aeabi_ui2f
       0   Temperature::updatePID()
      16   Temperature::updateTemperaturesFromRawValues()
        16   -> Temperature::analog2temp(int, uint8_t)
        16   -> Temperature::analog2tempBed(int)
        16   -> Temperature::read_max6675()
       8   __sti__routine()
         8   -> __aeabi_f2iz
       0   lcd_buttons_update()
       0   lcd_update()
      32   print_heater_state(float const &, float const &, int8_t)
        32   -> Print::print(double, int)
        32   -> USARTClass::write(uint8_t)
        32   -> __aeabi_f2d
         0   -> serial_echopair_P(char const *, float)
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " - Invalid extruder n...">
       4  ?<Constant " /">
       4  ?<Constant " @">
       4  ?<Constant " @:">
       8  ?<Constant " B@:">
       8  ?<Constant " Kd: ">
       8  ?<Constant " Ki: ">
       8  ?<Constant " Kp: ">
       8  ?<Constant " Ku: ">
       8  ?<Constant " Tu: ">
       8  ?<Constant " bias: ">
       8  ?<Constant " d: ">
       8  ?<Constant " max: ">
       8  ?<Constant " min: ">
       1  ?<Constant "">
      20  ?<Constant "#define  DEFAULT_">
      24  ?<Constant "#define  DEFAULT_Kd ">
      24  ?<Constant "#define  DEFAULT_Ki ">
      24  ?<Constant "#define  DEFAULT_Kp ">
      24  ?<Constant "#define  DEFAULT_bedKd ">
      24  ?<Constant "#define  DEFAULT_bedKi ">
      24  ?<Constant "#define  DEFAULT_bedKp ">
      32  ?<Constant ", system stopped! Hea...">
      20  ?<Constant "Err: MAXTEMP BED">
      16  ?<Constant "Err: MAXTEMP">
      20  ?<Constant "Err: MINTEMP BED">
      16  ?<Constant "Err: MINTEMP">
      16  ?<Constant "Heating failed">
      12  ?<Constant "KILLED. ">
       4  ?<Constant "Kd ">
       4  ?<Constant "Ki ">
       4  ?<Constant "Kp ">
      12  ?<Constant "MAX31855 ">
      20  ?<Constant "MAXTEMP triggered">
      20  ?<Constant "MINTEMP triggered">
      16  ?<Constant "Open Circuit\n">
      44  ?<Constant "PID Autotune failed! ...">
      44  ?<Constant "PID Autotune failed! ...">_1
      32  ?<Constant "PID Autotune failed! ...">_2
      96  ?<Constant "PID Autotune finished...">
      20  ?<Constant "PID Autotune start">
      16  ?<Constant "Short to GND\n">
      16  ?<Constant "Short to VCC\n">
      16  ?<Constant "THERMAL RUNAWAY">
      28  ?<Constant "Temp measurement error! ">
      16  ?<Constant "Thermal Runaway">
      16  ?<Constant "\n Classic PID \n">
       4  ?<Constant "bed">
       8  ?<Constant "bed\n">
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable52_2
       4  ??DataTable52_3
       4  ??DataTable53
       4  ??DataTable56
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable57_2
       4  ??DataTable57_3
       4  ??DataTable57_4
       4  ??DataTable57_5
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable58_2
       4  ??DataTable58_3
       4  ??DataTable58_4
       4  ??DataTable59
       4  ??DataTable59_1
       4  ??DataTable59_2
       4  ??DataTable59_3
       4  ??DataTable61
       4  ??DataTable61_1
       4  ??DataTable61_2
       4  ??DataTable61_3
       4  ??DataTable61_4
       4  ??DataTable64
       4  ??DataTable65
       4  ??DataTable66
       4  ??DataTable68
       4  ??DataTable68_1
       4  ??DataTable68_10
       4  ??DataTable68_11
       4  ??DataTable68_12
       4  ??DataTable68_2
       4  ??DataTable68_3
       4  ??DataTable68_4
       4  ??DataTable68_5
       4  ??DataTable68_6
       4  ??DataTable68_7
       4  ??DataTable68_8
       4  ??DataTable68_9
       4  ??DataTable70
       4  ??DataTable70_1
       4  ??DataTable70_2
       4  ??DataTable70_3
       4  ??DataTable72
       4  ??DataTable72_1
       4  ??DataTable72_10
       4  ??DataTable72_11
       4  ??DataTable72_12
       4  ??DataTable72_13
       4  ??DataTable72_14
       4  ??DataTable72_15
       4  ??DataTable72_16
       4  ??DataTable72_17
       4  ??DataTable72_18
       4  ??DataTable72_19
       4  ??DataTable72_2
       4  ??DataTable72_20
       4  ??DataTable72_21
       4  ??DataTable72_22
       4  ??DataTable72_23
       4  ??DataTable72_24
       4  ??DataTable72_25
       4  ??DataTable72_26
       4  ??DataTable72_3
       4  ??DataTable72_4
       4  ??DataTable72_5
       4  ??DataTable72_6
       4  ??DataTable72_7
       4  ??DataTable72_8
       4  ??DataTable72_9
      12  IsRunning()
       2  IsrTemperatureHandler
    1778  Temperature::PID_autotune(float, int8_t, int8_t, bool)
       2  Temperature::Temperature()
     694  Temperature::TemperatureHandler()
     110  Temperature::_temp_error(int8_t, char const *, char const *)
       1  Temperature::allow_cold_extrude
     262  Temperature::analog2temp(int, uint8_t)
     124  Temperature::analog2tempBed(int)
       8  Temperature::auto_report_temp_interval
          Temperature::next_temp_report_ms
      54  Temperature::auto_report_temperatures()
      12  Temperature::degBed()
      16  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetBed()
      16  Temperature::degTargetHotend(uint8_t)
     164  Temperature::disable_all_heaters()
       2  Temperature::extrude_min_temp
      16  Temperature::getHeaterPower(int)
     348  Temperature::get_pid_output(int8_t)
     246  Temperature::get_pid_output_bed()
     290  Temperature::init()
     656  Temperature::manage_heater()
      66  Temperature::max_temp_error(int8_t)
      66  Temperature::min_temp_error(int8_t)
      52  Temperature::pid_reset
          Temperature::temp_iState
          Temperature::temp_dState
          Temperature::pTerm
          Temperature::iTerm
          Temperature::dTerm
          Temperature::pid_error
     226  Temperature::print_heaterstates()
     176  Temperature::read_max6675()
      52  Temperature::setTargetBed(float)
      32  Temperature::setTargetHotend(float, uint8_t)
      32  Temperature::set_current_temp_raw()
     144  Temperature::soft_pwm_amount
          Temperature::temp_meas_ready
          Temperature::soft_pwm_amount_bed
          Temperature::in_temp_isr
          temp_count
          adc_sensor_state
          pwm_count
          soft_pwm_count_0
          soft_pwm_count_1
          soft_pwm_count_BED
          do_buttons
          delay_count
          Temperature::raw_temp_value
          Temperature::minttemp_raw
          Temperature::maxttemp_raw
          Temperature::minttemp
          Temperature::maxttemp
          Temperature::target_temperature_bed
          Temperature::watch_target_bed_temp
          Temperature::raw_temp_bed_value
          Temperature::bed_minttemp_raw
          Temperature::bed_maxttemp_raw
          Temperature::watch_target_temp
          Temperature::current_temperature_raw
          Temperature::current_temperature
          Temperature::current_temperature_bed
          Temperature::target_temperature
          Temperature::current_temperature_bed_raw
          Temperature::Kp
          Temperature::Ki
          Temperature::Kd
          Temperature::bedKp
          Temperature::bedKi
          Temperature::bedKd
          Temperature::watch_heater_next_ms
          Temperature::watch_bed_next_ms
          Temperature::next_bed_check_ms
          current_temper_bak
          Temperature::thermal_runaway_bed_state_machine
          Temperature::thermal_runaway_state_machine
          Temperature::thermal_runaway_timer
          Temperature::thermal_runaway_bed_timer
     106  Temperature::start_watching_bed()
     128  Temperature::start_watching_heater(uint8_t)
       4  Temperature::subobject Temperature()
      24  Temperature::temp_iState_bed
          Temperature::temp_dState_bed
          Temperature::pTerm_bed
          Temperature::iTerm_bed
          Temperature::dTerm_bed
          Temperature::pid_error_bed
     180  Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
       2  Temperature::updatePID()
      88  Temperature::updateTemperaturesFromRawValues()
      20  __sti__routine()
      12  heater_ttbllen_map
          heater_ttbl_map
       1  killed
       2  lcd_buttons_update()
       2  lcd_update()
       8  max6675_temp
          next_max6675_ms
     120  print_heater_state(float const &, float const &, int8_t)
      28  serialprintPGM(char const *)
     256  temptable_1
       4  thermalManager
      12  tr_target_temperature
       5  -- Other

 
   104 bytes in section .bss
   164 bytes in section .data
     4 bytes in section .init_array
    30 bytes in section .rodata
 7 524 bytes in section .text
 
 7 338 bytes of CODE  memory (+ 190 bytes shared)
    29 bytes of CONST memory (+   1 byte  shared)
   268 bytes of DATA  memory

Errors: none
Warnings: 14
