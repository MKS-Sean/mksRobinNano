###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\mmask.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\mmask.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\mmask.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\mmask.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\mmask.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Masking for Micro QR Code.
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * This library is free software; you can redistribute it and/or
      8           * modify it under the terms of the GNU Lesser General Public
      9           * License as published by the Free Software Foundation; either
     10           * version 2.1 of the License, or any later version.
     11           *
     12           * This library is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     15           * Lesser General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU Lesser General Public
     18           * License along with this library; if not, write to the Free Software
     19           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     20           */
     21          
     22          #if HAVE_CONFIG_H
     23          # include "config.h"
     24          #endif
     25          #include <stdlib.h>
     26          #include <string.h>
     27          #include <limits.h>
     28          #include <errno.h>
     29          
     30          #include "qrencode.h"
     31          #include "mqrspec.h"
     32          #include "mmask.h"
     33          

   \                                 In section .text, align 2, keep-with-next
     34          static void MMask_writeFormatInformation(int version, int width, unsigned char *frame, int mask, QRecLevel level)
     35          {
   \                     MMask_writeFormatInformation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
     36          	unsigned int format;
     37          	unsigned char v;
     38          	int i;
     39          
     40          	format = MQRspec_getFormatInfo(mask, version, level);
   \   00000006   0xF99D 0x2010      LDRSB    R2,[SP, #+16]
   \   0000000A   0x4601             MOV      R1,R0
   \   0000000C   0x4618             MOV      R0,R3
   \   0000000E   0x.... 0x....      BL       MQRspec_getFormatInfo
     41          
     42          	for(i=0; i<8; i++) {
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xE008             B.N      ??MMask_writeFormatInformation_0
     43          		v = 0x84 | (format & 1);
     44          		frame[width * (i + 1) + 8] = v;
   \                     ??MMask_writeFormatInformation_1: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xF000 0x0201      AND      R2,R0,#0x1
   \   0000001C   0xF042 0x0284      ORR      R2,R2,#0x84
   \   00000020   0xFB01 0x5304      MLA      R3,R1,R4,R5
   \   00000024   0x721A             STRB     R2,[R3, #+8]
     45          		format = format >> 1;
   \   00000026   0x0840             LSRS     R0,R0,#+1
     46          	}
   \                     ??MMask_writeFormatInformation_0: (+1)
   \   00000028   0x2908             CMP      R1,#+8
   \   0000002A   0xDBF4             BLT.N    ??MMask_writeFormatInformation_1
     47          	for(i=0; i<7; i++) {
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xE009             B.N      ??MMask_writeFormatInformation_2
     48          		v = 0x84 | (format & 1);
     49          		frame[width * 8 + 7 - i] = v;
   \                     ??MMask_writeFormatInformation_3: (+1)
   \   00000030   0x00E2             LSLS     R2,R4,#+3
   \   00000032   0x1DD2             ADDS     R2,R2,#+7
   \   00000034   0x1A52             SUBS     R2,R2,R1
   \   00000036   0xF000 0x0301      AND      R3,R0,#0x1
   \   0000003A   0xF043 0x0384      ORR      R3,R3,#0x84
   \   0000003E   0x5553             STRB     R3,[R2, R5]
     50          		format = format >> 1;
   \   00000040   0x0840             LSRS     R0,R0,#+1
     51          	}
   \   00000042   0x1C49             ADDS     R1,R1,#+1
   \                     ??MMask_writeFormatInformation_2: (+1)
   \   00000044   0x2907             CMP      R1,#+7
   \   00000046   0xDBF3             BLT.N    ??MMask_writeFormatInformation_3
     52          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     53          
     54          #define MASKMAKER(__exp__) \
     55          	int x, y;\
     56          \
     57          	for(y=0; y<width; y++) {\
     58          		for(x=0; x<width; x++) {\
     59          			if(*s & 0x80) {\
     60          				*d = *s;\
     61          			} else {\
     62          				*d = *s ^ ((__exp__) == 0);\
     63          			}\
     64          			s++; d++;\
     65          		}\
     66          	}
     67          

   \                                 In section .text, align 2, keep-with-next
     68          static void Mask_mask0(int width, const unsigned char *s, unsigned char *d)
     69          {
   \                     Mask_mask0: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     70          	MASKMAKER(y&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE000             B.N      ??Mask_mask0_0
   \                     ??Mask_mask0_1: (+1)
   \   00000006   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Mask_mask0_0: (+1)
   \   00000008   0x4283             CMP      R3,R0
   \   0000000A   0xDA11             BGE.N    ??Mask_mask0_2
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE008             B.N      ??Mask_mask0_3
   \                     ??Mask_mask0_4: (+1)
   \   00000010   0xF003 0x0601      AND      R6,R3,#0x1
   \   00000014   0xF086 0x0601      EOR      R6,R6,#0x1
   \   00000018   0x4075             EORS     R5,R6,R5
   \   0000001A   0x7015             STRB     R5,[R2, #+0]
   \                     ??Mask_mask0_5: (+1)
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask0_3: (+1)
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xDAEF             BGE.N    ??Mask_mask0_1
   \   00000026   0x780D             LDRB     R5,[R1, #+0]
   \   00000028   0x062E             LSLS     R6,R5,#+24
   \   0000002A   0xD5F1             BPL.N    ??Mask_mask0_4
   \   0000002C   0x7015             STRB     R5,[R2, #+0]
   \   0000002E   0xE7F5             B.N      ??Mask_mask0_5
     71          }
   \                     ??Mask_mask0_2: (+1)
   \   00000030   0xBC70             POP      {R4-R6}
   \   00000032   0x4770             BX       LR               ;; return
     72          

   \                                 In section .text, align 2, keep-with-next
     73          static void Mask_mask1(int width, const unsigned char *s, unsigned char *d)
     74          {
   \                     Mask_mask1: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     75          	MASKMAKER(((y/2)+(x/3))&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE000             B.N      ??Mask_mask1_0
   \                     ??Mask_mask1_1: (+1)
   \   00000006   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Mask_mask1_0: (+1)
   \   00000008   0x4283             CMP      R3,R0
   \   0000000A   0xDA18             BGE.N    ??Mask_mask1_2
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE00F             B.N      ??Mask_mask1_3
   \                     ??Mask_mask1_4: (+1)
   \   00000010   0xEB03 0x76D3      ADD      R6,R3,R3, LSR #+31
   \   00000014   0x2703             MOVS     R7,#+3
   \   00000016   0xFB94 0xF7F7      SDIV     R7,R4,R7
   \   0000001A   0xEB07 0x0666      ADD      R6,R7,R6, ASR #+1
   \   0000001E   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000022   0xF086 0x0601      EOR      R6,R6,#0x1
   \   00000026   0x4075             EORS     R5,R6,R5
   \   00000028   0x7015             STRB     R5,[R2, #+0]
   \                     ??Mask_mask1_5: (+1)
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x1C52             ADDS     R2,R2,#+1
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask1_3: (+1)
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xDAE8             BGE.N    ??Mask_mask1_1
   \   00000034   0x780D             LDRB     R5,[R1, #+0]
   \   00000036   0x062E             LSLS     R6,R5,#+24
   \   00000038   0xD5EA             BPL.N    ??Mask_mask1_4
   \   0000003A   0x7015             STRB     R5,[R2, #+0]
   \   0000003C   0xE7F5             B.N      ??Mask_mask1_5
     76          }
   \                     ??Mask_mask1_2: (+1)
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return
     77          

   \                                 In section .text, align 2, keep-with-next
     78          static void Mask_mask2(int width, const unsigned char *s, unsigned char *d)
     79          {
   \                     Mask_mask2: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     80          	MASKMAKER((((x*y)&1)+(x*y)%3)&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xF06F 0x0702      MVN      R7,#+2
   \   00000008   0xE000             B.N      ??Mask_mask2_0
   \                     ??Mask_mask2_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Mask_mask2_0: (+1)
   \   0000000C   0x4283             CMP      R3,R0
   \   0000000E   0xDA15             BGE.N    ??Mask_mask2_2
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE00C             B.N      ??Mask_mask2_3
   \                     ??Mask_mask2_4: (+1)
   \   00000014   0xFB03 0xF604      MUL      R6,R3,R4
   \   00000018   0xFB96 0xF6F7      SDIV     R6,R6,R7
   \   0000001C   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000020   0xF086 0x0601      EOR      R6,R6,#0x1
   \   00000024   0x4075             EORS     R5,R6,R5
   \   00000026   0x7015             STRB     R5,[R2, #+0]
   \                     ??Mask_mask2_5: (+1)
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x1C52             ADDS     R2,R2,#+1
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask2_3: (+1)
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xDAEB             BGE.N    ??Mask_mask2_1
   \   00000032   0x780D             LDRB     R5,[R1, #+0]
   \   00000034   0x062E             LSLS     R6,R5,#+24
   \   00000036   0xD5ED             BPL.N    ??Mask_mask2_4
   \   00000038   0x7015             STRB     R5,[R2, #+0]
   \   0000003A   0xE7F5             B.N      ??Mask_mask2_5
     81          }
   \                     ??Mask_mask2_2: (+1)
   \   0000003C   0xBCF0             POP      {R4-R7}
   \   0000003E   0x4770             BX       LR               ;; return
     82          

   \                                 In section .text, align 2, keep-with-next
     83          static void Mask_mask3(int width, const unsigned char *s, unsigned char *d)
     84          {
   \                     Mask_mask3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     85          	MASKMAKER((((x+y)&1)+((x*y)%3))&1)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xF04F 0x0C03      MOV      R12,#+3
   \   00000008   0xE000             B.N      ??Mask_mask3_0
   \                     ??Mask_mask3_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??Mask_mask3_0: (+1)
   \   0000000C   0x4283             CMP      R3,R0
   \   0000000E   0xDA18             BGE.N    ??Mask_mask3_2
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE00F             B.N      ??Mask_mask3_3
   \                     ??Mask_mask3_4: (+1)
   \   00000014   0xFB03 0xF604      MUL      R6,R3,R4
   \   00000018   0x191F             ADDS     R7,R3,R4
   \   0000001A   0x19F7             ADDS     R7,R6,R7
   \   0000001C   0xFB96 0xF6FC      SDIV     R6,R6,R12
   \   00000020   0x1BBE             SUBS     R6,R7,R6
   \   00000022   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000026   0xF086 0x0601      EOR      R6,R6,#0x1
   \   0000002A   0x4075             EORS     R5,R6,R5
   \   0000002C   0x7015             STRB     R5,[R2, #+0]
   \                     ??Mask_mask3_5: (+1)
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x1C52             ADDS     R2,R2,#+1
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \                     ??Mask_mask3_3: (+1)
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xDAE8             BGE.N    ??Mask_mask3_1
   \   00000038   0x780D             LDRB     R5,[R1, #+0]
   \   0000003A   0x062E             LSLS     R6,R5,#+24
   \   0000003C   0xD5EA             BPL.N    ??Mask_mask3_4
   \   0000003E   0x7015             STRB     R5,[R2, #+0]
   \   00000040   0xE7F5             B.N      ??Mask_mask3_5
     86          }
   \                     ??Mask_mask3_2: (+1)
   \   00000042   0xBCF0             POP      {R4-R7}
   \   00000044   0x4770             BX       LR               ;; return
     87          
     88          #define maskNum (4)
     89          typedef void MaskMaker(int, const unsigned char *, unsigned char *);

   \                                 In section .data, align 4
     90          static MaskMaker *maskMakers[maskNum] = {
   \                     maskMakers:
   \   00000000   0x........         DC32 Mask_mask0, Mask_mask1, Mask_mask2, Mask_mask3
   \              0x........   
   \              0x........   
   \              0x........   
     91          	Mask_mask0, Mask_mask1, Mask_mask2, Mask_mask3
     92          };
     93          
     94          #ifdef WITH_TESTS
     95          unsigned char *MMask_makeMaskedFrame(int width, unsigned char *frame, int mask)
     96          {
     97          	unsigned char *masked;
     98          
     99          	masked = (unsigned char *)malloc(width * width);
    100          	if(masked == NULL) return NULL;
    101          
    102          	maskMakers[mask](width, frame, masked);
    103          
    104          	return masked;
    105          }
    106          #endif
    107          

   \                                 In section .text, align 2, keep-with-next
    108          unsigned char *MMask_makeMask(int version, unsigned char *frame, int mask, QRecLevel level)
    109          {
   \                     MMask_makeMask: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    110          	unsigned char *masked;
    111          	int width;
    112          
    113          	if(mask < 0 || mask >= maskNum) {
   \   0000000C   0x2E04             CMP      R6,#+4
   \   0000000E   0xD306             BCC.N    ??MMask_makeMask_0
    114          		errno = EINVAL;
   \   00000010   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    115          		return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE01B             B.N      ??MMask_makeMask_1
    116          	}
    117          
    118          	width = MQRspec_getWidth(version);
   \                     ??MMask_makeMask_0: (+1)
   \   0000001E   0x.... 0x....      BL       MQRspec_getWidth
   \   00000022   0x4680             MOV      R8,R0
    119          	masked = (unsigned char *)malloc(width * width);
   \   00000024   0xFB08 0xF008      MUL      R0,R8,R8
   \   00000028   0x.... 0x....      BL       malloc
   \   0000002C   0x4681             MOV      R9,R0
    120          	if(masked == NULL) return NULL;
   \   0000002E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000032   0xD101             BNE.N    ??MMask_makeMask_2
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE00E             B.N      ??MMask_makeMask_1
    121          
    122          	maskMakers[mask](width, frame, masked);
   \                     ??MMask_makeMask_2: (+1)
   \   00000038   0x464A             MOV      R2,R9
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x....             LDR.N    R3,??DataTable1
   \   00000040   0xF853 0x3026      LDR      R3,[R3, R6, LSL #+2]
   \   00000044   0x4798             BLX      R3
    123          	MMask_writeFormatInformation(version, width, masked, mask, level);
   \   00000046   0x9700             STR      R7,[SP, #+0]
   \   00000048   0x4633             MOV      R3,R6
   \   0000004A   0x464A             MOV      R2,R9
   \   0000004C   0x4641             MOV      R1,R8
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       MMask_writeFormatInformation
    124          
    125          	return masked;
   \   00000054   0x4648             MOV      R0,R9
   \                     ??MMask_makeMask_1: (+1)
   \   00000056   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          static int MMask_evaluateSymbol(int width, unsigned char *frame)
    129          {
   \                     MMask_evaluateSymbol: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    130          	int x, y;
    131          	unsigned char *p;
    132          	int sum1 = 0, sum2 = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4613             MOV      R3,R2
    133          
    134          	p = frame + width * (width - 1);
   \   00000006   0x1E44             SUBS     R4,R0,#+1
   \   00000008   0xFB04 0x1400      MLA      R4,R4,R0,R1
    135          	for(x=1; x<width; x++) {
   \   0000000C   0x2501             MOVS     R5,#+1
   \   0000000E   0xE004             B.N      ??MMask_evaluateSymbol_0
    136          		sum1 += (p[x] & 1);
   \                     ??MMask_evaluateSymbol_1: (+1)
   \   00000010   0x5D2E             LDRB     R6,[R5, R4]
   \   00000012   0xF006 0x0601      AND      R6,R6,#0x1
   \   00000016   0x18B2             ADDS     R2,R6,R2
    137          	}
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??MMask_evaluateSymbol_0: (+1)
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xDBF8             BLT.N    ??MMask_evaluateSymbol_1
    138          
    139          	p = frame + width * 2 - 1;
   \   0000001E   0xEB01 0x0140      ADD      R1,R1,R0, LSL #+1
   \   00000022   0x1E49             SUBS     R1,R1,#+1
    140          	for(y=1; y<width; y++) {
   \   00000024   0x2401             MOVS     R4,#+1
   \   00000026   0xE005             B.N      ??MMask_evaluateSymbol_2
    141          		sum2 += (*p & 1);
   \                     ??MMask_evaluateSymbol_3: (+1)
   \   00000028   0x780D             LDRB     R5,[R1, #+0]
   \   0000002A   0xF005 0x0501      AND      R5,R5,#0x1
   \   0000002E   0x18EB             ADDS     R3,R5,R3
    142          		p += width;
   \   00000030   0x1841             ADDS     R1,R0,R1
    143          	}
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \                     ??MMask_evaluateSymbol_2: (+1)
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xDBF7             BLT.N    ??MMask_evaluateSymbol_3
    144          
    145          	return (sum1 <= sum2)?(sum1 * 16 + sum2):(sum2 * 16 + sum1);
   \   00000038   0x4293             CMP      R3,R2
   \   0000003A   0xDB02             BLT.N    ??MMask_evaluateSymbol_4
   \   0000003C   0xEB03 0x1002      ADD      R0,R3,R2, LSL #+4
   \   00000040   0xE001             B.N      ??MMask_evaluateSymbol_5
   \                     ??MMask_evaluateSymbol_4: (+1)
   \   00000042   0xEB02 0x1003      ADD      R0,R2,R3, LSL #+4
   \                     ??MMask_evaluateSymbol_5: (+1)
   \   00000046   0xBC70             POP      {R4-R6}
   \   00000048   0x4770             BX       LR               ;; return
    146          }
    147          

   \                                 In section .text, align 2, keep-with-next
    148          unsigned char *MMask_mask(int version, unsigned char *frame, QRecLevel level)
    149          {
   \                     MMask_mask: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
    150          	int i;
    151          	unsigned char *mask, *bestMask;
    152          	int maxScore = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    153          	int score;
    154          	int width;
    155          
    156          	width = MQRspec_getWidth(version);
   \   0000000E   0x.... 0x....      BL       MQRspec_getWidth
   \   00000012   0x4680             MOV      R8,R0
    157          
    158          	mask = (unsigned char *)malloc(width * width);
   \   00000014   0xFB08 0xF008      MUL      R0,R8,R8
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x.... 0x....      BL       malloc
   \   0000001E   0x4681             MOV      R9,R0
    159          	if(mask == NULL) return NULL;
   \   00000020   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000024   0xD101             BNE.N    ??MMask_mask_0
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0xE02B             B.N      ??MMask_mask_1
    160          	bestMask = NULL;
   \                     ??MMask_mask_0: (+1)
   \   0000002A   0x46BA             MOV      R10,R7
    161          
    162          	for(i=0; i<maskNum; i++) {
   \   0000002C   0x46BB             MOV      R11,R7
   \   0000002E   0xE001             B.N      ??MMask_mask_2
   \                     ??MMask_mask_3: (+1)
   \   00000030   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??MMask_mask_2: (+1)
   \   00000034   0xF1BB 0x0F04      CMP      R11,#+4
   \   00000038   0xDA1F             BGE.N    ??MMask_mask_4
    163          		score = 0;
    164          		maskMakers[i](width, frame, mask);
   \   0000003A   0x464A             MOV      R2,R9
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x....             LDR.N    R3,??DataTable1
   \   00000042   0xF853 0x302B      LDR      R3,[R3, R11, LSL #+2]
   \   00000046   0x4798             BLX      R3
    165          		MMask_writeFormatInformation(version, width, mask, i, level);
   \   00000048   0x9600             STR      R6,[SP, #+0]
   \   0000004A   0x465B             MOV      R3,R11
   \   0000004C   0x464A             MOV      R2,R9
   \   0000004E   0x4641             MOV      R1,R8
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       MMask_writeFormatInformation
    166          		score = MMask_evaluateSymbol(width, mask);
   \   00000056   0x4649             MOV      R1,R9
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       MMask_evaluateSymbol
    167          		if(score > maxScore) {
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xDAE6             BGE.N    ??MMask_mask_3
    168          			maxScore = score;
   \   00000062   0x4607             MOV      R7,R0
    169          			free(bestMask);
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0x.... 0x....      BL       free
    170          			bestMask = mask;
   \   0000006A   0x46CA             MOV      R10,R9
    171          			mask = (unsigned char *)malloc(width * width);
   \   0000006C   0x9801             LDR      R0,[SP, #+4]
   \   0000006E   0x.... 0x....      BL       malloc
   \   00000072   0x4681             MOV      R9,R0
    172          			if(mask == NULL) break;
   \   00000074   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000078   0xD1DA             BNE.N    ??MMask_mask_3
    173          		}
    174          	}
    175          	free(mask);
   \                     ??MMask_mask_4: (+1)
   \   0000007A   0x4648             MOV      R0,R9
   \   0000007C   0x.... 0x....      BL       free
    176          	return bestMask;
   \   00000080   0x4650             MOV      R0,R10
   \                     ??MMask_mask_1: (+1)
   \   00000082   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    177          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     maskMakers

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   MMask_evaluateSymbol
      32   MMask_makeMask
        32   -- Indirect call
        32   -> MMask_writeFormatInformation
        32   -> MQRspec_getWidth
        32   -> __aeabi_errno_addr
        32   -> malloc
      48   MMask_mask
        48   -- Indirect call
        48   -> MMask_evaluateSymbol
        48   -> MMask_writeFormatInformation
        48   -> MQRspec_getWidth
        48   -> free
        48   -> malloc
      16   MMask_writeFormatInformation
        16   -> MQRspec_getFormatInfo
      12   Mask_mask0
      16   Mask_mask1
      16   Mask_mask2
      16   Mask_mask3


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      74  MMask_evaluateSymbol
      90  MMask_makeMask
     134  MMask_mask
      74  MMask_writeFormatInformation
      52  Mask_mask0
      66  Mask_mask1
      64  Mask_mask2
      70  Mask_mask3
      16  maskMakers

 
  16 bytes in section .data
 628 bytes in section .text
 
 628 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
