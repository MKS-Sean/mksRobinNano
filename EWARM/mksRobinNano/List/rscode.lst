###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:51
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\rscode.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\rscode.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\rscode.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\rscode.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\rscode.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Reed solomon encoder. This code is taken from Phil Karn's libfec then
      5           * editted and packed into a pair of .c and .h files.
      6           *
      7           * Copyright (C) 2002, 2003, 2004, 2006 Phil Karn, KA9Q
      8           * (libfec is released under the GNU Lesser General Public License.)
      9           *
     10           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
     11           *
     12           * This library is free software; you can redistribute it and/or
     13           * modify it under the terms of the GNU Lesser General Public
     14           * License as published by the Free Software Foundation; either
     15           * version 2.1 of the License, or any later version.
     16           *
     17           * This library is distributed in the hope that it will be useful,
     18           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     19           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     20           * Lesser General Public License for more details.
     21           *
     22           * You should have received a copy of the GNU Lesser General Public
     23           * License along with this library; if not, write to the Free Software
     24           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     25           */
     26          
     27          #if HAVE_CONFIG_H
     28          # include "config.h"
     29          #endif
     30          #include <stdlib.h>
     31          #include <string.h>
     32          #ifdef HAVE_LIBPTHREAD
     33          #  include <pthread.h>
     34          #endif
     35          
     36          #include "rscode.h"
     37          
     38          /* Stuff specific to the 8-bit symbol version of the general purpose RS codecs
     39           *
     40           */
     41          typedef unsigned char data_t;
     42          
     43          
     44          /**
     45           * Reed-Solomon codec control block
     46           */
     47          struct _RS {
     48          	int mm;              /* Bits per symbol */
     49          	int nn;              /* Symbols per block (= (1<<mm)-1) */
     50          	data_t *alpha_to;     /* log lookup table */
     51          	data_t *index_of;     /* Antilog lookup table */
     52          	data_t *genpoly;      /* Generator polynomial */
     53          	int nroots;     /* Number of generator roots = number of parity symbols */
     54          	int fcr;        /* First consecutive root, index form */
     55          	int prim;       /* Primitive element, index form */
     56          	int iprim;      /* prim-th root of 1, index form */
     57          	int pad;        /* Padding bytes in shortened block */
     58          	int gfpoly;
     59          	struct _RS *next;
     60          };
     61          

   \                                 In section .bss, align 4
     62          static RS *rslist = NULL;
   \                     rslist:
   \   00000000                      DS8 4
     63          #ifdef HAVE_LIBPTHREAD
     64          static pthread_mutex_t rslist_mutex = PTHREAD_MUTEX_INITIALIZER;
     65          #endif
     66          

   \                                 In section .text, align 2, keep-with-next
     67          static int modnn(RS *rs, int x){
   \                     modnn: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0xE005             B.N      ??modnn_0
     68          	while (x >= rs->nn) {
     69          		x -= rs->nn;
   \                     ??modnn_1: (+1)
   \   00000004   0x1A89             SUBS     R1,R1,R2
     70          		x = (x >> rs->mm) + (x & rs->nn);
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0xFA41 0xF303      ASR      R3,R1,R3
   \   0000000C   0x4011             ANDS     R1,R2,R1
   \   0000000E   0x18C9             ADDS     R1,R1,R3
     71          	}
   \                     ??modnn_0: (+1)
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xDAF7             BGE.N    ??modnn_1
     72          	return x;
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
     73          }
     74          
     75          
     76          #define MODNN(x) modnn(rs,x)
     77          
     78          #define MM (rs->mm)
     79          #define NN (rs->nn)
     80          #define ALPHA_TO (rs->alpha_to) 
     81          #define INDEX_OF (rs->index_of)
     82          #define GENPOLY (rs->genpoly)
     83          #define NROOTS (rs->nroots)
     84          #define FCR (rs->fcr)
     85          #define PRIM (rs->prim)
     86          #define IPRIM (rs->iprim)
     87          #define PAD (rs->pad)
     88          #define A0 (NN)
     89          
     90          
     91          /* Initialize a Reed-Solomon codec
     92           * symsize = symbol size, bits
     93           * gfpoly = Field generator polynomial coefficients
     94           * fcr = first root of RS code generator polynomial, index form
     95           * prim = primitive element to generate polynomial roots
     96           * nroots = RS code generator polynomial degree (number of roots)
     97           * pad = padding bytes at front of shortened block
     98           */

   \                                 In section .text, align 2, keep-with-next
     99          static RS *init_rs_char(int symsize, int gfpoly, int fcr, int prim, int nroots, int pad)
    100          {
   \                     init_rs_char: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461D             MOV      R5,R3
    101            RS *rs;
    102          
    103          
    104          /* Common code for intializing a Reed-Solomon control block (char or int symbols)
    105           * Copyright 2004 Phil Karn, KA9Q
    106           * May be used under the terms of the GNU Lesser General Public License (LGPL)
    107           */
    108          //#undef NULL
    109          //#define NULL ((void *)0)
    110          
    111            int i, j, sr,root,iprim;
    112          
    113            rs = NULL;
   \   0000000C   0x2400             MOVS     R4,#+0
    114            /* Check parameter ranges */
    115            if(symsize < 0 || symsize > (int)(8*sizeof(data_t))){
   \   0000000E   0x2F09             CMP      R7,#+9
   \   00000010   0xF080 0x80D1      BCS.W    ??init_rs_char_0
    116              goto done;
    117            }
    118          
    119            if(fcr < 0 || fcr >= (1<<symsize))
   \   00000014   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000018   0xF100 0x80CD      BMI.W    ??init_rs_char_0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x40B8             LSLS     R0,R0,R7
   \   00000020   0x4580             CMP      R8,R0
   \   00000022   0xF280 0x80C8      BGE.W    ??init_rs_char_0
    120              goto done;
    121            if(prim <= 0 || prim >= (1<<symsize))
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xF2C0 0x80C5      BLT.W    ??init_rs_char_0
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xF280 0x80C2      BGE.W    ??init_rs_char_0
   \   00000032   0x9E0A             LDR      R6,[SP, #+40]
    122              goto done;
    123            if(nroots < 0 || nroots >= (1<<symsize))
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xF100 0x80BE      BMI.W    ??init_rs_char_0
   \   0000003A   0x4286             CMP      R6,R0
   \   0000003C   0xF280 0x80BB      BGE.W    ??init_rs_char_0
   \   00000040   0xF8DD 0xA02C      LDR      R10,[SP, #+44]
    124              goto done; /* Can't have more roots than symbol values! */
    125            if(pad < 0 || pad >= ((1<<symsize) -1 - nroots))
   \   00000044   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000048   0xF100 0x80B5      BMI.W    ??init_rs_char_0
   \   0000004C   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \   00000050   0xEBAB 0x0006      SUB      R0,R11,R6
   \   00000054   0x4582             CMP      R10,R0
   \   00000056   0xF280 0x80AE      BGE.W    ??init_rs_char_0
    126              goto done; /* Too much padding */
    127          
    128            rs = (RS *)calloc(1,sizeof(RS));
   \   0000005A   0x2130             MOVS     R1,#+48
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       calloc
   \   00000062   0x0004             MOVS     R4,R0
    129            if(rs == NULL)
   \   00000064   0xF000 0x80A7      BEQ.W    ??init_rs_char_0
    130              goto done;
    131          
    132            rs->mm = symsize;
   \   00000068   0x6027             STR      R7,[R4, #+0]
    133            rs->nn = (1<<symsize)-1;
   \   0000006A   0xF8C4 0xB004      STR      R11,[R4, #+4]
    134            rs->pad = pad;
   \   0000006E   0xF8C4 0xA024      STR      R10,[R4, #+36]
    135          
    136            rs->alpha_to = (data_t *)malloc(sizeof(data_t)*(rs->nn+1));
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0x.... 0x....      BL       malloc
   \   0000007A   0x60A0             STR      R0,[R4, #+8]
    137            if(rs->alpha_to == NULL){
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD104             BNE.N    ??init_rs_char_1
    138              free(rs);
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       free
    139              rs = NULL;
   \   00000086   0x2400             MOVS     R4,#+0
    140              goto done;
   \   00000088   0xE095             B.N      ??init_rs_char_0
    141            }
    142            rs->index_of = (data_t *)malloc(sizeof(data_t)*(rs->nn+1));
   \                     ??init_rs_char_1: (+1)
   \   0000008A   0x6860             LDR      R0,[R4, #+4]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x.... 0x....      BL       malloc
   \   00000092   0x60E0             STR      R0,[R4, #+12]
    143            if(rs->index_of == NULL){
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD107             BNE.N    ??init_rs_char_2
    144              free(rs->alpha_to);
   \   00000098   0x68A0             LDR      R0,[R4, #+8]
   \   0000009A   0x.... 0x....      BL       free
    145              free(rs);
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       free
    146              rs = NULL;
   \   000000A4   0x2400             MOVS     R4,#+0
    147              goto done;
   \   000000A6   0xE086             B.N      ??init_rs_char_0
    148            }
    149          
    150            /* Generate Galois field lookup tables */
    151            rs->index_of[0] = A0; /* log(zero) = -inf */
   \                     ??init_rs_char_2: (+1)
   \   000000A8   0x6861             LDR      R1,[R4, #+4]
   \   000000AA   0x7001             STRB     R1,[R0, #+0]
    152            rs->alpha_to[A0] = 0; /* alpha**-inf = 0 */
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x6861             LDR      R1,[R4, #+4]
   \   000000B0   0x68A2             LDR      R2,[R4, #+8]
   \   000000B2   0x5488             STRB     R0,[R1, R2]
    153            sr = 1;
   \   000000B4   0x2101             MOVS     R1,#+1
    154            for(i=0;i<rs->nn;i++){
   \   000000B6   0xE00D             B.N      ??init_rs_char_3
    155              rs->index_of[sr] = i;
   \                     ??init_rs_char_4: (+1)
   \   000000B8   0x68E2             LDR      R2,[R4, #+12]
   \   000000BA   0x5488             STRB     R0,[R1, R2]
    156              rs->alpha_to[i] = sr;
   \   000000BC   0x68A2             LDR      R2,[R4, #+8]
   \   000000BE   0x5481             STRB     R1,[R0, R2]
    157              sr <<= 1;
   \   000000C0   0x0049             LSLS     R1,R1,#+1
    158              if(sr & (1<<symsize))
   \   000000C2   0xFA41 0xF207      ASR      R2,R1,R7
   \   000000C6   0x07D2             LSLS     R2,R2,#+31
   \   000000C8   0xD501             BPL.N    ??init_rs_char_5
    159                sr ^= gfpoly;
   \   000000CA   0xEA89 0x0101      EOR      R1,R9,R1
    160              sr &= rs->nn;
   \                     ??init_rs_char_5: (+1)
   \   000000CE   0x6862             LDR      R2,[R4, #+4]
   \   000000D0   0x4011             ANDS     R1,R2,R1
    161            }
   \   000000D2   0x1C40             ADDS     R0,R0,#+1
   \                     ??init_rs_char_3: (+1)
   \   000000D4   0x6862             LDR      R2,[R4, #+4]
   \   000000D6   0x4290             CMP      R0,R2
   \   000000D8   0xDBEE             BLT.N    ??init_rs_char_4
    162            if(sr != 1){
   \   000000DA   0x2901             CMP      R1,#+1
   \   000000DC   0xD105             BNE.N    ??init_rs_char_6
    163              /* field generator polynomial is not primitive! */
    164              free(rs->alpha_to);
    165              free(rs->index_of);
    166              free(rs);
    167              rs = NULL;
    168              goto done;
    169            }
    170          
    171            /* Form RS code generator polynomial from its roots */
    172            rs->genpoly = (data_t *)malloc(sizeof(data_t)*(nroots+1));
   \   000000DE   0x1C70             ADDS     R0,R6,#+1
   \   000000E0   0x.... 0x....      BL       malloc
   \   000000E4   0x6120             STR      R0,[R4, #+16]
    173            if(rs->genpoly == NULL){
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD10A             BNE.N    ??init_rs_char_7
    174              free(rs->alpha_to);
   \                     ??init_rs_char_6: (+1)
   \   000000EA   0x68A0             LDR      R0,[R4, #+8]
   \   000000EC   0x.... 0x....      BL       free
    175              free(rs->index_of);
   \   000000F0   0x68E0             LDR      R0,[R4, #+12]
   \   000000F2   0x.... 0x....      BL       free
    176              free(rs);
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       free
    177              rs = NULL;
   \   000000FC   0x2400             MOVS     R4,#+0
    178              goto done;
   \   000000FE   0xE05A             B.N      ??init_rs_char_0
    179            }
    180            rs->fcr = fcr;
   \                     ??init_rs_char_7: (+1)
   \   00000100   0xF8C4 0x8018      STR      R8,[R4, #+24]
    181            rs->prim = prim;
   \   00000104   0x61E5             STR      R5,[R4, #+28]
    182            rs->nroots = nroots;
   \   00000106   0x6166             STR      R6,[R4, #+20]
    183            rs->gfpoly = gfpoly;
   \   00000108   0xF8C4 0x9028      STR      R9,[R4, #+40]
    184            /* Find prim-th root of 1, used in decoding */
    185            for(iprim=1;(iprim % prim) != 0;iprim += rs->nn)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xE001             B.N      ??init_rs_char_8
   \                     ??init_rs_char_9: (+1)
   \   00000110   0x6861             LDR      R1,[R4, #+4]
   \   00000112   0x1808             ADDS     R0,R1,R0
   \                     ??init_rs_char_8: (+1)
   \   00000114   0xFB90 0xF1F5      SDIV     R1,R0,R5
   \   00000118   0xFB05 0x0211      MLS      R2,R5,R1,R0
   \   0000011C   0x2A00             CMP      R2,#+0
   \   0000011E   0xD1F7             BNE.N    ??init_rs_char_9
    186              ;
    187            rs->iprim = iprim / prim;
   \   00000120   0x6221             STR      R1,[R4, #+32]
    188          
    189            rs->genpoly[0] = 1;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x6921             LDR      R1,[R4, #+16]
   \   00000126   0x7008             STRB     R0,[R1, #+0]
    190            for (i = 0,root=fcr*prim; i < nroots; i++,root += prim) {
   \   00000128   0x2700             MOVS     R7,#+0
   \   0000012A   0xFB05 0xF808      MUL      R8,R5,R8
   \   0000012E   0xE00D             B.N      ??init_rs_char_10
    191              rs->genpoly[i+1] = 1;
    192          
    193              /* Multiply rs->genpoly[] by  @**(root + x) */
    194              for (j = i; j > 0; j--){
    195                if (rs->genpoly[j] != 0)
    196          	rs->genpoly[j] = rs->genpoly[j-1] ^ rs->alpha_to[modnn(rs,rs->index_of[rs->genpoly[j]] + root)];
    197                else
    198          	rs->genpoly[j] = rs->genpoly[j-1];
    199              }
    200              /* rs->genpoly[0] can never be zero */
    201              rs->genpoly[0] = rs->alpha_to[modnn(rs,rs->index_of[rs->genpoly[0]] + root)];
   \                     ??init_rs_char_11: (+1)
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x68E1             LDR      R1,[R4, #+12]
   \   00000134   0x5C40             LDRB     R0,[R0, R1]
   \   00000136   0xEB08 0x0100      ADD      R1,R8,R0
   \   0000013A   0x4620             MOV      R0,R4
   \   0000013C   0x.... 0x....      BL       modnn
   \   00000140   0x68A1             LDR      R1,[R4, #+8]
   \   00000142   0x5C40             LDRB     R0,[R0, R1]
   \   00000144   0x6921             LDR      R1,[R4, #+16]
   \   00000146   0x7008             STRB     R0,[R1, #+0]
   \   00000148   0x1C7F             ADDS     R7,R7,#+1
   \   0000014A   0x44A8             ADD      R8,R5,R8
   \                     ??init_rs_char_10: (+1)
   \   0000014C   0x42B7             CMP      R7,R6
   \   0000014E   0xDA28             BGE.N    ??init_rs_char_12
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0x6921             LDR      R1,[R4, #+16]
   \   00000154   0x1879             ADDS     R1,R7,R1
   \   00000156   0x7048             STRB     R0,[R1, #+1]
   \   00000158   0x46B9             MOV      R9,R7
   \   0000015A   0xE007             B.N      ??init_rs_char_13
   \                     ??init_rs_char_14: (+1)
   \   0000015C   0xEB09 0x0100      ADD      R1,R9,R0
   \   00000160   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   00000164   0xF809 0x1000      STRB     R1,[R9, R0]
   \                     ??init_rs_char_15: (+1)
   \   00000168   0xF1A9 0x0901      SUB      R9,R9,#+1
   \                     ??init_rs_char_13: (+1)
   \   0000016C   0x6920             LDR      R0,[R4, #+16]
   \   0000016E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000172   0xDBDD             BLT.N    ??init_rs_char_11
   \   00000174   0xF819 0x1000      LDRB     R1,[R9, R0]
   \   00000178   0x2900             CMP      R1,#+0
   \   0000017A   0xD0EF             BEQ.N    ??init_rs_char_14
   \   0000017C   0x4682             MOV      R10,R0
   \   0000017E   0xEB09 0x000A      ADD      R0,R9,R10
   \   00000182   0xF810 0xBC01      LDRB     R11,[R0, #-1]
   \   00000186   0x68E0             LDR      R0,[R4, #+12]
   \   00000188   0x5C08             LDRB     R0,[R1, R0]
   \   0000018A   0xEB08 0x0100      ADD      R1,R8,R0
   \   0000018E   0x4620             MOV      R0,R4
   \   00000190   0x.... 0x....      BL       modnn
   \   00000194   0x68A1             LDR      R1,[R4, #+8]
   \   00000196   0x5C40             LDRB     R0,[R0, R1]
   \   00000198   0xEA80 0x000B      EOR      R0,R0,R11
   \   0000019C   0xF809 0x000A      STRB     R0,[R9, R10]
   \   000001A0   0xE7E2             B.N      ??init_rs_char_15
    202            }
    203            /* convert rs->genpoly[] to index form for quicker encoding */
    204            for (i = 0; i <= nroots; i++)
   \                     ??init_rs_char_12: (+1)
   \   000001A2   0x2000             MOVS     R0,#+0
   \   000001A4   0xE005             B.N      ??init_rs_char_16
    205              rs->genpoly[i] = rs->index_of[rs->genpoly[i]];
   \                     ??init_rs_char_17: (+1)
   \   000001A6   0x6921             LDR      R1,[R4, #+16]
   \   000001A8   0x5C42             LDRB     R2,[R0, R1]
   \   000001AA   0x68E3             LDR      R3,[R4, #+12]
   \   000001AC   0x5CD2             LDRB     R2,[R2, R3]
   \   000001AE   0x5442             STRB     R2,[R0, R1]
   \   000001B0   0x1C40             ADDS     R0,R0,#+1
   \                     ??init_rs_char_16: (+1)
   \   000001B2   0x4286             CMP      R6,R0
   \   000001B4   0xDAF7             BGE.N    ??init_rs_char_17
    206           done:;
    207          
    208            return rs;
   \                     ??init_rs_char_0: (+1)
   \   000001B6   0x4620             MOV      R0,R4
   \   000001B8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          RS *init_rs(int symsize, int gfpoly, int fcr, int prim, int nroots, int pad)
    212          {
   \                     init_rs: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x461C             MOV      R4,R3
    213          	RS *rs;
    214          
    215          #ifdef HAVE_LIBPTHREAD
    216          	pthread_mutex_lock(&rslist_mutex);
    217          #endif
    218          	for(rs = rslist; rs != NULL; rs = rs->next) {
   \   00000006   0x....             LDR.N    R5,??DataTable1
   \   00000008   0x682B             LDR      R3,[R5, #+0]
   \   0000000A   0x9E08             LDR      R6,[SP, #+32]
   \   0000000C   0x9F09             LDR      R7,[SP, #+36]
   \   0000000E   0xE018             B.N      ??init_rs_0
    219          		if(rs->pad != pad) continue;
   \                     ??init_rs_1: (+1)
   \   00000010   0xF8D3 0xC024      LDR      R12,[R3, #+36]
   \   00000014   0x45BC             CMP      R12,R7
   \   00000016   0xD113             BNE.N    ??init_rs_2
    220          		if(rs->nroots != nroots) continue;
   \   00000018   0xF8D3 0xC014      LDR      R12,[R3, #+20]
   \   0000001C   0x45B4             CMP      R12,R6
   \   0000001E   0xD10F             BNE.N    ??init_rs_2
    221          		if(rs->mm != symsize) continue;
   \   00000020   0xF8D3 0xC000      LDR      R12,[R3, #+0]
   \   00000024   0x4584             CMP      R12,R0
   \   00000026   0xD10B             BNE.N    ??init_rs_2
    222          		if(rs->gfpoly != gfpoly) continue;
   \   00000028   0xF8D3 0xC028      LDR      R12,[R3, #+40]
   \   0000002C   0x458C             CMP      R12,R1
   \   0000002E   0xD107             BNE.N    ??init_rs_2
    223          		if(rs->fcr != fcr) continue;
   \   00000030   0xF8D3 0xC018      LDR      R12,[R3, #+24]
   \   00000034   0x4594             CMP      R12,R2
   \   00000036   0xD103             BNE.N    ??init_rs_2
    224          		if(rs->prim != prim) continue;
   \   00000038   0xF8D3 0xC01C      LDR      R12,[R3, #+28]
   \   0000003C   0x45A4             CMP      R12,R4
   \   0000003E   0xD00C             BEQ.N    ??init_rs_3
    225          
    226          		goto DONE;
    227          	}
   \                     ??init_rs_2: (+1)
   \   00000040   0x6ADB             LDR      R3,[R3, #+44]
   \                     ??init_rs_0: (+1)
   \   00000042   0x2B00             CMP      R3,#+0
   \   00000044   0xD1E4             BNE.N    ??init_rs_1
    228          
    229          	rs = init_rs_char(symsize, gfpoly, fcr, prim, nroots, pad);
   \   00000046   0x9701             STR      R7,[SP, #+4]
   \   00000048   0x9600             STR      R6,[SP, #+0]
   \   0000004A   0x4623             MOV      R3,R4
   \   0000004C   0x.... 0x....      BL       init_rs_char
   \   00000050   0x0003             MOVS     R3,R0
    230          	if(rs == NULL) goto DONE;
   \   00000052   0xD002             BEQ.N    ??init_rs_3
    231          	rs->next = rslist;
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0x62D8             STR      R0,[R3, #+44]
    232          	rslist = rs;
   \   00000058   0x602B             STR      R3,[R5, #+0]
    233          
    234          DONE:
    235          #ifdef HAVE_LIBPTHREAD
    236          	pthread_mutex_unlock(&rslist_mutex);
    237          #endif
    238          	return rs;
   \                     ??init_rs_3: (+1)
   \   0000005A   0x4618             MOV      R0,R3
   \   0000005C   0xBDFE             POP      {R1-R7,PC}       ;; return
    239          }
    240          
    241          

   \                                 In section .text, align 2, keep-with-next
    242          void free_rs_char(RS *rs)
    243          {
   \                     free_rs_char: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    244          	free(rs->alpha_to);
   \   00000004   0x68A0             LDR      R0,[R4, #+8]
   \   00000006   0x.... 0x....      BL       free
    245          	free(rs->index_of);
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x.... 0x....      BL       free
    246          	free(rs->genpoly);
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x.... 0x....      BL       free
    247          	free(rs);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      free
    248          }
    249          

   \                                 In section .text, align 2, keep-with-next
    250          void free_rs_cache(void)
    251          {
   \                     free_rs_cache: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    252          	RS *rs, *next;
    253          
    254          #ifdef HAVE_LIBPTHREAD
    255          	pthread_mutex_lock(&rslist_mutex);
    256          #endif
    257          	rs = rslist;
   \   00000002   0x....             LDR.N    R4,??DataTable1
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xE003             B.N      ??free_rs_cache_0
    258          	while(rs != NULL) {
    259          		next = rs->next;
   \                     ??free_rs_cache_1: (+1)
   \   0000000A   0x6AC5             LDR      R5,[R0, #+44]
    260          		free_rs_char(rs);
   \   0000000C   0x.... 0x....      BL       free_rs_char
    261          		rs = next;
   \   00000010   0x0028             MOVS     R0,R5
    262          	}
   \                     ??free_rs_cache_0: (+1)
   \   00000012   0xD1FA             BNE.N    ??free_rs_cache_1
    263          	rslist = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6020             STR      R0,[R4, #+0]
    264          #ifdef HAVE_LIBPTHREAD
    265          	pthread_mutex_unlock(&rslist_mutex);
    266          #endif
    267          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    268          
    269          /* The guts of the Reed-Solomon encoder, meant to be #included
    270           * into a function body with the following typedefs, macros and variables supplied
    271           * according to the code parameters:
    272          
    273           * data_t - a typedef for the data symbol
    274           * data_t data[] - array of NN-NROOTS-PAD and type data_t to be encoded
    275           * data_t parity[] - an array of NROOTS and type data_t to be written with parity symbols
    276           * NROOTS - the number of roots in the RS code generator polynomial,
    277           *          which is the same as the number of parity symbols in a block.
    278                      Integer variable or literal.
    279          	    * 
    280           * NN - the total number of symbols in a RS block. Integer variable or literal.
    281           * PAD - the number of pad symbols in a block. Integer variable or literal.
    282           * ALPHA_TO - The address of an array of NN elements to convert Galois field
    283           *            elements in index (log) form to polynomial form. Read only.
    284           * INDEX_OF - The address of an array of NN elements to convert Galois field
    285           *            elements in polynomial form to index (log) form. Read only.
    286           * MODNN - a function to reduce its argument modulo NN. May be inline or a macro.
    287           * GENPOLY - an array of NROOTS+1 elements containing the generator polynomial in index form
    288          
    289           * The memset() and memmove() functions are used. The appropriate header
    290           * file declaring these functions (usually <string.h>) must be included by the calling
    291           * program.
    292          
    293           * Copyright 2004, Phil Karn, KA9Q
    294           * May be used under the terms of the GNU Lesser General Public License (LGPL)
    295           */
    296          
    297          #undef A0
    298          #define A0 (NN) /* Special reserved value encoding zero in index form */
    299          

   \                                 In section .text, align 2, keep-with-next
    300          void encode_rs_char(RS *rs, const data_t *data, data_t *parity)
    301          {
   \                     encode_rs_char: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    302            int i, j;
    303            data_t feedback;
    304          
    305            memset(parity,0,NROOTS*sizeof(data_t));
   \   0000000A   0x6962             LDR      R2,[R4, #+20]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x.... 0x....      BL       memset
    306          
    307            for(i=0;i<NN-NROOTS-PAD;i++){
   \   00000014   0x2700             MOVS     R7,#+0
   \   00000016   0xE005             B.N      ??encode_rs_char_0
    308              feedback = INDEX_OF[data[i] ^ parity[0]];
    309              if(feedback != A0){      /* feedback term is non-zero */
    310          #ifdef UNNORMALIZED
    311                /* This line is unnecessary when GENPOLY[NROOTS] is unity, as it must
    312                 * always be for the polynomials constructed by init_rs()
    313                 */
    314                feedback = MODNN(NN - GENPOLY[NROOTS] + feedback);
    315          #endif
    316                for(j=1;j<NROOTS;j++)
    317          	parity[j] ^= ALPHA_TO[MODNN(feedback + GENPOLY[NROOTS-j])];
    318              }
    319              /* Shift */
    320              memmove(&parity[0],&parity[1],sizeof(data_t)*(NROOTS-1));
    321              if(feedback != A0)
    322                parity[NROOTS-1] = ALPHA_TO[MODNN(feedback + GENPOLY[0])];
    323              else
    324                parity[NROOTS-1] = 0;
   \                     ??encode_rs_char_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6961             LDR      R1,[R4, #+20]
   \   0000001C   0x1989             ADDS     R1,R1,R6
   \   0000001E   0xF801 0x0C01      STRB     R0,[R1, #-1]
   \                     ??encode_rs_char_2: (+1)
   \   00000022   0x1C7F             ADDS     R7,R7,#+1
   \                     ??encode_rs_char_0: (+1)
   \   00000024   0x6860             LDR      R0,[R4, #+4]
   \   00000026   0x6961             LDR      R1,[R4, #+20]
   \   00000028   0x1A41             SUBS     R1,R0,R1
   \   0000002A   0x6A62             LDR      R2,[R4, #+36]
   \   0000002C   0x1A89             SUBS     R1,R1,R2
   \   0000002E   0x428F             CMP      R7,R1
   \   00000030   0xDA37             BGE.N    ??encode_rs_char_3
   \   00000032   0x5D79             LDRB     R1,[R7, R5]
   \   00000034   0x7832             LDRB     R2,[R6, #+0]
   \   00000036   0x4051             EORS     R1,R2,R1
   \   00000038   0x68E2             LDR      R2,[R4, #+12]
   \   0000003A   0xF811 0x8002      LDRB     R8,[R1, R2]
   \   0000003E   0x4580             CMP      R8,R0
   \   00000040   0xD018             BEQ.N    ??encode_rs_char_4
   \   00000042   0xF04F 0x0901      MOV      R9,#+1
   \   00000046   0xE012             B.N      ??encode_rs_char_5
   \                     ??encode_rs_char_6: (+1)
   \   00000048   0xF819 0xA006      LDRB     R10,[R9, R6]
   \   0000004C   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000050   0x6921             LDR      R1,[R4, #+16]
   \   00000052   0x5C40             LDRB     R0,[R0, R1]
   \   00000054   0xEB00 0x0108      ADD      R1,R0,R8
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       modnn
   \   0000005E   0x68A1             LDR      R1,[R4, #+8]
   \   00000060   0x5C40             LDRB     R0,[R0, R1]
   \   00000062   0xEA80 0x000A      EOR      R0,R0,R10
   \   00000066   0xF809 0x0006      STRB     R0,[R9, R6]
   \   0000006A   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??encode_rs_char_5: (+1)
   \   0000006E   0x6960             LDR      R0,[R4, #+20]
   \   00000070   0x4581             CMP      R9,R0
   \   00000072   0xDBE9             BLT.N    ??encode_rs_char_6
   \                     ??encode_rs_char_4: (+1)
   \   00000074   0x6960             LDR      R0,[R4, #+20]
   \   00000076   0x1E42             SUBS     R2,R0,#+1
   \   00000078   0x1C71             ADDS     R1,R6,#+1
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0x.... 0x....      BL       memmove
   \   00000080   0x6860             LDR      R0,[R4, #+4]
   \   00000082   0x4580             CMP      R8,R0
   \   00000084   0xD0C8             BEQ.N    ??encode_rs_char_1
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0xEB00 0x0108      ADD      R1,R0,R8
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       modnn
   \   00000094   0x68A1             LDR      R1,[R4, #+8]
   \   00000096   0x5C40             LDRB     R0,[R0, R1]
   \   00000098   0x6961             LDR      R1,[R4, #+20]
   \   0000009A   0x1989             ADDS     R1,R1,R6
   \   0000009C   0xF801 0x0C01      STRB     R0,[R1, #-1]
   \   000000A0   0xE7BF             B.N      ??encode_rs_char_2
    325            }
    326          }
   \                     ??encode_rs_char_3: (+1)
   \   000000A2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     rslist

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   encode_rs_char
        32   -> memmove
        32   -> memset
        32   -> modnn
      16   free_rs_cache
        16   -> free_rs_char
       8   free_rs_char
         0   -> free
         8   -> free
      32   init_rs
        32   -> init_rs_char
      40   init_rs_char
        40   -> calloc
        40   -> free
        40   -> malloc
        40   -> modnn
       0   modnn


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
     166  encode_rs_char
      26  free_rs_cache
      32  free_rs_char
      94  init_rs
     444  init_rs_char
      24  modnn
       4  rslist

 
   4 bytes in section .bss
 790 bytes in section .text
 
 790 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
