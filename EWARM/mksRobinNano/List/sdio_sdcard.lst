###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:52
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\sdio_sdcard.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\sdio_sdcard.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.c
      1          #include "sdio_sdcard.h"

  #define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",152  Warning[Pe047]: 
          incompatible redefinition of macro "IS_NVIC_PRIORITY_GROUP"
          (declared at line 277 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SYSTICK_CLK_SOURCE" (declared
          at line 296 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define SDIO_INIT_CLK_DIV        0x166//0xB2 		//SDIO初始化频率，最大400Kh  
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",36  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_INIT_CLK_DIV" (declared at
          line 479 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SDIO_TRANSFER_CLK_DIV    0x07//0x02//0x01		//SDIO传输频率，最大24Mhz(4bit)。该值太小可能会导致读写文件出错 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",37  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_TRANSFER_CLK_DIV" (declared
          at line 482 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SD_CMD_GO_IDLE_STATE                       ((u8)0)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IDLE_STATE" (declared
          at line 304 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_OP_COND                        ((u8)1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",171  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_OP_COND" (declared
          at line 305 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ALL_SEND_CID                        ((u8)2)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",172  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ALL_SEND_CID" (declared
          at line 306 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_REL_ADDR                        ((u8)3) /*!< SDIO_SEND_REL_ADDR for SD Card */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_REL_ADDR" (declared
          at line 307 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_DSR                             ((u8)4)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_DSR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_SEN_OP_COND                    ((u8)5)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",175  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_SEN_OP_COND"
          (declared at line 309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SWITCH                           ((u8)6)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",176  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SWITCH" (declared at
          line 311 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEL_DESEL_CARD                      ((u8)7)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",177  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEL_DESEL_CARD" (declared
          at line 312 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SEND_EXT_CSD                     ((u8)8)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",178  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SEND_EXT_CSD"
          (declared at line 313 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CSD                            ((u8)9)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",179  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CSD" (declared at
          line 315 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CID                            ((u8)10)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",180  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CID" (declared at
          line 316 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_DAT_UNTIL_STOP                 ((u8)11) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",181  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_DAT_UNTIL_STOP"
          (declared at line 317 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_STOP_TRANSMISSION                   ((u8)12)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_STOP_TRANSMISSION"
          (declared at line 318 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_STATUS                         ((u8)13)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",183  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_STATUS" (declared at
          line 319 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_READ                     ((u8)14)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",184  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_READ"
          (declared at line 320 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_INACTIVE_STATE                   ((u8)15)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_INACTIVE_STATE"
          (declared at line 321 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCKLEN                        ((u8)16)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",186  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCKLEN" (declared
          at line 322 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_SINGLE_BLOCK                   ((u8)17)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",187  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_SINGLE_BLOCK"
          (declared at line 325 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_MULT_BLOCK                     ((u8)18)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",188  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_MULT_BLOCK"
          (declared at line 327 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_WRITE                    ((u8)19)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",189  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_WRITE"
          (declared at line 329 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_DAT_UNTIL_STOP                ((u8)20) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",190  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_DAT_UNTIL_STOP"
          (declared at line 330 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCK_COUNT                     ((u8)23) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",191  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCK_COUNT"
          (declared at line 331 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_SINGLE_BLOCK                  ((u8)24)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",192  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_SINGLE_BLOCK"
          (declared at line 332 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_MULT_BLOCK                    ((u8)25)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",193  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_MULT_BLOCK"
          (declared at line 334 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CID                            ((u8)26)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CID" (declared at
          line 335 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CSD                            ((u8)27)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",195  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CSD" (declared at
          line 336 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_WRITE_PROT                      ((u8)28)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",196  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_WRITE_PROT" (declared
          at line 337 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_CLR_WRITE_PROT                      ((u8)29)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_CLR_WRITE_PROT" (declared
          at line 338 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_WRITE_PROT                     ((u8)30)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",198  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_WRITE_PROT"
          (declared at line 339 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_START                  ((u8)32) /*!< To set the address of the first write
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",199  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_START"
          (declared at line 340 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_END                    ((u8)33) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",201  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_END"
          (declared at line 341 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_START                     ((u8)35) /*!< To set the address of the first write block to be erased.
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",203  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_START"
          (declared at line 342 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_END                       ((u8)36) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",206  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_END" (declared
          at line 344 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE                               ((u8)38)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE" (declared at line
          346 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_FAST_IO                             ((u8)39) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",210  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_FAST_IO" (declared at
          line 347 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_IRQ_STATE                        ((u8)40) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",211  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IRQ_STATE" (declared
          at line 348 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_LOCK_UNLOCK                         ((u8)42)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_LOCK_UNLOCK" (declared at
          line 349 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_CMD                             ((u8)55)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",213  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_CMD" (declared at
          line 351 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GEN_CMD                             ((u8)56)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",214  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GEN_CMD" (declared at
          line 353 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_NO_CMD                              ((u8)64)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",215  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_NO_CMD" (declared at line
          355 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_SD_SET_BUSWIDTH                 ((u8)6)  /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_SD_SET_BUSWIDTH"
          (declared at line 361 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_STAUS                        ((u8)13) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",222  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_STAUS" (declared
          at line 2841 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS        ((u8)22) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",223  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS" (declared at line 364 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_OP_COND                      ((u8)41) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",224  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_OP_COND" (declared
          at line 366 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CLR_CARD_DETECT          ((u8)42) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",225  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SET_CLR_CARD_DETECT" (declared at line 368 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SEND_SCR                     ((u8)51) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",226  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SEND_SCR"
          (declared at line 369 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_DIRECT                      ((u8)52) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",227  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_DIRECT" (declared
          at line 370 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_EXTENDED                    ((u8)53) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",228  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_EXTENDED"
          (declared at line 371 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MKB                      ((u8)43) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",234  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MKB" (declared
          at line 377 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MID                      ((u8)44) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",235  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MID" (declared
          at line 378 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RN1                  ((u8)45) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",236  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RN1"
          (declared at line 379 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RN2                  ((u8)46) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",237  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RN2"
          (declared at line 380 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RES2                 ((u8)47) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",238  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RES2"
          (declared at line 381 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RES1                 ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RES1"
          (declared at line 382 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK   ((u8)18) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",240  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK" (declared at line 383 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK  ((u8)25) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",241  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK" (declared at line 384 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_ERASE                 ((u8)38) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",242  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_ERASE"
          (declared at line 385 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_CHANGE_SECURE_AREA           ((u8)49) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",243  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_CHANGE_SECURE_AREA"
          (declared at line 386 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MKB             ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",244  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_WRITE_MKB"
          (declared at line 387 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define NULL 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "NULL" (declared at line 22 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench
          7.0\arm\inc\c\stdio.h")

  #define SD_OCR_CID_CSD_OVERWRIETE       ((u32)0x00010000)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",278  Warning[Pe047]: 
          incompatible redefinition of macro "SD_OCR_CID_CSD_OVERWRIETE"
          (declared at line 2840 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")
      2          #include "string.h"	 
      3          #include "sys.h"
      4          #include "bsp_driver_sd.h"

  #define SD_DATATIMEOUT           ((uint32_t)100000000)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\bsp_driver_sd.h",78  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DATATIMEOUT" (declared at
          line 310 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Src\sdio_sdcard.h")
      5          //#include "usart.h"	 
      6          ////////////////////////////////////////////////////////////////////////////////////////////////////
      7          //本程序只供学习使用，未经作者许可，不得用于其它任何用途
      8          //ALIENTEK STM32开发板
      9          //SDIO 驱动代码(改自ST官方SDIO例程,感谢网友mygod提供的参考代码)	   
     10          //正点原子@ALIENTEK
     11          //技术论坛:www.openedv.com
     12          //修改日期:2013/03/04
     13          //版本：V1.1 
     14          //版权所有，盗版必究。
     15          //Copyright(C) 广州市星翼电子科技有限公司 2009-2019
     16          //All rights reserved
     17          //**************************************************************************************************
     18          //V1.1修改说明
     19          //1,修改部分定义,减少内存占用.
     20          //2,修改CardCapacity类型,使之支持高容量卡
     21          //3,修改对MMC卡的支持.	
     22          //4,增加对写数据时出错的处理,防假死
     23          //5,目前该版本通杀所有SD卡包括MMC卡							  
     24          ////////////////////////////////////////////////////////////////////////////////////////////////////  													   
     25          									  

   \                                 In section .data, align 4
     26          static u8 CardType=SDIO_STD_CAPACITY_SD_CARD_V1_1;		//SD卡类型
   \                     CardType:
   \   00000000   0x00               DC8 0
   \   00000001   0x01               DC8 1
   \   00000002   0x00               DC8 0
     27          static u32 CSD_Tab[4],CID_Tab[4],RCA=0;					//SD卡CSD,CID以及相对地址(RCA)数据
     28          static u8 DeviceMode=SD_DMA_MODE;		   				//工作模式,注意,工作模式必须通过SD_SetDeviceMode,后才算数.这里只是定义一个默认的模式(SD_DMA_MODE)
     29          static u8 StopCondition=0; 								//是否发送停止传输标志位,DMA多块读写的时候用到  
     30          volatile SD_Error TransferError=SD_OK;					//数据传输错误标志,DMA读写时使用	    
   \                     TransferError:
   \   00000003   0x00               DC8 0
     31          volatile u8 TransferEnd=0;								//传输结束标志,DMA读写时使用
   \                     TransferEnd:
   \   00000004   0x00               DC8 0
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00000000         DC32 0

   \                                 In section .bss, align 8
     32          SD_CardInfo SDCardInfo;									//SD卡信息
   \                     SDCardInfo:
   \   00000000                      DS8 88
     33          
     34          //SD_ReadDisk/SD_WriteDisk函数专用buf,当这两个函数的数据缓存区地址不是4字节对齐的时候,
     35          //需要用到该数组,确保数据缓存区地址是4字节对齐的.
     36          #pragma pack(4) 

   \                                 In section .bss, align 4
     37          u8 SDIO_DATA_BUFFER[512];						  
   \                     SDIO_DATA_BUFFER:
   \   00000000                      DS8 512
     38          #pragma pack() 
     39          
     40          //初始化SD卡
     41          //返回值:错误代码;(0,无错误)

   \                                 In section .text, align 2, keep-with-next
     42          SD_Error SD_Init(void)
     43          {
   \                     SD_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     44            NVIC_InitTypeDef NVIC_InitStructure;
     45              
     46          	SD_Error errorstatus=SD_OK;	   
     47          	//SDIO IO口初始化
     48          	RCC->APB2ENR|=1<<4;    	//使能PORTC时钟	   	 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021014
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000000C   0x6041             STR      R1,[R0, #+4]
     49          	RCC->APB2ENR|=1<<5;    	//使能PORTD时钟
   \   0000000E   0x6841             LDR      R1,[R0, #+4]
   \   00000010   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000014   0x6041             STR      R1,[R0, #+4]
     50            RCC->AHBENR|=1<<10;    	//使能SDIO时钟	   	 
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000001C   0x6001             STR      R1,[R0, #+0]
     51           	RCC->AHBENR|=1<<1;    	//使能DMA2时钟
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000024   0x6001             STR      R1,[R0, #+0]
     52          
     53          	GPIOC->CRH&=0XFFF00000; 
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40011004
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x0D09             LSRS     R1,R1,#+20
   \   0000002E   0x0509             LSLS     R1,R1,#+20
   \   00000030   0x6001             STR      R1,[R0, #+0]
     54          	GPIOC->CRH|=0X000BBBBB;	//PC.8~12 复用输出
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable12_2  ;; 0xbbbbb
   \   00000038   0x4311             ORRS     R1,R2,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
     55          
     56          	GPIOD->CRL&=0XFFFFF0FF; 
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40011400
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x6170      BIC      R1,R1,#0xF00
   \   00000046   0x6001             STR      R1,[R0, #+0]
     57          	GPIOD->CRL|=0X00000B00;	//PD2复用输出,PD7 上拉输入
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF441 0x6130      ORR      R1,R1,#0xB00
   \   0000004E   0x6001             STR      R1,[R0, #+0]
     58           	//SDIO外设寄存器设置为默认值 			   
     59          	SDIO->POWER=0x00000000;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6001             STR      R1,[R0, #+0]
     60          	SDIO->CLKCR=0x00000000;
   \   00000058   0x6041             STR      R1,[R0, #+4]
     61          	SDIO->ARG=0x00000000;
   \   0000005A   0x6081             STR      R1,[R0, #+8]
     62          	SDIO->CMD=0x00000000;
   \   0000005C   0x60C1             STR      R1,[R0, #+12]
     63          	SDIO->DTIMER=0x00000000;
   \   0000005E   0x6241             STR      R1,[R0, #+36]
     64          	SDIO->DLEN=0x00000000;
   \   00000060   0x6281             STR      R1,[R0, #+40]
     65          	SDIO->DCTRL=0x00000000;
   \   00000062   0x62C1             STR      R1,[R0, #+44]
     66          	SDIO->ICR=0x00C007FF;
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0xc007ff
   \   00000068   0x6381             STR      R1,[R0, #+56]
     67          	SDIO->MASK=0x00000000;	
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x63C1             STR      R1,[R0, #+60]
     68          	
     69              
     70           	//MY_NVIC_Init(0,0,SDIO_IRQChannel,2);//SDIO中断配置
     71              NVIC_InitStructure.NVIC_IRQChannel = SDIO_IRQn;			//SDIO中断配置
   \   0000006E   0x2031             MOVS     R0,#+49
   \   00000070   0xF88D 0x0000      STRB     R0,[SP, #+0]
     72              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	//抢占优先级0 
   \   00000074   0x4608             MOV      R0,R1
   \   00000076   0xF88D 0x0001      STRB     R0,[SP, #+1]
     73              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;					//子优先级0 
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF88D 0x0002      STRB     R0,[SP, #+2]
     74              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;								//使能外部中断通道
   \   00000080   0xF88D 0x0003      STRB     R0,[SP, #+3]
     75              NVIC_Init(&NVIC_InitStructure);  	  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
   \   00000084   0xA800             ADD      R0,SP,#+0
   \   00000086   0x.... 0x....      BL       NVIC_Init
     76            
     77             	errorstatus=SD_PowerON();			//SD卡上电
   \   0000008A   0x.... 0x....      BL       SD_PowerON
     78           	if(errorstatus==SD_OK)errorstatus=SD_InitializeCards();			//初始化SD卡														  
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD101             BNE.N    ??SD_Init_0
   \   00000092   0x.... 0x....      BL       SD_InitializeCards
     79            	if(errorstatus==SD_OK)errorstatus=SD_GetCardInfo(&SDCardInfo);	//获取卡信息
   \                     ??SD_Init_0: (+1)
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD103             BNE.N    ??SD_Init_1
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   0000009E   0x.... 0x....      BL       SD_GetCardInfo
     80           	if(errorstatus==SD_OK)errorstatus=SD_SelectDeselect((u32)(SDCardInfo.RCA<<16));//选中SD卡   
   \                     ??SD_Init_1: (+1)
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD106             BNE.N    ??SD_Init_2
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   000000AA   0xF8B0 0x0054      LDRH     R0,[R0, #+84]
   \   000000AE   0x0400             LSLS     R0,R0,#+16
   \   000000B0   0x.... 0x....      BL       SD_SelectDeselect
     81             	if(errorstatus==SD_OK)errorstatus=SD_EnableWideBusOperation(1);	//4位宽度,如果是MMC卡,则不能用4位模式 
   \                     ??SD_Init_2: (+1)
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD102             BNE.N    ??SD_Init_3
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x.... 0x....      BL       SD_EnableWideBusOperation
     82            	if((errorstatus==SD_OK)||(SDIO_MULTIMEDIA_CARD==CardType))
   \                     ??SD_Init_3: (+1)
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD004             BEQ.N    ??SD_Init_4
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000000C6   0x7809             LDRB     R1,[R1, #+0]
   \   000000C8   0x2903             CMP      R1,#+3
   \   000000CA   0xD105             BNE.N    ??SD_Init_5
     83          	{  		    
     84          		SDIO_Clock_Set(SDIO_TRANSFER_CLK_DIV);			//设置时钟频率,SDIO时钟计算公式:SDIO_CK时钟=SDIOCLK/[clkdiv+2];其中,SDIOCLK一般为72Mhz 
   \                     ??SD_Init_4: (+1)
   \   000000CC   0x2007             MOVS     R0,#+7
   \   000000CE   0x.... 0x....      BL       SDIO_Clock_Set
     85          		errorstatus=SD_SetDeviceMode(SD_DMA_MODE);		//设置为DMA模式
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0x.... 0x....      BL       SD_SetDeviceMode
     86          		//errorstatus=SD_SetDeviceMode(SD_POLLING_MODE);//设置为查询模式
     87           	}
     88          	return errorstatus;		 
   \                     ??SD_Init_5: (+1)
   \   000000D8   0xBD02             POP      {R1,PC}          ;; return
     89          }
     90          //SDIO时钟初始化设置
     91          //clkdiv:时钟分频系数
     92          //CK时钟=SDIOCLK/[clkdiv+2];(SDIOCLK时钟直接就是AHB时钟,一般为72Mhz)

   \                                 In section .text, align 2, keep-with-next
     93          void SDIO_Clock_Set(u8 clkdiv)
     94          {
     95            	SDIO->CLKCR&=0XFFFFFF00;
   \                     SDIO_Clock_Set: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40018004
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0x0212             LSLS     R2,R2,#+8
   \   0000000A   0x600A             STR      R2,[R1, #+0]
     96           	SDIO->CLKCR|=clkdiv; 
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x4310             ORRS     R0,R0,R2
   \   00000010   0x6008             STR      R0,[R1, #+0]
     97          } 
   \   00000012   0x4770             BX       LR               ;; return
     98          //SDIO发送命令函数
     99          //cmdindex:命令索引,低六位有效
    100          //waitrsp:期待的相应.00/10,无响应;01,短相应;11,长响应
    101          //arg:参数

   \                                 In section .text, align 2, keep-with-next
    102          void SDIO_Send_Cmd(u8 cmdindex,u8 waitrsp,u32 arg)
    103          {						    
    104          	SDIO->ARG=arg;
   \                     SDIO_Send_Cmd: (+1)
   \   00000000   0x.... 0x....      LDR.W    R3,??DataTable13_5  ;; 0x40018008
   \   00000004   0x601A             STR      R2,[R3, #+0]
    105          	SDIO->CMD&=0XFFFFF800;		//清除index和waitrsp
   \   00000006   0x685A             LDR      R2,[R3, #+4]
   \   00000008   0x0AD2             LSRS     R2,R2,#+11
   \   0000000A   0x02D2             LSLS     R2,R2,#+11
   \   0000000C   0x605A             STR      R2,[R3, #+4]
    106          	SDIO->CMD|=cmdindex&0X3F;	//设置新的index			 
   \   0000000E   0x685A             LDR      R2,[R3, #+4]
   \   00000010   0xF000 0x003F      AND      R0,R0,#0x3F
   \   00000014   0x4310             ORRS     R0,R0,R2
   \   00000016   0x6058             STR      R0,[R3, #+4]
    107          	SDIO->CMD|=waitrsp<<6;		//设置新的wait rsp 
   \   00000018   0x6858             LDR      R0,[R3, #+4]
   \   0000001A   0xEA40 0x1081      ORR      R0,R0,R1, LSL #+6
   \   0000001E   0x6058             STR      R0,[R3, #+4]
    108          	SDIO->CMD|=0<<8;			//无等待
   \   00000020   0x6858             LDR      R0,[R3, #+4]
   \   00000022   0x6058             STR      R0,[R3, #+4]
    109            SDIO->CMD|=1<<10;			//命令通道状态机使能
   \   00000024   0x6858             LDR      R0,[R3, #+4]
   \   00000026   0xF440 0x6080      ORR      R0,R0,#0x400
   \   0000002A   0x6058             STR      R0,[R3, #+4]
    110          }
   \   0000002C   0x4770             BX       LR               ;; return
    111          //SDIO发送数据配置函数
    112          //datatimeout:超时时间设置
    113          //datalen:传输数据长度,低25位有效,必须为块大小的整数倍
    114          //blksize:块大小.实际大小为:2^blksize字节
    115          //dir:数据传输方向:0,控制器到卡;1,卡到控制器;

   \                                 In section .text, align 2, keep-with-next
    116          void SDIO_Send_Data_Cfg(u32 datatimeout,u32 datalen,u8 blksize,u8 dir)
    117          {
   \                     SDIO_Send_Data_Cfg: (+1)
   \   00000000   0xB410             PUSH     {R4}
    118          	SDIO->DTIMER=datatimeout;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable13_6  ;; 0x40018024
   \   00000006   0x6020             STR      R0,[R4, #+0]
    119            SDIO->DLEN=datalen&0X1FFFFFF;	//低25位有效
   \   00000008   0x01C8             LSLS     R0,R1,#+7
   \   0000000A   0x09C0             LSRS     R0,R0,#+7
   \   0000000C   0x6060             STR      R0,[R4, #+4]
    120          	SDIO->DCTRL&=0xFFFFFF08;		//清除之前的设置.
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0xF020 0x00F7      BIC      R0,R0,#0xF7
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    121          	SDIO->DCTRL|=blksize<<4;		//设置块大小
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0xEA40 0x1002      ORR      R0,R0,R2, LSL #+4
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
    122          	SDIO->DCTRL|=0<<2;				//块数据传输
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x60A0             STR      R0,[R4, #+8]
    123          	SDIO->DCTRL|=(dir&0X01)<<1;		//方向控制
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0xF003 0x0101      AND      R1,R3,#0x1
   \   00000028   0xEA40 0x0041      ORR      R0,R0,R1, LSL #+1
   \   0000002C   0x60A0             STR      R0,[R4, #+8]
    124          	SDIO->DCTRL|=1<<0;				//数据传输使能,DPSM状态机
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000034   0x60A0             STR      R0,[R4, #+8]
    125          }  
   \   00000036   0xBC10             POP      {R4}
   \   00000038   0x4770             BX       LR               ;; return
    126          
    127          //卡上电
    128          //查询所有SDIO接口上的卡设备,并查询其电压和配置时钟
    129          //返回值:错误代码;(0,无错误)

   \                                 In section .text, align 2, keep-with-next
    130          SD_Error SD_PowerON(void)
    131          {
   \                     SD_PowerON: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    132          	volatile int delay_us=0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    133           	u8 i=0;
   \   00000008   0x4682             MOV      R10,R0
    134          	SD_Error errorstatus=SD_OK;
   \   0000000A   0x4681             MOV      R9,R0
    135          	u32 response=0,count=0,validvoltage=0;
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0x4606             MOV      R6,R0
    136          	u32 SDType=SD_STD_CAPACITY;
   \   00000012   0x4683             MOV      R11,R0
    137          	//配置CLKCR寄存器 
    138          	SDIO->CLKCR=0;				//清空CLKCR之前的设置
   \   00000014   0x.... 0x....      LDR.W    R7,??DataTable13  ;; 0x40018000
   \   00000018   0x6078             STR      R0,[R7, #+4]
    139          	SDIO->CLKCR|=0<<9;			//非省电模式
   \   0000001A   0x6878             LDR      R0,[R7, #+4]
   \   0000001C   0x6078             STR      R0,[R7, #+4]
    140          	SDIO->CLKCR|=0<<10;			//关闭旁路,CK根据分频设置输出
   \   0000001E   0x6878             LDR      R0,[R7, #+4]
   \   00000020   0x6078             STR      R0,[R7, #+4]
    141          	SDIO->CLKCR|=0<<11;			//1位数据宽度
   \   00000022   0x6878             LDR      R0,[R7, #+4]
   \   00000024   0x6078             STR      R0,[R7, #+4]
    142          	SDIO->CLKCR|=0<<13;			//SDIOCLK上升沿产生SDIOCK
   \   00000026   0x6878             LDR      R0,[R7, #+4]
   \   00000028   0x6078             STR      R0,[R7, #+4]
    143          	SDIO->CLKCR|=0<<14;			//关闭硬件流控制    
   \   0000002A   0x6878             LDR      R0,[R7, #+4]
   \   0000002C   0x6078             STR      R0,[R7, #+4]
    144          	SDIO_Clock_Set(SDIO_INIT_CLK_DIV);//设置时钟频率(初始化的时候,不能超过400Khz)			 
                 	               ^
Warning[Pe069]: integer conversion resulted in truncation
   \   0000002E   0x2066             MOVS     R0,#+102
   \   00000030   0x.... 0x....      BL       SDIO_Clock_Set
    145           	SDIO->POWER=0X03;			//上电状态,开启卡时钟    
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0x6038             STR      R0,[R7, #+0]
    146            SDIO->CLKCR|=1<<8;			//SDIOCK使能   
   \   00000038   0x6878             LDR      R0,[R7, #+4]
   \   0000003A   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000003E   0x6078             STR      R0,[R7, #+4]
    147          
    148          	for(delay_us = 5000;0<delay_us;delay_us--);
   \   00000040   0xF241 0x3888      MOVW     R8,#+5000
   \   00000044   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000048   0xE002             B.N      ??SD_PowerON_0
   \                     ??SD_PowerON_1: (+1)
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \                     ??SD_PowerON_0: (+1)
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xDAF9             BGE.N    ??SD_PowerON_1
    149          
    150            for(i=0;i<74;i++)
   \                     ??SD_PowerON_2: (+1)
   \   00000056   0xFA5F 0xFA8A      UXTB     R10,R10
   \   0000005A   0xF1BA 0x0F4A      CMP      R10,#+74
   \   0000005E   0xDA0D             BGE.N    ??SD_PowerON_3
    151          	{
    152          		SDIO_Send_Cmd(SD_CMD_GO_IDLE_STATE,0,0);//发送进入IDLE STAGE模式命令.												  
   \   00000060   0x4622             MOV      R2,R4
   \   00000062   0x4611             MOV      R1,R2
   \   00000064   0x4608             MOV      R0,R1
   \   00000066   0x.... 0x....      BL       SDIO_Send_Cmd
    153          		errorstatus=CmdError();
   \   0000006A   0x.... 0x....      BL       CmdError
   \   0000006E   0x4681             MOV      R9,R0
    154          		if(errorstatus==SD_OK)break;
   \   00000070   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000074   0xD002             BEQ.N    ??SD_PowerON_3
    155           	}
   \   00000076   0xF10A 0x0A01      ADD      R10,R10,#+1
   \   0000007A   0xE7EC             B.N      ??SD_PowerON_2
    156           	if(errorstatus)return errorstatus;//返回错误状态
   \                     ??SD_PowerON_3: (+1)
   \   0000007C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000080   0xF040 0x80C3      BNE.W    ??SD_PowerON_4
    157          	SDIO_Send_Cmd(SDIO_SEND_IF_COND,1,SD_CHECK_PATTERN);//发送CMD8,短响应,检查SD卡接口特性.
   \   00000084   0xF44F 0x72D5      MOV      R2,#+426
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x2008             MOVS     R0,#+8
   \   0000008C   0x.... 0x....      BL       SDIO_Send_Cmd
    158           														//arg[11:8]:01,支持电压范围,2.7~3.6V
    159          														//arg[7:0]:默认0XAA
    160          														//返回响应7
    161            	errorstatus=CmdResp7Error();						//等待R7响应
    162           	if(errorstatus==SD_OK) 								//R7响应正常
   \   00000090   0x.... 0x....      BL       CmdResp7Error
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD106             BNE.N    ??SD_PowerON_5
    163          	{
    164          		CardType=SDIO_STD_CAPACITY_SD_CARD_V2_0;		//SD 2.0卡
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
    165          		SDType=SD_HIGH_CAPACITY;			   			//高容量卡
   \   000000A0   0xF04F 0x4B80      MOV      R11,#+1073741824
   \   000000A4   0xE00B             B.N      ??SD_PowerON_6
    166          	}else 
    167          	{
    168          	#if 0 //tan 20181217
    169          		SDIO_Send_Cmd(SD_CMD_APP_CMD,1,0);				//发送CMD55,短响应	  
    170          	   	errorstatus=CmdResp1Error(SD_CMD_APP_CMD);
    171          			#else
    172          				SDIO_Send_Cmd(SD_CMD_GO_IDLE_STATE,0,0);//发送进入IDLE STAGE模式命令.												  
   \                     ??SD_PowerON_5: (+1)
   \   000000A6   0x4622             MOV      R2,R4
   \   000000A8   0x4611             MOV      R1,R2
   \   000000AA   0x4608             MOV      R0,R1
   \   000000AC   0x.... 0x....      BL       SDIO_Send_Cmd
    173          				errorstatus=CmdError();
   \   000000B0   0x.... 0x....      BL       CmdError
   \   000000B4   0x4681             MOV      R9,R0
    174          				if(errorstatus!=SD_OK)return errorstatus;			
   \   000000B6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BA   0xF040 0x80A6      BNE.W    ??SD_PowerON_4
    175          			#endif
    176          	}
    177          
    178          	SDIO_Send_Cmd(SD_CMD_APP_CMD,1,0);					//发送CMD55,短响应	 
   \                     ??SD_PowerON_6: (+1)
   \   000000BE   0x4622             MOV      R2,R4
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0x2037             MOVS     R0,#+55
   \   000000C4   0x.... 0x....      BL       SDIO_Send_Cmd
    179          	errorstatus=CmdResp1Error(SD_CMD_APP_CMD); 		 	//等待R1响应   
   \   000000C8   0x2037             MOVS     R0,#+55
   \   000000CA   0x.... 0x....      BL       CmdResp1Error
   \   000000CE   0x4681             MOV      R9,R0
    180          
    181          	if(errorstatus==SD_OK)//SD2.0(电压不匹配的)/SD 1.1,否则为MMC卡
   \   000000D0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D4   0xF64F 0x7AFF      MOVW     R10,#+65535
   \   000000D8   0xD051             BEQ.N    ??SD_PowerON_7
    182          	{																  
    183          		//SD卡,发送ACMD41 SD_APP_OP_COND,参数为:0x80100000 
    184          		while((!validvoltage)&&(count<SD_MAX_VOLT_TRIAL))
    185          		{	   										   
    186          			SDIO_Send_Cmd(SD_CMD_APP_CMD,1,0);				//发送CMD55,短响应	 
    187          			errorstatus=CmdResp1Error(SD_CMD_APP_CMD); 	 	//等待R1响应   
    188           			if(errorstatus!=SD_OK)return errorstatus;   	//响应错误
    189          			SDIO_Send_Cmd(SD_CMD_SD_APP_OP_COND,1,SD_VOLTAGE_WINDOW_SD|SD_OCR_XPC|SD_OCR_S18 |SDType);//发送ACMD41,短响应	 
    190          			errorstatus=CmdResp3Error(); 					//等待R3响应   
    191           			if(errorstatus!=SD_OK)return errorstatus;   	//响应错误  
    192          			response=SDIO->RESP1;;			   				//得到响应
    193          			validvoltage=(((response>>31)==1)?1:0);
    194          			count++;
    195          		}
    196          		if(count>=SD_MAX_VOLT_TRIAL)
    197          		{
    198          			errorstatus=SD_INVALID_VOLTRANGE;
    199          			return errorstatus;
    200          		}	 
    201          		if(response&=SD_HIGH_CAPACITY)
    202          		{
    203          			CardType=SDIO_HIGH_CAPACITY_SD_CARD;
    204          		}
    205          		//tan//不加这部分,
    206          		//当先使用卡类型为SDIO_HIGH_CAPACITY_SD_CARD，
    207          		//之后再是卡类型为SDIO_STD_CAPACITY_SD_CARD_V1_1
    208          		//的卡，会出现读取不到SDIO_STD_CAPACITY_SD_CARD_V1_1卡的情况
    209          		else
    210          		{
    211          			if(SDType!=SD_HIGH_CAPACITY)
    212          				CardType=SDIO_STD_CAPACITY_SD_CARD_V1_1;
    213          		}
    214           	}else//MMC卡
    215          	{
    216          	#if 0 //tan20181217
    217          		CardType=SDIO_MULTIMEDIA_CARD;	  
    218          		//MMC卡,发送CMD0 SDIO_SEND_OP_COND,参数为:0x80FF8000 
    219          		while((!validvoltage)&&(count<SD_MAX_VOLT_TRIAL))
    220          		{	   										   				   
    221          			SDIO_Send_Cmd(SD_CMD_SEND_OP_COND,1,SD_VOLTAGE_WINDOW_MMC);//发送CMD0,短响应	 
    222          			errorstatus=CmdResp3Error(); 					//等待R3响应   
    223           			if(errorstatus!=SD_OK)return errorstatus;   	//响应错误  
    224          			response=SDIO->RESP1;;			   				//得到响应
    225          			validvoltage=(((response>>31)==1)?1:0);
    226          			count++;
    227          		}
    228          		if(count>=SD_MAX_VOLT_TRIAL)
    229          		{
    230          			errorstatus=SD_INVALID_VOLTRANGE;
    231          			return errorstatus;
    232          		}	 			    
    233            	}  
    234            	return(errorstatus);
    235          		#else
    236          		SDIO_Send_Cmd(SD_CMD_GO_IDLE_STATE,0,0xF0F0F0F0);//发送进入IDLE STAGE模式命令.												  
   \   000000DA   0xF04F 0x32F0      MOV      R2,#-252645136
   \   000000DE   0x4621             MOV      R1,R4
   \   000000E0   0x4608             MOV      R0,R1
   \   000000E2   0x.... 0x....      BL       SDIO_Send_Cmd
    237          		errorstatus=CmdError();
   \   000000E6   0x.... 0x....      BL       CmdError
   \   000000EA   0x4681             MOV      R9,R0
    238          		if(errorstatus!=SD_OK)return errorstatus;				
   \   000000EC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F0   0xF040 0x808B      BNE.W    ??SD_PowerON_4
    239          
    240          		SDIO_Send_Cmd(SD_CMD_GO_IDLE_STATE,0,0);//发送进入IDLE STAGE模式命令.												  
   \   000000F4   0x4622             MOV      R2,R4
   \   000000F6   0x4611             MOV      R1,R2
   \   000000F8   0x4608             MOV      R0,R1
   \   000000FA   0x.... 0x....      BL       SDIO_Send_Cmd
    241          		errorstatus=CmdError();
   \   000000FE   0x.... 0x....      BL       CmdError
   \   00000102   0x4681             MOV      R9,R0
    242          		if(errorstatus!=SD_OK)return errorstatus;			
   \   00000104   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000108   0xF040 0x807F      BNE.W    ??SD_PowerON_4
    243          
    244          		/*!< Send CMD1 SEND_OP_COND with Argument 0x80FF8000 + Bits[30:29]=1,0 */
    245          		while ((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
   \                     ??SD_PowerON_8: (+1)
   \   0000010C   0x2E00             CMP      R6,#+0
   \   0000010E   0xD14B             BNE.N    ??SD_PowerON_9
   \   00000110   0x4555             CMP      R5,R10
   \   00000112   0xD249             BCS.N    ??SD_PowerON_9
    246          		{
    247          			SDIO_Send_Cmd(SD_CMD_SEND_OP_COND,1,SD_VOLTAGE_WINDOW_MMC | MMC_HIGH_CAPACITY);//发送CMD0,短响应	 
   \   00000114   0x.... 0x....      LDR.W    R2,??DataTable13_7  ;; 0xc0ff8000
   \   00000118   0x2101             MOVS     R1,#+1
   \   0000011A   0x4608             MOV      R0,R1
   \   0000011C   0x.... 0x....      BL       SDIO_Send_Cmd
    248          			errorstatus=CmdResp3Error(); 					//等待R3响应   
   \   00000120   0x.... 0x....      BL       CmdResp3Error
   \   00000124   0x4681             MOV      R9,R0
    249           			if(errorstatus!=SD_OK)return errorstatus;   	//响应错误  
   \   00000126   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000012A   0xD16E             BNE.N    ??SD_PowerON_4
    250          			response=SDIO->RESP1;			   				//得到响应
   \   0000012C   0x697C             LDR      R4,[R7, #+20]
    251          			validvoltage=(((response>>31)==1)?1:0);
   \   0000012E   0x0FE6             LSRS     R6,R4,#+31
    252          			count++;		
   \   00000130   0x1C6D             ADDS     R5,R5,#+1
    253          			
    254          			for(delay_us = 5000;0<delay_us;delay_us--);
   \   00000132   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??SD_PowerON_10: (+1)
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xDBE7             BLT.N    ??SD_PowerON_8
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0x1E40             SUBS     R0,R0,#+1
   \   00000140   0x9000             STR      R0,[SP, #+0]
   \   00000142   0xE7F8             B.N      ??SD_PowerON_10
    255          			
    256          		}
   \                     ??SD_PowerON_11: (+1)
   \   00000144   0x2200             MOVS     R2,#+0
   \   00000146   0x2101             MOVS     R1,#+1
   \   00000148   0x2037             MOVS     R0,#+55
   \   0000014A   0x.... 0x....      BL       SDIO_Send_Cmd
   \   0000014E   0x2037             MOVS     R0,#+55
   \   00000150   0x.... 0x....      BL       CmdResp1Error
   \   00000154   0x4681             MOV      R9,R0
   \   00000156   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000015A   0xD156             BNE.N    ??SD_PowerON_4
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x91100000
   \   00000160   0xEA40 0x020B      ORR      R2,R0,R11
   \   00000164   0x2101             MOVS     R1,#+1
   \   00000166   0x2029             MOVS     R0,#+41
   \   00000168   0x.... 0x....      BL       SDIO_Send_Cmd
   \   0000016C   0x.... 0x....      BL       CmdResp3Error
   \   00000170   0x4681             MOV      R9,R0
   \   00000172   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000176   0xD148             BNE.N    ??SD_PowerON_4
   \   00000178   0x697C             LDR      R4,[R7, #+20]
   \   0000017A   0x0FE6             LSRS     R6,R4,#+31
   \   0000017C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SD_PowerON_7: (+1)
   \   0000017E   0x2E00             CMP      R6,#+0
   \   00000180   0xD101             BNE.N    ??SD_PowerON_12
   \   00000182   0x4555             CMP      R5,R10
   \   00000184   0xD3DE             BCC.N    ??SD_PowerON_11
   \                     ??SD_PowerON_12: (+1)
   \   00000186   0x4555             CMP      R5,R10
   \   00000188   0xD231             BCS.N    ??SD_PowerON_13
   \   0000018A   0x0060             LSLS     R0,R4,#+1
   \   0000018C   0xD504             BPL.N    ??SD_PowerON_14
   \   0000018E   0x2002             MOVS     R0,#+2
   \   00000190   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000194   0x7008             STRB     R0,[R1, #+0]
   \   00000196   0xE038             B.N      ??SD_PowerON_4
   \                     ??SD_PowerON_14: (+1)
   \   00000198   0xF1BB 0x4F80      CMP      R11,#+1073741824
   \   0000019C   0xD035             BEQ.N    ??SD_PowerON_4
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000001A4   0x7008             STRB     R0,[R1, #+0]
   \   000001A6   0xE030             B.N      ??SD_PowerON_4
    257          
    258          		if (count >= SD_MAX_VOLT_TRIAL)
   \                     ??SD_PowerON_9: (+1)
   \   000001A8   0x4555             CMP      R5,R10
   \   000001AA   0xD322             BCC.N    ??SD_PowerON_15
    259          		{
    260          			/* Retry as non-MMC_HIGH_CAPACITY argument */
    261          			response = 0, count = 0, validvoltage = 0;
   \   000001AC   0x2400             MOVS     R4,#+0
   \   000001AE   0x4625             MOV      R5,R4
   \   000001B0   0x4626             MOV      R6,R4
    262          			
    263          			/*!< Send CMD1 SEND_OP_COND with Argument 0x80FF8000 */
    264          			while ((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
   \                     ??SD_PowerON_16: (+1)
   \   000001B2   0x2E00             CMP      R6,#+0
   \   000001B4   0xD119             BNE.N    ??SD_PowerON_17
   \   000001B6   0x4555             CMP      R5,R10
   \   000001B8   0xD217             BCS.N    ??SD_PowerON_17
    265          			{
    266          				/*!< CMD1: SEND_OP_COND ----------------------------------------------------*/
    267          				/*!< Send CMD1 to receive the contents of the Operating Conditions Register */
    268          				/*!< CMD Response: R3 */
    269          				SDIO_Send_Cmd(SD_CMD_SEND_OP_COND,1,SD_VOLTAGE_WINDOW_MMC);
   \   000001BA   0x.... 0x....      LDR.W    R2,??DataTable14  ;; 0x80ff8000
   \   000001BE   0x2101             MOVS     R1,#+1
   \   000001C0   0x4608             MOV      R0,R1
   \   000001C2   0x.... 0x....      BL       SDIO_Send_Cmd
    270          				errorstatus = CmdResp3Error();
   \   000001C6   0x.... 0x....      BL       CmdResp3Error
   \   000001CA   0x4681             MOV      R9,R0
    271          				if (errorstatus != SD_OK)
   \   000001CC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001D0   0xD11B             BNE.N    ??SD_PowerON_4
    272          				{
    273          					return(errorstatus);
    274          				}
    275          		
    276          				response = SDIO->RESP1;
   \   000001D2   0x697C             LDR      R4,[R7, #+20]
    277          				validvoltage = (((response >> 31) == 1) ? 1 : 0);
   \   000001D4   0x0FE6             LSRS     R6,R4,#+31
    278          				count++;
   \   000001D6   0x1C6D             ADDS     R5,R5,#+1
    279          				for(delay_us = 5000;0<delay_us;delay_us--); /* Need for MMCv5 devices */
   \   000001D8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??SD_PowerON_18: (+1)
   \   000001DC   0x9800             LDR      R0,[SP, #+0]
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xDBE7             BLT.N    ??SD_PowerON_16
   \   000001E2   0x9800             LDR      R0,[SP, #+0]
   \   000001E4   0x1E40             SUBS     R0,R0,#+1
   \   000001E6   0x9000             STR      R0,[SP, #+0]
   \   000001E8   0xE7F8             B.N      ??SD_PowerON_18
    280          			}
    281          			
    282          			if (count >= SD_MAX_VOLT_TRIAL)
   \                     ??SD_PowerON_17: (+1)
   \   000001EA   0x4555             CMP      R5,R10
   \   000001EC   0xD301             BCC.N    ??SD_PowerON_15
    283          			{
    284          				errorstatus = SD_INVALID_VOLTRANGE;
    285          				return(errorstatus);
   \                     ??SD_PowerON_13: (+1)
   \   000001EE   0x201B             MOVS     R0,#+27
   \   000001F0   0xE00C             B.N      ??SD_PowerON_19
    286          			}
    287          		}
    288          
    289          		if ((response & MMC_HIGH_CAPACITY_MASK) == MMC_HIGH_CAPACITY)
   \                     ??SD_PowerON_15: (+1)
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   000001F6   0xF004 0x41C0      AND      R1,R4,#0x60000000
   \   000001FA   0xF1B1 0x4F80      CMP      R1,#+1073741824
   \   000001FE   0xD102             BNE.N    ??SD_PowerON_20
    290          		{
    291          			CardType = SDIO_HIGH_CAPACITY_MMC_CARD;
   \   00000200   0x2107             MOVS     R1,#+7
   \   00000202   0x7001             STRB     R1,[R0, #+0]
   \   00000204   0xE001             B.N      ??SD_PowerON_4
    292          		}
    293          		else
    294          		{
    295          			CardType = SDIO_MULTIMEDIA_CARD;
   \                     ??SD_PowerON_20: (+1)
   \   00000206   0x2103             MOVS     R1,#+3
   \   00000208   0x7001             STRB     R1,[R0, #+0]
    296          		}		
    297          		}
    298          
    299          		return(errorstatus);
   \                     ??SD_PowerON_4: (+1)
   \   0000020A   0x4648             MOV      R0,R9
   \                     ??SD_PowerON_19: (+1)
   \   0000020C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    300          		
    301          		#endif
    302          
    303          }
    304          //SD卡 Power OFF
    305          //返回值:错误代码;(0,无错误)

   \                                 In section .text, align 2, keep-with-next
    306          SD_Error SD_PowerOFF(void)
    307          {
    308            	SDIO->POWER&=~(3<<0);//SDIO电源关闭,时钟停止	
   \                     SD_PowerOFF: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x0889             LSRS     R1,R1,#+2
   \   00000008   0x0089             LSLS     R1,R1,#+2
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    309          	return SD_OK;		  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    310          }   
    311          //初始化所有的卡,并让卡进入就绪状态
    312          //返回值:错误代码

   \                                 In section .text, align 2, keep-with-next
    313          SD_Error SD_InitializeCards(void)
    314          {
   \                     SD_InitializeCards: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    315           	SD_Error errorstatus=SD_OK;
    316          	u16 rca = 0x01;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    317           	if((SDIO->POWER&0X03)==0)return SD_REQUEST_NOT_APPLICABLE;//检查电源状态,确保为上电状态
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable13  ;; 0x40018000
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF010 0x0F03      TST      R0,#0x3
   \   00000012   0xD101             BNE.N    ??SD_InitializeCards_0
   \   00000014   0x2025             MOVS     R0,#+37
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
    318           	if(SDIO_SECURE_DIGITAL_IO_CARD!=CardType)			//非SECURE_DIGITAL_IO_CARD
   \                     ??SD_InitializeCards_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R5,??DataTable14_1
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xD010             BEQ.N    ??SD_InitializeCards_1
    319          	{
    320          		SDIO_Send_Cmd(SD_CMD_ALL_SEND_CID,3,0);			//发送CMD2,取得CID,长响应	 
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2103             MOVS     R1,#+3
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       SDIO_Send_Cmd
    321          		errorstatus=CmdResp2Error(); 					//等待R1响应   
   \   0000002C   0x.... 0x....      BL       CmdResp2Error
    322          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误		    
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD13B             BNE.N    ??SD_InitializeCards_2
    323           		CID_Tab[0]=SDIO->RESP1;
   \   00000034   0x6960             LDR      R0,[R4, #+20]
   \   00000036   0x61A8             STR      R0,[R5, #+24]
    324          		CID_Tab[1]=SDIO->RESP2;
   \   00000038   0x69A0             LDR      R0,[R4, #+24]
   \   0000003A   0x61E8             STR      R0,[R5, #+28]
    325          		CID_Tab[2]=SDIO->RESP3;
   \   0000003C   0x69E0             LDR      R0,[R4, #+28]
   \   0000003E   0x6228             STR      R0,[R5, #+32]
    326          		CID_Tab[3]=SDIO->RESP4;
   \   00000040   0x6A20             LDR      R0,[R4, #+32]
   \   00000042   0x6268             STR      R0,[R5, #+36]
    327          	}
    328          	if((SDIO_STD_CAPACITY_SD_CARD_V1_1==CardType)||
    329          		(SDIO_STD_CAPACITY_SD_CARD_V2_0==CardType)||
    330          		(SDIO_SECURE_DIGITAL_IO_COMBO_CARD==CardType)||
    331          		(SDIO_HIGH_CAPACITY_SD_CARD==CardType)||	
    332          		(SDIO_MULTIMEDIA_CARD == CardType)				||
    333          		(SDIO_HIGH_SPEED_MULTIMEDIA_CARD == CardType)   ||
    334          		(SDIO_HIGH_CAPACITY_MMC_CARD  == CardType) )//判断卡类型
   \                     ??SD_InitializeCards_1: (+1)
   \   00000044   0x7828             LDRB     R0,[R5, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD00B             BEQ.N    ??SD_InitializeCards_3
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD009             BEQ.N    ??SD_InitializeCards_3
   \   0000004E   0x2806             CMP      R0,#+6
   \   00000050   0xD007             BEQ.N    ??SD_InitializeCards_3
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xD005             BEQ.N    ??SD_InitializeCards_3
   \   00000056   0x2803             CMP      R0,#+3
   \   00000058   0xD003             BEQ.N    ??SD_InitializeCards_3
   \   0000005A   0x2805             CMP      R0,#+5
   \   0000005C   0xD001             BEQ.N    ??SD_InitializeCards_3
   \   0000005E   0x2807             CMP      R0,#+7
   \   00000060   0xD10A             BNE.N    ??SD_InitializeCards_4
    335          	{
    336          		SDIO_Send_Cmd(SD_CMD_SET_REL_ADDR,1,0);			//发送CMD3,短响应 
   \                     ??SD_InitializeCards_3: (+1)
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       SDIO_Send_Cmd
    337          		errorstatus=CmdResp6Error(SD_CMD_SET_REL_ADDR, &rca);//等待R6响应 
   \   0000006C   0xA900             ADD      R1,SP,#+0
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0x.... 0x....      BL       CmdResp6Error
    338          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误		    
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD119             BNE.N    ??SD_InitializeCards_2
    339          	} 
    340          	/*
    341              if (SDIO_MULTIMEDIA_CARD==CardType)
    342              {
    343           		SDIO_Send_Cmd(SD_CMD_SET_REL_ADDR,1,(u32)(rca<<16));//发送CMD3,短响应 	   
    344          		errorstatus=CmdResp2Error(); 					//等待R1响应   
    345          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误	 
    346              }
    347              */
    348          	if (SDIO_SECURE_DIGITAL_IO_CARD!=CardType)			//非SECURE_DIGITAL_IO_CARD
   \                     ??SD_InitializeCards_4: (+1)
   \   00000078   0x7828             LDRB     R0,[R5, #+0]
   \   0000007A   0x2804             CMP      R0,#+4
   \   0000007C   0xD015             BEQ.N    ??SD_InitializeCards_5
    349          	{
    350          		RCA = rca;
   \   0000007E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000082   0x62A8             STR      R0,[R5, #+40]
    351          		SDIO_Send_Cmd(SD_CMD_SEND_CSD,3,(u32)(rca<<16));//发送CMD9+卡RCA,取得CSD,长响应 	   
   \   00000084   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000088   0x0402             LSLS     R2,R0,#+16
   \   0000008A   0x2103             MOVS     R1,#+3
   \   0000008C   0x2009             MOVS     R0,#+9
   \   0000008E   0x.... 0x....      BL       SDIO_Send_Cmd
    352          		errorstatus=CmdResp2Error(); 					//等待R1响应   
   \   00000092   0x.... 0x....      BL       CmdResp2Error
    353          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误		    
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD108             BNE.N    ??SD_InitializeCards_2
    354            		CSD_Tab[0]=SDIO->RESP1;
   \   0000009A   0x6960             LDR      R0,[R4, #+20]
   \   0000009C   0x60A8             STR      R0,[R5, #+8]
    355          		CSD_Tab[1]=SDIO->RESP2;
   \   0000009E   0x69A0             LDR      R0,[R4, #+24]
   \   000000A0   0x60E8             STR      R0,[R5, #+12]
    356          		CSD_Tab[2]=SDIO->RESP3;						
   \   000000A2   0x69E0             LDR      R0,[R4, #+28]
   \   000000A4   0x6128             STR      R0,[R5, #+16]
    357          		CSD_Tab[3]=SDIO->RESP4;					    
   \   000000A6   0x6A20             LDR      R0,[R4, #+32]
   \   000000A8   0x6168             STR      R0,[R5, #+20]
    358          	}
    359          	return SD_OK;//卡初始化成功
   \                     ??SD_InitializeCards_5: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??SD_InitializeCards_2: (+1)
   \   000000AC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    360          } 
    361          //得到卡信息
    362          //cardinfo:卡信息存储区
    363          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
    364          SD_Error SD_GetCardInfo(HAL_SD_CardInfoTypedef *cardinfo)
    365          {
   \                     SD_GetCardInfo: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
    366           	SD_Error errorstatus=SD_OK;
    367          	u8 tmp=0;	   
    368          	cardinfo->CardType=(u8)CardType; 				//卡类型
   \   00000006   0x.... 0x....      LDR.W    R7,??DataTable13_3
   \   0000000A   0xF897 0x8000      LDRB     R8,[R7, #+0]
   \   0000000E   0xF886 0x8056      STRB     R8,[R6, #+86]
    369          	cardinfo->RCA=(u16)RCA;							//卡RCA值
   \   00000012   0x6AB8             LDR      R0,[R7, #+40]
   \   00000014   0xF8A6 0x0054      STRH     R0,[R6, #+84]
    370          	tmp=(u8)((CSD_Tab[0]&0xFF000000)>>24);
   \   00000018   0x68B8             LDR      R0,[R7, #+8]
   \   0000001A   0x0E00             LSRS     R0,R0,#+24
    371          	cardinfo->SD_csd.CSDStruct=(tmp&0xC0)>>6;		//CSD结构
   \   0000001C   0x1181             ASRS     R1,R0,#+6
   \   0000001E   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000022   0x7031             STRB     R1,[R6, #+0]
    372          	cardinfo->SD_csd.SysSpecVersion=(tmp&0x3C)>>2;	//2.0协议还没定义这部分(为保留),应该是后续协议定义的
   \   00000024   0x1081             ASRS     R1,R0,#+2
   \   00000026   0xF001 0x010F      AND      R1,R1,#0xF
   \   0000002A   0x7071             STRB     R1,[R6, #+1]
    373          	cardinfo->SD_csd.Reserved1=tmp&0x03;			//2个保留位  
   \   0000002C   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000030   0x70B0             STRB     R0,[R6, #+2]
    374          	tmp=(u8)((CSD_Tab[0]&0x00FF0000)>>16);			//第1个字节
    375          	cardinfo->SD_csd.TAAC=tmp;				   		//数据读时间1
   \   00000032   0x68B8             LDR      R0,[R7, #+8]
   \   00000034   0x0C00             LSRS     R0,R0,#+16
   \   00000036   0x70F0             STRB     R0,[R6, #+3]
    376          	tmp=(u8)((CSD_Tab[0]&0x0000FF00)>>8);	  		//第2个字节
    377          	cardinfo->SD_csd.NSAC=tmp;		  				//数据读时间2
   \   00000038   0x68B8             LDR      R0,[R7, #+8]
   \   0000003A   0x0A00             LSRS     R0,R0,#+8
   \   0000003C   0x7130             STRB     R0,[R6, #+4]
    378          	tmp=(u8)(CSD_Tab[0]&0x000000FF);				//第3个字节
    379          	cardinfo->SD_csd.MaxBusClkFrec=tmp;		  		//传输速度	   
   \   0000003E   0x68B8             LDR      R0,[R7, #+8]
   \   00000040   0x7170             STRB     R0,[R6, #+5]
    380          	tmp=(u8)((CSD_Tab[1]&0xFF000000)>>24);			//第4个字节
    381          	cardinfo->SD_csd.CardComdClasses=tmp<<4;    	//卡指令类高四位
   \   00000042   0x68F8             LDR      R0,[R7, #+12]
   \   00000044   0x0E00             LSRS     R0,R0,#+24
   \   00000046   0x0100             LSLS     R0,R0,#+4
   \   00000048   0x80F0             STRH     R0,[R6, #+6]
    382          	tmp=(u8)((CSD_Tab[1]&0x00FF0000)>>16);	 		//第5个字节
   \   0000004A   0x68F8             LDR      R0,[R7, #+12]
   \   0000004C   0xF3C0 0x4007      UBFX     R0,R0,#+16,#+8
    383          	cardinfo->SD_csd.CardComdClasses|=(tmp&0xF0)>>4;//卡指令类低四位
   \   00000050   0x88F1             LDRH     R1,[R6, #+6]
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0xEA51 0x1112      ORRS     R1,R1,R2, LSR #+4
   \   00000058   0x80F1             STRH     R1,[R6, #+6]
    384          	cardinfo->SD_csd.RdBlockLen=tmp&0x0F;	    	//最大读取数据长度
   \   0000005A   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000005E   0x7230             STRB     R0,[R6, #+8]
    385          	tmp=(u8)((CSD_Tab[1]&0x0000FF00)>>8);			//第6个字节
   \   00000060   0x68F8             LDR      R0,[R7, #+12]
   \   00000062   0xEA4F 0x2C10      LSR      R12,R0,#+8
   \   00000066   0xFA5F 0xFC8C      UXTB     R12,R12
    386          	cardinfo->SD_csd.PartBlockRead=(tmp&0x80)>>7;	//允许分块读
   \   0000006A   0xEA4F 0x10EC      ASR      R0,R12,#+7
   \   0000006E   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000072   0x7270             STRB     R0,[R6, #+9]
    387          	cardinfo->SD_csd.WrBlockMisalign=(tmp&0x40)>>6;	//写块错位
   \   00000074   0xEA4F 0x10AC      ASR      R0,R12,#+6
   \   00000078   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000007C   0x72B0             STRB     R0,[R6, #+10]
    388          	cardinfo->SD_csd.RdBlockMisalign=(tmp&0x20)>>5;	//读块错位
   \   0000007E   0xEA4F 0x106C      ASR      R0,R12,#+5
   \   00000082   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000086   0x72F0             STRB     R0,[R6, #+11]
    389          	cardinfo->SD_csd.DSRImpl=(tmp&0x10)>>4;
   \   00000088   0xEA4F 0x102C      ASR      R0,R12,#+4
   \   0000008C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000090   0x7330             STRB     R0,[R6, #+12]
    390          	cardinfo->SD_csd.Reserved2=0; 					//保留
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x7370             STRB     R0,[R6, #+13]
    391           	if((CardType==SDIO_STD_CAPACITY_SD_CARD_V1_1)||(CardType==SDIO_STD_CAPACITY_SD_CARD_V2_0)/*||(SDIO_MULTIMEDIA_CARD==CardType)*/)//标准1.1/2.0卡/MMC卡
   \   00000096   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009A   0xD002             BEQ.N    ??SD_GetCardInfo_0
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD152             BNE.N    ??SD_GetCardInfo_1
    392          	{
    393          		cardinfo->SD_csd.DeviceSize=(tmp&0x03)<<10;	//C_SIZE(12位)
   \                     ??SD_GetCardInfo_0: (+1)
   \   000000A2   0xF00C 0x0003      AND      R0,R12,#0x3
   \   000000A6   0x0280             LSLS     R0,R0,#+10
   \   000000A8   0x6130             STR      R0,[R6, #+16]
    394          	 	tmp=(u8)(CSD_Tab[1]&0x000000FF); 			//第7个字节	
    395          		cardinfo->SD_csd.DeviceSize|=(tmp)<<2;
   \   000000AA   0x6930             LDR      R0,[R6, #+16]
   \   000000AC   0x7B39             LDRB     R1,[R7, #+12]
   \   000000AE   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   000000B2   0x6130             STR      R0,[R6, #+16]
    396           		tmp=(u8)((CSD_Tab[2]&0xFF000000)>>24);		//第8个字节	
   \   000000B4   0x6938             LDR      R0,[R7, #+16]
   \   000000B6   0x0E00             LSRS     R0,R0,#+24
    397          		cardinfo->SD_csd.DeviceSize|=(tmp&0xC0)>>6;
   \   000000B8   0x6931             LDR      R1,[R6, #+16]
   \   000000BA   0x1182             ASRS     R2,R0,#+6
   \   000000BC   0xF002 0x0203      AND      R2,R2,#0x3
   \   000000C0   0x4311             ORRS     R1,R2,R1
   \   000000C2   0x6131             STR      R1,[R6, #+16]
    398           		cardinfo->SD_csd.MaxRdCurrentVDDMin=(tmp&0x38)>>3;
   \   000000C4   0x10C1             ASRS     R1,R0,#+3
   \   000000C6   0xF001 0x0107      AND      R1,R1,#0x7
   \   000000CA   0x7531             STRB     R1,[R6, #+20]
    399          		cardinfo->SD_csd.MaxRdCurrentVDDMax=(tmp&0x07);
   \   000000CC   0xF000 0x0007      AND      R0,R0,#0x7
   \   000000D0   0x7570             STRB     R0,[R6, #+21]
    400           		tmp=(u8)((CSD_Tab[2]&0x00FF0000)>>16);		//第9个字节	
   \   000000D2   0x6938             LDR      R0,[R7, #+16]
   \   000000D4   0x0C00             LSRS     R0,R0,#+16
   \   000000D6   0xB2C0             UXTB     R0,R0
    401          		cardinfo->SD_csd.MaxWrCurrentVDDMin=(tmp&0xE0)>>5;
   \   000000D8   0x1141             ASRS     R1,R0,#+5
   \   000000DA   0xF001 0x0107      AND      R1,R1,#0x7
   \   000000DE   0x75B1             STRB     R1,[R6, #+22]
    402          		cardinfo->SD_csd.MaxWrCurrentVDDMax=(tmp&0x1C)>>2;
   \   000000E0   0x1081             ASRS     R1,R0,#+2
   \   000000E2   0xF001 0x0107      AND      R1,R1,#0x7
   \   000000E6   0x75F1             STRB     R1,[R6, #+23]
    403          		cardinfo->SD_csd.DeviceSizeMul=(tmp&0x03)<<1;//C_SIZE_MULT
   \   000000E8   0xF000 0x0003      AND      R0,R0,#0x3
   \   000000EC   0x0040             LSLS     R0,R0,#+1
   \   000000EE   0x7630             STRB     R0,[R6, #+24]
    404           		tmp=(u8)((CSD_Tab[2]&0x0000FF00)>>8);	  	//第10个字节	
   \   000000F0   0x6938             LDR      R0,[R7, #+16]
   \   000000F2   0xEA4F 0x2C10      LSR      R12,R0,#+8
   \   000000F6   0xFA5F 0xFC8C      UXTB     R12,R12
    405          		cardinfo->SD_csd.DeviceSizeMul|=(tmp&0x80)>>7;
   \   000000FA   0x7E30             LDRB     R0,[R6, #+24]
   \   000000FC   0xEA4F 0x11EC      ASR      R1,R12,#+7
   \   00000100   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000104   0x4308             ORRS     R0,R1,R0
   \   00000106   0x7630             STRB     R0,[R6, #+24]
    406           		cardinfo->CardCapacity=(cardinfo->SD_csd.DeviceSize+1);//计算卡容量
   \   00000108   0x6930             LDR      R0,[R6, #+16]
   \   0000010A   0x1C44             ADDS     R4,R0,#+1
   \   0000010C   0x2500             MOVS     R5,#+0
   \   0000010E   0xE9C6 0x4512      STRD     R4,R5,[R6, #+72]
    407          		cardinfo->CardCapacity*=(1<<(cardinfo->SD_csd.DeviceSizeMul+2));
   \   00000112   0xF04F 0x0E01      MOV      LR,#+1
   \   00000116   0x7E30             LDRB     R0,[R6, #+24]
   \   00000118   0x1C80             ADDS     R0,R0,#+2
   \   0000011A   0xFA0E 0xF000      LSL      R0,LR,R0
   \   0000011E   0x17C1             ASRS     R1,R0,#+31
   \   00000120   0xFBA0 0x2304      UMULL    R2,R3,R0,R4
   \   00000124   0xFB01 0x3304      MLA      R3,R1,R4,R3
   \   00000128   0xE9C6 0x2312      STRD     R2,R3,[R6, #+72]
    408          		cardinfo->CardBlockSize=1<<(cardinfo->SD_csd.RdBlockLen);//块大小
   \   0000012C   0xF996 0x0008      LDRSB    R0,[R6, #+8]
   \   00000130   0xFA0E 0xF000      LSL      R0,LR,R0
   \   00000134   0x6530             STR      R0,[R6, #+80]
    409          		cardinfo->CardCapacity*=cardinfo->CardBlockSize;
   \   00000136   0xE9D6 0x2312      LDRD     R2,R3,[R6, #+72]
   \   0000013A   0xFBA0 0x4502      UMULL    R4,R5,R0,R2
   \   0000013E   0xFB00 0x5503      MLA      R5,R0,R3,R5
   \   00000142   0xE9C6 0x4512      STRD     R4,R5,[R6, #+72]
   \   00000146   0xE0B3             B.N      ??SD_GetCardInfo_2
    410          	}
    411          	else if(CardType==SDIO_HIGH_CAPACITY_SD_CARD)	//高容量卡
   \                     ??SD_GetCardInfo_1: (+1)
   \   00000148   0x2802             CMP      R0,#+2
   \   0000014A   0xD11F             BNE.N    ??SD_GetCardInfo_3
    412          	{
    413           		tmp=(u8)(CSD_Tab[1]&0x000000FF); 		//第7个字节	
    414          		cardinfo->SD_csd.DeviceSize=(tmp&0x3F)<<16;//C_SIZE
   \   0000014C   0x7B38             LDRB     R0,[R7, #+12]
   \   0000014E   0xF000 0x003F      AND      R0,R0,#0x3F
   \   00000152   0x0400             LSLS     R0,R0,#+16
   \   00000154   0x6130             STR      R0,[R6, #+16]
    415           		tmp=(u8)((CSD_Tab[2]&0xFF000000)>>24); 	//第8个字节	
    416           		cardinfo->SD_csd.DeviceSize|=(tmp<<8);
   \   00000156   0x6930             LDR      R0,[R6, #+16]
   \   00000158   0x6939             LDR      R1,[R7, #+16]
   \   0000015A   0x0E09             LSRS     R1,R1,#+24
   \   0000015C   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000160   0x6130             STR      R0,[R6, #+16]
    417           		tmp=(u8)((CSD_Tab[2]&0x00FF0000)>>16);	//第9个字节	
    418           		cardinfo->SD_csd.DeviceSize|=(tmp);
   \   00000162   0x6930             LDR      R0,[R6, #+16]
   \   00000164   0x6939             LDR      R1,[R7, #+16]
   \   00000166   0x0C09             LSRS     R1,R1,#+16
   \   00000168   0xB2C9             UXTB     R1,R1
   \   0000016A   0x4308             ORRS     R0,R1,R0
   \   0000016C   0x6130             STR      R0,[R6, #+16]
    419           		tmp=(u8)((CSD_Tab[2]&0x0000FF00)>>8); 	//第10个字节	
   \   0000016E   0x6938             LDR      R0,[R7, #+16]
   \   00000170   0xF3C0 0x2C07      UBFX     R12,R0,#+8,#+8
    420           		cardinfo->CardCapacity=(long long)(cardinfo->SD_csd.DeviceSize+1)*512*1024;//计算卡容量
   \   00000174   0x6930             LDR      R0,[R6, #+16]
   \   00000176   0x1C40             ADDS     R0,R0,#+1
   \   00000178   0x2100             MOVS     R1,#+0
   \   0000017A   0xEA41 0x3150      ORR      R1,R1,R0, LSR #+13
   \   0000017E   0x04C0             LSLS     R0,R0,#+19
   \   00000180   0xE9C6 0x0112      STRD     R0,R1,[R6, #+72]
    421          		cardinfo->CardBlockSize=512; 			//块大小固定为512字节
   \   00000184   0xF44F 0x7000      MOV      R0,#+512
   \   00000188   0x6530             STR      R0,[R6, #+80]
   \   0000018A   0xE091             B.N      ??SD_GetCardInfo_2
    422          	}	
    423          	else if(SDIO_MULTIMEDIA_CARD==CardType)
   \                     ??SD_GetCardInfo_3: (+1)
   \   0000018C   0x2803             CMP      R0,#+3
   \   0000018E   0xD152             BNE.N    ??SD_GetCardInfo_4
    424          	{
    425          		cardinfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;
   \   00000190   0xF00C 0x0003      AND      R0,R12,#0x3
   \   00000194   0x0280             LSLS     R0,R0,#+10
   \   00000196   0x6130             STR      R0,[R6, #+16]
    426          
    427          		/*!< Byte 7 */
    428          		tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
    429          		cardinfo->SD_csd.DeviceSize |= (tmp) << 2;
   \   00000198   0x6930             LDR      R0,[R6, #+16]
   \   0000019A   0x7B39             LDRB     R1,[R7, #+12]
   \   0000019C   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   000001A0   0x6130             STR      R0,[R6, #+16]
    430          
    431          		/*!< Byte 8 */
    432          		tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
   \   000001A2   0x6938             LDR      R0,[R7, #+16]
   \   000001A4   0x0E00             LSRS     R0,R0,#+24
    433          		cardinfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;
   \   000001A6   0x6931             LDR      R1,[R6, #+16]
   \   000001A8   0x1182             ASRS     R2,R0,#+6
   \   000001AA   0xF002 0x0203      AND      R2,R2,#0x3
   \   000001AE   0x4311             ORRS     R1,R2,R1
   \   000001B0   0x6131             STR      R1,[R6, #+16]
    434          
    435          		cardinfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
   \   000001B2   0x10C1             ASRS     R1,R0,#+3
   \   000001B4   0xF001 0x0107      AND      R1,R1,#0x7
   \   000001B8   0x7531             STRB     R1,[R6, #+20]
    436          		cardinfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);
   \   000001BA   0xF000 0x0007      AND      R0,R0,#0x7
   \   000001BE   0x7570             STRB     R0,[R6, #+21]
    437          
    438          		/*!< Byte 9 */
    439          		tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
   \   000001C0   0x6938             LDR      R0,[R7, #+16]
   \   000001C2   0x0C00             LSRS     R0,R0,#+16
   \   000001C4   0xB2C0             UXTB     R0,R0
    440          		cardinfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
   \   000001C6   0x1141             ASRS     R1,R0,#+5
   \   000001C8   0xF001 0x0107      AND      R1,R1,#0x7
   \   000001CC   0x75B1             STRB     R1,[R6, #+22]
    441          		cardinfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
   \   000001CE   0x1081             ASRS     R1,R0,#+2
   \   000001D0   0xF001 0x0107      AND      R1,R1,#0x7
   \   000001D4   0x75F1             STRB     R1,[R6, #+23]
    442          		cardinfo->SD_csd.DeviceSizeMul = (tmp & 0x03) << 1;
   \   000001D6   0xF000 0x0003      AND      R0,R0,#0x3
   \   000001DA   0x0040             LSLS     R0,R0,#+1
   \   000001DC   0x7630             STRB     R0,[R6, #+24]
    443          		/*!< Byte 10 */
    444          		tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
   \   000001DE   0x6938             LDR      R0,[R7, #+16]
   \   000001E0   0xEA4F 0x2C10      LSR      R12,R0,#+8
   \   000001E4   0xFA5F 0xFC8C      UXTB     R12,R12
    445          		cardinfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;
   \   000001E8   0x7E30             LDRB     R0,[R6, #+24]
   \   000001EA   0xEA4F 0x11EC      ASR      R1,R12,#+7
   \   000001EE   0xF001 0x0101      AND      R1,R1,#0x1
   \   000001F2   0x4308             ORRS     R0,R1,R0
   \   000001F4   0x7630             STRB     R0,[R6, #+24]
    446          
    447          		cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
   \   000001F6   0x6930             LDR      R0,[R6, #+16]
   \   000001F8   0x1C42             ADDS     R2,R0,#+1
   \   000001FA   0x2300             MOVS     R3,#+0
   \   000001FC   0xE9C6 0x2312      STRD     R2,R3,[R6, #+72]
    448          		cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
   \   00000200   0xF04F 0x0E01      MOV      LR,#+1
   \   00000204   0x7E30             LDRB     R0,[R6, #+24]
   \   00000206   0x1C80             ADDS     R0,R0,#+2
   \   00000208   0xFA0E 0xF000      LSL      R0,LR,R0
   \   0000020C   0x17C1             ASRS     R1,R0,#+31
   \   0000020E   0xFBA0 0x4502      UMULL    R4,R5,R0,R2
   \   00000212   0xFB01 0x5502      MLA      R5,R1,R2,R5
   \   00000216   0xE9C6 0x4512      STRD     R4,R5,[R6, #+72]
    449          		cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
   \   0000021A   0xF996 0x0008      LDRSB    R0,[R6, #+8]
   \   0000021E   0xFA0E 0xF000      LSL      R0,LR,R0
   \   00000222   0x6530             STR      R0,[R6, #+80]
    450          		cardinfo->CardCapacity *= cardinfo->CardBlockSize; 	
   \   00000224   0xE9D6 0x2312      LDRD     R2,R3,[R6, #+72]
   \   00000228   0xFBA0 0x4502      UMULL    R4,R5,R0,R2
   \   0000022C   0xFB00 0x5503      MLA      R5,R0,R3,R5
   \   00000230   0xE9C6 0x4512      STRD     R4,R5,[R6, #+72]
   \   00000234   0xE03C             B.N      ??SD_GetCardInfo_2
    451          	}
    452          	else if(CardType == SDIO_HIGH_CAPACITY_MMC_CARD)
   \                     ??SD_GetCardInfo_4: (+1)
   \   00000236   0x2807             CMP      R0,#+7
   \   00000238   0xD13A             BNE.N    ??SD_GetCardInfo_2
    453          	{
    454          		cardinfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;
   \   0000023A   0xF00C 0x0003      AND      R0,R12,#0x3
   \   0000023E   0x0280             LSLS     R0,R0,#+10
   \   00000240   0x6130             STR      R0,[R6, #+16]
    455          
    456          		/*!< Byte 7 */
    457          		tmp = (uint8_t)(CSD_Tab[1] & 0x000000FF);
    458          		cardinfo->SD_csd.DeviceSize |= (tmp) << 2;
   \   00000242   0x6930             LDR      R0,[R6, #+16]
   \   00000244   0x7B39             LDRB     R1,[R7, #+12]
   \   00000246   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   0000024A   0x6130             STR      R0,[R6, #+16]
    459          
    460          		/*!< Byte 8 */
    461          		tmp = (uint8_t)((CSD_Tab[2] & 0xFF000000) >> 24);
   \   0000024C   0x6938             LDR      R0,[R7, #+16]
   \   0000024E   0x0E00             LSRS     R0,R0,#+24
    462          		cardinfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;
   \   00000250   0x6931             LDR      R1,[R6, #+16]
   \   00000252   0x1182             ASRS     R2,R0,#+6
   \   00000254   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000258   0x4311             ORRS     R1,R2,R1
   \   0000025A   0x6131             STR      R1,[R6, #+16]
    463          
    464          		cardinfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
   \   0000025C   0x10C1             ASRS     R1,R0,#+3
   \   0000025E   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000262   0x7531             STRB     R1,[R6, #+20]
    465          		cardinfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);
   \   00000264   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000268   0x7570             STRB     R0,[R6, #+21]
    466          
    467          		/*!< Byte 9 */
    468          		tmp = (uint8_t)((CSD_Tab[2] & 0x00FF0000) >> 16);
   \   0000026A   0x6938             LDR      R0,[R7, #+16]
   \   0000026C   0x0C00             LSRS     R0,R0,#+16
   \   0000026E   0xB2C0             UXTB     R0,R0
    469          		cardinfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
   \   00000270   0x1141             ASRS     R1,R0,#+5
   \   00000272   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000276   0x75B1             STRB     R1,[R6, #+22]
    470          		cardinfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
   \   00000278   0x1081             ASRS     R1,R0,#+2
   \   0000027A   0xF001 0x0107      AND      R1,R1,#0x7
   \   0000027E   0x75F1             STRB     R1,[R6, #+23]
    471          		cardinfo->SD_csd.DeviceSizeMul = (tmp & 0x03) << 1;
   \   00000280   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000284   0x0040             LSLS     R0,R0,#+1
   \   00000286   0x7630             STRB     R0,[R6, #+24]
    472          		/*!< Byte 10 */
    473          		tmp = (uint8_t)((CSD_Tab[2] & 0x0000FF00) >> 8);
   \   00000288   0x6938             LDR      R0,[R7, #+16]
   \   0000028A   0xEA4F 0x2C10      LSR      R12,R0,#+8
   \   0000028E   0xFA5F 0xFC8C      UXTB     R12,R12
    474          		cardinfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;
   \   00000292   0x7E30             LDRB     R0,[R6, #+24]
   \   00000294   0xEA4F 0x11EC      ASR      R1,R12,#+7
   \   00000298   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000029C   0x4308             ORRS     R0,R1,R0
   \   0000029E   0x7630             STRB     R0,[R6, #+24]
    475          
    476          		/* Notice:
    477          		   HighCapacity MMC & eMMC need to read ExtCSD Register(CMD8)
    478          		   to get total sector count. 
    479          		   To read ExtCSD correctly,throw CMD7 at first.
    480          		   Thus on s**kly SPD libraries,cannot execute CMD8 in this function scope.
    481          		   Anyway,I set SDCardInfo value for USB-MSC Example.
    482          		*/
    483          		cardinfo->CardCapacity  = SDCardInfo.CardCapacity;
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   000002A4   0xE9D0 0x2312      LDRD     R2,R3,[R0, #+72]
   \   000002A8   0xE9C6 0x2312      STRD     R2,R3,[R6, #+72]
    484          		cardinfo->CardBlockSize = SDCardInfo.CardBlockSize;	
   \   000002AC   0x6D00             LDR      R0,[R0, #+80]
   \   000002AE   0x6530             STR      R0,[R6, #+80]
    485          	}
    486          	cardinfo->SD_csd.EraseGrSize=(tmp&0x40)>>6;
   \                     ??SD_GetCardInfo_2: (+1)
   \   000002B0   0xEA4F 0x10AC      ASR      R0,R12,#+6
   \   000002B4   0xF000 0x0001      AND      R0,R0,#0x1
   \   000002B8   0x7670             STRB     R0,[R6, #+25]
    487          	cardinfo->SD_csd.EraseGrMul=(tmp&0x3F)<<1;	   
   \   000002BA   0xF00C 0x003F      AND      R0,R12,#0x3F
   \   000002BE   0x0040             LSLS     R0,R0,#+1
   \   000002C0   0x76B0             STRB     R0,[R6, #+26]
    488          	tmp=(u8)(CSD_Tab[2]&0x000000FF);			//第11个字节	
   \   000002C2   0x7C38             LDRB     R0,[R7, #+16]
    489          	cardinfo->SD_csd.EraseGrMul|=(tmp&0x80)>>7;
   \   000002C4   0x7EB1             LDRB     R1,[R6, #+26]
   \   000002C6   0x4602             MOV      R2,R0
   \   000002C8   0xEA41 0x11D2      ORR      R1,R1,R2, LSR #+7
   \   000002CC   0x76B1             STRB     R1,[R6, #+26]
    490          	cardinfo->SD_csd.WrProtectGrSize=(tmp&0x7F);
   \   000002CE   0xF000 0x007F      AND      R0,R0,#0x7F
   \   000002D2   0x76F0             STRB     R0,[R6, #+27]
    491           	tmp=(u8)((CSD_Tab[3]&0xFF000000)>>24);		//第12个字节	
   \   000002D4   0x6978             LDR      R0,[R7, #+20]
   \   000002D6   0x0E00             LSRS     R0,R0,#+24
    492          	cardinfo->SD_csd.WrProtectGrEnable=(tmp&0x80)>>7;
   \   000002D8   0x11C1             ASRS     R1,R0,#+7
   \   000002DA   0xF001 0x0101      AND      R1,R1,#0x1
   \   000002DE   0x7731             STRB     R1,[R6, #+28]
    493          	cardinfo->SD_csd.ManDeflECC=(tmp&0x60)>>5;
   \   000002E0   0x1141             ASRS     R1,R0,#+5
   \   000002E2   0xF001 0x0103      AND      R1,R1,#0x3
   \   000002E6   0x7771             STRB     R1,[R6, #+29]
    494          	cardinfo->SD_csd.WrSpeedFact=(tmp&0x1C)>>2;
   \   000002E8   0x1081             ASRS     R1,R0,#+2
   \   000002EA   0xF001 0x0107      AND      R1,R1,#0x7
   \   000002EE   0x77B1             STRB     R1,[R6, #+30]
    495          	cardinfo->SD_csd.MaxWrBlockLen=(tmp&0x03)<<2;	 
   \   000002F0   0xF000 0x0003      AND      R0,R0,#0x3
   \   000002F4   0x0080             LSLS     R0,R0,#+2
   \   000002F6   0x77F0             STRB     R0,[R6, #+31]
    496          	tmp=(u8)((CSD_Tab[3]&0x00FF0000)>>16);		//第13个字节
   \   000002F8   0x6978             LDR      R0,[R7, #+20]
   \   000002FA   0x0C00             LSRS     R0,R0,#+16
   \   000002FC   0xB2C0             UXTB     R0,R0
    497          	cardinfo->SD_csd.MaxWrBlockLen|=(tmp&0xC0)>>6;
   \   000002FE   0x7FF1             LDRB     R1,[R6, #+31]
   \   00000300   0x1182             ASRS     R2,R0,#+6
   \   00000302   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000306   0x4311             ORRS     R1,R2,R1
   \   00000308   0x77F1             STRB     R1,[R6, #+31]
    498          	cardinfo->SD_csd.WriteBlockPaPartial=(tmp&0x20)>>5;
   \   0000030A   0x1141             ASRS     R1,R0,#+5
   \   0000030C   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000310   0xF886 0x1020      STRB     R1,[R6, #+32]
    499          	cardinfo->SD_csd.Reserved3=0;
   \   00000314   0x2100             MOVS     R1,#+0
   \   00000316   0xF886 0x1021      STRB     R1,[R6, #+33]
    500          	cardinfo->SD_csd.ContentProtectAppli=(tmp&0x01);  
   \   0000031A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000031E   0xF886 0x0022      STRB     R0,[R6, #+34]
    501          	tmp=(u8)((CSD_Tab[3]&0x0000FF00)>>8);		//第14个字节
   \   00000322   0x6978             LDR      R0,[R7, #+20]
   \   00000324   0x0A00             LSRS     R0,R0,#+8
   \   00000326   0xB2C0             UXTB     R0,R0
    502          	cardinfo->SD_csd.FileFormatGrouop=(tmp&0x80)>>7;
   \   00000328   0x11C1             ASRS     R1,R0,#+7
   \   0000032A   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000032E   0xF886 0x1023      STRB     R1,[R6, #+35]
    503          	cardinfo->SD_csd.CopyFlag=(tmp&0x40)>>6;
   \   00000332   0x1181             ASRS     R1,R0,#+6
   \   00000334   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000338   0xF886 0x1024      STRB     R1,[R6, #+36]
    504          	cardinfo->SD_csd.PermWrProtect=(tmp&0x20)>>5;
   \   0000033C   0x1141             ASRS     R1,R0,#+5
   \   0000033E   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000342   0xF886 0x1025      STRB     R1,[R6, #+37]
    505          	cardinfo->SD_csd.TempWrProtect=(tmp&0x10)>>4;
   \   00000346   0x1101             ASRS     R1,R0,#+4
   \   00000348   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000034C   0xF886 0x1026      STRB     R1,[R6, #+38]
    506          	cardinfo->SD_csd.FileFormat=(tmp&0x0C)>>2;
   \   00000350   0x1081             ASRS     R1,R0,#+2
   \   00000352   0xF001 0x0103      AND      R1,R1,#0x3
   \   00000356   0xF886 0x1027      STRB     R1,[R6, #+39]
    507          	cardinfo->SD_csd.ECC=(tmp&0x03);  
   \   0000035A   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000035E   0xF886 0x0028      STRB     R0,[R6, #+40]
    508          	tmp=(u8)(CSD_Tab[3]&0x000000FF);			//第15个字节
    509          	cardinfo->SD_csd.CSD_CRC=(tmp&0xFE)>>1;
   \   00000362   0x6978             LDR      R0,[R7, #+20]
   \   00000364   0xB2C0             UXTB     R0,R0
   \   00000366   0x0840             LSRS     R0,R0,#+1
   \   00000368   0xF886 0x0029      STRB     R0,[R6, #+41]
    510          	cardinfo->SD_csd.Reserved4=1;	
   \   0000036C   0x2001             MOVS     R0,#+1
   \   0000036E   0xF886 0x002A      STRB     R0,[R6, #+42]
    511          	if ((CardType == SDIO_STD_CAPACITY_SD_CARD_V1_1)  || \
    512                  (CardType == SDIO_STD_CAPACITY_SD_CARD_V2_0)  || \
    513          		(CardType == SDIO_HIGH_CAPACITY_SD_CARD))
   \   00000372   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000376   0xD004             BEQ.N    ??SD_GetCardInfo_5
   \   00000378   0x4640             MOV      R0,R8
   \   0000037A   0x2801             CMP      R0,#+1
   \   0000037C   0xD001             BEQ.N    ??SD_GetCardInfo_5
   \   0000037E   0x2802             CMP      R0,#+2
   \   00000380   0xD160             BNE.N    ??SD_GetCardInfo_6
    514          		{
    515          	tmp=(u8)((CID_Tab[0]&0xFF000000)>>24);		//第0个字节
    516          	cardinfo->SD_cid.ManufacturerID=tmp;		    
   \                     ??SD_GetCardInfo_5: (+1)
   \   00000382   0x69B8             LDR      R0,[R7, #+24]
   \   00000384   0x0E00             LSRS     R0,R0,#+24
   \   00000386   0xF886 0x002C      STRB     R0,[R6, #+44]
    517          	tmp=(u8)((CID_Tab[0]&0x00FF0000)>>16);		//第1个字节
    518          	cardinfo->SD_cid.OEM_AppliID=tmp<<8;	  
   \   0000038A   0x69B8             LDR      R0,[R7, #+24]
   \   0000038C   0x0C00             LSRS     R0,R0,#+16
   \   0000038E   0xB2C0             UXTB     R0,R0
   \   00000390   0x0200             LSLS     R0,R0,#+8
   \   00000392   0x85F0             STRH     R0,[R6, #+46]
    519          	tmp=(u8)((CID_Tab[0]&0x000000FF00)>>8);		//第2个字节
    520          	cardinfo->SD_cid.OEM_AppliID|=tmp;	    
   \   00000394   0x8DF0             LDRH     R0,[R6, #+46]
   \   00000396   0x69B9             LDR      R1,[R7, #+24]
   \   00000398   0x0A09             LSRS     R1,R1,#+8
   \   0000039A   0xB2C9             UXTB     R1,R1
   \   0000039C   0x4308             ORRS     R0,R1,R0
   \   0000039E   0x85F0             STRH     R0,[R6, #+46]
    521          	tmp=(u8)(CID_Tab[0]&0x000000FF);			//第3个字节	
    522          	cardinfo->SD_cid.ProdName1=tmp<<24;				  
   \   000003A0   0x7E38             LDRB     R0,[R7, #+24]
   \   000003A2   0x0600             LSLS     R0,R0,#+24
   \   000003A4   0x6330             STR      R0,[R6, #+48]
    523          	tmp=(u8)((CID_Tab[1]&0xFF000000)>>24); 		//第4个字节
    524          	cardinfo->SD_cid.ProdName1|=tmp<<16;	  
   \   000003A6   0x6B30             LDR      R0,[R6, #+48]
   \   000003A8   0x69F9             LDR      R1,[R7, #+28]
   \   000003AA   0x0E09             LSRS     R1,R1,#+24
   \   000003AC   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000003B0   0x6330             STR      R0,[R6, #+48]
    525          	tmp=(u8)((CID_Tab[1]&0x00FF0000)>>16);	   	//第5个字节
    526          	cardinfo->SD_cid.ProdName1|=tmp<<8;		 
   \   000003B2   0x6B30             LDR      R0,[R6, #+48]
   \   000003B4   0x69F9             LDR      R1,[R7, #+28]
   \   000003B6   0x0C09             LSRS     R1,R1,#+16
   \   000003B8   0xB2C9             UXTB     R1,R1
   \   000003BA   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000003BE   0x6330             STR      R0,[R6, #+48]
    527          	tmp=(u8)((CID_Tab[1]&0x0000FF00)>>8);		//第6个字节
    528          	cardinfo->SD_cid.ProdName1|=tmp;		   
   \   000003C0   0x6B30             LDR      R0,[R6, #+48]
   \   000003C2   0x69F9             LDR      R1,[R7, #+28]
   \   000003C4   0x0A09             LSRS     R1,R1,#+8
   \   000003C6   0xB2C9             UXTB     R1,R1
   \   000003C8   0x4308             ORRS     R0,R1,R0
   \   000003CA   0x6330             STR      R0,[R6, #+48]
    529          	tmp=(u8)(CID_Tab[1]&0x000000FF);	  		//第7个字节
    530          	cardinfo->SD_cid.ProdName2=tmp;			  
   \   000003CC   0x69F8             LDR      R0,[R7, #+28]
   \   000003CE   0xF886 0x0034      STRB     R0,[R6, #+52]
    531          	tmp=(u8)((CID_Tab[2]&0xFF000000)>>24); 		//第8个字节
    532          	cardinfo->SD_cid.ProdRev=tmp;		 
   \   000003D2   0x6A38             LDR      R0,[R7, #+32]
   \   000003D4   0x0E00             LSRS     R0,R0,#+24
   \   000003D6   0xF886 0x0035      STRB     R0,[R6, #+53]
    533          	tmp=(u8)((CID_Tab[2]&0x00FF0000)>>16);		//第9个字节
    534          	cardinfo->SD_cid.ProdSN=tmp<<24;	   
   \   000003DA   0x6A38             LDR      R0,[R7, #+32]
   \   000003DC   0x0C00             LSRS     R0,R0,#+16
   \   000003DE   0xB2C0             UXTB     R0,R0
   \   000003E0   0x0600             LSLS     R0,R0,#+24
   \   000003E2   0x63B0             STR      R0,[R6, #+56]
    535          	tmp=(u8)((CID_Tab[2]&0x0000FF00)>>8); 		//第10个字节
    536          	cardinfo->SD_cid.ProdSN|=tmp<<16;	   
   \   000003E4   0x6BB0             LDR      R0,[R6, #+56]
   \   000003E6   0x6A39             LDR      R1,[R7, #+32]
   \   000003E8   0x0A09             LSRS     R1,R1,#+8
   \   000003EA   0xB2C9             UXTB     R1,R1
   \   000003EC   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000003F0   0x63B0             STR      R0,[R6, #+56]
    537          	tmp=(u8)(CID_Tab[2]&0x000000FF);   			//第11个字节
    538          	cardinfo->SD_cid.ProdSN|=tmp<<8;		   
   \   000003F2   0x6BB0             LDR      R0,[R6, #+56]
   \   000003F4   0xF897 0x1020      LDRB     R1,[R7, #+32]
   \   000003F8   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000003FC   0x63B0             STR      R0,[R6, #+56]
    539          	tmp=(u8)((CID_Tab[3]&0xFF000000)>>24); 		//第12个字节
    540          	cardinfo->SD_cid.ProdSN|=tmp;			     
   \   000003FE   0x6BB0             LDR      R0,[R6, #+56]
   \   00000400   0x6A79             LDR      R1,[R7, #+36]
   \   00000402   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   00000406   0x63B0             STR      R0,[R6, #+56]
    541          	tmp=(u8)((CID_Tab[3]&0x00FF0000)>>16);	 	//第13个字节
   \   00000408   0x6A78             LDR      R0,[R7, #+36]
   \   0000040A   0x0C00             LSRS     R0,R0,#+16
   \   0000040C   0xB2C0             UXTB     R0,R0
    542          	cardinfo->SD_cid.Reserved1|=(tmp&0xF0)>>4;
   \   0000040E   0xF896 0x103C      LDRB     R1,[R6, #+60]
   \   00000412   0x1102             ASRS     R2,R0,#+4
   \   00000414   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000418   0x4311             ORRS     R1,R2,R1
   \   0000041A   0xF886 0x103C      STRB     R1,[R6, #+60]
    543          	cardinfo->SD_cid.ManufactDate=(tmp&0x0F)<<8;    
   \   0000041E   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000422   0x0200             LSLS     R0,R0,#+8
   \   00000424   0x87F0             STRH     R0,[R6, #+62]
    544          	tmp=(u8)((CID_Tab[3]&0x0000FF00)>>8);		//第14个字节
    545          	cardinfo->SD_cid.ManufactDate|=tmp;		 	  
   \   00000426   0x8FF0             LDRH     R0,[R6, #+62]
   \   00000428   0x6A79             LDR      R1,[R7, #+36]
   \   0000042A   0x0A09             LSRS     R1,R1,#+8
   \   0000042C   0xB2C9             UXTB     R1,R1
   \   0000042E   0x4308             ORRS     R0,R1,R0
   \   00000430   0x87F0             STRH     R0,[R6, #+62]
    546          	tmp=(u8)(CID_Tab[3]&0x000000FF);			//第15个字节
    547          	cardinfo->SD_cid.CID_CRC=(tmp&0xFE)>>1;
   \   00000432   0x6A78             LDR      R0,[R7, #+36]
   \   00000434   0xB2C0             UXTB     R0,R0
   \   00000436   0x0840             LSRS     R0,R0,#+1
   \   00000438   0xF886 0x0040      STRB     R0,[R6, #+64]
    548          	cardinfo->SD_cid.Reserved2=1;	 
   \   0000043C   0x2001             MOVS     R0,#+1
   \   0000043E   0xF886 0x0041      STRB     R0,[R6, #+65]
   \   00000442   0xE061             B.N      ??SD_GetCardInfo_7
    549          		}
    550          	else if ((CardType == SDIO_MULTIMEDIA_CARD) || (CardType == SDIO_HIGH_CAPACITY_MMC_CARD))
   \                     ??SD_GetCardInfo_6: (+1)
   \   00000444   0x2803             CMP      R0,#+3
   \   00000446   0xD001             BEQ.N    ??SD_GetCardInfo_8
   \   00000448   0x2807             CMP      R0,#+7
   \   0000044A   0xD15D             BNE.N    ??SD_GetCardInfo_7
    551          	{
    552          		/*!< Byte 0 */
    553          		tmp = (uint8_t)((CID_Tab[0] & 0xFF000000) >> 24);
    554          		cardinfo->SD_cid.ManufacturerID = tmp;
   \                     ??SD_GetCardInfo_8: (+1)
   \   0000044C   0x69B8             LDR      R0,[R7, #+24]
   \   0000044E   0x0E00             LSRS     R0,R0,#+24
   \   00000450   0xF886 0x002C      STRB     R0,[R6, #+44]
    555          
    556          		/*!< Byte 1 */
    557          		tmp = (uint8_t)((CID_Tab[0] & 0x00FF0000) >> 16);
    558          		cardinfo->SD_cid.OEM_AppliID = tmp << 8;
   \   00000454   0x69B8             LDR      R0,[R7, #+24]
   \   00000456   0x0C00             LSRS     R0,R0,#+16
   \   00000458   0xB2C0             UXTB     R0,R0
   \   0000045A   0x0200             LSLS     R0,R0,#+8
   \   0000045C   0x85F0             STRH     R0,[R6, #+46]
    559          
    560          		/*!< Byte 2 */
    561          		tmp = (uint8_t)((CID_Tab[0] & 0x000000FF00) >> 8);
    562          		cardinfo->SD_cid.OEM_AppliID |= tmp;
   \   0000045E   0x8DF0             LDRH     R0,[R6, #+46]
   \   00000460   0x69B9             LDR      R1,[R7, #+24]
   \   00000462   0x0A09             LSRS     R1,R1,#+8
   \   00000464   0xB2C9             UXTB     R1,R1
   \   00000466   0x4308             ORRS     R0,R1,R0
   \   00000468   0x85F0             STRH     R0,[R6, #+46]
    563          
    564          		/*!< Byte 3 */
    565          		tmp = (uint8_t)(CID_Tab[0] & 0x000000FF);
    566          		cardinfo->SD_cid.ProdName1 = tmp << 24;
   \   0000046A   0x7E38             LDRB     R0,[R7, #+24]
   \   0000046C   0x0600             LSLS     R0,R0,#+24
   \   0000046E   0x6330             STR      R0,[R6, #+48]
    567          
    568          		/*!< Byte 4 */
    569          		tmp = (uint8_t)((CID_Tab[1] & 0xFF000000) >> 24);
    570          		cardinfo->SD_cid.ProdName1 |= tmp << 16;
   \   00000470   0x6B30             LDR      R0,[R6, #+48]
   \   00000472   0x69F9             LDR      R1,[R7, #+28]
   \   00000474   0x0E09             LSRS     R1,R1,#+24
   \   00000476   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000047A   0x6330             STR      R0,[R6, #+48]
    571          
    572          		/*!< Byte 5 */
    573          		tmp = (uint8_t)((CID_Tab[1] & 0x00FF0000) >> 16);
    574          		cardinfo->SD_cid.ProdName1 |= tmp << 8;
   \   0000047C   0x6B30             LDR      R0,[R6, #+48]
   \   0000047E   0x69F9             LDR      R1,[R7, #+28]
   \   00000480   0x0C09             LSRS     R1,R1,#+16
   \   00000482   0xB2C9             UXTB     R1,R1
   \   00000484   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000488   0x6330             STR      R0,[R6, #+48]
    575          
    576          		/*!< Byte 6 */
    577          		tmp = (uint8_t)((CID_Tab[1] & 0x0000FF00) >> 8);
    578          		cardinfo->SD_cid.ProdName1 |= tmp;
   \   0000048A   0x6B30             LDR      R0,[R6, #+48]
   \   0000048C   0x69F9             LDR      R1,[R7, #+28]
   \   0000048E   0x0A09             LSRS     R1,R1,#+8
   \   00000490   0xB2C9             UXTB     R1,R1
   \   00000492   0x4308             ORRS     R0,R1,R0
   \   00000494   0x6330             STR      R0,[R6, #+48]
    579          
    580          		/*!< Byte 7 */
    581          		tmp = (uint8_t)(CID_Tab[1] & 0x000000FF);
    582          		cardinfo->SD_cid.ProdName2 = tmp << 16;
   \   00000496   0x2000             MOVS     R0,#+0
   \   00000498   0xF886 0x0034      STRB     R0,[R6, #+52]
    583          
    584          		/*!< Byte 8 */
    585          		tmp = (uint8_t)((CID_Tab[2] & 0xFF000000) >> 24);
    586          		cardinfo->SD_cid.ProdName2 |= tmp;
   \   0000049C   0xF896 0x0034      LDRB     R0,[R6, #+52]
   \   000004A0   0x6A39             LDR      R1,[R7, #+32]
   \   000004A2   0xEA50 0x6011      ORRS     R0,R0,R1, LSR #+24
   \   000004A6   0xF886 0x0034      STRB     R0,[R6, #+52]
    587          
    588          		/*!< Byte 9 */
    589          		tmp = (uint8_t)((CID_Tab[2] & 0x00FF0000) >> 16);
    590          		cardinfo->SD_cid.ProdRev = tmp;
   \   000004AA   0x6A38             LDR      R0,[R7, #+32]
   \   000004AC   0x0C00             LSRS     R0,R0,#+16
   \   000004AE   0xF886 0x0035      STRB     R0,[R6, #+53]
    591          
    592          		/*!< Byte 10 */
    593          		tmp = (uint8_t)((CID_Tab[2] & 0x0000FF00) >> 8);
    594          		cardinfo->SD_cid.ProdSN = tmp << 24;
   \   000004B2   0x6A38             LDR      R0,[R7, #+32]
   \   000004B4   0x0A00             LSRS     R0,R0,#+8
   \   000004B6   0xB2C0             UXTB     R0,R0
   \   000004B8   0x0600             LSLS     R0,R0,#+24
   \   000004BA   0x63B0             STR      R0,[R6, #+56]
    595          
    596          		/*!< Byte 11 */
    597          		tmp = (uint8_t)((CID_Tab[2] & 0x000000FF));
    598          		cardinfo->SD_cid.ProdSN |= tmp << 16;
   \   000004BC   0x6BB0             LDR      R0,[R6, #+56]
   \   000004BE   0xF897 0x1020      LDRB     R1,[R7, #+32]
   \   000004C2   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000004C6   0x63B0             STR      R0,[R6, #+56]
    599          
    600          		/*!< Byte 12 */
    601          		tmp = (uint8_t)((CID_Tab[3] & 0xFF000000) >> 24);
    602          		cardinfo->SD_cid.ProdSN |= tmp << 8;
   \   000004C8   0x6BB0             LDR      R0,[R6, #+56]
   \   000004CA   0x6A79             LDR      R1,[R7, #+36]
   \   000004CC   0x0E09             LSRS     R1,R1,#+24
   \   000004CE   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000004D2   0x63B0             STR      R0,[R6, #+56]
    603          
    604          		/*!< Byte 13 */
    605          		tmp = (uint8_t)((CID_Tab[3] & 0x00FF0000) >> 16);
    606          		cardinfo->SD_cid.ProdSN |= tmp;
   \   000004D4   0x6BB0             LDR      R0,[R6, #+56]
   \   000004D6   0x6A79             LDR      R1,[R7, #+36]
   \   000004D8   0x0C09             LSRS     R1,R1,#+16
   \   000004DA   0xB2C9             UXTB     R1,R1
   \   000004DC   0x4308             ORRS     R0,R1,R0
   \   000004DE   0x63B0             STR      R0,[R6, #+56]
    607          
    608          		/*!< Byte 14 */
    609          		tmp = (uint8_t)((CID_Tab[3] & 0x0000FF00) >> 8);
    610          		cardinfo->SD_cid.ManufactDate = (tmp & 0x0F) << 4;
   \   000004E0   0x6A78             LDR      R0,[R7, #+36]
   \   000004E2   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \   000004E6   0x0100             LSLS     R0,R0,#+4
   \   000004E8   0x87F0             STRH     R0,[R6, #+62]
    611          
    612          		/*!< Byte 14 */
    613          		tmp = (uint8_t)((CID_Tab[3] & 0x0000FF00) >> 8);
    614          		cardinfo->SD_cid.ManufactDate |= (tmp & 0xF0) >> 4;
   \   000004EA   0x8FF0             LDRH     R0,[R6, #+62]
   \   000004EC   0x6A79             LDR      R1,[R7, #+36]
   \   000004EE   0x0A09             LSRS     R1,R1,#+8
   \   000004F0   0xB2C9             UXTB     R1,R1
   \   000004F2   0xEA50 0x1011      ORRS     R0,R0,R1, LSR #+4
   \   000004F6   0x87F0             STRH     R0,[R6, #+62]
    615          
    616          		/*!< Byte 15 */
    617          		tmp = (uint8_t)(CID_Tab[3] & 0x000000FF);
    618          		cardinfo->SD_cid.CID_CRC = (tmp & 0xFE) >> 1;
   \   000004F8   0x6A78             LDR      R0,[R7, #+36]
   \   000004FA   0xB2C0             UXTB     R0,R0
   \   000004FC   0x0840             LSRS     R0,R0,#+1
   \   000004FE   0xF886 0x0040      STRB     R0,[R6, #+64]
    619          		cardinfo->SD_cid.Reserved2 = 1;
   \   00000502   0x2001             MOVS     R0,#+1
   \   00000504   0xF886 0x0041      STRB     R0,[R6, #+65]
    620          		}
    621          	return errorstatus;
   \                     ??SD_GetCardInfo_7: (+1)
   \   00000508   0x2000             MOVS     R0,#+0
   \   0000050A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    622          }
    623          
    624          //设置SDIO总线宽度(MMC卡不支持4bit模式)
    625          //wmode:位宽模式.0,1位数据宽度;1,4位数据宽度;2,8位数据宽度
    626          //返回值:SD卡错误状态

   \                                 In section .text, align 2, keep-with-next
    627          SD_Error SD_EnableWideBusOperation(u32 wmode)
    628          {
   \                     SD_EnableWideBusOperation: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    629            	SD_Error errorstatus=SD_OK;
   \   00000004   0x2000             MOVS     R0,#+0
    630           	if((SDIO_MULTIMEDIA_CARD==CardType)||
    631          		(SDIO_HIGH_SPEED_MULTIMEDIA_CARD == CardType) ||
    632          		(SDIO_HIGH_CAPACITY_MMC_CARD  == CardType))
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x460A             MOV      R2,R1
   \   0000000E   0x2A03             CMP      R2,#+3
   \   00000010   0xD003             BEQ.N    ??SD_EnableWideBusOperation_0
   \   00000012   0x2A05             CMP      R2,#+5
   \   00000014   0xD001             BEQ.N    ??SD_EnableWideBusOperation_0
   \   00000016   0x2A07             CMP      R2,#+7
   \   00000018   0xD11A             BNE.N    ??SD_EnableWideBusOperation_1
    633           	{
    634          		if(wmode>=2)return SD_UNSUPPORTED_FEATURE;//MMC卡不支持
   \                     ??SD_EnableWideBusOperation_0: (+1)
   \   0000001A   0x2C02             CMP      R4,#+2
   \   0000001C   0xD220             BCS.N    ??SD_EnableWideBusOperation_2
    635          		else
    636          		{
    637          			/* MMC WideBus Mode Supports above v4 cards! */
    638          			if(SDCardInfo.SD_csd.SysSpecVersion >= 4)
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000022   0x7849             LDRB     R1,[R1, #+1]
   \   00000024   0x2904             CMP      R1,#+4
   \   00000026   0xDB30             BLT.N    ??SD_EnableWideBusOperation_3
    639          			{
    640          				errorstatus=SDEnWideBus(wmode);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       SDEnWideBus
    641          	 			if(SD_OK==errorstatus)
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD12A             BNE.N    ??SD_EnableWideBusOperation_3
    642          				{
    643          					SDIO->CLKCR&=~(3<<11);		//清除之前的位宽设置    
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40018004
   \   00000038   0x680A             LDR      R2,[R1, #+0]
   \   0000003A   0xF422 0x52C0      BIC      R2,R2,#0x1800
   \   0000003E   0x600A             STR      R2,[R1, #+0]
    644          					SDIO->CLKCR|=(u16)wmode<<11;//1位/4位总线宽度 
   \   00000040   0x680A             LDR      R2,[R1, #+0]
   \   00000042   0xB2A4             UXTH     R4,R4
   \   00000044   0xEA42 0x22C4      ORR      R2,R2,R4, LSL #+11
   \   00000048   0x600A             STR      R2,[R1, #+0]
    645          					SDIO->CLKCR|=0<<14;			//不开启硬件流控制 
   \   0000004A   0x680A             LDR      R2,[R1, #+0]
   \   0000004C   0x600A             STR      R2,[R1, #+0]
   \   0000004E   0xBD10             POP      {R4,PC}
    646          				}		
    647          			}
    648          		}
    649           	}
    650           	else if((SDIO_STD_CAPACITY_SD_CARD_V1_1==CardType)||
    651          		(SDIO_STD_CAPACITY_SD_CARD_V2_0==CardType)||
    652          		(SDIO_HIGH_CAPACITY_SD_CARD==CardType))
   \                     ??SD_EnableWideBusOperation_1: (+1)
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD003             BEQ.N    ??SD_EnableWideBusOperation_4
   \   00000054   0x2A01             CMP      R2,#+1
   \   00000056   0xD001             BEQ.N    ??SD_EnableWideBusOperation_4
   \   00000058   0x2A02             CMP      R2,#+2
   \   0000005A   0xD116             BNE.N    ??SD_EnableWideBusOperation_3
    653          	{
    654          		if(wmode>=2)return SD_UNSUPPORTED_FEATURE;//不支持8位模式
   \                     ??SD_EnableWideBusOperation_4: (+1)
   \   0000005C   0x2C02             CMP      R4,#+2
   \   0000005E   0xD301             BCC.N    ??SD_EnableWideBusOperation_5
   \                     ??SD_EnableWideBusOperation_2: (+1)
   \   00000060   0x2027             MOVS     R0,#+39
   \   00000062   0xBD10             POP      {R4,PC}
    655           		else   
    656          		{
    657          			errorstatus=SDEnWideBus(wmode);
   \                     ??SD_EnableWideBusOperation_5: (+1)
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0x.... 0x....      BL       SDEnWideBus
    658           			if(SD_OK==errorstatus)
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD10C             BNE.N    ??SD_EnableWideBusOperation_3
    659          			{
    660          				SDIO->CLKCR&=~(3<<11);		//清除之前的位宽设置    
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40018004
   \   00000074   0x680A             LDR      R2,[R1, #+0]
   \   00000076   0xF422 0x52C0      BIC      R2,R2,#0x1800
   \   0000007A   0x600A             STR      R2,[R1, #+0]
    661          				SDIO->CLKCR|=(u16)wmode<<11;//1位/4位总线宽度 
   \   0000007C   0x680A             LDR      R2,[R1, #+0]
   \   0000007E   0xB2A4             UXTH     R4,R4
   \   00000080   0xEA42 0x22C4      ORR      R2,R2,R4, LSL #+11
   \   00000084   0x600A             STR      R2,[R1, #+0]
    662          				SDIO->CLKCR|=0<<14;			//不开启硬件流控制 
   \   00000086   0x680A             LDR      R2,[R1, #+0]
   \   00000088   0x600A             STR      R2,[R1, #+0]
    663          			}
    664          		}  
    665          	}
    666          	return errorstatus; 
   \                     ??SD_EnableWideBusOperation_3: (+1)
   \   0000008A   0xBD10             POP      {R4,PC}          ;; return
    667          }
    668          //设置SD卡工作模式
    669          //Mode:
    670          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
    671          SD_Error SD_SetDeviceMode(u32 Mode)
    672          {
    673          	SD_Error errorstatus = SD_OK;
   \                     SD_SetDeviceMode: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    674           	if((Mode==SD_DMA_MODE)||(Mode==SD_POLLING_MODE))DeviceMode=Mode;
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD001             BEQ.N    ??SD_SetDeviceMode_0
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE.N    ??SD_SetDeviceMode_1
   \                     ??SD_SetDeviceMode_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   0000000E   0x7050             STRB     R0,[R2, #+1]
   \   00000010   0xE000             B.N      ??SD_SetDeviceMode_2
    675          	else errorstatus=SD_INVALID_PARAMETER;
   \                     ??SD_SetDeviceMode_1: (+1)
   \   00000012   0x2126             MOVS     R1,#+38
    676          	return errorstatus;	    
   \                     ??SD_SetDeviceMode_2: (+1)
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x4770             BX       LR               ;; return
    677          }
    678          //选卡
    679          //发送CMD7,选择相对地址(rca)为addr的卡,取消其他卡.如果为0,则都不选择.
    680          //addr:卡的RCA地址

   \                                 In section .text, align 2, keep-with-next
    681          SD_Error SD_SelectDeselect(u32 addr)
    682          {
   \                     SD_SelectDeselect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    683           	SDIO_Send_Cmd(SD_CMD_SEL_DESEL_CARD,1,addr);	//发送CMD7,选择卡,短响应	 	   
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2007             MOVS     R0,#+7
   \   00000008   0x.... 0x....      BL       SDIO_Send_Cmd
    684             	return CmdResp1Error(SD_CMD_SEL_DESEL_CARD);	  
   \   0000000C   0x2007             MOVS     R0,#+7
   \   0000000E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000012   0x.... 0x....      B.W      CmdResp1Error
    685          }
    686          //SD卡读取一个块 
    687          //buf:读数据缓存区(必须4字节对齐!!)
    688          //addr:读取地址
    689          //blksize:块大小

   \                                 In section .text, align 2, keep-with-next
    690          SD_Error SD_ReadBlock(u8 *buf,uint64_t addr,u16 blksize)
    691          {	  
   \                     SD_ReadBlock: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    692          	SD_Error errorstatus=SD_OK;
    693          	u8 power;
    694             	u32 count=0,*tempbuff=(u32*)buf;//转换为u32指针 
   \   0000000A   0x46B8             MOV      R8,R7
    695          	u32 timeout=0;   
    696             	if(NULL==buf)return SD_INVALID_PARAMETER; 
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD06F             BEQ.N    ??SD_ReadBlock_0
    697             	SDIO->DCTRL=0x0;	//数据控制寄存器清零(关DMA)   
   \   00000010   0x.... 0x....      LDR.W    R9,??DataTable24  ;; 0x40018014
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF8C9 0x0018      STR      R0,[R9, #+24]
    698          	if(CardType==SDIO_HIGH_CAPACITY_SD_CARD)//大容量卡
   \   0000001A   0x.... 0x....      LDR.W    R10,??DataTable13_3
   \   0000001E   0x9E0A             LDR      R6,[SP, #+40]
   \   00000020   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD104             BNE.N    ??SD_ReadBlock_1
    699          	{
    700          		blksize=512;
   \   00000028   0xF44F 0x7600      MOV      R6,#+512
    701          		addr>>=9;
   \   0000002C   0x0A64             LSRS     R4,R4,#+9
   \   0000002E   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   \                     ??SD_ReadBlock_1: (+1)
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x461A             MOV      R2,R3
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x5f5e100
    702          	}   
    703            	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,0,0,0);	//清除DPSM状态机配置
   \   0000003C   0x.... 0x....      BL       SDIO_Send_Data_Cfg
    704          	if(SDIO->RESP1&SD_CARD_LOCKED)return SD_LOCK_UNLOCK_FAILED;//卡锁了
   \   00000040   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000044   0x0180             LSLS     R0,R0,#+6
   \   00000046   0xD501             BPL.N    ??SD_ReadBlock_2
   \   00000048   0x200E             MOVS     R0,#+14
   \   0000004A   0xE0BE             B.N      ??SD_ReadBlock_3
    705          	if((blksize>0)&&(blksize<=2048)&&((blksize&(blksize-1))==0))
   \                     ??SD_ReadBlock_2: (+1)
   \   0000004C   0x2E00             CMP      R6,#+0
   \   0000004E   0xD04F             BEQ.N    ??SD_ReadBlock_0
   \   00000050   0xF5B6 0x6F00      CMP      R6,#+2048
   \   00000054   0xDC4C             BGT.N    ??SD_ReadBlock_0
   \   00000056   0x1E71             SUBS     R1,R6,#+1
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x4208             TST      R0,R1
   \   0000005C   0xD148             BNE.N    ??SD_ReadBlock_0
    706          	{
    707          		power=convert_from_bytes_to_power_of_two(blksize);	    	   
   \   0000005E   0x.... 0x....      BL       convert_from_bytes_to_power_of_two
   \   00000062   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000066   0x4632             MOV      R2,R6
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2010             MOVS     R0,#+16
    708          		SDIO_Send_Cmd(SD_CMD_SET_BLOCKLEN,1,blksize);	//发送CMD16+设置数据长度为blksize,短响应 	   
   \   0000006C   0x.... 0x....      BL       SDIO_Send_Cmd
    709          		errorstatus=CmdResp1Error(SD_CMD_SET_BLOCKLEN);	//等待R1响应   
   \   00000070   0x2010             MOVS     R0,#+16
   \   00000072   0x.... 0x....      BL       CmdResp1Error
   \   00000076   0x4683             MOV      R11,R0
    710          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误	 
   \   00000078   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000007C   0xF040 0x80A4      BNE.W    ??SD_ReadBlock_4
    711          	}else return SD_INVALID_PARAMETER;	  	  									    
    712            	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,blksize,power,1);	//blksize,卡到控制器	  
   \   00000080   0x2301             MOVS     R3,#+1
   \   00000082   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000086   0x4631             MOV      R1,R6
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x5f5e100
   \   0000008C   0x.... 0x....      BL       SDIO_Send_Data_Cfg
    713             	SDIO_Send_Cmd(SD_CMD_READ_SINGLE_BLOCK,1,addr);		//发送CMD17+从addr地址出读取数据,短响应 	   
   \   00000090   0x4622             MOV      R2,R4
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x2011             MOVS     R0,#+17
   \   00000096   0x.... 0x....      BL       SDIO_Send_Cmd
    714          	errorstatus=CmdResp1Error(SD_CMD_READ_SINGLE_BLOCK);//等待R1响应   
   \   0000009A   0x2011             MOVS     R0,#+17
   \   0000009C   0x.... 0x....      BL       CmdResp1Error
   \   000000A0   0x4683             MOV      R11,R0
    715          	if(errorstatus!=SD_OK)return errorstatus;   		//响应错误	 
   \   000000A2   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000A6   0xF040 0x808F      BNE.W    ??SD_ReadBlock_4
    716          	if(DeviceMode==SD_POLLING_MODE)						//查询模式,轮询数据	 
   \   000000AA   0xF89A 0x0001      LDRB     R0,[R10, #+1]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD029             BEQ.N    ??SD_ReadBlock_5
    717          	{
    718          		while(!(SDIO->STA&((1<<5)|(1<<1)|(1<<3)|(1<<10)|(1<<9))))//无上溢/CRC/超时/完成(标志)/起始位错误
    719          		{
    720          			if(SDIO->STA&(1<<15))						//接收区半满,表示至少存了8个字
    721          			{
    722          				for(count=0;count<8;count++)			//循环读取数据
    723          				{
    724          					*(tempbuff+count)=SDIO->FIFO;	 
    725          				}
    726          				tempbuff+=8;
    727          			}
    728          		} 
    729          		if(SDIO->STA&(1<<3))		//数据超时错误
    730          		{										   
    731          	 		SDIO->ICR|=1<<3; 		//清错误标志
    732          			return SD_DATA_TIMEOUT;
    733          	 	}else if(SDIO->STA&(1<<1))	//数据块CRC错误
    734          		{
    735          	 		SDIO->ICR|=1<<1; 		//清错误标志
    736          			return SD_DATA_CRC_FAIL;		   
    737          		}else if(SDIO->STA&(1<<5)) 	//接收fifo上溢错误
    738          		{
    739          	 		SDIO->ICR|=1<<5; 		//清错误标志
    740          			return SD_RX_OVERRUN;		 
    741          		}else if(SDIO->STA&(1<<9)) 	//接收起始位错误
    742          		{
    743          	 		SDIO->ICR|=1<<9; 		//清错误标志
    744          			return SD_START_BIT_ERR;		 
    745          		}   
    746          		while(SDIO->STA&(1<<21))	//FIFO里面,还存在可用数据
    747          		{
    748          			*tempbuff=SDIO->FIFO;	//循环读取数据
    749          			tempbuff++;
    750          		}
    751          		SDIO->ICR=0X5FF;	 		//清除所有标记
    752          	}else if(DeviceMode==SD_DMA_MODE)
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xF040 0x8088      BNE.W    ??SD_ReadBlock_4
    753          	{
    754           		TransferError=SD_OK;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF88A 0x0003      STRB     R0,[R10, #+3]
    755          		StopCondition=0;			//单块读,不需要发送停止传输指令
   \   000000BE   0xF88A 0x0002      STRB     R0,[R10, #+2]
    756          		TransferEnd=0;				//传输结束标置位，在中断服务置1
   \   000000C2   0xF88A 0x0004      STRB     R0,[R10, #+4]
    757          		SDIO->MASK|=(1<<1)|(1<<3)|(1<<8)|(1<<5)|(1<<9);	//配置需要的中断 
   \   000000C6   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   000000CA   0xF240 0x312A      MOVW     R1,#+810
   \   000000CE   0x4308             ORRS     R0,R1,R0
   \   000000D0   0xF8C9 0x0028      STR      R0,[R9, #+40]
    758          	 	SDIO->DCTRL|=1<<3;		 	//SDIO DMA使能 
   \   000000D4   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   000000D8   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000000DC   0xF8C9 0x0018      STR      R0,[R9, #+24]
    759           	    SD_DMA_Config((u32*)buf,blksize,0);
   \   000000E0   0x2200             MOVS     R2,#+0
   \   000000E2   0x4631             MOV      R1,R6
   \   000000E4   0x4638             MOV      R0,R7
   \   000000E6   0x.... 0x....      BL       SD_DMA_Config
    760          		timeout=SDIO_DATATIMEOUT;
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x1ffff
   \   000000EE   0xE052             B.N      ??SD_ReadBlock_6
   \                     ??SD_ReadBlock_0: (+1)
   \   000000F0   0x2026             MOVS     R0,#+38
   \   000000F2   0xE06A             B.N      ??SD_ReadBlock_3
   \                     ??SD_ReadBlock_7: (+1)
   \   000000F4   0xF8D9 0x106C      LDR      R1,[R9, #+108]
   \   000000F8   0xF848 0x1020      STR      R1,[R8, R0, LSL #+2]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \                     ??SD_ReadBlock_8: (+1)
   \   000000FE   0x2808             CMP      R0,#+8
   \   00000100   0xD3F8             BCC.N    ??SD_ReadBlock_7
   \   00000102   0xF108 0x0820      ADD      R8,R8,#+32
   \                     ??SD_ReadBlock_5: (+1)
   \   00000106   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   0000010A   0xF240 0x612A      MOVW     R1,#+1578
   \   0000010E   0x4208             TST      R0,R1
   \   00000110   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   00000114   0xD103             BNE.N    ??SD_ReadBlock_9
   \   00000116   0x0400             LSLS     R0,R0,#+16
   \   00000118   0xD5F5             BPL.N    ??SD_ReadBlock_5
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xE7EF             B.N      ??SD_ReadBlock_8
   \                     ??SD_ReadBlock_9: (+1)
   \   0000011E   0x0700             LSLS     R0,R0,#+28
   \   00000120   0xD507             BPL.N    ??SD_ReadBlock_10
   \   00000122   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   00000126   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000012A   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   0000012E   0x2004             MOVS     R0,#+4
   \   00000130   0xE04B             B.N      ??SD_ReadBlock_3
   \                     ??SD_ReadBlock_10: (+1)
   \   00000132   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   00000136   0x0780             LSLS     R0,R0,#+30
   \   00000138   0xD507             BPL.N    ??SD_ReadBlock_11
   \   0000013A   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   0000013E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000142   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   00000146   0x2002             MOVS     R0,#+2
   \   00000148   0xE03F             B.N      ??SD_ReadBlock_3
   \                     ??SD_ReadBlock_11: (+1)
   \   0000014A   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   0000014E   0x0680             LSLS     R0,R0,#+26
   \   00000150   0xD507             BPL.N    ??SD_ReadBlock_12
   \   00000152   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   00000156   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000015A   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   0000015E   0x2006             MOVS     R0,#+6
   \   00000160   0xE033             B.N      ??SD_ReadBlock_3
   \                     ??SD_ReadBlock_12: (+1)
   \   00000162   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   00000166   0x0580             LSLS     R0,R0,#+22
   \   00000168   0xD50B             BPL.N    ??SD_ReadBlock_13
   \   0000016A   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   0000016E   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000172   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   00000176   0x2007             MOVS     R0,#+7
   \   00000178   0xE027             B.N      ??SD_ReadBlock_3
   \                     ??SD_ReadBlock_14: (+1)
   \   0000017A   0xF8D9 0x006C      LDR      R0,[R9, #+108]
   \   0000017E   0xF848 0x0B04      STR      R0,[R8], #+4
   \                     ??SD_ReadBlock_13: (+1)
   \   00000182   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   00000186   0x0280             LSLS     R0,R0,#+10
   \   00000188   0xD4F7             BMI.N    ??SD_ReadBlock_14
   \   0000018A   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000018E   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   00000192   0xE019             B.N      ??SD_ReadBlock_4
    761           		while(((DMA2->ISR&0X2000)==RESET)&&(TransferEnd==0)&&(TransferError==SD_OK)&&timeout)timeout--;//等待传输完成 
   \                     ??SD_ReadBlock_15: (+1)
   \   00000194   0x1E40             SUBS     R0,R0,#+1
   \                     ??SD_ReadBlock_6: (+1)
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x40020400
   \   0000019A   0x6809             LDR      R1,[R1, #+0]
   \   0000019C   0x0489             LSLS     R1,R1,#+18
   \   0000019E   0xD409             BMI.N    ??SD_ReadBlock_16
   \   000001A0   0xF89A 0x1004      LDRB     R1,[R10, #+4]
   \   000001A4   0x2900             CMP      R1,#+0
   \   000001A6   0xD105             BNE.N    ??SD_ReadBlock_16
   \   000001A8   0xF99A 0x1003      LDRSB    R1,[R10, #+3]
   \   000001AC   0x2900             CMP      R1,#+0
   \   000001AE   0xD101             BNE.N    ??SD_ReadBlock_16
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD1EF             BNE.N    ??SD_ReadBlock_15
    762          		if(timeout==0)return SD_DATA_TIMEOUT;//超时
   \                     ??SD_ReadBlock_16: (+1)
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xD101             BNE.N    ??SD_ReadBlock_17
   \   000001B8   0x2004             MOVS     R0,#+4
   \   000001BA   0xE006             B.N      ??SD_ReadBlock_3
    763          		if(TransferError!=SD_OK)errorstatus=TransferError;  
   \                     ??SD_ReadBlock_17: (+1)
   \   000001BC   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xD001             BEQ.N    ??SD_ReadBlock_4
   \   000001C4   0xF99A 0xB003      LDRSB    R11,[R10, #+3]
    764              }   
    765           	return errorstatus; 
   \                     ??SD_ReadBlock_4: (+1)
   \   000001C8   0x4658             MOV      R0,R11
   \                     ??SD_ReadBlock_3: (+1)
   \   000001CA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    766          }
    767          //SD卡读取多个块 
    768          //buf:读数据缓存区
    769          //addr:读取地址
    770          //blksize:块大小
    771          //nblks:要读取的块数
    772          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
    773          SD_Error SD_ReadMultiBlocks(u8 *buf,uint64_t addr,u16 blksize,u32 nblks)
    774          {
   \                     SD_ReadMultiBlocks: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    775            	SD_Error errorstatus=SD_OK;
    776          	u8 power;
    777             	u32 count=0,*tempbuff=(u32*)buf;//转换为u32指针
   \   0000000A   0x4607             MOV      R7,R0
    778          	u32 timeout=0;  
    779              SDIO->DCTRL=0x0;		//数据控制寄存器清零(关DMA)   
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable24  ;; 0x40018014
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8C8 0x0018      STR      R0,[R8, #+24]
    780          	if(CardType==SDIO_HIGH_CAPACITY_SD_CARD)//大容量卡
   \   00000016   0x.... 0x....      LDR.W    R9,??DataTable13_3
   \   0000001A   0x9E0C             LDR      R6,[SP, #+48]
   \   0000001C   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD104             BNE.N    ??SD_ReadMultiBlocks_0
    781          	{
    782          		blksize=512;
   \   00000024   0xF44F 0x7600      MOV      R6,#+512
    783          		addr>>=9;
   \   00000028   0x0A64             LSRS     R4,R4,#+9
   \   0000002A   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
    784          	}  
    785             	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,0,0,0);	//清除DPSM状态机配置
   \                     ??SD_ReadMultiBlocks_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R10,??DataTable24_1  ;; 0x5f5e100
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x461A             MOV      R2,R3
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x4650             MOV      R0,R10
   \   0000003A   0x.... 0x....      BL       SDIO_Send_Data_Cfg
    786          	if(SDIO->RESP1&SD_CARD_LOCKED)return SD_LOCK_UNLOCK_FAILED;//卡锁了
   \   0000003E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000042   0x0180             LSLS     R0,R0,#+6
   \   00000044   0xD501             BPL.N    ??SD_ReadMultiBlocks_1
   \   00000046   0x200E             MOVS     R0,#+14
   \   00000048   0xE0DF             B.N      ??SD_ReadMultiBlocks_2
    787          	if((blksize>0)&&(blksize<=2048)&&((blksize&(blksize-1))==0))
   \                     ??SD_ReadMultiBlocks_1: (+1)
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD020             BEQ.N    ??SD_ReadMultiBlocks_3
   \   0000004E   0xF5B6 0x6F00      CMP      R6,#+2048
   \   00000052   0xDC1D             BGT.N    ??SD_ReadMultiBlocks_3
   \   00000054   0x1E71             SUBS     R1,R6,#+1
   \   00000056   0x4630             MOV      R0,R6
   \   00000058   0x4208             TST      R0,R1
   \   0000005A   0xD119             BNE.N    ??SD_ReadMultiBlocks_3
    788          	{
    789          		power=convert_from_bytes_to_power_of_two(blksize);	    
   \   0000005C   0x.... 0x....      BL       convert_from_bytes_to_power_of_two
   \   00000060   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000064   0x4632             MOV      R2,R6
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x2010             MOVS     R0,#+16
    790          		SDIO_Send_Cmd(SD_CMD_SET_BLOCKLEN,1,blksize);	//发送CMD16+设置数据长度为blksize,短响应 	   
   \   0000006A   0x.... 0x....      BL       SDIO_Send_Cmd
    791          		errorstatus=CmdResp1Error(SD_CMD_SET_BLOCKLEN);	//等待R1响应   
   \   0000006E   0x2010             MOVS     R0,#+16
   \   00000070   0x.... 0x....      BL       CmdResp1Error
   \   00000074   0x4683             MOV      R11,R0
    792          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误	 
   \   00000076   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000007A   0xF040 0x80C5      BNE.W    ??SD_ReadMultiBlocks_4
   \   0000007E   0x980D             LDR      R0,[SP, #+52]
    793          	}else return SD_INVALID_PARAMETER;	  
    794          	if(nblks>1)											//多块读  
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xF0C0 0x80C1      BCC.W    ??SD_ReadMultiBlocks_4
    795          	{									    
    796           	  	if(nblks*blksize>SD_MAX_DATA_LENGTH)return SD_INVALID_PARAMETER;//判断是否超过最大接收长度
   \   00000086   0x4370             MULS     R0,R6,R0
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   0000008E   0xD301             BCC.N    ??SD_ReadMultiBlocks_5
   \                     ??SD_ReadMultiBlocks_3: (+1)
   \   00000090   0x2026             MOVS     R0,#+38
   \   00000092   0xE0BA             B.N      ??SD_ReadMultiBlocks_2
    797          		SDIO_Send_Data_Cfg(SD_DATATIMEOUT,nblks*blksize,power,1);//nblks*blksize,512块大小,卡到控制器	  
   \                     ??SD_ReadMultiBlocks_5: (+1)
   \   00000094   0x2301             MOVS     R3,#+1
   \   00000096   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x4650             MOV      R0,R10
   \   0000009E   0x.... 0x....      BL       SDIO_Send_Data_Cfg
    798          	  	SDIO_Send_Cmd(SD_CMD_READ_MULT_BLOCK,1,addr);	//发送CMD18+从addr地址出读取数据,短响应 	   
   \   000000A2   0x4622             MOV      R2,R4
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0x2012             MOVS     R0,#+18
   \   000000A8   0x.... 0x....      BL       SDIO_Send_Cmd
    799          		errorstatus=CmdResp1Error(SD_CMD_READ_MULT_BLOCK);//等待R1响应   
   \   000000AC   0x2012             MOVS     R0,#+18
   \   000000AE   0x.... 0x....      BL       CmdResp1Error
   \   000000B2   0x4683             MOV      R11,R0
    800          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误	  
   \   000000B4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000B8   0xF040 0x80A6      BNE.W    ??SD_ReadMultiBlocks_4
    801          		if(DeviceMode==SD_POLLING_MODE)
   \   000000BC   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD028             BEQ.N    ??SD_ReadMultiBlocks_6
    802          		{
    803          			while(!(SDIO->STA&((1<<5)|(1<<1)|(1<<3)|(1<<8)|(1<<9))))//无上溢/CRC/超时/完成(标志)/起始位错误
    804          			{
    805          					if(SDIO->STA&(1<<15))						//接收区半满,表示至少存了8个字
    806          					{
    807          						for(count=0;count<8;count++)			//循环读取数据
    808          						{
    809          							*(tempbuff+count)=SDIO->FIFO;	 
    810          						}
    811          						tempbuff+=8;
    812          					}
    813          			} 
    814          			if(SDIO->STA&(1<<3))		//数据超时错误
    815          			{										   
    816          		 		SDIO->ICR|=1<<3; 		//清错误标志
    817          				return SD_DATA_TIMEOUT;
    818          		 	}else if(SDIO->STA&(1<<1))	//数据块CRC错误
    819          			{
    820          		 		SDIO->ICR|=1<<1; 		//清错误标志
    821          				return SD_DATA_CRC_FAIL;		   
    822          			}else if(SDIO->STA&(1<<5)) 	//接收fifo上溢错误
    823          			{
    824          		 		SDIO->ICR|=1<<5; 		//清错误标志
    825          				return SD_RX_OVERRUN;		 
    826          			}else if(SDIO->STA&(1<<9)) 	//接收起始位错误
    827          			{
    828          		 		SDIO->ICR|=1<<9; 		//清错误标志
    829          				return SD_START_BIT_ERR;		 
    830          			}   
    831          			while(SDIO->STA&(1<<21))	//FIFO里面,还存在可用数据
    832          			{
    833          				*tempbuff=SDIO->FIFO;	//循环读取数据
    834          				tempbuff++;
    835          			}
    836          	 		if(SDIO->STA&(1<<8))		//接收结束
    837          			{
    838          				if((SDIO_STD_CAPACITY_SD_CARD_V1_1==CardType)||(SDIO_STD_CAPACITY_SD_CARD_V2_0==CardType)||(SDIO_HIGH_CAPACITY_SD_CARD==CardType))
    839          				{
    840          					SDIO_Send_Cmd(SD_CMD_STOP_TRANSMISSION,1,0);		//发送CMD12+结束传输 	   
    841          					errorstatus=CmdResp1Error(SD_CMD_STOP_TRANSMISSION);//等待R1响应   
    842          					if(errorstatus!=SD_OK)return errorstatus;	 
    843          				}
    844           			}
    845          	 		SDIO->ICR=0X5FF;	 		//清除所有标记 
    846           		}else if(DeviceMode==SD_DMA_MODE)
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xF040 0x809F      BNE.W    ??SD_ReadMultiBlocks_4
    847          		{
    848          	   		TransferError=SD_OK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF889 0x0003      STRB     R0,[R9, #+3]
    849          			StopCondition=1;			//多块读,需要发送停止传输指令 
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xF889 0x0002      STRB     R0,[R9, #+2]
    850          			TransferEnd=0;				//传输结束标置位，在中断服务置1
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF889 0x0004      STRB     R0,[R9, #+4]
    851          			SDIO->MASK|=(1<<1)|(1<<3)|(1<<8)|(1<<5)|(1<<9);	//配置需要的中断 
   \   000000DC   0xF8D8 0x0028      LDR      R0,[R8, #+40]
   \   000000E0   0xF240 0x312A      MOVW     R1,#+810
   \   000000E4   0x4308             ORRS     R0,R1,R0
   \   000000E6   0xF8C8 0x0028      STR      R0,[R8, #+40]
    852          		 	SDIO->DCTRL|=1<<3;		 						//SDIO DMA使能 
   \   000000EA   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   000000EE   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000000F2   0xF8C8 0x0018      STR      R0,[R8, #+24]
    853          	 	    SD_DMA_Config((u32*)buf,nblks*blksize,0);
   \   000000F6   0x2200             MOVS     R2,#+0
   \   000000F8   0x9900             LDR      R1,[SP, #+0]
   \   000000FA   0x9802             LDR      R0,[SP, #+8]
   \   000000FC   0x.... 0x....      BL       SD_DMA_Config
    854          			timeout=SDIO_DATATIMEOUT;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x1ffff
   \   00000104   0xE067             B.N      ??SD_ReadMultiBlocks_7
   \                     ??SD_ReadMultiBlocks_8: (+1)
   \   00000106   0xF8D8 0x106C      LDR      R1,[R8, #+108]
   \   0000010A   0xF847 0x1020      STR      R1,[R7, R0, LSL #+2]
   \   0000010E   0x1C40             ADDS     R0,R0,#+1
   \                     ??SD_ReadMultiBlocks_9: (+1)
   \   00000110   0x2808             CMP      R0,#+8
   \   00000112   0xD3F8             BCC.N    ??SD_ReadMultiBlocks_8
   \   00000114   0x3720             ADDS     R7,R7,#+32
   \                     ??SD_ReadMultiBlocks_6: (+1)
   \   00000116   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   0000011A   0xF240 0x312A      MOVW     R1,#+810
   \   0000011E   0x4208             TST      R0,R1
   \   00000120   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   00000124   0xD103             BNE.N    ??SD_ReadMultiBlocks_10
   \   00000126   0x0400             LSLS     R0,R0,#+16
   \   00000128   0xD5F5             BPL.N    ??SD_ReadMultiBlocks_6
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xE7F0             B.N      ??SD_ReadMultiBlocks_9
   \                     ??SD_ReadMultiBlocks_10: (+1)
   \   0000012E   0x0700             LSLS     R0,R0,#+28
   \   00000130   0xD507             BPL.N    ??SD_ReadMultiBlocks_11
   \   00000132   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \   00000136   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000013A   0xF8C8 0x0024      STR      R0,[R8, #+36]
   \   0000013E   0x2004             MOVS     R0,#+4
   \   00000140   0xE063             B.N      ??SD_ReadMultiBlocks_2
   \                     ??SD_ReadMultiBlocks_11: (+1)
   \   00000142   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   00000146   0x0780             LSLS     R0,R0,#+30
   \   00000148   0xD507             BPL.N    ??SD_ReadMultiBlocks_12
   \   0000014A   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \   0000014E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000152   0xF8C8 0x0024      STR      R0,[R8, #+36]
   \   00000156   0x2002             MOVS     R0,#+2
   \   00000158   0xE057             B.N      ??SD_ReadMultiBlocks_2
   \                     ??SD_ReadMultiBlocks_12: (+1)
   \   0000015A   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   0000015E   0x0680             LSLS     R0,R0,#+26
   \   00000160   0xD507             BPL.N    ??SD_ReadMultiBlocks_13
   \   00000162   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \   00000166   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000016A   0xF8C8 0x0024      STR      R0,[R8, #+36]
   \   0000016E   0x2006             MOVS     R0,#+6
   \   00000170   0xE04B             B.N      ??SD_ReadMultiBlocks_2
   \                     ??SD_ReadMultiBlocks_13: (+1)
   \   00000172   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   00000176   0x0580             LSLS     R0,R0,#+22
   \   00000178   0xD50B             BPL.N    ??SD_ReadMultiBlocks_14
   \   0000017A   0xF8D8 0x0024      LDR      R0,[R8, #+36]
   \   0000017E   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000182   0xF8C8 0x0024      STR      R0,[R8, #+36]
   \   00000186   0x2007             MOVS     R0,#+7
   \   00000188   0xE03F             B.N      ??SD_ReadMultiBlocks_2
   \                     ??SD_ReadMultiBlocks_15: (+1)
   \   0000018A   0xF8D8 0x006C      LDR      R0,[R8, #+108]
   \   0000018E   0xF847 0x0B04      STR      R0,[R7], #+4
   \                     ??SD_ReadMultiBlocks_14: (+1)
   \   00000192   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   00000196   0x0280             LSLS     R0,R0,#+10
   \   00000198   0xD4F7             BMI.N    ??SD_ReadMultiBlocks_15
   \   0000019A   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   0000019E   0x05C0             LSLS     R0,R0,#+23
   \   000001A0   0xD513             BPL.N    ??SD_ReadMultiBlocks_16
   \   000001A2   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD003             BEQ.N    ??SD_ReadMultiBlocks_17
   \   000001AA   0x2801             CMP      R0,#+1
   \   000001AC   0xD001             BEQ.N    ??SD_ReadMultiBlocks_17
   \   000001AE   0x2802             CMP      R0,#+2
   \   000001B0   0xD10B             BNE.N    ??SD_ReadMultiBlocks_16
   \                     ??SD_ReadMultiBlocks_17: (+1)
   \   000001B2   0x2200             MOVS     R2,#+0
   \   000001B4   0x2101             MOVS     R1,#+1
   \   000001B6   0x200C             MOVS     R0,#+12
   \   000001B8   0x.... 0x....      BL       SDIO_Send_Cmd
   \   000001BC   0x200C             MOVS     R0,#+12
   \   000001BE   0x.... 0x....      BL       CmdResp1Error
   \   000001C2   0x4683             MOV      R11,R0
   \   000001C4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001C8   0xD11E             BNE.N    ??SD_ReadMultiBlocks_4
   \                     ??SD_ReadMultiBlocks_16: (+1)
   \   000001CA   0xF240 0x50FF      MOVW     R0,#+1535
   \   000001CE   0xF8C8 0x0024      STR      R0,[R8, #+36]
   \   000001D2   0xE019             B.N      ??SD_ReadMultiBlocks_4
    855          	 		while(((DMA2->ISR&0X2000)==RESET)&&timeout)timeout--;//等待传输完成 
   \                     ??SD_ReadMultiBlocks_18: (+1)
   \   000001D4   0x1E40             SUBS     R0,R0,#+1
   \                     ??SD_ReadMultiBlocks_7: (+1)
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x40020400
   \   000001DA   0x6809             LDR      R1,[R1, #+0]
   \   000001DC   0x0489             LSLS     R1,R1,#+18
   \   000001DE   0xD401             BMI.N    ??SD_ReadMultiBlocks_19
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD1F7             BNE.N    ??SD_ReadMultiBlocks_18
    856          			if(timeout==0)return SD_DATA_TIMEOUT;//超时
   \                     ??SD_ReadMultiBlocks_19: (+1)
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD101             BNE.N    ??SD_ReadMultiBlocks_20
   \   000001E8   0x2004             MOVS     R0,#+4
   \   000001EA   0xE00E             B.N      ??SD_ReadMultiBlocks_2
    857          			while((TransferEnd==0)&&(TransferError==SD_OK)); 
   \                     ??SD_ReadMultiBlocks_20: (+1)
   \   000001EC   0xF899 0x0004      LDRB     R0,[R9, #+4]
   \   000001F0   0x2800             CMP      R0,#+0
   \   000001F2   0xD103             BNE.N    ??SD_ReadMultiBlocks_21
   \   000001F4   0xF999 0x0003      LDRSB    R0,[R9, #+3]
   \   000001F8   0x2800             CMP      R0,#+0
   \   000001FA   0xD0F7             BEQ.N    ??SD_ReadMultiBlocks_20
    858          			if(TransferError!=SD_OK)errorstatus=TransferError;  	 
   \                     ??SD_ReadMultiBlocks_21: (+1)
   \   000001FC   0xF999 0x0003      LDRSB    R0,[R9, #+3]
   \   00000200   0x2800             CMP      R0,#+0
   \   00000202   0xD001             BEQ.N    ??SD_ReadMultiBlocks_4
   \   00000204   0xF999 0xB003      LDRSB    R11,[R9, #+3]
    859          		}		 
    860            	}
    861          	return errorstatus;
   \                     ??SD_ReadMultiBlocks_4: (+1)
   \   00000208   0x4658             MOV      R0,R11
   \                     ??SD_ReadMultiBlocks_2: (+1)
   \   0000020A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    862          }			    																  
    863          //SD卡写1个块 
    864          //buf:数据缓存区
    865          //addr:写地址
    866          //blksize:块大小	  
    867          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
    868          SD_Error SD_WriteBlock(u8 *buf,uint64_t addr,  u16 blksize)
    869          {
   \                     SD_WriteBlock: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    870          	SD_Error errorstatus = SD_OK;
    871          	u8  power=0,cardstate=0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    872          	u32 timeout=0,bytestransferred=0;
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0x9E0C             LDR      R6,[SP, #+48]
    873          	u32 cardstatus=0,count=0,restwords=0;
    874          	u32	tlen=blksize;						//总长度(字节)
   \   00000014   0x9601             STR      R6,[SP, #+4]
    875          	u32*tempbuff=(u32*)buf;								 
   \   00000016   0xF8DD 0x8008      LDR      R8,[SP, #+8]
    876           	if(buf==NULL)return SD_INVALID_PARAMETER;//参数错误   
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD046             BEQ.N    ??SD_WriteBlock_0
    877            	SDIO->DCTRL=0x0;							//数据控制寄存器清零(关DMA)   
   \   00000020   0x.... 0x....      LDR.W    R9,??DataTable24  ;; 0x40018014
   \   00000024   0x4638             MOV      R0,R7
   \   00000026   0xF8C9 0x0018      STR      R0,[R9, #+24]
   \   0000002A   0x4603             MOV      R3,R0
   \   0000002C   0x4602             MOV      R2,R0
   \   0000002E   0x4601             MOV      R1,R0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x5f5e100
    878            	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,0,0,0);	//清除DPSM状态机配置
   \   00000034   0x.... 0x....      BL       SDIO_Send_Data_Cfg
    879          	if(SDIO->RESP1&SD_CARD_LOCKED)return SD_LOCK_UNLOCK_FAILED;//卡锁了
   \   00000038   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000003C   0x0180             LSLS     R0,R0,#+6
   \   0000003E   0xD501             BPL.N    ??SD_WriteBlock_1
   \   00000040   0x200E             MOVS     R0,#+14
   \   00000042   0xE124             B.N      ??SD_WriteBlock_2
    880           	if(CardType==SDIO_HIGH_CAPACITY_SD_CARD)	//大容量卡
   \                     ??SD_WriteBlock_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R10,??DataTable14_1
   \   00000048   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD104             BNE.N    ??SD_WriteBlock_3
    881          	{
    882          		blksize=512;
   \   00000050   0xF44F 0x7600      MOV      R6,#+512
    883          		addr>>=9;
   \   00000054   0x0A64             LSRS     R4,R4,#+9
   \   00000056   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
    884          	}    
    885          	if((blksize>0)&&(blksize<=2048)&&((blksize&(blksize-1))==0))
   \                     ??SD_WriteBlock_3: (+1)
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD027             BEQ.N    ??SD_WriteBlock_0
   \   0000005E   0xF5B6 0x6F00      CMP      R6,#+2048
   \   00000062   0xDC24             BGT.N    ??SD_WriteBlock_0
   \   00000064   0x1E71             SUBS     R1,R6,#+1
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x4208             TST      R0,R1
   \   0000006A   0xD120             BNE.N    ??SD_WriteBlock_0
    886          	{
    887          		power=convert_from_bytes_to_power_of_two(blksize);	    
   \   0000006C   0x.... 0x....      BL       convert_from_bytes_to_power_of_two
   \   00000070   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000074   0x4632             MOV      R2,R6
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x2010             MOVS     R0,#+16
    888          		SDIO_Send_Cmd(SD_CMD_SET_BLOCKLEN,1,blksize);	//发送CMD16+设置数据长度为blksize,短响应 	   
   \   0000007A   0x.... 0x....      BL       SDIO_Send_Cmd
    889          		errorstatus=CmdResp1Error(SD_CMD_SET_BLOCKLEN);	//等待R1响应   
   \   0000007E   0x2010             MOVS     R0,#+16
   \   00000080   0x.... 0x....      BL       CmdResp1Error
    890          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误	 
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xF040 0x8102      BNE.W    ??SD_WriteBlock_2
    891          	}else return SD_INVALID_PARAMETER;	 
    892             	SDIO_Send_Cmd(SD_CMD_SEND_STATUS,1,(u32)RCA<<16);	//发送CMD13,查询卡的状态,短响应 	   
   \   0000008A   0xF8DA 0x0028      LDR      R0,[R10, #+40]
   \   0000008E   0x0402             LSLS     R2,R0,#+16
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x200D             MOVS     R0,#+13
   \   00000094   0x.... 0x....      BL       SDIO_Send_Cmd
    893          	errorstatus=CmdResp1Error(SD_CMD_SEND_STATUS);		//等待R1响应   		   
   \   00000098   0x200D             MOVS     R0,#+13
   \   0000009A   0x.... 0x....      BL       CmdResp1Error
    894          	if(errorstatus!=SD_OK)return errorstatus;
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xF040 0x80F5      BNE.W    ??SD_WriteBlock_2
    895          	cardstatus=SDIO->RESP1;													  
   \   000000A4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
    896          	timeout=SD_DATATIMEOUT;
   \   000000A8   0x.... 0x....      LDR.W    R11,??DataTable24_1  ;; 0x5f5e100
   \   000000AC   0xE012             B.N      ??SD_WriteBlock_4
   \                     ??SD_WriteBlock_0: (+1)
   \   000000AE   0x2026             MOVS     R0,#+38
   \   000000B0   0xE0ED             B.N      ??SD_WriteBlock_2
    897             	while(((cardstatus&0x00000100)==0)&&(timeout>0)) 	//检查READY_FOR_DATA位是否置位
    898          	{
    899          		timeout--;
   \                     ??SD_WriteBlock_5: (+1)
   \   000000B2   0xF1AB 0x0B01      SUB      R11,R11,#+1
    900          	   	SDIO_Send_Cmd(SD_CMD_SEND_STATUS,1,(u32)RCA<<16);//发送CMD13,查询卡的状态,短响应 	   
   \   000000B6   0xF8DA 0x0028      LDR      R0,[R10, #+40]
   \   000000BA   0x0402             LSLS     R2,R0,#+16
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0x200D             MOVS     R0,#+13
   \   000000C0   0x.... 0x....      BL       SDIO_Send_Cmd
    901          		errorstatus=CmdResp1Error(SD_CMD_SEND_STATUS);	//等待R1响应   		   
   \   000000C4   0x200D             MOVS     R0,#+13
   \   000000C6   0x.... 0x....      BL       CmdResp1Error
    902          		if(errorstatus!=SD_OK)return errorstatus;				    
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xF040 0x80DF      BNE.W    ??SD_WriteBlock_2
    903          		cardstatus=SDIO->RESP1;													  
   \   000000D0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
    904          	}
   \                     ??SD_WriteBlock_4: (+1)
   \   000000D4   0x05C0             LSLS     R0,R0,#+23
   \   000000D6   0xD402             BMI.N    ??SD_WriteBlock_6
   \   000000D8   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000DC   0xD1E9             BNE.N    ??SD_WriteBlock_5
    905          	if(timeout==0)return SD_ERROR;
   \                     ??SD_WriteBlock_6: (+1)
   \   000000DE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000E2   0xD101             BNE.N    ??SD_WriteBlock_7
   \   000000E4   0x2029             MOVS     R0,#+41
   \   000000E6   0xE0D2             B.N      ??SD_WriteBlock_2
    906             	SDIO_Send_Cmd(SD_CMD_WRITE_SINGLE_BLOCK,1,addr);	//发送CMD24,写单块指令,短响应 	   
   \                     ??SD_WriteBlock_7: (+1)
   \   000000E8   0x4622             MOV      R2,R4
   \   000000EA   0x2101             MOVS     R1,#+1
   \   000000EC   0x2018             MOVS     R0,#+24
   \   000000EE   0x.... 0x....      BL       SDIO_Send_Cmd
    907          	errorstatus=CmdResp1Error(SD_CMD_WRITE_SINGLE_BLOCK);//等待R1响应   		   
   \   000000F2   0x2018             MOVS     R0,#+24
   \   000000F4   0x.... 0x....      BL       CmdResp1Error
    908          	if(errorstatus!=SD_OK)return errorstatus;   	  
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xF040 0x80C8      BNE.W    ??SD_WriteBlock_2
    909          	StopCondition=0;									//单块写,不需要发送停止传输指令 
   \   000000FE   0x4638             MOV      R0,R7
   \   00000100   0xF88A 0x0002      STRB     R0,[R10, #+2]
    910           	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,blksize,power,0);	//blksize, 控制器到卡	  
   \   00000104   0x4603             MOV      R3,R0
   \   00000106   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   0000010A   0x4631             MOV      R1,R6
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x5f5e100
   \   00000110   0x.... 0x....      BL       SDIO_Send_Data_Cfg
    911          	if (DeviceMode == SD_POLLING_MODE)
   \   00000114   0xF89A 0x0001      LDRB     R0,[R10, #+1]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD028             BEQ.N    ??SD_WriteBlock_8
    912          	{
    913          		while(!(SDIO->STA&((1<<10)|(1<<4)|(1<<1)|(1<<3)|(1<<9))))//数据块发送成功/下溢/CRC/超时/起始位错误
    914          		{
    915          			if(SDIO->STA&(1<<14))							//发送区半空,表示至少存了8个字
    916          			{
    917          				if((tlen-bytestransferred)<SD_HALFFIFOBYTES)//不够32字节了
    918          				{
    919          					restwords=((tlen-bytestransferred)%4==0)?((tlen-bytestransferred)/4):((tlen-bytestransferred)/4+1);
    920          					
    921          					for(count=0;count<restwords;count++,tempbuff++,bytestransferred+=4)
    922          					{
    923          						SDIO->FIFO=*tempbuff;
    924          					}
    925          				}else
    926          				{
    927          					for(count=0;count<8;count++)
    928          					{
    929          						SDIO->FIFO=*(tempbuff+count);
    930          					}
    931          					tempbuff+=8;
    932          					bytestransferred+=32;
    933          				}
    934          
    935          			}
    936          		} 
    937          		if(SDIO->STA&(1<<3))		//数据超时错误
    938          		{										   
    939          	 		SDIO->ICR|=1<<3; 		//清错误标志
    940          			return SD_DATA_TIMEOUT;
    941          	 	}else if(SDIO->STA&(1<<1))	//数据块CRC错误
    942          		{
    943          	 		SDIO->ICR|=1<<1; 		//清错误标志
    944          			return SD_DATA_CRC_FAIL;		   
    945          		}else if(SDIO->STA&(1<<4)) 	//接收fifo下溢错误
    946          		{
    947          	 		SDIO->ICR|=1<<4; 		//清错误标志
    948          			return SD_TX_UNDERRUN;		 
    949          		}else if(SDIO->STA&(1<<9)) 	//接收起始位错误
    950          		{
    951          	 		SDIO->ICR|=1<<9; 		//清错误标志
    952          			return SD_START_BIT_ERR;		 
    953          		}   
    954          		SDIO->ICR=0X5FF;	 		//清除所有标记	  
    955          	}else if(DeviceMode==SD_DMA_MODE)
   \   0000011C   0x2801             CMP      R0,#+1
   \   0000011E   0xD177             BNE.N    ??SD_WriteBlock_9
    956          	{
    957             		TransferError=SD_OK;
   \   00000120   0x4638             MOV      R0,R7
   \   00000122   0xF88A 0x0003      STRB     R0,[R10, #+3]
    958          		StopCondition=0;			//单块写,不需要发送停止传输指令 
   \   00000126   0xF88A 0x0002      STRB     R0,[R10, #+2]
    959          		TransferEnd=0;				//传输结束标置位，在中断服务置1
   \   0000012A   0xF88A 0x0004      STRB     R0,[R10, #+4]
    960          		SDIO->MASK|=(1<<1)|(1<<3)|(1<<8)|(1<<4)|(1<<9);	//配置产生数据接收完成中断
   \   0000012E   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   00000132   0xF240 0x311A      MOVW     R1,#+794
   \   00000136   0x4308             ORRS     R0,R1,R0
   \   00000138   0xF8C9 0x0028      STR      R0,[R9, #+40]
    961          		SD_DMA_Config((u32*)buf,blksize,1);				//SDIO DMA配置
   \   0000013C   0x2201             MOVS     R2,#+1
   \   0000013E   0x4631             MOV      R1,R6
   \   00000140   0x9802             LDR      R0,[SP, #+8]
   \   00000142   0x.... 0x....      BL       SD_DMA_Config
    962           	 	SDIO->DCTRL|=1<<3;								//SDIO DMA使能. 
   \   00000146   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   0000014A   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000014E   0xF8C9 0x0018      STR      R0,[R9, #+24]
    963          		timeout=SDIO_DATATIMEOUT;
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x1ffff
   \   00000156   0x4683             MOV      R11,R0
   \   00000158   0xE064             B.N      ??SD_WriteBlock_10
   \                     ??SD_WriteBlock_11: (+1)
   \   0000015A   0xF858 0x1020      LDR      R1,[R8, R0, LSL #+2]
   \   0000015E   0xF8C9 0x106C      STR      R1,[R9, #+108]
   \   00000162   0x1C40             ADDS     R0,R0,#+1
   \                     ??SD_WriteBlock_12: (+1)
   \   00000164   0x2808             CMP      R0,#+8
   \   00000166   0xD3F8             BCC.N    ??SD_WriteBlock_11
   \   00000168   0xF108 0x0820      ADD      R8,R8,#+32
   \   0000016C   0x3720             ADDS     R7,R7,#+32
   \                     ??SD_WriteBlock_8: (+1)
   \   0000016E   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   00000172   0xF240 0x611A      MOVW     R1,#+1562
   \   00000176   0x4208             TST      R0,R1
   \   00000178   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   0000017C   0xD116             BNE.N    ??SD_WriteBlock_13
   \   0000017E   0x0440             LSLS     R0,R0,#+17
   \   00000180   0xD5F5             BPL.N    ??SD_WriteBlock_8
   \   00000182   0x9801             LDR      R0,[SP, #+4]
   \   00000184   0x1BC0             SUBS     R0,R0,R7
   \   00000186   0x2820             CMP      R0,#+32
   \   00000188   0xD20E             BCS.N    ??SD_WriteBlock_14
   \   0000018A   0x0881             LSRS     R1,R0,#+2
   \   0000018C   0xF010 0x0F03      TST      R0,#0x3
   \   00000190   0xD000             BEQ.N    ??SD_WriteBlock_15
   \   00000192   0x1C49             ADDS     R1,R1,#+1
   \                     ??SD_WriteBlock_15: (+1)
   \   00000194   0x2000             MOVS     R0,#+0
   \                     ??SD_WriteBlock_16: (+1)
   \   00000196   0x4288             CMP      R0,R1
   \   00000198   0xD2E9             BCS.N    ??SD_WriteBlock_8
   \   0000019A   0xF858 0x2B04      LDR      R2,[R8], #+4
   \   0000019E   0xF8C9 0x206C      STR      R2,[R9, #+108]
   \   000001A2   0x1C40             ADDS     R0,R0,#+1
   \   000001A4   0x1D3F             ADDS     R7,R7,#+4
   \   000001A6   0xE7F6             B.N      ??SD_WriteBlock_16
   \                     ??SD_WriteBlock_14: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0xE7DB             B.N      ??SD_WriteBlock_12
   \                     ??SD_WriteBlock_13: (+1)
   \   000001AC   0x0700             LSLS     R0,R0,#+28
   \   000001AE   0xD507             BPL.N    ??SD_WriteBlock_17
   \   000001B0   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001B4   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000001B8   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000001BC   0x2004             MOVS     R0,#+4
   \   000001BE   0xE066             B.N      ??SD_WriteBlock_2
   \                     ??SD_WriteBlock_17: (+1)
   \   000001C0   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000001C4   0x0780             LSLS     R0,R0,#+30
   \   000001C6   0xD507             BPL.N    ??SD_WriteBlock_18
   \   000001C8   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001CC   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001D0   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000001D4   0x2002             MOVS     R0,#+2
   \   000001D6   0xE05A             B.N      ??SD_WriteBlock_2
   \                     ??SD_WriteBlock_18: (+1)
   \   000001D8   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000001DC   0x06C0             LSLS     R0,R0,#+27
   \   000001DE   0xD507             BPL.N    ??SD_WriteBlock_19
   \   000001E0   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001E4   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000001E8   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000001EC   0x2005             MOVS     R0,#+5
   \   000001EE   0xE04E             B.N      ??SD_WriteBlock_2
   \                     ??SD_WriteBlock_19: (+1)
   \   000001F0   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000001F4   0x0580             LSLS     R0,R0,#+22
   \   000001F6   0xD507             BPL.N    ??SD_WriteBlock_20
   \   000001F8   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001FC   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000200   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   00000204   0x2007             MOVS     R0,#+7
   \   00000206   0xE042             B.N      ??SD_WriteBlock_2
   \                     ??SD_WriteBlock_20: (+1)
   \   00000208   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000020C   0xF8C9 0x0024      STR      R0,[R9, #+36]
    964           		while(((DMA2->ISR&0X2000)==RESET)&&timeout)timeout--;//等待传输完成 
    965          		if(timeout==0)
    966          		{
    967            			SD_Init();	 					//重新初始化SD卡,可以解决写入死机的问题
    968          			return SD_DATA_TIMEOUT;			//超时	 
    969           		}
    970          		timeout=SDIO_DATATIMEOUT;
    971          		while((TransferEnd==0)&&(TransferError==SD_OK)&&timeout)timeout--;
    972           		if(timeout==0)return SD_DATA_TIMEOUT;			//超时	 
    973            		if(TransferError!=SD_OK)return TransferError;
    974           	}  
    975           	SDIO->ICR=0X5FF;	 		//清除所有标记
   \                     ??SD_WriteBlock_9: (+1)
   \   00000210   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000214   0xF8C9 0x0024      STR      R0,[R9, #+36]
    976           	errorstatus=IsCardProgramming(&cardstate);
   \   00000218   0xA800             ADD      R0,SP,#+0
   \   0000021A   0x.... 0x....      BL       IsCardProgramming
   \   0000021E   0xE02E             B.N      ??SD_WriteBlock_21
   \                     ??SD_WriteBlock_22: (+1)
   \   00000220   0xF1AB 0x0B01      SUB      R11,R11,#+1
   \                     ??SD_WriteBlock_10: (+1)
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable27  ;; 0x40020400
   \   00000228   0x6809             LDR      R1,[R1, #+0]
   \   0000022A   0x0489             LSLS     R1,R1,#+18
   \   0000022C   0xD402             BMI.N    ??SD_WriteBlock_23
   \   0000022E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000232   0xD1F5             BNE.N    ??SD_WriteBlock_22
   \                     ??SD_WriteBlock_23: (+1)
   \   00000234   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000238   0xD103             BNE.N    ??SD_WriteBlock_24
   \   0000023A   0x.... 0x....      BL       SD_Init
   \   0000023E   0x2004             MOVS     R0,#+4
   \   00000240   0xE025             B.N      ??SD_WriteBlock_2
   \                     ??SD_WriteBlock_24: (+1)
   \   00000242   0x4683             MOV      R11,R0
   \   00000244   0xE001             B.N      ??SD_WriteBlock_25
   \                     ??SD_WriteBlock_26: (+1)
   \   00000246   0xF1AB 0x0B01      SUB      R11,R11,#+1
   \                     ??SD_WriteBlock_25: (+1)
   \   0000024A   0xF89A 0x0004      LDRB     R0,[R10, #+4]
   \   0000024E   0x2800             CMP      R0,#+0
   \   00000250   0xD106             BNE.N    ??SD_WriteBlock_27
   \   00000252   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   00000256   0x2800             CMP      R0,#+0
   \   00000258   0xD102             BNE.N    ??SD_WriteBlock_27
   \   0000025A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000025E   0xD1F2             BNE.N    ??SD_WriteBlock_26
   \                     ??SD_WriteBlock_27: (+1)
   \   00000260   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000264   0xD101             BNE.N    ??SD_WriteBlock_28
   \   00000266   0x2004             MOVS     R0,#+4
   \   00000268   0xE011             B.N      ??SD_WriteBlock_2
   \                     ??SD_WriteBlock_28: (+1)
   \   0000026A   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   0000026E   0x2800             CMP      R0,#+0
   \   00000270   0xD0CE             BEQ.N    ??SD_WriteBlock_9
   \   00000272   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   00000276   0xE00A             B.N      ??SD_WriteBlock_2
    977           	while((errorstatus==SD_OK)&&((cardstate==SD_CARD_PROGRAMMING)||(cardstate==SD_CARD_RECEIVING)))
    978          	{
    979          		errorstatus=IsCardProgramming(&cardstate);
   \                     ??SD_WriteBlock_29: (+1)
   \   00000278   0xA800             ADD      R0,SP,#+0
   \   0000027A   0x.... 0x....      BL       IsCardProgramming
    980          	}   
   \                     ??SD_WriteBlock_21: (+1)
   \   0000027E   0x2800             CMP      R0,#+0
   \   00000280   0xD105             BNE.N    ??SD_WriteBlock_2
   \   00000282   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000286   0x2907             CMP      R1,#+7
   \   00000288   0xD0F6             BEQ.N    ??SD_WriteBlock_29
   \   0000028A   0x2906             CMP      R1,#+6
   \   0000028C   0xD0F4             BEQ.N    ??SD_WriteBlock_29
    981          	return errorstatus;
   \                     ??SD_WriteBlock_2: (+1)
   \   0000028E   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    982          }
    983          //SD卡写多个块 
    984          //buf:数据缓存区
    985          //addr:写地址
    986          //blksize:块大小
    987          //nblks:要写入的块数
    988          //返回值:错误状态												   

   \                                 In section .text, align 2, keep-with-next
    989          SD_Error SD_WriteMultiBlocks(u8 *buf,uint64_t addr,u16 blksize,u32 nblks)
    990          {
   \                     SD_WriteMultiBlocks: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    991          	SD_Error errorstatus = SD_OK;
    992          	u8  power = 0, cardstate = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    993          	u32 timeout=0,bytestransferred=0;
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0x9E0C             LDR      R6,[SP, #+48]
   \   00000014   0xF8DD 0xB034      LDR      R11,[SP, #+52]
    994          	u32 count = 0, restwords = 0;
    995          	u32 tlen=nblks*blksize;				//总长度(字节)
   \   00000018   0xFB06 0xF00B      MUL      R0,R6,R11
   \   0000001C   0x9001             STR      R0,[SP, #+4]
    996          	u32 *tempbuff = (u32*)buf;  
   \   0000001E   0xF8DD 0x8008      LDR      R8,[SP, #+8]
    997            	if(buf==NULL)return SD_INVALID_PARAMETER; //参数错误  
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD03D             BEQ.N    ??SD_WriteMultiBlocks_0
    998            	SDIO->DCTRL=0x0;							//数据控制寄存器清零(关DMA)   
   \   00000028   0x.... 0x....      LDR.W    R9,??DataTable24  ;; 0x40018014
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0xF8C9 0x0018      STR      R0,[R9, #+24]
   \   00000032   0x4603             MOV      R3,R0
   \   00000034   0x4602             MOV      R2,R0
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x5f5e100
    999            	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,0,0,0);	//清除DPSM状态机配置
   \   0000003C   0x.... 0x....      BL       SDIO_Send_Data_Cfg
   1000          	if(SDIO->RESP1&SD_CARD_LOCKED)return SD_LOCK_UNLOCK_FAILED;//卡锁了
   \   00000040   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000044   0x0180             LSLS     R0,R0,#+6
   \   00000046   0xD501             BPL.N    ??SD_WriteMultiBlocks_1
   \   00000048   0x200E             MOVS     R0,#+14
   \   0000004A   0xE130             B.N      ??SD_WriteMultiBlocks_2
   1001           	if(CardType==SDIO_HIGH_CAPACITY_SD_CARD)//大容量卡
   \                     ??SD_WriteMultiBlocks_1: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R10,??DataTable28
   \   00000050   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD104             BNE.N    ??SD_WriteMultiBlocks_3
   1002          	{
   1003          		blksize=512;
   \   00000058   0xF44F 0x7600      MOV      R6,#+512
   1004          		addr>>=9;
   \   0000005C   0x0A64             LSRS     R4,R4,#+9
   \   0000005E   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1005          	}    
   1006          	if((blksize>0)&&(blksize<=2048)&&((blksize&(blksize-1))==0))
   \                     ??SD_WriteMultiBlocks_3: (+1)
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD01E             BEQ.N    ??SD_WriteMultiBlocks_0
   \   00000066   0xF5B6 0x6F00      CMP      R6,#+2048
   \   0000006A   0xDC1B             BGT.N    ??SD_WriteMultiBlocks_0
   \   0000006C   0x1E71             SUBS     R1,R6,#+1
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD117             BNE.N    ??SD_WriteMultiBlocks_0
   1007          	{
   1008          		power=convert_from_bytes_to_power_of_two(blksize);	    
   \   00000074   0x.... 0x....      BL       convert_from_bytes_to_power_of_two
   \   00000078   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1009          		SDIO_Send_Cmd(SD_CMD_SET_BLOCKLEN,1,blksize);	//发送CMD16+设置数据长度为blksize,短响应 	   
   \   0000007C   0x4632             MOV      R2,R6
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x2010             MOVS     R0,#+16
   \   00000082   0x.... 0x....      BL       SDIO_Send_Cmd
   1010          		errorstatus=CmdResp1Error(SD_CMD_SET_BLOCKLEN);	//等待R1响应   
   \   00000086   0x2010             MOVS     R0,#+16
   \   00000088   0x.... 0x....      BL       CmdResp1Error
   1011          		if(errorstatus!=SD_OK)return errorstatus;   	//响应错误	 
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xF040 0x810E      BNE.W    ??SD_WriteMultiBlocks_2
   1012          	}else return SD_INVALID_PARAMETER;	 
   1013          	if(nblks>1)
   \   00000092   0xF1BB 0x0F02      CMP      R11,#+2
   \   00000096   0xF0C0 0x80D1      BCC.W    ??SD_WriteMultiBlocks_4
   1014          	{					  
   1015          		if(nblks*blksize>SD_MAX_DATA_LENGTH)return SD_INVALID_PARAMETER;   
   \   0000009A   0xFB06 0xF60B      MUL      R6,R6,R11
   \   0000009E   0xF1B6 0x7F00      CMP      R6,#+33554432
   \   000000A2   0xD301             BCC.N    ??SD_WriteMultiBlocks_5
   \                     ??SD_WriteMultiBlocks_0: (+1)
   \   000000A4   0x2026             MOVS     R0,#+38
   \   000000A6   0xE102             B.N      ??SD_WriteMultiBlocks_2
   1016               	if((SDIO_STD_CAPACITY_SD_CARD_V1_1==CardType)||(SDIO_STD_CAPACITY_SD_CARD_V2_0==CardType)||(SDIO_HIGH_CAPACITY_SD_CARD==CardType))
   \                     ??SD_WriteMultiBlocks_5: (+1)
   \   000000A8   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD003             BEQ.N    ??SD_WriteMultiBlocks_6
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD001             BEQ.N    ??SD_WriteMultiBlocks_6
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xD117             BNE.N    ??SD_WriteMultiBlocks_7
   1017              	{
   1018          			//提高性能
   1019          	 	   	SDIO_Send_Cmd(SD_CMD_APP_CMD,1,(u32)RCA<<16);	//发送ACMD55,短响应 	   
   \                     ??SD_WriteMultiBlocks_6: (+1)
   \   000000B8   0xF8DA 0x0028      LDR      R0,[R10, #+40]
   \   000000BC   0x0402             LSLS     R2,R0,#+16
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x2037             MOVS     R0,#+55
   \   000000C2   0x.... 0x....      BL       SDIO_Send_Cmd
   1020          			errorstatus=CmdResp1Error(SD_CMD_APP_CMD);		//等待R1响应   		   
   \   000000C6   0x2037             MOVS     R0,#+55
   \   000000C8   0x.... 0x....      BL       CmdResp1Error
   1021          			if(errorstatus!=SD_OK)return errorstatus;				    
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xF040 0x80EE      BNE.W    ??SD_WriteMultiBlocks_2
   1022          	 	   	SDIO_Send_Cmd(SD_CMD_SET_BLOCK_COUNT,1,nblks);	//发送CMD23,设置块数量,短响应 	   
   \   000000D2   0x465A             MOV      R2,R11
   \   000000D4   0x2101             MOVS     R1,#+1
   \   000000D6   0x2017             MOVS     R0,#+23
   \   000000D8   0x.... 0x....      BL       SDIO_Send_Cmd
   1023          			errorstatus=CmdResp1Error(SD_CMD_SET_BLOCK_COUNT);//等待R1响应   		   
   \   000000DC   0x2017             MOVS     R0,#+23
   \   000000DE   0x.... 0x....      BL       CmdResp1Error
   1024          			if(errorstatus!=SD_OK)return errorstatus;				    
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xF040 0x80E3      BNE.W    ??SD_WriteMultiBlocks_2
   1025          		} 
   1026          		SDIO_Send_Cmd(SD_CMD_WRITE_MULT_BLOCK,1,addr);		//发送CMD25,多块写指令,短响应 	   
   \                     ??SD_WriteMultiBlocks_7: (+1)
   \   000000E8   0x4622             MOV      R2,R4
   \   000000EA   0x2101             MOVS     R1,#+1
   \   000000EC   0x2019             MOVS     R0,#+25
   \   000000EE   0x.... 0x....      BL       SDIO_Send_Cmd
   1027          		errorstatus=CmdResp1Error(SD_CMD_WRITE_MULT_BLOCK);	//等待R1响应   		   
   \   000000F2   0x2019             MOVS     R0,#+25
   \   000000F4   0x.... 0x....      BL       CmdResp1Error
   1028          		if(errorstatus!=SD_OK)return errorstatus;
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xF040 0x80D8      BNE.W    ??SD_WriteMultiBlocks_2
   1029           	 	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,nblks*blksize,power,0);//blksize, 控制器到卡	
   \   000000FE   0x463B             MOV      R3,R7
   \   00000100   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000104   0x4631             MOV      R1,R6
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x5f5e100
   \   0000010A   0x.... 0x....      BL       SDIO_Send_Data_Cfg
   1030          	    if(DeviceMode==SD_POLLING_MODE)
   \   0000010E   0xF89A 0x0001      LDRB     R0,[R10, #+1]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD02B             BEQ.N    ??SD_WriteMultiBlocks_8
   1031          	    {
   1032          			while(!(SDIO->STA&((1<<4)|(1<<1)|(1<<8)|(1<<3)|(1<<9))))//下溢/CRC/数据结束/超时/起始位错误
   1033          			{
   1034          				if(SDIO->STA&(1<<14))							//发送区半空,表示至少存了8字(32字节)
   1035          				{	  
   1036          					if((tlen-bytestransferred)<SD_HALFFIFOBYTES)//不够32字节了
   1037          					{
   1038          						restwords=((tlen-bytestransferred)%4==0)?((tlen-bytestransferred)/4):((tlen-bytestransferred)/4+1);
   1039          						for(count=0;count<restwords;count++,tempbuff++,bytestransferred+=4)
   1040          						{
   1041          							SDIO->FIFO=*tempbuff;
   1042          						}
   1043          					}else 										//发送区半空,可以发送至少8字(32字节)数据
   1044          					{
   1045          						for(count=0;count<SD_HALFFIFO;count++)
   1046          						{
   1047          							SDIO->FIFO=*(tempbuff+count);
   1048          						}
   1049          						tempbuff+=SD_HALFFIFO;
   1050          						bytestransferred+=SD_HALFFIFOBYTES;
   1051          					} 
   1052          				}
   1053          			} 
   1054          			if(SDIO->STA&(1<<3))		//数据超时错误
   1055          			{										   
   1056          		 		SDIO->ICR|=1<<3; 		//清错误标志
   1057          				return SD_DATA_TIMEOUT;
   1058          		 	}else if(SDIO->STA&(1<<1))	//数据块CRC错误
   1059          			{
   1060          		 		SDIO->ICR|=1<<1; 		//清错误标志
   1061          				return SD_DATA_CRC_FAIL;		   
   1062          			}else if(SDIO->STA&(1<<4)) 	//接收fifo下溢错误
   1063          			{
   1064          		 		SDIO->ICR|=1<<4; 		//清错误标志
   1065          				return SD_TX_UNDERRUN;		 
   1066          			}else if(SDIO->STA&(1<<9)) 	//接收起始位错误
   1067          			{
   1068          		 		SDIO->ICR|=1<<9; 		//清错误标志
   1069          				return SD_START_BIT_ERR;		 
   1070          			}   										   
   1071          			if(SDIO->STA&(1<<8))		//接收结束
   1072          			{															 
   1073          				if((SDIO_STD_CAPACITY_SD_CARD_V1_1==CardType)||(SDIO_STD_CAPACITY_SD_CARD_V2_0==CardType)||(SDIO_HIGH_CAPACITY_SD_CARD==CardType))
   1074          				{
   1075          					SDIO_Send_Cmd(SD_CMD_STOP_TRANSMISSION,1,0);		//发送CMD12+结束传输 	   
   1076          					errorstatus=CmdResp1Error(SD_CMD_STOP_TRANSMISSION);//等待R1响应   
   1077          					if(errorstatus!=SD_OK)return errorstatus;	 
   1078          				}
   1079          			}
   1080          	 		SDIO->ICR=0X5FF;	 		//清除所有标记 
   1081          	    }else if(DeviceMode==SD_DMA_MODE)
   \   00000116   0x2801             CMP      R0,#+1
   \   00000118   0xF040 0x8090      BNE.W    ??SD_WriteMultiBlocks_4
   1082          		{
   1083          	   		TransferError=SD_OK;
   \   0000011C   0x4638             MOV      R0,R7
   \   0000011E   0xF88A 0x0003      STRB     R0,[R10, #+3]
   1084          			StopCondition=1;			//多块写,需要发送停止传输指令 
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xF88A 0x0002      STRB     R0,[R10, #+2]
   1085          			TransferEnd=0;				//传输结束标置位，在中断服务置1
   \   00000128   0x4638             MOV      R0,R7
   \   0000012A   0xF88A 0x0004      STRB     R0,[R10, #+4]
   1086          			SDIO->MASK|=(1<<1)|(1<<3)|(1<<8)|(1<<4)|(1<<9);	//配置产生数据接收完成中断
   \   0000012E   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   00000132   0xF240 0x311A      MOVW     R1,#+794
   \   00000136   0x4308             ORRS     R0,R1,R0
   \   00000138   0xF8C9 0x0028      STR      R0,[R9, #+40]
   1087          			SD_DMA_Config((u32*)buf,nblks*blksize,1);		//SDIO DMA配置
   \   0000013C   0x2201             MOVS     R2,#+1
   \   0000013E   0x4631             MOV      R1,R6
   \   00000140   0x9802             LDR      R0,[SP, #+8]
   \   00000142   0x.... 0x....      BL       SD_DMA_Config
   1088          	 	 	SDIO->DCTRL|=1<<3;								//SDIO DMA使能. 
   \   00000146   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   0000014A   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000014E   0xF8C9 0x0018      STR      R0,[R9, #+24]
   1089          			timeout=SDIO_DATATIMEOUT;
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x1ffff
   \   00000156   0x4601             MOV      R1,R0
   \   00000158   0xE079             B.N      ??SD_WriteMultiBlocks_9
   \                     ??SD_WriteMultiBlocks_10: (+1)
   \   0000015A   0xF858 0x1020      LDR      R1,[R8, R0, LSL #+2]
   \   0000015E   0xF8C9 0x106C      STR      R1,[R9, #+108]
   \   00000162   0x1C40             ADDS     R0,R0,#+1
   \                     ??SD_WriteMultiBlocks_11: (+1)
   \   00000164   0x2808             CMP      R0,#+8
   \   00000166   0xD3F8             BCC.N    ??SD_WriteMultiBlocks_10
   \   00000168   0xF108 0x0820      ADD      R8,R8,#+32
   \   0000016C   0x3720             ADDS     R7,R7,#+32
   \                     ??SD_WriteMultiBlocks_8: (+1)
   \   0000016E   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   00000172   0xF240 0x311A      MOVW     R1,#+794
   \   00000176   0x4208             TST      R0,R1
   \   00000178   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   0000017C   0xD116             BNE.N    ??SD_WriteMultiBlocks_12
   \   0000017E   0x0440             LSLS     R0,R0,#+17
   \   00000180   0xD5F5             BPL.N    ??SD_WriteMultiBlocks_8
   \   00000182   0x9801             LDR      R0,[SP, #+4]
   \   00000184   0x1BC0             SUBS     R0,R0,R7
   \   00000186   0x2820             CMP      R0,#+32
   \   00000188   0xD20E             BCS.N    ??SD_WriteMultiBlocks_13
   \   0000018A   0x0881             LSRS     R1,R0,#+2
   \   0000018C   0xF010 0x0F03      TST      R0,#0x3
   \   00000190   0xD000             BEQ.N    ??SD_WriteMultiBlocks_14
   \   00000192   0x1C49             ADDS     R1,R1,#+1
   \                     ??SD_WriteMultiBlocks_14: (+1)
   \   00000194   0x2000             MOVS     R0,#+0
   \                     ??SD_WriteMultiBlocks_15: (+1)
   \   00000196   0x4288             CMP      R0,R1
   \   00000198   0xD2E9             BCS.N    ??SD_WriteMultiBlocks_8
   \   0000019A   0xF858 0x2B04      LDR      R2,[R8], #+4
   \   0000019E   0xF8C9 0x206C      STR      R2,[R9, #+108]
   \   000001A2   0x1C40             ADDS     R0,R0,#+1
   \   000001A4   0x1D3F             ADDS     R7,R7,#+4
   \   000001A6   0xE7F6             B.N      ??SD_WriteMultiBlocks_15
   \                     ??SD_WriteMultiBlocks_13: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0xE7DB             B.N      ??SD_WriteMultiBlocks_11
   \                     ??SD_WriteMultiBlocks_12: (+1)
   \   000001AC   0x0700             LSLS     R0,R0,#+28
   \   000001AE   0xD507             BPL.N    ??SD_WriteMultiBlocks_16
   \   000001B0   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001B4   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000001B8   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000001BC   0x2004             MOVS     R0,#+4
   \   000001BE   0xE076             B.N      ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_16: (+1)
   \   000001C0   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000001C4   0x0780             LSLS     R0,R0,#+30
   \   000001C6   0xD507             BPL.N    ??SD_WriteMultiBlocks_17
   \   000001C8   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001CC   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001D0   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000001D4   0x2002             MOVS     R0,#+2
   \   000001D6   0xE06A             B.N      ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_17: (+1)
   \   000001D8   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000001DC   0x06C0             LSLS     R0,R0,#+27
   \   000001DE   0xD507             BPL.N    ??SD_WriteMultiBlocks_18
   \   000001E0   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001E4   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000001E8   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000001EC   0x2005             MOVS     R0,#+5
   \   000001EE   0xE05E             B.N      ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_18: (+1)
   \   000001F0   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000001F4   0x0580             LSLS     R0,R0,#+22
   \   000001F6   0xD507             BPL.N    ??SD_WriteMultiBlocks_19
   \   000001F8   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \   000001FC   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000200   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   00000204   0x2007             MOVS     R0,#+7
   \   00000206   0xE052             B.N      ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_19: (+1)
   \   00000208   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   0000020C   0x05C0             LSLS     R0,R0,#+23
   \   0000020E   0xD511             BPL.N    ??SD_WriteMultiBlocks_20
   \   00000210   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD003             BEQ.N    ??SD_WriteMultiBlocks_21
   \   00000218   0x2801             CMP      R0,#+1
   \   0000021A   0xD001             BEQ.N    ??SD_WriteMultiBlocks_21
   \   0000021C   0x2802             CMP      R0,#+2
   \   0000021E   0xD109             BNE.N    ??SD_WriteMultiBlocks_20
   \                     ??SD_WriteMultiBlocks_21: (+1)
   \   00000220   0x2200             MOVS     R2,#+0
   \   00000222   0x2101             MOVS     R1,#+1
   \   00000224   0x200C             MOVS     R0,#+12
   \   00000226   0x.... 0x....      BL       SDIO_Send_Cmd
   \   0000022A   0x200C             MOVS     R0,#+12
   \   0000022C   0x.... 0x....      BL       CmdResp1Error
   \   00000230   0x2800             CMP      R0,#+0
   \   00000232   0xD13C             BNE.N    ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_20: (+1)
   \   00000234   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000238   0xF8C9 0x0024      STR      R0,[R9, #+36]
   1090          	 		while(((DMA2->ISR&0X2000)==RESET)&&timeout)timeout--;//等待传输完成 
   1091          			if(timeout==0)	 								//超时
   1092          			{									  
   1093            				SD_Init();	 					//重新初始化SD卡,可以解决写入死机的问题
   1094          	 			return SD_DATA_TIMEOUT;			//超时	 
   1095          	 		}
   1096          			timeout=SDIO_DATATIMEOUT;
   1097          			while((TransferEnd==0)&&(TransferError==SD_OK)&&timeout)timeout--;
   1098          	 		if(timeout==0)return SD_DATA_TIMEOUT;			//超时	 
   1099          	 		if(TransferError!=SD_OK)return TransferError;	 
   1100          		}
   1101            	}
   1102           	SDIO->ICR=0X5FF;	 		//清除所有标记
   \                     ??SD_WriteMultiBlocks_4: (+1)
   \   0000023C   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000240   0xF8C9 0x0024      STR      R0,[R9, #+36]
   1103           	errorstatus=IsCardProgramming(&cardstate);
   \   00000244   0xA800             ADD      R0,SP,#+0
   \   00000246   0x.... 0x....      BL       IsCardProgramming
   \   0000024A   0xE028             B.N      ??SD_WriteMultiBlocks_22
   \                     ??SD_WriteMultiBlocks_23: (+1)
   \   0000024C   0x1E49             SUBS     R1,R1,#+1
   \                     ??SD_WriteMultiBlocks_9: (+1)
   \   0000024E   0x.... 0x....      LDR.W    R2,??DataTable27  ;; 0x40020400
   \   00000252   0x6812             LDR      R2,[R2, #+0]
   \   00000254   0x0492             LSLS     R2,R2,#+18
   \   00000256   0xD401             BMI.N    ??SD_WriteMultiBlocks_24
   \   00000258   0x2900             CMP      R1,#+0
   \   0000025A   0xD1F7             BNE.N    ??SD_WriteMultiBlocks_23
   \                     ??SD_WriteMultiBlocks_24: (+1)
   \   0000025C   0x2900             CMP      R1,#+0
   \   0000025E   0xD103             BNE.N    ??SD_WriteMultiBlocks_25
   \   00000260   0x.... 0x....      BL       SD_Init
   \   00000264   0x2004             MOVS     R0,#+4
   \   00000266   0xE022             B.N      ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_25: (+1)
   \   00000268   0x4601             MOV      R1,R0
   \   0000026A   0xE000             B.N      ??SD_WriteMultiBlocks_26
   \                     ??SD_WriteMultiBlocks_27: (+1)
   \   0000026C   0x1E49             SUBS     R1,R1,#+1
   \                     ??SD_WriteMultiBlocks_26: (+1)
   \   0000026E   0xF89A 0x0004      LDRB     R0,[R10, #+4]
   \   00000272   0x2800             CMP      R0,#+0
   \   00000274   0xD105             BNE.N    ??SD_WriteMultiBlocks_28
   \   00000276   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   0000027A   0x2800             CMP      R0,#+0
   \   0000027C   0xD101             BNE.N    ??SD_WriteMultiBlocks_28
   \   0000027E   0x2900             CMP      R1,#+0
   \   00000280   0xD1F4             BNE.N    ??SD_WriteMultiBlocks_27
   \                     ??SD_WriteMultiBlocks_28: (+1)
   \   00000282   0x2900             CMP      R1,#+0
   \   00000284   0xD101             BNE.N    ??SD_WriteMultiBlocks_29
   \   00000286   0x2004             MOVS     R0,#+4
   \   00000288   0xE011             B.N      ??SD_WriteMultiBlocks_2
   \                     ??SD_WriteMultiBlocks_29: (+1)
   \   0000028A   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   0000028E   0x2800             CMP      R0,#+0
   \   00000290   0xD0D4             BEQ.N    ??SD_WriteMultiBlocks_4
   \   00000292   0xF99A 0x0003      LDRSB    R0,[R10, #+3]
   \   00000296   0xE00A             B.N      ??SD_WriteMultiBlocks_2
   1104           	while((errorstatus==SD_OK)&&((cardstate==SD_CARD_PROGRAMMING)||(cardstate==SD_CARD_RECEIVING)))
   1105          	{
   1106          		errorstatus=IsCardProgramming(&cardstate);
   \                     ??SD_WriteMultiBlocks_30: (+1)
   \   00000298   0xA800             ADD      R0,SP,#+0
   \   0000029A   0x.... 0x....      BL       IsCardProgramming
   1107          	}   
   \                     ??SD_WriteMultiBlocks_22: (+1)
   \   0000029E   0x2800             CMP      R0,#+0
   \   000002A0   0xD105             BNE.N    ??SD_WriteMultiBlocks_2
   \   000002A2   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000002A6   0x2907             CMP      R1,#+7
   \   000002A8   0xD0F6             BEQ.N    ??SD_WriteMultiBlocks_30
   \   000002AA   0x2906             CMP      R1,#+6
   \   000002AC   0xD0F4             BEQ.N    ??SD_WriteMultiBlocks_30
   1108          	return errorstatus;	   
   \                     ??SD_WriteMultiBlocks_2: (+1)
   \   000002AE   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1109          }
   1110          //SDIO中断服务函数
   1111          extern volatile uint8_t sd_pause_flag;

   \                                 In section .text, align 2, keep-with-next
   1112          void SDIO_IRQHandler(void) 
   \                     SDIO_IRQHandler: (+1)
   \   00000000   0xBF00             Nop      
   1113          {	
   1114                  //if(sd_pause_flag == 1)
   1115                    SD_ProcessIRQSrc();//处理所有SDIO相关中断
   \   00000002                      REQUIRE SD_ProcessIRQSrc
   \   00000002                      ;; // Fall through to label SD_ProcessIRQSrc
   1116          }	 																    
   1117          //SDIO中断处理函数
   1118          //处理SDIO传输过程中的各种中断事务
   1119          //返回值:错误代码

   \                                 In section .text, align 2, keep-with-next
   1120          SD_Error SD_ProcessIRQSrc(void)
   1121          {
   \                     SD_ProcessIRQSrc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1122          	if(SDIO->STA&(1<<8))//接收完成中断
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable28_1  ;; 0x40018034
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD51E             BPL.N    ??SD_ProcessIRQSrc_0
   1123          	{	 
   1124          		if (StopCondition==1)
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable28
   \   00000010   0x78A8             LDRB     R0,[R5, #+2]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD109             BNE.N    ??SD_ProcessIRQSrc_1
   1125          		{
   1126          			SDIO_Send_Cmd(SD_CMD_STOP_TRANSMISSION,1,0);		//发送CMD12,结束传输 	   
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x200C             MOVS     R0,#+12
   \   0000001C   0x.... 0x....      BL       SDIO_Send_Cmd
   1127          			TransferError=CmdResp1Error(SD_CMD_STOP_TRANSMISSION);
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0x.... 0x....      BL       CmdResp1Error
   \   00000026   0x70E8             STRB     R0,[R5, #+3]
   \   00000028   0xE001             B.N      ??SD_ProcessIRQSrc_2
   1128          		}else TransferError = SD_OK;	
   \                     ??SD_ProcessIRQSrc_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x70E8             STRB     R0,[R5, #+3]
   1129           		SDIO->ICR|=1<<8;//清除完成中断标记
   \                     ??SD_ProcessIRQSrc_2: (+1)
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000034   0x6060             STR      R0,[R4, #+4]
   1130          		SDIO->MASK&=~((1<<1)|(1<<3)|(1<<8)|(1<<14)|(1<<15)|(1<<4)|(1<<5)|(1<<9));//关闭相关中断
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0xffff3cc5
   \   0000003C   0x4008             ANDS     R0,R1,R0
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   1131           		TransferEnd = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7128             STRB     R0,[R5, #+4]
   1132          		return(TransferError);
   \   00000044   0xF995 0x0003      LDRSB    R0,[R5, #+3]
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}
   1133          	}
   1134           	if(SDIO->STA&(1<<1))//数据CRC错误
   \                     ??SD_ProcessIRQSrc_0: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x0780             LSLS     R0,R0,#+30
   \   0000004E   0xD50D             BPL.N    ??SD_ProcessIRQSrc_3
   1135          	{
   1136          		SDIO->ICR|=1<<1;//清除中断标记
   \   00000050   0x6860             LDR      R0,[R4, #+4]
   \   00000052   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000056   0x6060             STR      R0,[R4, #+4]
   1137          		SDIO->MASK&=~((1<<1)|(1<<3)|(1<<8)|(1<<14)|(1<<15)|(1<<4)|(1<<5)|(1<<9));//关闭相关中断
   \   00000058   0x68A0             LDR      R0,[R4, #+8]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0xffff3cc5
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x60A0             STR      R0,[R4, #+8]
   1138          	    TransferError = SD_DATA_CRC_FAIL;
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000068   0x70C8             STRB     R0,[R1, #+3]
   1139          	    return(SD_DATA_CRC_FAIL);
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}
   1140          	}
   1141           	if(SDIO->STA&(1<<3))//数据超时错误
   \                     ??SD_ProcessIRQSrc_3: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x0700             LSLS     R0,R0,#+28
   \   00000070   0xD50D             BPL.N    ??SD_ProcessIRQSrc_4
   1142          	{
   1143          		SDIO->ICR|=1<<3;//清除中断标记
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000078   0x6060             STR      R0,[R4, #+4]
   1144          		SDIO->MASK&=~((1<<1)|(1<<3)|(1<<8)|(1<<14)|(1<<15)|(1<<4)|(1<<5)|(1<<9));//关闭相关中断
   \   0000007A   0x68A0             LDR      R0,[R4, #+8]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0xffff3cc5
   \   00000080   0x4008             ANDS     R0,R1,R0
   \   00000082   0x60A0             STR      R0,[R4, #+8]
   1145          	    TransferError = SD_DATA_TIMEOUT;
   \   00000084   0x2004             MOVS     R0,#+4
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable28
   \   0000008A   0x70C8             STRB     R0,[R1, #+3]
   1146          	    return(SD_DATA_TIMEOUT);
   \   0000008C   0xBD32             POP      {R1,R4,R5,PC}
   1147          	}
   1148            	if(SDIO->STA&(1<<5))//FIFO上溢错误
   \                     ??SD_ProcessIRQSrc_4: (+1)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x0680             LSLS     R0,R0,#+26
   \   00000092   0xD50D             BPL.N    ??SD_ProcessIRQSrc_5
   1149          	{
   1150          		SDIO->ICR|=1<<5;//清除中断标记
   \   00000094   0x6860             LDR      R0,[R4, #+4]
   \   00000096   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000009A   0x6060             STR      R0,[R4, #+4]
   1151          		SDIO->MASK&=~((1<<1)|(1<<3)|(1<<8)|(1<<14)|(1<<15)|(1<<4)|(1<<5)|(1<<9));//关闭相关中断
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0xffff3cc5
   \   000000A2   0x4008             ANDS     R0,R1,R0
   \   000000A4   0x60A0             STR      R0,[R4, #+8]
   1152          	    TransferError = SD_RX_OVERRUN;
   \   000000A6   0x2006             MOVS     R0,#+6
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000AC   0x70C8             STRB     R0,[R1, #+3]
   1153          	    return(SD_RX_OVERRUN);
   \   000000AE   0xBD32             POP      {R1,R4,R5,PC}
   1154          	}
   1155             	if(SDIO->STA&(1<<4))//FIFO下溢错误
   \                     ??SD_ProcessIRQSrc_5: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x06C0             LSLS     R0,R0,#+27
   \   000000B4   0xD50D             BPL.N    ??SD_ProcessIRQSrc_6
   1156          	{
   1157          		SDIO->ICR|=1<<4;//清除中断标记
   \   000000B6   0x6860             LDR      R0,[R4, #+4]
   \   000000B8   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000BC   0x6060             STR      R0,[R4, #+4]
   1158          		SDIO->MASK&=~((1<<1)|(1<<3)|(1<<8)|(1<<14)|(1<<15)|(1<<4)|(1<<5)|(1<<9));//关闭相关中断
   \   000000BE   0x68A0             LDR      R0,[R4, #+8]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0xffff3cc5
   \   000000C4   0x4008             ANDS     R0,R1,R0
   \   000000C6   0x60A0             STR      R0,[R4, #+8]
   1159          	    TransferError = SD_TX_UNDERRUN;
   \   000000C8   0x2005             MOVS     R0,#+5
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000CE   0x70C8             STRB     R0,[R1, #+3]
   1160          	    return(SD_TX_UNDERRUN);
   \   000000D0   0xBD32             POP      {R1,R4,R5,PC}
   1161          	}
   1162          	if(SDIO->STA&(1<<9))//起始位错误
   \                     ??SD_ProcessIRQSrc_6: (+1)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x0580             LSLS     R0,R0,#+22
   \   000000D6   0xD50D             BPL.N    ??SD_ProcessIRQSrc_7
   1163          	{
   1164          		SDIO->ICR|=1<<9;//清除中断标记
   \   000000D8   0x6860             LDR      R0,[R4, #+4]
   \   000000DA   0xF440 0x7000      ORR      R0,R0,#0x200
   \   000000DE   0x6060             STR      R0,[R4, #+4]
   1165          		SDIO->MASK&=~((1<<1)|(1<<3)|(1<<8)|(1<<14)|(1<<15)|(1<<4)|(1<<5)|(1<<9));//关闭相关中断
   \   000000E0   0x68A0             LDR      R0,[R4, #+8]
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable28_2  ;; 0xffff3cc5
   \   000000E6   0x4008             ANDS     R0,R1,R0
   \   000000E8   0x60A0             STR      R0,[R4, #+8]
   1166          	    TransferError = SD_START_BIT_ERR;
   \   000000EA   0x2007             MOVS     R0,#+7
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable28
   \   000000F0   0x70C8             STRB     R0,[R1, #+3]
   1167          	    return(SD_START_BIT_ERR);
   \   000000F2   0xBD32             POP      {R1,R4,R5,PC}
   1168          	}
   1169          	return(SD_OK);
   \                     ??SD_ProcessIRQSrc_7: (+1)
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1170          }
   1171            
   1172          //检查CMD0的执行状态
   1173          //返回值:sd卡错误码

   \                                 In section .text, align 2, keep-with-next
   1174          SD_Error CmdError(void)
   1175          {
   1176          	SD_Error errorstatus = SD_OK;
   1177          	u32 timeout=SDIO_CMD0TIMEOUT;	   
   \                     CmdError: (+1)
   \   00000000   0xF242 0x7010      MOVW     R0,#+10000
   1178          	while(timeout--)
   \                     ??CmdError_0: (+1)
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x1E48             SUBS     R0,R1,#+1
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??CmdError_1
   1179          	{
   1180          		if(SDIO->STA&(1<<7))break;	//命令已发送(无需响应)	 
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40018034
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xD5F6             BPL.N    ??CmdError_0
   1181          	}	    
   1182          	if(timeout==0)return SD_CMD_RSP_TIMEOUT;  
   \                     ??CmdError_1: (+1)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??CmdError_2
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0x4770             BX       LR
   1183          	SDIO->ICR=0X5FF;				//清除标记
   \                     ??CmdError_2: (+1)
   \   0000001E   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40018034
   \   00000026   0x6048             STR      R0,[R1, #+4]
   1184          	return errorstatus;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
   1185          }	 
   1186          //检查R7响应的错误状态
   1187          //返回值:sd卡错误码

   \                                 In section .text, align 2, keep-with-next
   1188          SD_Error CmdResp7Error(void)
   1189          {
   1190          	SD_Error errorstatus=SD_OK;
   1191          	u32 status;
   1192          	u32 timeout=SDIO_CMD0TIMEOUT;
   \                     CmdResp7Error: (+1)
   \   00000000   0xF242 0x7110      MOVW     R1,#+10000
   1193           	while(timeout--)
   \                     ??CmdResp7Error_0: (+1)
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x1E51             SUBS     R1,R2,#+1
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD005             BEQ.N    ??CmdResp7Error_1
   1194          	{
   1195          		status=SDIO->STA;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40018034
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   1196          		if(status&((1<<0)|(1<<2)|(1<<6)))break;//CRC错误/命令响应超时/已经收到响应(CRC校验成功)	
   \   00000012   0xF010 0x0F45      TST      R0,#0x45
   \   00000016   0xD0F5             BEQ.N    ??CmdResp7Error_0
   1197          	}
   1198           	if((timeout==0)||(status&(1<<2)))	//响应超时
   \                     ??CmdResp7Error_1: (+1)
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD001             BEQ.N    ??CmdResp7Error_2
   \   0000001C   0x0741             LSLS     R1,R0,#+29
   \   0000001E   0xD507             BPL.N    ??CmdResp7Error_3
   1199          	{																				    
   1200          		errorstatus=SD_CMD_RSP_TIMEOUT;	//当前卡不是2.0兼容卡,或者不支持设定的电压范围
   1201          		SDIO->ICR|=1<<2;				//清除命令响应超时标志
   \                     ??CmdResp7Error_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40018034
   \   00000024   0x6841             LDR      R1,[R0, #+4]
   \   00000026   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000002A   0x6041             STR      R1,[R0, #+4]
   1202          		return errorstatus;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x4770             BX       LR
   1203          	}	 
   1204          	if(status&1<<6)						//成功接收到响应
   \                     ??CmdResp7Error_3: (+1)
   \   00000030   0x0640             LSLS     R0,R0,#+25
   \   00000032   0xD505             BPL.N    ??CmdResp7Error_4
   1205          	{								   
   1206          		errorstatus=SD_OK;
   1207          		SDIO->ICR|=1<<6;				//清除响应标志
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40018034
   \   00000038   0x6841             LDR      R1,[R0, #+4]
   \   0000003A   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000003E   0x6041             STR      R1,[R0, #+4]
   1208           	}
   1209          	return errorstatus;
   \                     ??CmdResp7Error_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4770             BX       LR               ;; return
   1210          }	   
   1211          //检查R1响应的错误状态
   1212          //cmd:当前命令
   1213          //返回值:sd卡错误码

   \                                 In section .text, align 2, keep-with-next
   1214          SD_Error CmdResp1Error(u8 cmd)
   1215          {	  
   \                     CmdResp1Error: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable28_3  ;; 0x40018010
   1216             	u32 status;
   1217          	while(1)
   1218          	{
   1219          		status=SDIO->STA;
   \                     ??CmdResp1Error_0: (+1)
   \   00000004   0x6A4A             LDR      R2,[R1, #+36]
   1220          		if(status&((1<<0)|(1<<2)|(1<<6)))break;//CRC错误/命令响应超时/已经收到响应(CRC校验成功)	
   \   00000006   0xF012 0x0F45      TST      R2,#0x45
   \   0000000A   0xD0FB             BEQ.N    ??CmdResp1Error_0
   1221          	}  
   1222           	if(status&(1<<2))					//响应超时
   \   0000000C   0x0753             LSLS     R3,R2,#+29
   \   0000000E   0xD503             BPL.N    ??CmdResp1Error_1
   1223          	{																				    
   1224           		SDIO->ICR=1<<2;					//清除命令响应超时标志
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x6288             STR      R0,[R1, #+40]
   1225          		return SD_CMD_RSP_TIMEOUT;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x4770             BX       LR
   1226          	}	
   1227           	if(status&(1<<0))					//CRC错误
   \                     ??CmdResp1Error_1: (+1)
   \   00000018   0x07D2             LSLS     R2,R2,#+31
   \   0000001A   0xD502             BPL.N    ??CmdResp1Error_2
   1228          	{																				    
   1229           		SDIO->ICR=1<<0;					//清除标志
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x6288             STR      R0,[R1, #+40]
   1230          		return SD_CMD_CRC_FAIL;
   \   00000020   0x4770             BX       LR
   1231          	}		
   1232          	if(SDIO->RESPCMD!=cmd)return SD_ILLEGAL_CMD;//命令不匹配 
   \                     ??CmdResp1Error_2: (+1)
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x4282             CMP      R2,R0
   \   00000026   0xD001             BEQ.N    ??CmdResp1Error_3
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0x4770             BX       LR
   1233            	SDIO->ICR=0X5FF;	 				//清除标记
   \                     ??CmdResp1Error_3: (+1)
   \   0000002C   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000030   0x6288             STR      R0,[R1, #+40]
   1234          	return (SD_Error)(SDIO->RESP1&SD_OCR_ERRORBITS);//返回卡响应
   \   00000032   0x6848             LDR      R0,[R1, #+4]
   \   00000034   0xF000 0x0008      AND      R0,R0,#0x8
   \   00000038   0x4770             BX       LR               ;; return
   1235          }
   1236          //检查R3响应的错误状态
   1237          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
   1238          SD_Error CmdResp3Error(void)
   1239          {
   \                     CmdResp3Error: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40018034
   1240          	u32 status;						 
   1241           	while(1)
   1242          	{
   1243          		status=SDIO->STA;
   \                     ??CmdResp3Error_0: (+1)
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   1244          		if(status&((1<<0)|(1<<2)|(1<<6)))break;//CRC错误/命令响应超时/已经收到响应(CRC校验成功)	
   \   00000006   0xF011 0x0F45      TST      R1,#0x45
   \   0000000A   0xD0FB             BEQ.N    ??CmdResp3Error_0
   1245          	}
   1246           	if(status&(1<<2))					//响应超时
   \   0000000C   0x0749             LSLS     R1,R1,#+29
   \   0000000E   0xD505             BPL.N    ??CmdResp3Error_1
   1247          	{											 
   1248          		SDIO->ICR|=1<<2;				//清除命令响应超时标志
   \   00000010   0x6841             LDR      R1,[R0, #+4]
   \   00000012   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000016   0x6041             STR      R1,[R0, #+4]
   1249          		return SD_CMD_RSP_TIMEOUT;
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x4770             BX       LR
   1250          	}	 
   1251             	SDIO->ICR=0X5FF;	 				//清除标记
   \                     ??CmdResp3Error_1: (+1)
   \   0000001C   0xF240 0x51FF      MOVW     R1,#+1535
   \   00000020   0x6041             STR      R1,[R0, #+4]
   1252           	return SD_OK;								  
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
   1253          }
   1254          //检查R2响应的错误状态
   1255          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
   1256          SD_Error CmdResp2Error(void)
   1257          {
   1258          	SD_Error errorstatus=SD_OK;
   \                     CmdResp2Error: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   1259          	u32 status;
   1260          	u32 timeout=SDIO_CMD0TIMEOUT;
   \   00000002   0xF242 0x7210      MOVW     R2,#+10000
   1261           	while(timeout--)
   \                     ??CmdResp2Error_0: (+1)
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x1E5A             SUBS     R2,R3,#+1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD005             BEQ.N    ??CmdResp2Error_1
   1262          	{
   1263          		status=SDIO->STA;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40018034
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   1264          		if(status&((1<<0)|(1<<2)|(1<<6)))break;//CRC错误/命令响应超时/已经收到响应(CRC校验成功)	
   \   00000014   0xF011 0x0F45      TST      R1,#0x45
   \   00000018   0xD0F5             BEQ.N    ??CmdResp2Error_0
   1265          	}
   1266            	if((timeout==0)||(status&(1<<2)))	//响应超时
   \                     ??CmdResp2Error_1: (+1)
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD001             BEQ.N    ??CmdResp2Error_2
   \   0000001E   0x074A             LSLS     R2,R1,#+29
   \   00000020   0xD507             BPL.N    ??CmdResp2Error_3
   1267          	{																				    
   1268          		errorstatus=SD_CMD_RSP_TIMEOUT; 
   1269          		SDIO->ICR|=1<<2;				//清除命令响应超时标志
   \                     ??CmdResp2Error_2: (+1)
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable28_1  ;; 0x40018034
   \   00000026   0x6850             LDR      R0,[R2, #+4]
   \   00000028   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000002C   0x6050             STR      R0,[R2, #+4]
   1270          		return errorstatus;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x4770             BX       LR
   1271          	}	 
   1272          	if(status&1<<0)						//CRC错误
   \                     ??CmdResp2Error_3: (+1)
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable28_1  ;; 0x40018034
   \   00000036   0x07C9             LSLS     R1,R1,#+31
   \   00000038   0xD504             BPL.N    ??CmdResp2Error_4
   1273          	{								   
   1274          		errorstatus=SD_CMD_CRC_FAIL;
   \   0000003A   0x2001             MOVS     R0,#+1
   1275          		SDIO->ICR|=1<<0;				//清除响应标志
   \   0000003C   0x6851             LDR      R1,[R2, #+4]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x6051             STR      R1,[R2, #+4]
   1276           	}
   1277          	SDIO->ICR=0X5FF;	 				//清除标记
   \                     ??CmdResp2Error_4: (+1)
   \   00000044   0xF240 0x51FF      MOVW     R1,#+1535
   \   00000048   0x6051             STR      R1,[R2, #+4]
   1278           	return errorstatus;								    		 
   \   0000004A   0x4770             BX       LR               ;; return
   1279          } 
   1280          //检查R6响应的错误状态
   1281          //cmd:之前发送的命令
   1282          //prca:卡返回的RCA地址
   1283          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
   1284          SD_Error CmdResp6Error(u8 cmd,u16*prca)
   1285          {
   \                     CmdResp6Error: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable28_3  ;; 0x40018010
   1286          	SD_Error errorstatus=SD_OK;
   1287          	u32 status;					    
   1288          	u32 rspr1;
   1289           	while(1)
   1290          	{
   1291          		status=SDIO->STA;
   \                     ??CmdResp6Error_0: (+1)
   \   00000006   0x6A53             LDR      R3,[R2, #+36]
   1292          		if(status&((1<<0)|(1<<2)|(1<<6)))break;//CRC错误/命令响应超时/已经收到响应(CRC校验成功)	
   \   00000008   0xF013 0x0F45      TST      R3,#0x45
   \   0000000C   0xD0FB             BEQ.N    ??CmdResp6Error_0
   1293          	}
   1294          	if(status&(1<<2))					//响应超时
   \   0000000E   0x075C             LSLS     R4,R3,#+29
   \   00000010   0xD505             BPL.N    ??CmdResp6Error_1
   1295          	{																				    
   1296           		SDIO->ICR|=1<<2;				//清除命令响应超时标志
   \   00000012   0x6A90             LDR      R0,[R2, #+40]
   \   00000014   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000018   0x6290             STR      R0,[R2, #+40]
   1297          		return SD_CMD_RSP_TIMEOUT;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xE022             B.N      ??CmdResp6Error_2
   1298          	}	 	 
   1299          	if(status&1<<0)						//CRC错误
   \                     ??CmdResp6Error_1: (+1)
   \   0000001E   0x07DB             LSLS     R3,R3,#+31
   \   00000020   0xD505             BPL.N    ??CmdResp6Error_3
   1300          	{								   
   1301          		SDIO->ICR|=1<<0;				//清除响应标志
   \   00000022   0x6A90             LDR      R0,[R2, #+40]
   \   00000024   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000028   0x6290             STR      R0,[R2, #+40]
   1302           		return SD_CMD_CRC_FAIL;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE01A             B.N      ??CmdResp6Error_2
   1303          	}
   1304          	if(SDIO->RESPCMD!=cmd)				//判断是否响应cmd命令
   \                     ??CmdResp6Error_3: (+1)
   \   0000002E   0x6813             LDR      R3,[R2, #+0]
   \   00000030   0x4283             CMP      R3,R0
   \   00000032   0xD110             BNE.N    ??CmdResp6Error_4
   1305          	{
   1306           		return SD_ILLEGAL_CMD; 		
   1307          	}	    
   1308          	SDIO->ICR=0X5FF;	 				//清除所有标记
   \   00000034   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000038   0x6290             STR      R0,[R2, #+40]
   1309          	rspr1=SDIO->RESP1;					//得到响应 	 
   \   0000003A   0x6850             LDR      R0,[R2, #+4]
   1310          	if(SD_ALLZERO==(rspr1&(SD_R6_GENERAL_UNKNOWN_ERROR|SD_R6_ILLEGAL_CMD|SD_R6_COM_CRC_FAILED)))
   \   0000003C   0xF410 0x4F60      TST      R0,#0xE000
   \   00000040   0xD103             BNE.N    ??CmdResp6Error_5
   1311          	{
   1312          		*prca=(u16)(rspr1>>16);			//右移16位得到,rca
   \   00000042   0x0C00             LSRS     R0,R0,#+16
   \   00000044   0x8008             STRH     R0,[R1, #+0]
   1313          		return errorstatus;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE00C             B.N      ??CmdResp6Error_2
   1314          	}
   1315             	if(rspr1&SD_R6_GENERAL_UNKNOWN_ERROR)return SD_GENERAL_UNKNOWN_ERROR;
   \                     ??CmdResp6Error_5: (+1)
   \   0000004A   0x0481             LSLS     R1,R0,#+18
   \   0000004C   0xD501             BPL.N    ??CmdResp6Error_6
   \   0000004E   0x2013             MOVS     R0,#+19
   \   00000050   0xE008             B.N      ??CmdResp6Error_2
   1316             	if(rspr1&SD_R6_ILLEGAL_CMD)return SD_ILLEGAL_CMD;
   \                     ??CmdResp6Error_6: (+1)
   \   00000052   0x0441             LSLS     R1,R0,#+17
   \   00000054   0xD501             BPL.N    ??CmdResp6Error_7
   \                     ??CmdResp6Error_4: (+1)
   \   00000056   0x2010             MOVS     R0,#+16
   \   00000058   0xE004             B.N      ??CmdResp6Error_2
   1317             	if(rspr1&SD_R6_COM_CRC_FAILED)return SD_COM_CRC_FAILED;
   \                     ??CmdResp6Error_7: (+1)
   \   0000005A   0x0400             LSLS     R0,R0,#+16
   \   0000005C   0xD501             BPL.N    ??CmdResp6Error_8
   \   0000005E   0x200F             MOVS     R0,#+15
   \   00000060   0xE000             B.N      ??CmdResp6Error_2
   1318          	return errorstatus;
   \                     ??CmdResp6Error_8: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??CmdResp6Error_2: (+1)
   \   00000064   0xBC10             POP      {R4}
   \   00000066   0x4770             BX       LR               ;; return
   1319          }
   1320          
   1321          //SDIO使能宽总线模式
   1322          //enx:0,不使能;1,使能;
   1323          //返回值:错误状态

   \                                 In section .text, align 2, keep-with-next
   1324          SD_Error SDEnWideBus(u8 enx)
   1325          {
   \                     SDEnWideBus: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1326          	SD_Error errorstatus = SD_OK;
   1327           	u32 scr[2]={0,0};
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x4613             MOV      R3,R2
   \   0000000A   0xC10C             STM      R1!,{R2,R3}
   1328          	u8 arg=0X00;
   \   0000000C   0x4614             MOV      R4,R2
   1329          	if(enx)arg=0X02;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD000             BEQ.N    ??SDEnWideBus_0
   \   00000012   0x2402             MOVS     R4,#+2
   1330          	else arg=0X00;
   1331           	if(SDIO->RESP1&SD_CARD_LOCKED)return SD_LOCK_UNLOCK_FAILED;//SD卡处于LOCKED状态		    
   \                     ??SDEnWideBus_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable24  ;; 0x40018014
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0180             LSLS     R0,R0,#+6
   \   0000001A   0xD501             BPL.N    ??SDEnWideBus_1
   \   0000001C   0x200E             MOVS     R0,#+14
   \   0000001E   0xBD3E             POP      {R1-R5,PC}
   1332           	errorstatus=FindSCR(RCA,scr);						//得到SCR寄存器数据
   \                     ??SDEnWideBus_1: (+1)
   \   00000020   0x....             LDR.N    R5,??DataTable28
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x6AA8             LDR      R0,[R5, #+40]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x.... 0x....      BL       FindSCR
   1333           	if(errorstatus!=SD_OK)return errorstatus;
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD117             BNE.N    ??SDEnWideBus_2
   1334          	if((scr[1]&SD_WIDE_BUS_SUPPORT)!=SD_ALLZERO)		//支持宽总线
   \   00000030   0x9801             LDR      R0,[SP, #+4]
   \   00000032   0x0340             LSLS     R0,R0,#+13
   \   00000034   0xD513             BPL.N    ??SDEnWideBus_3
   1335          	{
   1336          	 	SDIO_Send_Cmd(SD_CMD_APP_CMD,1,(u32)RCA<<16);	//发送CMD55+RCA,短响应											  
   \   00000036   0x6AA8             LDR      R0,[R5, #+40]
   \   00000038   0x0402             LSLS     R2,R0,#+16
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2037             MOVS     R0,#+55
   \   0000003E   0x.... 0x....      BL       SDIO_Send_Cmd
   1337          	 	errorstatus=CmdResp1Error(SD_CMD_APP_CMD);
   \   00000042   0x2037             MOVS     R0,#+55
   \   00000044   0x.... 0x....      BL       CmdResp1Error
   1338          	 	if(errorstatus!=SD_OK)return errorstatus; 
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD109             BNE.N    ??SDEnWideBus_2
   1339          	 	SDIO_Send_Cmd(SD_CMD_APP_SD_SET_BUSWIDTH,1,arg);//发送ACMD6,短响应,参数:10,4位;00,1位.											  
   \   0000004C   0x4622             MOV      R2,R4
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2006             MOVS     R0,#+6
   \   00000052   0x.... 0x....      BL       SDIO_Send_Cmd
   1340          		errorstatus=CmdResp1Error(SD_CMD_APP_SD_SET_BUSWIDTH);
   1341          		return errorstatus;
   \   00000056   0x2006             MOVS     R0,#+6
   \   00000058   0x.... 0x....      BL       CmdResp1Error
   \   0000005C   0xBD3E             POP      {R1-R5,PC}
   1342          	}else return SD_REQUEST_NOT_APPLICABLE;				//不支持宽总线设置 	 
   \                     ??SDEnWideBus_3: (+1)
   \   0000005E   0x2025             MOVS     R0,#+37
   \                     ??SDEnWideBus_2: (+1)
   \   00000060   0xBD3E             POP      {R1-R5,PC}       ;; return
   1343          }												   
   1344          //检查卡是否正在执行写操作
   1345          //pstatus:当前状态.
   1346          //返回值:错误代码

   \                                 In section .text, align 2, keep-with-next
   1347          SD_Error IsCardProgramming(u8 *pstatus)
   1348          {
   \                     IsCardProgramming: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1349           	vu32 respR1 = 0, status = 0; 
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1350            	SDIO_Send_Cmd(SD_CMD_SEND_STATUS,1,(u32)RCA<<16);		//发送CMD13 	   
   \   0000000A   0x....             LDR.N    R0,??DataTable28
   \   0000000C   0x6A80             LDR      R0,[R0, #+40]
   \   0000000E   0x0402             LSLS     R2,R0,#+16
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x200D             MOVS     R0,#+13
   \   00000014   0x.... 0x....      BL       SDIO_Send_Cmd
   1351            	status=SDIO->STA;
   \   00000018   0x....             LDR.N    R0,??DataTable28_3  ;; 0x40018010
   \   0000001A   0x6A41             LDR      R1,[R0, #+36]
   \   0000001C   0x9100             STR      R1,[SP, #+0]
   \   0000001E   0xE001             B.N      ??IsCardProgramming_0
   1352          	while(!(status&((1<<0)|(1<<6)|(1<<2))))status=SDIO->STA;//等待操作完成
   \                     ??IsCardProgramming_1: (+1)
   \   00000020   0x6A41             LDR      R1,[R0, #+36]
   \   00000022   0x9100             STR      R1,[SP, #+0]
   \                     ??IsCardProgramming_0: (+1)
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0xF011 0x0F45      TST      R1,#0x45
   \   0000002A   0xD0F9             BEQ.N    ??IsCardProgramming_1
   1353             	if(status&(1<<0))			//CRC检测失败
   \   0000002C   0x9900             LDR      R1,[SP, #+0]
   \   0000002E   0x07C9             LSLS     R1,R1,#+31
   \   00000030   0xD505             BPL.N    ??IsCardProgramming_2
   1354          	{
   1355          		SDIO->ICR|=1<<0;		//清除错误标记
   \   00000032   0x6A81             LDR      R1,[R0, #+40]
   \   00000034   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000038   0x6281             STR      R1,[R0, #+40]
   1356          		return SD_CMD_CRC_FAIL;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}
   1357          	}
   1358             	if(status&(1<<2))			//命令超时 
   \                     ??IsCardProgramming_2: (+1)
   \   0000003E   0x9900             LDR      R1,[SP, #+0]
   \   00000040   0x0749             LSLS     R1,R1,#+29
   \   00000042   0xD505             BPL.N    ??IsCardProgramming_3
   1359          	{
   1360          		SDIO->ICR|=1<<2;		//清除错误标记
   \   00000044   0x6A81             LDR      R1,[R0, #+40]
   \   00000046   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004A   0x6281             STR      R1,[R0, #+40]
   1361          		return SD_CMD_RSP_TIMEOUT;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xBD16             POP      {R1,R2,R4,PC}
   1362          	}
   1363           	if(SDIO->RESPCMD!=SD_CMD_SEND_STATUS)return SD_ILLEGAL_CMD;
   \                     ??IsCardProgramming_3: (+1)
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x290D             CMP      R1,#+13
   \   00000054   0xD001             BEQ.N    ??IsCardProgramming_4
   \   00000056   0x2010             MOVS     R0,#+16
   \   00000058   0xBD16             POP      {R1,R2,R4,PC}
   1364          	SDIO->ICR=0X5FF;	 		//清除所有标记
   \                     ??IsCardProgramming_4: (+1)
   \   0000005A   0xF240 0x51FF      MOVW     R1,#+1535
   \   0000005E   0x6281             STR      R1,[R0, #+40]
   1365          	respR1=SDIO->RESP1;
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0x9001             STR      R0,[SP, #+4]
   1366          	*pstatus=(u8)((respR1>>9)&0x0000000F);
   \   00000064   0x9801             LDR      R0,[SP, #+4]
   \   00000066   0x0A40             LSRS     R0,R0,#+9
   \   00000068   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
   1367          	return SD_OK;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1368          }
   1369          //查找SD卡的SCR寄存器值
   1370          //rca:卡相对地址
   1371          //pscr:数据缓存区(存储SCR内容)
   1372          //返回值:错误状态		   

   \                                 In section .text, align 2, keep-with-next
   1373          SD_Error FindSCR(u16 rca,u32 *pscr)
   1374          { 
   \                     FindSCR: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1375          	u32 index = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1376          	SD_Error errorstatus = SD_OK;
   1377          	u32 tempscr[2]={0,0};  
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x4629             MOV      R1,R5
   \   0000000C   0x460A             MOV      R2,R1
   \   0000000E   0xC006             STM      R0!,{R1,R2}
   1378           	SDIO_Send_Cmd(SD_CMD_SET_BLOCKLEN,1,8);			//发送CMD16,短响应,设置Block Size为8字节											  
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x.... 0x....      BL       SDIO_Send_Cmd
   1379           	errorstatus=CmdResp1Error(SD_CMD_SET_BLOCKLEN);
   \   0000001A   0x2010             MOVS     R0,#+16
   \   0000001C   0x.... 0x....      BL       CmdResp1Error
   1380           	if(errorstatus!=SD_OK)return errorstatus;	    
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD16D             BNE.N    ??FindSCR_0
   1381            	SDIO_Send_Cmd(SD_CMD_APP_CMD,1,(u32)rca<<16);	//发送CMD55,短响应 									  
   \   00000024   0x0432             LSLS     R2,R6,#+16
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x2037             MOVS     R0,#+55
   \   0000002A   0x.... 0x....      BL       SDIO_Send_Cmd
   1382           	errorstatus=CmdResp1Error(SD_CMD_APP_CMD);
   \   0000002E   0x2037             MOVS     R0,#+55
   \   00000030   0x.... 0x....      BL       CmdResp1Error
   1383           	if(errorstatus!=SD_OK)return errorstatus;
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD163             BNE.N    ??FindSCR_0
   1384          	SDIO_Send_Data_Cfg(SD_DATATIMEOUT,8,3,1);		//8个字节长度,block为8字节,SD卡到SDIO.
   \   00000038   0x2301             MOVS     R3,#+1
   \   0000003A   0x2203             MOVS     R2,#+3
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0x....             LDR.N    R0,??DataTable28_4  ;; 0x5f5e100
   \   00000040   0x.... 0x....      BL       SDIO_Send_Data_Cfg
   1385             	SDIO_Send_Cmd(SD_CMD_SD_APP_SEND_SCR,1,0);		//发送ACMD51,短响应,参数为0											  
   \   00000044   0x462A             MOV      R2,R5
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2033             MOVS     R0,#+51
   \   0000004A   0x.... 0x....      BL       SDIO_Send_Cmd
   1386           	errorstatus=CmdResp1Error(SD_CMD_SD_APP_SEND_SCR);
   \   0000004E   0x2033             MOVS     R0,#+51
   \   00000050   0x.... 0x....      BL       CmdResp1Error
   1387           	if(errorstatus!=SD_OK)return errorstatus;							   
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD153             BNE.N    ??FindSCR_0
   1388           	while(!(SDIO->STA&(SDIO_FLAG_RXOVERR|SDIO_FLAG_DCRCFAIL|SDIO_FLAG_DTIMEOUT|SDIO_FLAG_DBCKEND|SDIO_FLAG_STBITERR)))
   \                     ??FindSCR_1: (+1)
   \   00000058   0x....             LDR.N    R1,??DataTable28_1  ;; 0x40018034
   \   0000005A   0x680A             LDR      R2,[R1, #+0]
   \   0000005C   0xF240 0x632A      MOVW     R3,#+1578
   \   00000060   0x421A             TST      R2,R3
   \   00000062   0xD109             BNE.N    ??FindSCR_2
   1389          	{
   1390          		if(SDIO->STA&(1<<21))//接收FIFO数据可用
   \   00000064   0x680A             LDR      R2,[R1, #+0]
   \   00000066   0x0292             LSLS     R2,R2,#+10
   \   00000068   0xD5F6             BPL.N    ??FindSCR_1
   1391          		{
   1392          			*(tempscr+index)=SDIO->FIFO;	//读取FIFO内容
   \   0000006A   0x6CCA             LDR      R2,[R1, #+76]
   \   0000006C   0xAB00             ADD      R3,SP,#+0
   \   0000006E   0xF843 0x2025      STR      R2,[R3, R5, LSL #+2]
   1393          			index++;
   \   00000072   0x1C6D             ADDS     R5,R5,#+1
   1394          			if(index>=2)break;
   \   00000074   0x2D02             CMP      R5,#+2
   \   00000076   0xD3EF             BCC.N    ??FindSCR_1
   1395          		}
   1396          	}
   1397           	if(SDIO->STA&(1<<3))		//接收数据超时
   \                     ??FindSCR_2: (+1)
   \   00000078   0x680A             LDR      R2,[R1, #+0]
   \   0000007A   0x0712             LSLS     R2,R2,#+28
   \   0000007C   0xD505             BPL.N    ??FindSCR_3
   1398          	{										 
   1399           		SDIO->ICR|=1<<3;		//清除标记
   \   0000007E   0x6848             LDR      R0,[R1, #+4]
   \   00000080   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000084   0x6048             STR      R0,[R1, #+4]
   1400          		return SD_DATA_TIMEOUT;
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0xBD76             POP      {R1,R2,R4-R6,PC}
   1401          	}
   1402          	else if(SDIO->STA&(1<<1))	//已发送/接收的数据块CRC校验错误
   \                     ??FindSCR_3: (+1)
   \   0000008A   0x680A             LDR      R2,[R1, #+0]
   \   0000008C   0x0792             LSLS     R2,R2,#+30
   \   0000008E   0xD505             BPL.N    ??FindSCR_4
   1403          	{
   1404           		SDIO->ICR|=1<<1;		//清除标记
   \   00000090   0x6848             LDR      R0,[R1, #+4]
   \   00000092   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000096   0x6048             STR      R0,[R1, #+4]
   1405          		return SD_DATA_CRC_FAIL;   
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1406          	}
   1407          	else if(SDIO->STA&(1<<5))	//接收FIFO溢出
   \                     ??FindSCR_4: (+1)
   \   0000009C   0x680A             LDR      R2,[R1, #+0]
   \   0000009E   0x0692             LSLS     R2,R2,#+26
   \   000000A0   0xD505             BPL.N    ??FindSCR_5
   1408          	{
   1409           		SDIO->ICR|=1<<5;		//清除标记
   \   000000A2   0x6848             LDR      R0,[R1, #+4]
   \   000000A4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000A8   0x6048             STR      R0,[R1, #+4]
   1410          		return SD_RX_OVERRUN;   	   
   \   000000AA   0x2006             MOVS     R0,#+6
   \   000000AC   0xBD76             POP      {R1,R2,R4-R6,PC}
   1411          	}
   1412          	else if(SDIO->STA&(1<<9))	//起始位检测错误
   \                     ??FindSCR_5: (+1)
   \   000000AE   0x680A             LDR      R2,[R1, #+0]
   \   000000B0   0x0592             LSLS     R2,R2,#+22
   \   000000B2   0xD505             BPL.N    ??FindSCR_6
   1413          	{
   1414           		SDIO->ICR|=1<<9;		//清除标记
   \   000000B4   0x6848             LDR      R0,[R1, #+4]
   \   000000B6   0xF440 0x7000      ORR      R0,R0,#0x200
   \   000000BA   0x6048             STR      R0,[R1, #+4]
   1415          		return SD_START_BIT_ERR;    
   \   000000BC   0x2007             MOVS     R0,#+7
   \   000000BE   0xBD76             POP      {R1,R2,R4-R6,PC}
   1416          	}
   1417             	SDIO->ICR=0X5FF;	 		//清除标记	 
   \                     ??FindSCR_6: (+1)
   \   000000C0   0xF240 0x52FF      MOVW     R2,#+1535
   \   000000C4   0x604A             STR      R2,[R1, #+4]
   1418          	//把数据顺序按8位为单位倒过来.   	
   1419          	*(pscr+1)=((tempscr[0]&SD_0TO7BITS)<<24)|((tempscr[0]&SD_8TO15BITS)<<8)|((tempscr[0]&SD_16TO23BITS)>>8)|((tempscr[0]&SD_24TO31BITS)>>24);
   \   000000C6   0x9900             LDR      R1,[SP, #+0]
   \   000000C8   0x460A             MOV      R2,R1
   \   000000CA   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   000000CE   0x0212             LSLS     R2,R2,#+8
   \   000000D0   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   000000D4   0x9A00             LDR      R2,[SP, #+0]
   \   000000D6   0x0A12             LSRS     R2,R2,#+8
   \   000000D8   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   000000DC   0x4311             ORRS     R1,R2,R1
   \   000000DE   0x9A00             LDR      R2,[SP, #+0]
   \   000000E0   0xEA41 0x6112      ORR      R1,R1,R2, LSR #+24
   \   000000E4   0x6061             STR      R1,[R4, #+4]
   \   000000E6   0x9901             LDR      R1,[SP, #+4]
   \   000000E8   0xF401 0x427F      AND      R2,R1,#0xFF00
   \   000000EC   0x0212             LSLS     R2,R2,#+8
   \   000000EE   0xEA42 0x6201      ORR      R2,R2,R1, LSL #+24
   \   000000F2   0x0A0B             LSRS     R3,R1,#+8
   \   000000F4   0xF403 0x437F      AND      R3,R3,#0xFF00
   \   000000F8   0x431A             ORRS     R2,R3,R2
   \   000000FA   0xEA42 0x6111      ORR      R1,R2,R1, LSR #+24
   \   000000FE   0x6021             STR      R1,[R4, #+0]
   1420          	*(pscr)=((tempscr[1]&SD_0TO7BITS)<<24)|((tempscr[1]&SD_8TO15BITS)<<8)|((tempscr[1]&SD_16TO23BITS)>>8)|((tempscr[1]&SD_24TO31BITS)>>24);
   1421           	return errorstatus;
   \                     ??FindSCR_0: (+1)
   \   00000100   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1422          }
   1423          //得到NumberOfBytes以2为底的指数.
   1424          //NumberOfBytes:字节数.
   1425          //返回值:以2为底的指数值

   \                                 In section .text, align 2, keep-with-next
   1426          u8 convert_from_bytes_to_power_of_two(u16 NumberOfBytes)
   1427          {
   1428          	u8 count=0;
   \                     convert_from_bytes_to_power_of_two: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??convert_from_bytes_to_power_of_two_0
   1429          	while(NumberOfBytes!=1)
   1430          	{
   1431          		NumberOfBytes>>=1;
   \                     ??convert_from_bytes_to_power_of_two_1: (+1)
   \   00000004   0x0840             LSRS     R0,R0,#+1
   1432          		count++;
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   1433          	}
   \                     ??convert_from_bytes_to_power_of_two_0: (+1)
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD1FB             BNE.N    ??convert_from_bytes_to_power_of_two_1
   1434          	return count;
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x4770             BX       LR               ;; return
   1435          } 	 
   1436          //配置SDIO DMA  
   1437          //mbuf:存储器地址
   1438          //bufsize:传输数据量
   1439          //dir:方向;1,存储器-->SDIO(写数据);0,SDIO-->存储器(读数据);

   \                                 In section .text, align 2, keep-with-next
   1440          void SD_DMA_Config(u32*mbuf,u32 bufsize,u8 dir)
   1441          {	
   \                     SD_DMA_Config: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1442           	DMA2->IFCR|=(0XF<<12);				//清除DMA2通道4的各种标记
   \   00000002   0x....             LDR.N    R3,??DataTable28_5  ;; 0x40020404
   \   00000004   0x681C             LDR      R4,[R3, #+0]
   \   00000006   0xF444 0x4470      ORR      R4,R4,#0xF000
   \   0000000A   0x601C             STR      R4,[R3, #+0]
   1443           	DMA2_Channel4->CCR&=~(1<<0);		//关闭DMA 通道4
   \   0000000C   0x6C1C             LDR      R4,[R3, #+64]
   \   0000000E   0x0864             LSRS     R4,R4,#+1
   \   00000010   0x0064             LSLS     R4,R4,#+1
   \   00000012   0x641C             STR      R4,[R3, #+64]
   1444            DMA2_Channel4->CCR&=~(0X7FF<<4);	//清除之前的设置,DIR,CIRC,PINC,MINC,PSIZE,MSIZE,PL,MEM2MEM
   \   00000014   0x6C1C             LDR      R4,[R3, #+64]
   \   00000016   0xF36F 0x140E      BFC      R4,#+4,#+11
   \   0000001A   0x641C             STR      R4,[R3, #+64]
   1445           	DMA2_Channel4->CCR|=dir<<4;  		//从存储器读   
   \   0000001C   0x6C1C             LDR      R4,[R3, #+64]
   \   0000001E   0xEA44 0x1202      ORR      R2,R4,R2, LSL #+4
   \   00000022   0x641A             STR      R2,[R3, #+64]
   1446          	DMA2_Channel4->CCR|=0<<5;  			//普通模式
   \   00000024   0x6C1A             LDR      R2,[R3, #+64]
   \   00000026   0x641A             STR      R2,[R3, #+64]
   1447          	DMA2_Channel4->CCR|=0<<6; 			//外设地址非增量模式
   \   00000028   0x6C1A             LDR      R2,[R3, #+64]
   \   0000002A   0x641A             STR      R2,[R3, #+64]
   1448          	DMA2_Channel4->CCR|=1<<7;  			//存储器增量模式
   \   0000002C   0x6C1A             LDR      R2,[R3, #+64]
   \   0000002E   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000032   0x641A             STR      R2,[R3, #+64]
   1449          	DMA2_Channel4->CCR|=2<<8;  			//外设数据宽度为32位
   \   00000034   0x6C1A             LDR      R2,[R3, #+64]
   \   00000036   0xF442 0x7200      ORR      R2,R2,#0x200
   \   0000003A   0x641A             STR      R2,[R3, #+64]
   1450          	DMA2_Channel4->CCR|=2<<10; 			//存储器数据宽度32位
   \   0000003C   0x6C1A             LDR      R2,[R3, #+64]
   \   0000003E   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000042   0x641A             STR      R2,[R3, #+64]
   1451          	DMA2_Channel4->CCR|=3<<12;//2<<12; 			//高优先级	  
   \   00000044   0x6C1A             LDR      R2,[R3, #+64]
   \   00000046   0xF442 0x5240      ORR      R2,R2,#0x3000
   \   0000004A   0x641A             STR      R2,[R3, #+64]
   1452            DMA2_Channel4->CNDTR=bufsize/4;   	//DMA2,传输数据量	  
   \   0000004C   0x0889             LSRS     R1,R1,#+2
   \   0000004E   0x6459             STR      R1,[R3, #+68]
   1453           	DMA2_Channel4->CPAR=(u32)&SDIO->FIFO;//DMA2 外设地址 
   \   00000050   0x....             LDR.N    R1,??DataTable28_6  ;; 0x40018080
   \   00000052   0x6499             STR      R1,[R3, #+72]
   1454          	DMA2_Channel4->CMAR=(u32)mbuf; 		//DMA2,存储器地址
   \   00000054   0x64D8             STR      R0,[R3, #+76]
   1455           	DMA2_Channel4->CCR|=1<<0; 			//开启DMA通道		
   \   00000056   0x6C18             LDR      R0,[R3, #+64]
   \   00000058   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000005C   0x6418             STR      R0,[R3, #+64]
   1456          }   
   \   0000005E   0xBC10             POP      {R4}
   \   00000060   0x4770             BX       LR               ;; return
   1457          //读SD卡
   1458          //buf:读数据缓存区
   1459          //sector:扇区地址
   1460          //cnt:扇区个数	
   1461          //返回值:错误状态;0,正常;其他,错误代码;				  				 

   \                                 In section .text, align 2, keep-with-next
   1462          u8 SD_ReadDisk(u8*buf,u32 sector,u8 cnt)
   1463          {
   \                     SD_ReadDisk: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4616             MOV      R6,R2
   1464          	u8 sta=SD_OK;
   \   0000000C   0xF04F 0x0900      MOV      R9,#+0
   1465          	u8 n;
   1466          
   1467          	//if(CardType!=SDIO_STD_CAPACITY_SD_CARD_V1_1)
   1468          	//	sector<<=9;
   1469          	if((u32)buf%4!=0)
   \   00000010   0xF015 0x0003      ANDS     R0,R5,#0x3
   \   00000014   0xD01B             BEQ.N    ??SD_ReadDisk_0
   1470          	{
   1471          	 	for(n=0;n<cnt;n++)
   \   00000016   0x464F             MOV      R7,R9
   \   00000018   0x.... 0x....      LDR.W    R8,??DataTable28_7
   \                     ??SD_ReadDisk_1: (+1)
   \   0000001C   0xB2FF             UXTB     R7,R7
   \   0000001E   0x42B7             CMP      R7,R6
   \   00000020   0xD22C             BCS.N    ??SD_ReadDisk_2
   1472          		{
   1473          		 	sta=SD_ReadBlock(SDIO_DATA_BUFFER,(uint64_t)sector*512UL,512);    	//单个sector的读操作
   \   00000022   0xF44F 0x7000      MOV      R0,#+512
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x4622             MOV      R2,R4
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0xEA43 0x53D2      ORR      R3,R3,R2, LSR #+23
   \   00000030   0x0252             LSLS     R2,R2,#+9
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0x.... 0x....      BL       SD_ReadBlock
   \   00000038   0x4681             MOV      R9,R0
   1474          			memcpy(buf,SDIO_DATA_BUFFER,512);
   \   0000003A   0xF44F 0x7200      MOV      R2,#+512
   \   0000003E   0x4641             MOV      R1,R8
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       memcpy
   1475          			buf+=512;
   \   00000046   0xF505 0x7500      ADD      R5,R5,#+512
   1476          		} 
   \   0000004A   0x1C7F             ADDS     R7,R7,#+1
   \   0000004C   0xE7E6             B.N      ??SD_ReadDisk_1
   1477          	}else
   1478          	{
   1479          		if(cnt==1)sta=SD_ReadBlock(buf,(uint64_t)sector*512UL,512);    	//单个sector的读操作
   \                     ??SD_ReadDisk_0: (+1)
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0x464B             MOV      R3,R9
   \   00000052   0xEA43 0x53D2      ORR      R3,R3,R2, LSR #+23
   \   00000056   0x0252             LSLS     R2,R2,#+9
   \   00000058   0x2E01             CMP      R6,#+1
   \   0000005A   0xD107             BNE.N    ??SD_ReadDisk_3
   \   0000005C   0xF44F 0x7000      MOV      R0,#+512
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       SD_ReadBlock
   \   00000068   0x4681             MOV      R9,R0
   \   0000006A   0xE007             B.N      ??SD_ReadDisk_2
   1480          		else sta=SD_ReadMultiBlocks(buf,(uint64_t)sector*512UL,512,cnt);//多个sector  
   \                     ??SD_ReadDisk_3: (+1)
   \   0000006C   0x9601             STR      R6,[SP, #+4]
   \   0000006E   0xF44F 0x7000      MOV      R0,#+512
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       SD_ReadMultiBlocks
   \   0000007A   0x4681             MOV      R9,R0
   1481          	}
   1482          	return sta;
   \                     ??SD_ReadDisk_2: (+1)
   \   0000007C   0x4648             MOV      R0,R9
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   1483          }
   1484          //写SD卡
   1485          //buf:写数据缓存区
   1486          //sector:扇区地址
   1487          //cnt:扇区个数	
   1488          //返回值:错误状态;0,正常;其他,错误代码;	

   \                                 In section .text, align 2, keep-with-next
   1489          u8 SD_WriteDisk(u8*buf,u32 sector,u8 cnt)
   1490          {
   \                     SD_WriteDisk: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4616             MOV      R6,R2
   1491          	u8 sta=SD_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   1492          	u8 n;
   1493          	//if(CardType!=SDIO_STD_CAPACITY_SD_CARD_V1_1)
   1494          	//	sector<<=9;
   1495          	if((u32)buf%4!=0)
   \   0000000C   0xF015 0x0103      ANDS     R1,R5,#0x3
   \   00000010   0xD01A             BEQ.N    ??SD_WriteDisk_0
   1496          	{
   1497          	 	for(n=0;n<cnt;n++)
   \   00000012   0x4607             MOV      R7,R0
   \   00000014   0x.... 0x....      LDR.W    R8,??DataTable28_7
   \                     ??SD_WriteDisk_1: (+1)
   \   00000018   0xB2FF             UXTB     R7,R7
   \   0000001A   0x42B7             CMP      R7,R6
   \   0000001C   0xD229             BCS.N    ??SD_WriteDisk_2
   1498          		{
   1499          			memcpy(SDIO_DATA_BUFFER,buf,512);
   \   0000001E   0xF44F 0x7200      MOV      R2,#+512
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0x.... 0x....      BL       memcpy
   1500          		 	sta=SD_WriteBlock(SDIO_DATA_BUFFER,(uint64_t)sector*512UL,512);    	//单个sector的写操作
   \   0000002A   0xF44F 0x7000      MOV      R0,#+512
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x4622             MOV      R2,R4
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0xEA43 0x53D2      ORR      R3,R3,R2, LSR #+23
   \   00000038   0x0252             LSLS     R2,R2,#+9
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       SD_WriteBlock
   1501          			buf+=512;
   \   00000040   0xF505 0x7500      ADD      R5,R5,#+512
   1502          		} 
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   \   00000046   0xE7E7             B.N      ??SD_WriteDisk_1
   1503          	}else
   1504          	{
   1505          		if(cnt==1)sta=SD_WriteBlock(buf,(uint64_t)sector*512UL,512);    	//单个sector的写操作
   \                     ??SD_WriteDisk_0: (+1)
   \   00000048   0x4622             MOV      R2,R4
   \   0000004A   0x4603             MOV      R3,R0
   \   0000004C   0xEA43 0x53D2      ORR      R3,R3,R2, LSR #+23
   \   00000050   0x0252             LSLS     R2,R2,#+9
   \   00000052   0x2E01             CMP      R6,#+1
   \   00000054   0xD106             BNE.N    ??SD_WriteDisk_3
   \   00000056   0xF44F 0x7000      MOV      R0,#+512
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       SD_WriteBlock
   \   00000062   0xE006             B.N      ??SD_WriteDisk_2
   1506          		else sta=SD_WriteMultiBlocks(buf,(uint64_t)sector*512UL,512,cnt);	//多个sector  
   \                     ??SD_WriteDisk_3: (+1)
   \   00000064   0x9601             STR      R6,[SP, #+4]
   \   00000066   0xF44F 0x7000      MOV      R0,#+512
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       SD_WriteMultiBlocks
   1507          	}
   1508          	return sta;
   \                     ??SD_WriteDisk_2: (+1)
   \   00000072   0xB2C0             UXTB     R0,R0
   \   00000074   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1509          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40021014         DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40011004         DC32     0x40011004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x000BBBBB         DC32     0xbbbbb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40018000         DC32     0x40018000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x00C007FF         DC32     0xc007ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     SDCardInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     CardType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40018004         DC32     0x40018004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40018008         DC32     0x40018008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40018024         DC32     0x40018024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0xC0FF8000         DC32     0xc0ff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x91100000         DC32     0x91100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x80FF8000         DC32     0x80ff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     CardType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40018014         DC32     0x40018014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x0001FFFF         DC32     0x1ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     CardType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x40018034         DC32     0x40018034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0xFFFF3CC5         DC32     0xffff3cc5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x40018010         DC32     0x40018010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x40020404         DC32     0x40020404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x40018080         DC32     0x40018080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x........         DC32     SDIO_DATA_BUFFER

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0}>`:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0}>_1`:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   1510          
   1511          
   1512          
   1513          
   1514          
   1515          
   1516          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CmdError
       0   CmdResp1Error
       0   CmdResp2Error
       0   CmdResp3Error
       4   CmdResp6Error
       0   CmdResp7Error
      24   FindSCR
        24   -> CmdResp1Error
        24   -> SDIO_Send_Cmd
        24   -> SDIO_Send_Data_Cfg
      16   IsCardProgramming
        16   -> SDIO_Send_Cmd
      24   SDEnWideBus
        24   -> CmdResp1Error
        24   -> FindSCR
        24   -> SDIO_Send_Cmd
       0   SDIO_Clock_Set
       0   SDIO_IRQHandler
         0   -> SD_ProcessIRQSrc
       0   SDIO_Send_Cmd
       4   SDIO_Send_Data_Cfg
       4   SD_DMA_Config
       8   SD_EnableWideBusOperation
         8   -> SDEnWideBus
      24   SD_GetCardInfo
       8   SD_Init
         8   -> NVIC_Init
         8   -> SDIO_Clock_Set
         8   -> SD_EnableWideBusOperation
         8   -> SD_GetCardInfo
         8   -> SD_InitializeCards
         8   -> SD_PowerON
         8   -> SD_SelectDeselect
         8   -> SD_SetDeviceMode
      16   SD_InitializeCards
        16   -> CmdResp2Error
        16   -> CmdResp6Error
        16   -> SDIO_Send_Cmd
       0   SD_PowerOFF
      40   SD_PowerON
        40   -> CmdError
        40   -> CmdResp1Error
        40   -> CmdResp3Error
        40   -> CmdResp7Error
        40   -> SDIO_Clock_Set
        40   -> SDIO_Send_Cmd
      16   SD_ProcessIRQSrc
        16   -> CmdResp1Error
        16   -> SDIO_Send_Cmd
      40   SD_ReadBlock
        40   -> CmdResp1Error
        40   -> SDIO_Send_Cmd
        40   -> SDIO_Send_Data_Cfg
        40   -> SD_DMA_Config
        40   -> convert_from_bytes_to_power_of_two
      40   SD_ReadDisk
        40   -> SD_ReadBlock
        40   -> SD_ReadMultiBlocks
        40   -> memcpy
      48   SD_ReadMultiBlocks
        48   -> CmdResp1Error
        48   -> SDIO_Send_Cmd
        48   -> SDIO_Send_Data_Cfg
        48   -> SD_DMA_Config
        48   -> convert_from_bytes_to_power_of_two
       8   SD_SelectDeselect
         0   -> CmdResp1Error
         8   -> SDIO_Send_Cmd
       0   SD_SetDeviceMode
      48   SD_WriteBlock
        48   -> CmdResp1Error
        48   -> IsCardProgramming
        48   -> SDIO_Send_Cmd
        48   -> SDIO_Send_Data_Cfg
        48   -> SD_DMA_Config
        48   -> SD_Init
        48   -> convert_from_bytes_to_power_of_two
      32   SD_WriteDisk
        32   -> SD_WriteBlock
        32   -> SD_WriteMultiBlocks
        32   -> memcpy
      48   SD_WriteMultiBlocks
        48   -> CmdResp1Error
        48   -> IsCardProgramming
        48   -> SDIO_Send_Cmd
        48   -> SDIO_Send_Data_Cfg
        48   -> SD_DMA_Config
        48   -> SD_Init
        48   -> convert_from_bytes_to_power_of_two
       0   convert_from_bytes_to_power_of_two


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {0, 0}>
       8  ?<Constant {0, 0}>_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
      44  CardType
          DeviceMode
          StopCondition
          TransferError
          TransferEnd
          CSD_Tab
          CID_Tab
          RCA
      44  CmdError
      58  CmdResp1Error
      76  CmdResp2Error
      38  CmdResp3Error
     104  CmdResp6Error
      68  CmdResp7Error
     258  FindSCR
     114  IsCardProgramming
      88  SDCardInfo
      98  SDEnWideBus
      20  SDIO_Clock_Set
     512  SDIO_DATA_BUFFER
       2  SDIO_IRQHandler
      46  SDIO_Send_Cmd
      58  SDIO_Send_Data_Cfg
      98  SD_DMA_Config
     140  SD_EnableWideBusOperation
    1294  SD_GetCardInfo
     218  SD_Init
     174  SD_InitializeCards
      16  SD_PowerOFF
     528  SD_PowerON
     248  SD_ProcessIRQSrc
     462  SD_ReadBlock
     132  SD_ReadDisk
     526  SD_ReadMultiBlocks
      22  SD_SelectDeselect
      24  SD_SetDeviceMode
     658  SD_WriteBlock
     120  SD_WriteDisk
     690  SD_WriteMultiBlocks
      18  convert_from_bytes_to_power_of_two

 
   600 bytes in section .bss
    44 bytes in section .data
    16 bytes in section .rodata
 6 460 bytes in section .text
 
 6 460 bytes of CODE  memory
    16 bytes of CONST memory
   644 bytes of DATA  memory

Errors: none
Warnings: 67
