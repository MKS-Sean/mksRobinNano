###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:12
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\string_deal.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\string_deal.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\string_deal.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\string_deal.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\string_deal.c
      1          #include "ff.h"
      2          #include "ffconf.h"
      3          #include "string_deal.h"
      4          
      5          #if _LFN_UNICODE 
      6          void cutFileName(TCHAR *path, int len, int bytePerLine,  TCHAR *outStr)
      7          #else

   \                                 In section .text, align 2, keep-with-next
      8          void cutFileName(char *path, int len, int bytePerLine,  char *outStr)
      9          #endif
     10          {
   \                     cutFileName: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
     11          	#if _LFN_UNICODE 
     12          	TCHAR *tmpFile;
     13          	TCHAR *strIndex1 = 0, *strIndex2 = 0, *beginIndex;
     14          	TCHAR secSeg[10] = {0};
     15          	TCHAR gFileTail[4] = {'~', '.', 'g', '\0'};
     16          	#else
     17          	char *tmpFile;
     18          	char *strIndex1 = 0, *strIndex2 = 0, *beginIndex;
     19          	char secSeg[10] = {0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0x460B             MOV      R3,R1
   \   00000016   0xC00E             STM      R0!,{R1-R3}
     20          	#endif
     21          	
     22          	if(path == 0 || len <= 3 || outStr == 0)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD04E             BEQ.N    ??cutFileName_0
   \   0000001C   0x2D04             CMP      R5,#+4
   \   0000001E   0xDB4C             BLT.N    ??cutFileName_0
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD04A             BEQ.N    ??cutFileName_0
     23          	{
     24          		return;
     25          	}
     26          	
     27          	tmpFile = path;
     28          	#if _LFN_UNICODE
     29          	strIndex1 = (WCHAR *)wcsstr((const WCHAR *)tmpFile, (const WCHAR *)'/');
     30          	strIndex2 = (WCHAR *)wcsstr((const WCHAR *)tmpFile, (const WCHAR *)'.');
     31          	#else
     32          	strIndex1 = (char *)strrchr(tmpFile, '/');
                 	                    ^
Warning[Pe223]: function "strrchr" declared implicitly
   \   00000024   0x212F             MOVS     R1,#+47
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       strrchr
   \   0000002C   0x4680             MOV      R8,R0
     33          	strIndex2 = (char *)strrchr(tmpFile, '.');
   \   0000002E   0x212E             MOVS     R1,#+46
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       strrchr
     34          	#endif
     35          
     36          	if(strIndex1 != 0)
   \   00000036   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003A   0xD001             BEQ.N    ??cutFileName_1
     37          	{
     38          		beginIndex = strIndex1 + 1;	
   \   0000003C   0xF108 0x0401      ADD      R4,R8,#+1
     39          	}
     40          	/*if((strIndex1 != 0) && (strIndex2 != 0) && (strIndex1 < strIndex2))
     41          	{
     42          		beginIndex = strIndex1 + 1;			
     43          	}*/
     44          	else
     45          	{
     46          		beginIndex = tmpFile;
     47          	}
     48          
     49          	if(strIndex2 == 0 ||  (strIndex1 > strIndex2))	//not gcode file
   \                     ??cutFileName_1: (+1)
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD001             BEQ.N    ??cutFileName_2
   \   00000044   0x4540             CMP      R0,R8
   \   00000046   0xD20F             BCS.N    ??cutFileName_3
     50          	{
     51          		#if _LFN_UNICODE
     52          			if(wcslen(beginIndex) > len)
     53          			{
     54          				wcsncpy(outStr, beginIndex, len);
     55          			
     56          			}
     57          			else
     58          			{
     59          				wcscpy(outStr, beginIndex);
     60          			}
     61          		#else
     62          			if(strlen(beginIndex) > len)
                 			   ^
Warning[Pe223]: function "strlen" declared implicitly
   \                     ??cutFileName_2: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       strlen
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xDA05             BGE.N    ??cutFileName_4
     63          			{
     64          				strncpy(outStr, beginIndex, len);
                 				^
Warning[Pe223]: function "strncpy" declared implicitly
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0x4621             MOV      R1,R4
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x.... 0x....      BL       strncpy
   \   0000005C   0xE01B             B.N      ??cutFileName_5
     65          			
     66          			}
     67          			else
     68          			{
     69          				strcpy(outStr, beginIndex);
                 				^
Warning[Pe223]: function "strcpy" declared implicitly
   \                     ??cutFileName_4: (+1)
   \   0000005E   0x4621             MOV      R1,R4
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       strcpy
   \   00000066   0xE016             B.N      ??cutFileName_5
     70          			}
     71          		#endif
     72          	}
     73          	else //gcode file
     74          	{
     75          		if(strIndex2 - beginIndex > (len - 2))
   \                     ??cutFileName_3: (+1)
   \   00000068   0x1B00             SUBS     R0,R0,R4
   \   0000006A   0x1EA9             SUBS     R1,R5,#+2
   \   0000006C   0x4281             CMP      R1,R0
   \   0000006E   0xDA09             BGE.N    ??cutFileName_6
     76          		{
     77          			#if _LFN_UNICODE
     78          				wcsncpy(outStr, (const WCHAR *)beginIndex, len - 3);
     79          				wcscat(outStr, (const WCHAR *)gFileTail);
     80          			#else
     81          				//strncpy(outStr, beginIndex, len - 3);
     82          				strncpy(outStr, beginIndex, len - 4);
                 				^
Warning[Pe223]: function "strncpy" declared implicitly
   \   00000070   0x1F2A             SUBS     R2,R5,#+4
   \   00000072   0x4621             MOV      R1,R4
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x.... 0x....      BL       strncpy
     83          				strcat(outStr, "~.g");
                 				^
Warning[Pe223]: function "strcat" declared implicitly
   \   0000007A   0x....             ADR.N    R1,??DataTable3  ;; "~.g"
   \   0000007C   0x4638             MOV      R0,R7
   \   0000007E   0x.... 0x....      BL       strcat
   \   00000082   0xE008             B.N      ??cutFileName_5
     84          			#endif
     85          		
     86          		}
     87          		else
     88          		{
     89          			#if _LFN_UNICODE
     90          				wcsncpy(outStr, (const WCHAR *)beginIndex, strIndex2 - beginIndex + 1);
     91          				wcscat(outStr, (const WCHAR *)&gFileTail[3]);
     92          			#else
     93          				strncpy(outStr, beginIndex, strIndex2 - beginIndex + 1);
                 				^
Warning[Pe223]: function "strncpy" declared implicitly
   \                     ??cutFileName_6: (+1)
   \   00000084   0x1C42             ADDS     R2,R0,#+1
   \   00000086   0x4621             MOV      R1,R4
   \   00000088   0x4638             MOV      R0,R7
   \   0000008A   0x.... 0x....      BL       strncpy
     94          				strcat(outStr, "g");
                 				^
Warning[Pe223]: function "strcat" declared implicitly
   \   0000008E   0x....             ADR.N    R1,??DataTable3_1  ;; "g"
   \   00000090   0x4638             MOV      R0,R7
   \   00000092   0x.... 0x....      BL       strcat
     95          			#endif
     96          		}
     97          		
     98          	}
     99          	#if _LFN_UNICODE
    100          	if(wcslen(outStr) > bytePerLine)
    101          	{
    102          		
    103          		wcscpy(secSeg, (const WCHAR *)&outStr[bytePerLine]);
    104          		outStr[bytePerLine] = '\n';
    105          		outStr[bytePerLine + 1] = '\0';
    106          		wcscat(outStr, (const WCHAR *)secSeg);
    107          		
    108          	}
    109          	#else
    110          	if(strlen(outStr) > bytePerLine)
                 	   ^
Warning[Pe223]: function "strlen" declared implicitly
   \                     ??cutFileName_5: (+1)
   \   00000096   0x4638             MOV      R0,R7
   \   00000098   0x.... 0x....      BL       strlen
   \   0000009C   0x4286             CMP      R6,R0
   \   0000009E   0xDA0C             BGE.N    ??cutFileName_0
    111          	{
    112          		
    113          		strcpy(secSeg, &outStr[bytePerLine]);
                 		^
Warning[Pe223]: function "strcpy" declared implicitly
   \   000000A0   0x19F1             ADDS     R1,R6,R7
   \   000000A2   0xA800             ADD      R0,SP,#+0
   \   000000A4   0x.... 0x....      BL       strcpy
    114          		outStr[bytePerLine] = '\n';
   \   000000A8   0x200A             MOVS     R0,#+10
   \   000000AA   0x55F0             STRB     R0,[R6, R7]
    115          		outStr[bytePerLine + 1] = '\0';
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x19F1             ADDS     R1,R6,R7
   \   000000B0   0x7048             STRB     R0,[R1, #+1]
    116          		strcat(outStr, secSeg);
                 		^
Warning[Pe223]: function "strcat" declared implicitly
   \   000000B2   0xA900             ADD      R1,SP,#+0
   \   000000B4   0x4638             MOV      R0,R7
   \   000000B6   0x.... 0x....      BL       strcat
    117          		
    118          	}
    119          	#endif
    120          }
   \                     ??cutFileName_0: (+1)
   \   000000BA   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x7E 0x2E          DC8      "~.g"
   \              0x67 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x67 0x00          DC8      "g",0x0,0x0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "~.g">`:
   \   00000000   0x7E 0x2E          DC8 "~.g"
   \              0x67 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "g">`:
   \   00000000   0x67 0x00          DC8 "g"
    121          	
    122          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   cutFileName
        40   -> strcat
        40   -> strcpy
        40   -> strlen
        40   -> strncpy
        40   -> strrchr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "g">
       4  ?<Constant "~.g">
      12  ?<Constant {0}>
       4  ??DataTable3
       4  ??DataTable3_1
     190  cutFileName

 
  18 bytes in section .rodata
 198 bytes in section .text
 
 198 bytes of CODE  memory
  18 bytes of CONST memory

Errors: none
Warnings: 11
