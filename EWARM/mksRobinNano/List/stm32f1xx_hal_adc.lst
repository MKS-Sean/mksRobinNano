###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:59
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_hal_adc.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_hal_adc.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC)
      9            *          peripheral:
     10            *           + Initialization and de-initialization functions
     11            *             ++ Initialization and Configuration of ADC
     12            *           + Operation functions
     13            *             ++ Start, stop, get result of conversions of regular
     14            *                group, using 3 possible modes: polling, interruption or DMA.
     15            *           + Control functions
     16            *             ++ Channels configuration on regular group
     17            *             ++ Channels configuration on injected group
     18            *             ++ Analog Watchdog configuration
     19            *           + State functions
     20            *             ++ ADC state machine management
     21            *             ++ Interrupts and flags management
     22            *          Other functions (extended functions) are available in file 
     23            *          "stm32f1xx_hal_adc_ex.c".
     24            *
     25            @verbatim
     26            ==============================================================================
     27                               ##### ADC peripheral features #####
     28            ==============================================================================
     29            [..]
     30            (+) 12-bit resolution
     31          
     32            (+) Interrupt generation at the end of regular conversion, end of injected
     33                conversion, and in case of analog watchdog or overrun events.
     34            
     35            (+) Single and continuous conversion modes.
     36            
     37            (+) Scan mode for conversion of several channels sequentially.
     38            
     39            (+) Data alignment with in-built data coherency.
     40            
     41            (+) Programmable sampling time (channel wise)
     42            
     43            (+) ADC conversion of regular group and injected group.
     44          
     45            (+) External trigger (timer or EXTI) 
     46                for both regular and injected groups.
     47          
     48            (+) DMA request generation for transfer of conversions data of regular group.
     49          
     50            (+) Multimode Dual mode (available on devices with 2 ADCs or more).
     51            
     52            (+) Configurable DMA data storage in Multimode Dual mode (available on devices
     53                with 2 DCs or more).
     54            
     55            (+) Configurable delay between conversions in Dual interleaved mode (available 
     56                on devices with 2 DCs or more).
     57            
     58            (+) ADC calibration
     59          
     60            (+) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
     61                slower speed.
     62            
     63            (+) ADC input range: from Vref- (connected to Vssa) to Vref+ (connected to 
     64                Vdda or to an external voltage reference).
     65          
     66          
     67                               ##### How to use this driver #####
     68            ==============================================================================
     69              [..]
     70          
     71               *** Configuration of top level parameters related to ADC ***
     72               ============================================================
     73               [..]
     74          
     75              (#) Enable the ADC interface
     76                (++) As prerequisite, ADC clock must be configured at RCC top level.
     77                     Caution: On STM32F1, ADC clock frequency max is 14MHz (refer
     78                              to device datasheet).
     79                              Therefore, ADC clock prescaler must be configured in 
     80                              function of ADC clock source frequency to remain below
     81                              this maximum frequency.
     82                  (++) One clock setting is mandatory:
     83                       ADC clock (core clock, also possibly conversion clock).
     84                       (+++) Example:
     85                             Into HAL_ADC_MspInit() (recommended code location) or with
     86                             other device clock parameters configuration:
     87                         (+++) RCC_PeriphCLKInitTypeDef  PeriphClkInit;
     88                         (+++) __ADC1_CLK_ENABLE();
     89                         (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
     90                         (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
     91                         (+++) HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
     92          
     93              (#) ADC pins configuration
     94                   (++) Enable the clock for the ADC GPIOs
     95                        using macro __HAL_RCC_GPIOx_CLK_ENABLE()
     96                   (++) Configure these ADC pins in analog mode
     97                        using function HAL_GPIO_Init()
     98          
     99              (#) Optionally, in case of usage of ADC with interruptions:
    100                   (++) Configure the NVIC for ADC
    101                        using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
    102                   (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
    103                        into the function of corresponding ADC interruption vector 
    104                        ADCx_IRQHandler().
    105          
    106              (#) Optionally, in case of usage of DMA:
    107                   (++) Configure the DMA (DMA channel, mode normal or circular, ...)
    108                        using function HAL_DMA_Init().
    109                   (++) Configure the NVIC for DMA
    110                        using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
    111                   (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
    112                        into the function of corresponding DMA interruption vector 
    113                        DMAx_Channelx_IRQHandler().
    114          
    115               *** Configuration of ADC, groups regular/injected, channels parameters ***
    116               ==========================================================================
    117               [..]
    118          
    119              (#) Configure the ADC parameters (resolution, data alignment, ...)
    120                  and regular group parameters (conversion trigger, sequencer, ...)
    121                  using function HAL_ADC_Init().
    122          
    123              (#) Configure the channels for regular group parameters (channel number, 
    124                  channel rank into sequencer, ..., into regular group)
    125                  using function HAL_ADC_ConfigChannel().
    126          
    127              (#) Optionally, configure the injected group parameters (conversion trigger, 
    128                  sequencer, ..., of injected group)
    129                  and the channels for injected group parameters (channel number, 
    130                  channel rank into sequencer, ..., into injected group)
    131                  using function HAL_ADCEx_InjectedConfigChannel().
    132          
    133              (#) Optionally, configure the analog watchdog parameters (channels
    134                  monitored, thresholds, ...)
    135                  using function HAL_ADC_AnalogWDGConfig().
    136          
    137              (#) Optionally, for devices with several ADC instances: configure the 
    138                  multimode parameters
    139                  using function HAL_ADCEx_MultiModeConfigChannel().
    140          
    141               *** Execution of ADC conversions ***
    142               ====================================
    143               [..]
    144          
    145              (#) Optionally, perform an automatic ADC calibration to improve the
    146                  conversion accuracy
    147                  using function HAL_ADCEx_Calibration_Start().
    148          
    149              (#) ADC driver can be used among three modes: polling, interruption,
    150                  transfer by DMA.
    151          
    152                  (++) ADC conversion by polling:
    153                    (+++) Activate the ADC peripheral and start conversions
    154                          using function HAL_ADC_Start()
    155                    (+++) Wait for ADC conversion completion 
    156                          using function HAL_ADC_PollForConversion()
    157                          (or for injected group: HAL_ADCEx_InjectedPollForConversion() )
    158                    (+++) Retrieve conversion results 
    159                          using function HAL_ADC_GetValue()
    160                          (or for injected group: HAL_ADCEx_InjectedGetValue() )
    161                    (+++) Stop conversion and disable the ADC peripheral 
    162                          using function HAL_ADC_Stop()
    163          
    164                  (++) ADC conversion by interruption: 
    165                    (+++) Activate the ADC peripheral and start conversions
    166                          using function HAL_ADC_Start_IT()
    167                    (+++) Wait for ADC conversion completion by call of function
    168                          HAL_ADC_ConvCpltCallback()
    169                          (this function must be implemented in user program)
    170                          (or for injected group: HAL_ADCEx_InjectedConvCpltCallback() )
    171                    (+++) Retrieve conversion results 
    172                          using function HAL_ADC_GetValue()
    173                          (or for injected group: HAL_ADCEx_InjectedGetValue() )
    174                    (+++) Stop conversion and disable the ADC peripheral 
    175                          using function HAL_ADC_Stop_IT()
    176          
    177                  (++) ADC conversion with transfer by DMA:
    178                    (+++) Activate the ADC peripheral and start conversions
    179                          using function HAL_ADC_Start_DMA()
    180                    (+++) Wait for ADC conversion completion by call of function
    181                          HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
    182                          (these functions must be implemented in user program)
    183                    (+++) Conversion results are automatically transferred by DMA into
    184                          destination variable address.
    185                    (+++) Stop conversion and disable the ADC peripheral 
    186                          using function HAL_ADC_Stop_DMA()
    187          
    188                  (++) For devices with several ADCs: ADC multimode conversion 
    189                       with transfer by DMA:
    190                    (+++) Activate the ADC peripheral (slave) and start conversions
    191                          using function HAL_ADC_Start()
    192                    (+++) Activate the ADC peripheral (master) and start conversions
    193                          using function HAL_ADCEx_MultiModeStart_DMA()
    194                    (+++) Wait for ADC conversion completion by call of function
    195                          HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
    196                          (these functions must be implemented in user program)
    197                    (+++) Conversion results are automatically transferred by DMA into
    198                          destination variable address.
    199                    (+++) Stop conversion and disable the ADC peripheral (master)
    200                          using function HAL_ADCEx_MultiModeStop_DMA()
    201                    (+++) Stop conversion and disable the ADC peripheral (slave)
    202                          using function HAL_ADC_Stop_IT()
    203          
    204               [..]
    205          
    206              (@) Callback functions must be implemented in user program:
    207                (+@) HAL_ADC_ErrorCallback()
    208                (+@) HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)
    209                (+@) HAL_ADC_ConvCpltCallback()
    210                (+@) HAL_ADC_ConvHalfCpltCallback
    211                (+@) HAL_ADCEx_InjectedConvCpltCallback()
    212          
    213               *** Deinitialization of ADC ***
    214               ============================================================
    215               [..]
    216          
    217              (#) Disable the ADC interface
    218                (++) ADC clock can be hard reset and disabled at RCC top level.
    219                  (++) Hard reset of ADC peripherals
    220                       using macro __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET().
    221                  (++) ADC clock disable
    222                       using the equivalent macro/functions as configuration step.
    223                       (+++) Example:
    224                             Into HAL_ADC_MspDeInit() (recommended code location) or with
    225                             other device clock parameters configuration:
    226                         (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC
    227                         (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPLLCLK2_OFF
    228                         (+++) HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit)
    229          
    230              (#) ADC pins configuration
    231                   (++) Disable the clock for the ADC GPIOs
    232                        using macro __HAL_RCC_GPIOx_CLK_DISABLE()
    233          
    234              (#) Optionally, in case of usage of ADC with interruptions:
    235                   (++) Disable the NVIC for ADC
    236                        using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
    237          
    238              (#) Optionally, in case of usage of DMA:
    239                   (++) Deinitialize the DMA
    240                        using function HAL_DMA_Init().
    241                   (++) Disable the NVIC for DMA
    242                        using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
    243          
    244              [..]
    245            
    246              @endverbatim
    247            ******************************************************************************
    248            * @attention
    249            *
    250            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    251            *
    252            * Redistribution and use in source and binary forms, with or without modification,
    253            * are permitted provided that the following conditions are met:
    254            *   1. Redistributions of source code must retain the above copyright notice,
    255            *      this list of conditions and the following disclaimer.
    256            *   2. Redistributions in binary form must reproduce the above copyright notice,
    257            *      this list of conditions and the following disclaimer in the documentation
    258            *      and/or other materials provided with the distribution.
    259            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    260            *      may be used to endorse or promote products derived from this software
    261            *      without specific prior written permission.
    262            *
    263            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    264            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    265            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    266            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    267            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    268            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    269            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    270            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    271            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    272            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    273            *
    274            ******************************************************************************  
    275            */
    276          
    277          /* Includes ------------------------------------------------------------------*/
    278          #include "stm32f1xx_hal.h"
    279          
    280          /** @addtogroup STM32F1xx_HAL_Driver
    281            * @{
    282            */
    283          
    284          /** @defgroup ADC ADC
    285            * @brief ADC HAL module driver
    286            * @{
    287            */
    288          
    289          #ifdef HAL_ADC_MODULE_ENABLED
    290          
    291          /* Private typedef -----------------------------------------------------------*/
    292          /* Private define ------------------------------------------------------------*/
    293          /** @defgroup ADC_Private_Constants ADC Private Constants
    294            * @{
    295            */
    296          
    297            /* Timeout values for ADC enable and disable settling time.                 */
    298            /* Values defined to be higher than worst cases: low clocks freq,           */
    299            /* maximum prescaler.                                                       */
    300            /* Ex of profile low frequency : Clock source at 0.1 MHz, ADC clock         */
    301            /* prescaler 4, sampling time 12.5 ADC clock cycles, resolution 12 bits.    */
    302            /* Unit: ms                                                                 */
    303            #define ADC_ENABLE_TIMEOUT              ((uint32_t) 2)
    304            #define ADC_DISABLE_TIMEOUT             ((uint32_t) 2)
    305          
    306            /* Delay for ADC stabilization time.                                        */
    307            /* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       */
    308            /* Unit: us                                                                 */
    309            #define ADC_STAB_DELAY_US               ((uint32_t) 1)
    310          
    311            /* Delay for temperature sensor stabilization time.                         */
    312            /* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
    313            /* Unit: us                                                                 */
    314            #define ADC_TEMPSENSOR_DELAY_US         ((uint32_t) 10)
    315          
    316          /**
    317            * @}
    318            */
    319          
    320          /* Private macro -------------------------------------------------------------*/
    321          /* Private variables ---------------------------------------------------------*/
    322          /* Private function prototypes -----------------------------------------------*/
    323          /** @defgroup ADC_Private_Functions ADC Private Functions
    324            * @{
    325            */
    326          /**
    327            * @}
    328            */
    329          
    330          /* Exported functions --------------------------------------------------------*/
    331          
    332          /** @defgroup ADC_Exported_Functions ADC Exported Functions
    333            * @{
    334            */
    335          
    336          /** @defgroup ADC_Exported_Functions_Group1 Initialization/de-initialization functions 
    337            * @brief    Initialization and Configuration functions
    338            *
    339          @verbatim    
    340           ===============================================================================
    341                        ##### Initialization and de-initialization functions #####
    342           ===============================================================================
    343              [..]  This section provides functions allowing to:
    344                (+) Initialize and configure the ADC. 
    345                (+) De-initialize the ADC.
    346          
    347          @endverbatim
    348            * @{
    349            */
    350          
    351          /**
    352            * @brief  Initializes the ADC peripheral and regular group according to  
    353            *         parameters specified in structure "ADC_InitTypeDef".
    354            * @note   As prerequisite, ADC clock must be configured at RCC top level
    355            *         (clock source APB2).
    356            *         See commented example code below that can be copied and uncommented 
    357            *         into HAL_ADC_MspInit().
    358            * @note   Possibility to update parameters on the fly:
    359            *         This function initializes the ADC MSP (HAL_ADC_MspInit()) only when
    360            *         coming from ADC state reset. Following calls to this function can
    361            *         be used to reconfigure some parameters of ADC_InitTypeDef  
    362            *         structure on the fly, without modifying MSP configuration. If ADC  
    363            *         MSP has to be modified again, HAL_ADC_DeInit() must be called
    364            *         before HAL_ADC_Init().
    365            *         The setting of these parameters is conditioned to ADC state.
    366            *         For parameters constraints, see comments of structure 
    367            *         "ADC_InitTypeDef".
    368            * @note   This function configures the ADC within 2 scopes: scope of entire 
    369            *         ADC and scope of regular group. For parameters details, see comments 
    370            *         of structure "ADC_InitTypeDef".
    371            * @param  hadc: ADC handle
    372            * @retval HAL status
    373            */

   \                                 In section .text, align 2, keep-with-next
    374          HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
    375          {
   \                     HAL_ADC_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    376            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    377            uint32_t tmp_cr1 = 0;
    378            uint32_t tmp_cr2 = 0;
    379            uint32_t tmp_sqr1 = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    380            
    381            /* Check ADC handle */
    382            if(hadc == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_ADC_Init_0
    383            {
    384              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    385            }
    386            
    387            /* Check the parameters */
    388            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    389            assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
    390            assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    391            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    392            assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    393            
    394            if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    395            {
    396              assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    397              assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    398              if(hadc->Init.DiscontinuousConvMode != DISABLE)
    399              {
    400                assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    401              }
    402            }
    403            
    404            /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
    405            /* at RCC top level.                                                        */
    406            /* Refer to header of this file for more details on clock enabling          */
    407            /* procedure.                                                               */
    408          
    409            /* Actions performed only if ADC is coming from state reset:                */
    410            /* - Initialization of ADC MSP                                              */
    411            if (hadc->State == HAL_ADC_STATE_RESET)
   \                     ??HAL_ADC_Init_0: (+1)
   \   0000000E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD106             BNE.N    ??HAL_ADC_Init_1
    412            {
    413              /* Initialize ADC error code */
    414              ADC_CLEAR_ERRORCODE(hadc);
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x62E0             STR      R0,[R4, #+44]
    415              
    416              /* Allocate lock resource and initialize it */
    417              hadc->Lock = HAL_UNLOCKED;
   \   00000018   0xF884 0x0024      STRB     R0,[R4, #+36]
    418              
    419              /* Init the low level hardware */
    420              HAL_ADC_MspInit(hadc);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_ADC_MspInit
    421            }
    422            
    423            /* Stop potential conversion on going, on regular and injected groups */
    424            /* Disable ADC peripheral */
    425            /* Note: In case of ADC already enabled, precaution to not launch an        */
    426            /*       unwanted conversion while modifying register CR2 by writing 1 to   */
    427            /*       bit ADON.                                                          */
    428            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \                     ??HAL_ADC_Init_1: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       ADC_ConversionStop_Disable
    429            
    430            
    431            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    432            /* correctly completed.                                                     */
    433            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
    434                (tmp_hal_status == HAL_OK)                                  )
   \   00000028   0x6AA1             LDR      R1,[R4, #+40]
   \   0000002A   0x06C9             LSLS     R1,R1,#+27
   \   0000002C   0xD474             BMI.N    ??HAL_ADC_Init_2
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD172             BNE.N    ??HAL_ADC_Init_2
    435            {
    436              /* Set ADC state */
    437              ADC_STATE_CLR_SET(hadc->State,
    438                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    439                                HAL_ADC_STATE_BUSY_INTERNAL);
   \   00000032   0x6AA1             LDR      R1,[R4, #+40]
   \   00000034   0xF421 0x5188      BIC      R1,R1,#0x1100
   \   00000038   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000003C   0x62A1             STR      R1,[R4, #+40]
    440              
    441              /* Set ADC parameters */
    442              
    443              /* Configuration of ADC:                                                  */
    444              /*  - data alignment                                                      */
    445              /*  - external trigger to start conversion                                */
    446              /*  - external trigger polarity (always set to 1, because needed for all  */
    447              /*    triggers: external trigger of SW start)                             */
    448              /*  - continuous conversion mode                                          */
    449              /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
    450              /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    451              /*       a conversion on injected group would start a conversion also on  */
    452              /*       regular group after ADC enabling.                                */
    453              tmp_cr2 |= (hadc->Init.DataAlign                               |
    454                          ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
    455                          ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)   );
   \   0000003E   0x69E1             LDR      R1,[R4, #+28]
   \   00000040   0x6822             LDR      R2,[R4, #+0]
   \   00000042   0x.... 0x....      LDR.W    R3,??DataTable8  ;; 0x40013c00
   \   00000046   0x429A             CMP      R2,R3
   \   00000048   0xD104             BNE.N    ??HAL_ADC_Init_3
   \   0000004A   0xF5B1 0x2F40      CMP      R1,#+786432
   \   0000004E   0xD101             BNE.N    ??HAL_ADC_Init_3
   \   00000050   0xF44F 0x2100      MOV      R1,#+524288
   \                     ??HAL_ADC_Init_3: (+1)
   \   00000054   0x68E3             LDR      R3,[R4, #+12]
   \   00000056   0x6862             LDR      R2,[R4, #+4]
   \   00000058   0x4311             ORRS     R1,R1,R2
   \   0000005A   0xEA41 0x0143      ORR      R1,R1,R3, LSL #+1
    456              
    457              /* Configuration of ADC:                                                  */
    458              /*  - scan mode                                                           */
    459              /*  - discontinuous mode disable/enable                                   */
    460              /*  - discontinuous mode number of conversions                            */
    461              tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
   \   0000005E   0x68A2             LDR      R2,[R4, #+8]
   \   00000060   0xF5B2 0x7F80      CMP      R2,#+256
   \   00000064   0xD001             BEQ.N    ??HAL_ADC_Init_4
   \   00000066   0x2A01             CMP      R2,#+1
   \   00000068   0xD102             BNE.N    ??HAL_ADC_Init_5
   \                     ??HAL_ADC_Init_4: (+1)
   \   0000006A   0xF44F 0x7280      MOV      R2,#+256
   \   0000006E   0xE000             B.N      ??HAL_ADC_Init_6
   \                     ??HAL_ADC_Init_5: (+1)
   \   00000070   0x462A             MOV      R2,R5
    462              
    463              /* Enable discontinuous mode only if continuous mode is disabled */
    464              /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    465              /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    466              if (hadc->Init.DiscontinuousConvMode == ENABLE)
   \                     ??HAL_ADC_Init_6: (+1)
   \   00000072   0x6966             LDR      R6,[R4, #+20]
   \   00000074   0x2E01             CMP      R6,#+1
   \   00000076   0xD110             BNE.N    ??HAL_ADC_Init_7
    467              {
    468                if (hadc->Init.ContinuousConvMode == DISABLE)
   \   00000078   0x2B00             CMP      R3,#+0
   \   0000007A   0xD106             BNE.N    ??HAL_ADC_Init_8
    469                {
    470                  /* Enable the selected ADC regular discontinuous mode */
    471                  /* Set the number of channels to be converted in discontinuous mode */
    472                  SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
    473                                   ADC_CR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion)  );
   \   0000007C   0x69A3             LDR      R3,[R4, #+24]
   \   0000007E   0x1E5B             SUBS     R3,R3,#+1
   \   00000080   0x035B             LSLS     R3,R3,#+13
   \   00000082   0xF443 0x6300      ORR      R3,R3,#0x800
   \   00000086   0x431A             ORRS     R2,R3,R2
   \   00000088   0xE007             B.N      ??HAL_ADC_Init_7
    474                }
    475                else
    476                {
    477                  /* ADC regular group settings continuous and sequencer discontinuous*/
    478                  /* cannot be enabled simultaneously.                                */
    479                  
    480                  /* Update ADC state machine to error */
    481                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADC_Init_8: (+1)
   \   0000008A   0x6AA3             LDR      R3,[R4, #+40]
   \   0000008C   0xF043 0x0320      ORR      R3,R3,#0x20
   \   00000090   0x62A3             STR      R3,[R4, #+40]
    482                  
    483                  /* Set ADC error code to ADC IP internal error */
    484                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   00000092   0x6AE3             LDR      R3,[R4, #+44]
   \   00000094   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000098   0x62E3             STR      R3,[R4, #+44]
    485                }
    486              }
    487              
    488              /* Update ADC configuration register CR1 with previous settings */
    489                MODIFY_REG(hadc->Instance->CR1,
    490                           ADC_CR1_SCAN    |
    491                           ADC_CR1_DISCEN  |
    492                           ADC_CR1_DISCNUM    ,
    493                           tmp_cr1             );
   \                     ??HAL_ADC_Init_7: (+1)
   \   0000009A   0x6823             LDR      R3,[R4, #+0]
   \   0000009C   0x685E             LDR      R6,[R3, #+4]
   \   0000009E   0xF426 0x4669      BIC      R6,R6,#0xE900
   \   000000A2   0x4332             ORRS     R2,R2,R6
   \   000000A4   0x605A             STR      R2,[R3, #+4]
    494              
    495              /* Update ADC configuration register CR2 with previous settings */
    496                MODIFY_REG(hadc->Instance->CR2,
    497                           ADC_CR2_ALIGN   |
    498                           ADC_CR2_EXTSEL  |
    499                           ADC_CR2_EXTTRIG |
    500                           ADC_CR2_CONT       ,
    501                           tmp_cr2             );
   \   000000A6   0x6822             LDR      R2,[R4, #+0]
   \   000000A8   0x6893             LDR      R3,[R2, #+8]
   \   000000AA   0x.... 0x....      LDR.W    R6,??DataTable8_1  ;; 0xffe1f7fd
   \   000000AE   0x4033             ANDS     R3,R6,R3
   \   000000B0   0x430B             ORRS     R3,R1,R3
   \   000000B2   0x6093             STR      R3,[R2, #+8]
    502          
    503              /* Configuration of regular group sequencer:                              */
    504              /* - if scan mode is disabled, regular channels sequence length is set to */
    505              /*   0x00: 1 channel converted (channel on regular rank 1)                */
    506              /*   Parameter "NbrOfConversion" is discarded.                            */
    507              /*   Note: Scan mode is present by hardware on this device and, if        */
    508              /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
    509              /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
    510              /* - if scan mode is enabled, regular channels sequence length is set to  */
    511              /*   parameter "NbrOfConversion"                                          */
    512              if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
   \   000000B4   0x68A2             LDR      R2,[R4, #+8]
   \   000000B6   0xF5B2 0x7F80      CMP      R2,#+256
   \   000000BA   0xD001             BEQ.N    ??HAL_ADC_Init_9
   \   000000BC   0x2A01             CMP      R2,#+1
   \   000000BE   0xD102             BNE.N    ??HAL_ADC_Init_10
   \                     ??HAL_ADC_Init_9: (+1)
   \   000000C0   0xF44F 0x7280      MOV      R2,#+256
   \   000000C4   0xE000             B.N      ??HAL_ADC_Init_11
   \                     ??HAL_ADC_Init_10: (+1)
   \   000000C6   0x462A             MOV      R2,R5
   \                     ??HAL_ADC_Init_11: (+1)
   \   000000C8   0xF5B2 0x7F80      CMP      R2,#+256
   \   000000CC   0xD102             BNE.N    ??HAL_ADC_Init_12
    513              {
    514                tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
   \   000000CE   0x6922             LDR      R2,[R4, #+16]
   \   000000D0   0x1E52             SUBS     R2,R2,#+1
   \   000000D2   0x0515             LSLS     R5,R2,#+20
    515              }
    516                
    517              MODIFY_REG(hadc->Instance->SQR1,
    518                         ADC_SQR1_L          ,
    519                         tmp_sqr1             );
   \                     ??HAL_ADC_Init_12: (+1)
   \   000000D4   0x6822             LDR      R2,[R4, #+0]
   \   000000D6   0x6AD3             LDR      R3,[R2, #+44]
   \   000000D8   0xF423 0x0370      BIC      R3,R3,#0xF00000
   \   000000DC   0x432B             ORRS     R3,R5,R3
   \   000000DE   0x62D3             STR      R3,[R2, #+44]
    520              
    521              /* Check back that ADC registers have effectively been configured to      */
    522              /* ensure of no potential problem of ADC core IP clocking.                */
    523              /* Check through register CR2 (excluding bits set in other functions:     */
    524              /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
    525              /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
    526              /* measurement path bit (TSVREFE).                                        */
    527              if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
    528                                                  ADC_CR2_SWSTART | ADC_CR2_JSWSTART |
    529                                                  ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL |
    530                                                  ADC_CR2_TSVREFE                     ))
    531                   == tmp_cr2)
   \   000000E0   0x6822             LDR      R2,[R4, #+0]
   \   000000E2   0x6892             LDR      R2,[R2, #+8]
   \   000000E4   0x.... 0x....      LDR.W    R3,??DataTable8_2  ;; 0xff1f0efe
   \   000000E8   0x401A             ANDS     R2,R3,R2
   \   000000EA   0x428A             CMP      R2,R1
   \   000000EC   0xD108             BNE.N    ??HAL_ADC_Init_13
    532              {
    533                /* Set ADC error code to none */
    534                ADC_CLEAR_ERRORCODE(hadc);
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0x62E1             STR      R1,[R4, #+44]
    535                
    536                /* Set the ADC state */
    537                ADC_STATE_CLR_SET(hadc->State,
    538                                  HAL_ADC_STATE_BUSY_INTERNAL,
    539                                  HAL_ADC_STATE_READY);
   \   000000F2   0x6AA1             LDR      R1,[R4, #+40]
   \   000000F4   0xF021 0x0102      BIC      R1,R1,#0x2
   \   000000F8   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000FC   0x62A1             STR      R1,[R4, #+40]
   \   000000FE   0xBD70             POP      {R4-R6,PC}
    540              }
    541              else
    542              {
    543                /* Update ADC state machine to error */
    544                ADC_STATE_CLR_SET(hadc->State,
    545                                  HAL_ADC_STATE_BUSY_INTERNAL,
    546                                  HAL_ADC_STATE_ERROR_INTERNAL);
   \                     ??HAL_ADC_Init_13: (+1)
   \   00000100   0x6AA0             LDR      R0,[R4, #+40]
   \   00000102   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000106   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000010A   0x62A0             STR      R0,[R4, #+40]
    547                
    548                /* Set ADC error code to ADC IP internal error */
    549                SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   0000010C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000010E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000112   0x62E0             STR      R0,[R4, #+44]
    550                
    551                tmp_hal_status = HAL_ERROR;
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0xBD70             POP      {R4-R6,PC}
    552              }
    553            
    554            }
    555            else
    556            {
    557              /* Update ADC state machine to error */
    558              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   \                     ??HAL_ADC_Init_2: (+1)
   \   00000118   0x6AA0             LDR      R0,[R4, #+40]
   \   0000011A   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000011E   0x62A0             STR      R0,[R4, #+40]
    559                  
    560              tmp_hal_status = HAL_ERROR;
   \   00000120   0x2001             MOVS     R0,#+1
    561            }
    562            
    563            /* Return function status */
    564            return tmp_hal_status;
   \   00000122   0xBD70             POP      {R4-R6,PC}       ;; return
    565          }
    566          
    567          /**
    568            * @brief  Deinitialize the ADC peripheral registers to their default reset
    569            *         values, with deinitialization of the ADC MSP.
    570            *         If needed, the example code can be copied and uncommented into
    571            *         function HAL_ADC_MspDeInit().
    572            * @param  hadc: ADC handle
    573            * @retval HAL status
    574            */

   \                                 In section .text, align 2, keep-with-next
    575          HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
    576          {
   \                     HAL_ADC_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    577            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    578            
    579            /* Check ADC handle */
    580            if(hadc == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_ADC_DeInit_0
    581            {
    582               return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    583            }
    584            
    585            /* Check the parameters */
    586            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    587            
    588            /* Set ADC state */
    589            SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
   \                     ??HAL_ADC_DeInit_0: (+1)
   \   0000000A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000000C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000010   0x62A0             STR      R0,[R4, #+40]
    590            
    591            /* Stop potential conversion on going, on regular and injected groups */
    592            /* Disable ADC peripheral */
    593            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       ADC_ConversionStop_Disable
   \   00000018   0x0005             MOVS     R5,R0
    594            
    595            
    596            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    597            /* correctly completed.                                                     */
    598            if (tmp_hal_status == HAL_OK)
   \   0000001A   0xD15B             BNE.N    ??HAL_ADC_DeInit_1
    599            {
    600              /* ========== Reset ADC registers ========== */
    601          
    602          
    603          
    604          
    605              /* Reset register SR */
    606              __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
    607                                          ADC_FLAG_JSTRT | ADC_FLAG_STRT));
   \   0000001C   0xF06F 0x001F      MVN      R0,#+31
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    608                                   
    609              /* Reset register CR1 */
    610              CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_AWDEN   | ADC_CR1_JAWDEN | ADC_CR1_DISCNUM | 
    611                                              ADC_CR1_JDISCEN | ADC_CR1_DISCEN | ADC_CR1_JAUTO   | 
    612                                              ADC_CR1_AWDSGL  | ADC_CR1_SCAN   | ADC_CR1_JEOCIE  |   
    613                                              ADC_CR1_AWDIE   | ADC_CR1_EOCIE  | ADC_CR1_AWDCH    ));
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6841             LDR      R1,[R0, #+4]
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0xff3f0000
   \   0000002C   0x4011             ANDS     R1,R2,R1
   \   0000002E   0x6041             STR      R1,[R0, #+4]
    614              
    615              /* Reset register CR2 */
    616              CLEAR_BIT(hadc->Instance->CR2, (ADC_CR2_TSVREFE | ADC_CR2_SWSTART | ADC_CR2_JSWSTART | 
    617                                              ADC_CR2_EXTTRIG | ADC_CR2_EXTSEL  | ADC_CR2_JEXTTRIG |  
    618                                              ADC_CR2_JEXTSEL | ADC_CR2_ALIGN   | ADC_CR2_DMA      |        
    619                                              ADC_CR2_RSTCAL  | ADC_CR2_CAL     | ADC_CR2_CONT     |          
    620                                              ADC_CR2_ADON                                          ));
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6881             LDR      R1,[R0, #+8]
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable8_4  ;; 0xff0106f0
   \   00000038   0x4011             ANDS     R1,R2,R1
   \   0000003A   0x6081             STR      R1,[R0, #+8]
    621              
    622              /* Reset register SMPR1 */
    623              CLEAR_BIT(hadc->Instance->SMPR1, (ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16 | ADC_SMPR1_SMP15 | 
    624                                                ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP12 | 
    625                                                ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10                    ));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0xF001 0x417F      AND      R1,R1,#0xFF000000
   \   00000044   0x60C1             STR      R1,[R0, #+12]
    626              
    627              /* Reset register SMPR2 */
    628              CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP9 | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | 
    629                                                ADC_SMPR2_SMP6 | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | 
    630                                                ADC_SMPR2_SMP3 | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | 
    631                                                ADC_SMPR2_SMP0                                    ));
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6901             LDR      R1,[R0, #+16]
   \   0000004A   0xF001 0x4140      AND      R1,R1,#0xC0000000
   \   0000004E   0x6101             STR      R1,[R0, #+16]
    632          
    633              /* Reset register JOFR1 */
    634              CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6941             LDR      R1,[R0, #+20]
   \   00000054   0x0B09             LSRS     R1,R1,#+12
   \   00000056   0x0309             LSLS     R1,R1,#+12
   \   00000058   0x6141             STR      R1,[R0, #+20]
    635              /* Reset register JOFR2 */
    636              CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6981             LDR      R1,[R0, #+24]
   \   0000005E   0x0B09             LSRS     R1,R1,#+12
   \   00000060   0x0309             LSLS     R1,R1,#+12
   \   00000062   0x6181             STR      R1,[R0, #+24]
    637              /* Reset register JOFR3 */
    638              CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x69C1             LDR      R1,[R0, #+28]
   \   00000068   0x0B09             LSRS     R1,R1,#+12
   \   0000006A   0x0309             LSLS     R1,R1,#+12
   \   0000006C   0x61C1             STR      R1,[R0, #+28]
    639              /* Reset register JOFR4 */
    640              CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6A01             LDR      R1,[R0, #+32]
   \   00000072   0x0B09             LSRS     R1,R1,#+12
   \   00000074   0x0309             LSLS     R1,R1,#+12
   \   00000076   0x6201             STR      R1,[R0, #+32]
    641              
    642              /* Reset register HTR */
    643              CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6A41             LDR      R1,[R0, #+36]
   \   0000007C   0x0B09             LSRS     R1,R1,#+12
   \   0000007E   0x0309             LSLS     R1,R1,#+12
   \   00000080   0x6241             STR      R1,[R0, #+36]
    644              /* Reset register LTR */
    645              CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6A81             LDR      R1,[R0, #+40]
   \   00000086   0x0B09             LSRS     R1,R1,#+12
   \   00000088   0x0309             LSLS     R1,R1,#+12
   \   0000008A   0x6281             STR      R1,[R0, #+40]
    646              
    647              /* Reset register SQR1 */
    648              CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
    649                                              ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
    650                                              ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000090   0xF001 0x417F      AND      R1,R1,#0xFF000000
   \   00000094   0x62C1             STR      R1,[R0, #+44]
    651              
    652              /* Reset register SQR1 */
    653              CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
    654                                              ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
    655                                              ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6AC1             LDR      R1,[R0, #+44]
   \   0000009A   0xF001 0x417F      AND      R1,R1,#0xFF000000
   \   0000009E   0x62C1             STR      R1,[R0, #+44]
    656              
    657              /* Reset register SQR2 */
    658              CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10 | 
    659                                              ADC_SQR2_SQ9  | ADC_SQR2_SQ8  | ADC_SQR2_SQ7   );
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6B01             LDR      R1,[R0, #+48]
   \   000000A4   0xF001 0x4140      AND      R1,R1,#0xC0000000
   \   000000A8   0x6301             STR      R1,[R0, #+48]
    660              
    661              /* Reset register SQR3 */
    662              CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4 | 
    663                                              ADC_SQR3_SQ3 | ADC_SQR3_SQ2 | ADC_SQR3_SQ1  );
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6B41             LDR      R1,[R0, #+52]
   \   000000AE   0xF001 0x4140      AND      R1,R1,#0xC0000000
   \   000000B2   0x6341             STR      R1,[R0, #+52]
    664              
    665              /* Reset register JSQR */
    666              CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
    667                                              ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
    668                                              ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6B81             LDR      R1,[R0, #+56]
   \   000000B8   0x0D89             LSRS     R1,R1,#+22
   \   000000BA   0x0589             LSLS     R1,R1,#+22
   \   000000BC   0x6381             STR      R1,[R0, #+56]
    669              
    670              /* Reset register JSQR */
    671              CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
    672                                              ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
    673                                              ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6B81             LDR      R1,[R0, #+56]
   \   000000C2   0x0D89             LSRS     R1,R1,#+22
   \   000000C4   0x0589             LSLS     R1,R1,#+22
   \   000000C6   0x6381             STR      R1,[R0, #+56]
    674              
    675              /* Reset register DR */
    676              /* bits in access mode read only, no direct reset applicable*/
    677              
    678              /* Reset registers JDR1, JDR2, JDR3, JDR4 */
    679              /* bits in access mode read only, no direct reset applicable*/
    680              
    681              /* ========== Hard reset ADC peripheral ========== */
    682              /* Performs a global reset of the entire ADC peripheral: ADC state is     */
    683              /* forced to a similar state after device power-on.                       */
    684              /* If needed, copy-paste and uncomment the following reset code into      */
    685              /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
    686              /*                                                                        */
    687              /*  __HAL_RCC_ADC1_FORCE_RESET()                                          */
    688              /*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */
    689              
    690              /* DeInit the low level hardware */
    691              HAL_ADC_MspDeInit(hadc);
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       HAL_ADC_MspDeInit
    692              
    693              /* Set ADC error code to none */
    694              ADC_CLEAR_ERRORCODE(hadc);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x62E0             STR      R0,[R4, #+44]
    695              
    696              /* Set ADC state */
    697              hadc->State = HAL_ADC_STATE_RESET; 
   \   000000D2   0x62A0             STR      R0,[R4, #+40]
    698            
    699            }
    700            
    701            /* Process unlocked */
    702            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_DeInit_1: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF884 0x0024      STRB     R0,[R4, #+36]
    703            
    704            /* Return function status */
    705            return tmp_hal_status;
   \   000000DA   0x4628             MOV      R0,R5
   \   000000DC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    706          }
    707          
    708          /**
    709            * @brief  Initializes the ADC MSP.
    710            * @param  hadc: ADC handle
    711            * @retval None
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
    714          {
    715            /* Prevent unused argument(s) compilation warning */
    716            UNUSED(hadc);
    717            /* NOTE : This function should not be modified. When the callback is needed,
    718                      function HAL_ADC_MspInit must be implemented in the user file.
    719             */ 
    720          }
   \                     HAL_ADC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    721          
    722          /**
    723            * @brief  DeInitializes the ADC MSP.
    724            * @param  hadc: ADC handle
    725            * @retval None
    726            */

   \                                 In section .text, align 2, keep-with-next
    727          __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
    728          {
    729            /* Prevent unused argument(s) compilation warning */
    730            UNUSED(hadc);
    731            /* NOTE : This function should not be modified. When the callback is needed,
    732                      function HAL_ADC_MspDeInit must be implemented in the user file.
    733             */ 
    734          }
   \                     HAL_ADC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    735          
    736          /**
    737            * @}
    738            */
    739          
    740          /** @defgroup ADC_Exported_Functions_Group2 IO operation functions
    741           *  @brief    Input and Output operation functions
    742           *
    743          @verbatim   
    744           ===============================================================================
    745                                ##### IO operation functions #####
    746           ===============================================================================
    747              [..]  This section provides functions allowing to:
    748                (+) Start conversion of regular group.
    749                (+) Stop conversion of regular group.
    750                (+) Poll for conversion complete on regular group.
    751                (+) Poll for conversion event.
    752                (+) Get result of regular channel conversion.
    753                (+) Start conversion of regular group and enable interruptions.
    754                (+) Stop conversion of regular group and disable interruptions.
    755                (+) Handle ADC interrupt request
    756                (+) Start conversion of regular group and enable DMA transfer.
    757                (+) Stop conversion of regular group and disable ADC DMA transfer.
    758          @endverbatim
    759            * @{
    760            */
    761          
    762          /**
    763            * @brief  Enables ADC, starts conversion of regular group.
    764            *         Interruptions enabled in this function: None.
    765            * @param  hadc: ADC handle
    766            * @retval HAL status
    767            */

   \                                 In section .text, align 2, keep-with-next
    768          HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
    769          {
   \                     HAL_ADC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    770            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    771            
    772            /* Check the parameters */
    773            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    774            
    775            /* Process locked */
    776            __HAL_LOCK(hadc);
   \   00000004   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_ADC_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_ADC_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0024      STRB     R0,[R4, #+36]
    777             
    778            /* Enable the ADC peripheral */
    779            tmp_hal_status = ADC_Enable(hadc);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       ADC_Enable
    780            
    781            /* Start conversion if ADC is effectively enabled */
    782            if (tmp_hal_status == HAL_OK)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD16F             BNE.N    ??HAL_ADC_Start_1
    783            {
    784              /* Set ADC state                                                          */
    785              /* - Clear state bitfield related to regular group conversion results     */
    786              /* - Set state bitfield related to regular operation                      */
    787              ADC_STATE_CLR_SET(hadc->State,
    788                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC,
    789                                HAL_ADC_STATE_REG_BUSY);
   \   00000020   0x6AA1             LDR      R1,[R4, #+40]
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable8_5  ;; 0xfffffdfe
   \   00000026   0x4011             ANDS     R1,R2,R1
   \   00000028   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000002C   0x62A1             STR      R1,[R4, #+40]
    790              
    791              /* Set group injected state (from auto-injection) and multimode state     */
    792              /* for all cases of multimode: independent mode, multimode ADC master     */
    793              /* or multimode ADC slave (for devices with several ADCs):                */
    794              if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x40012800
   \   00000032   0x6822             LDR      R2,[R4, #+0]
   \   00000034   0x428A             CMP      R2,R1
   \   00000036   0xD108             BNE.N    ??HAL_ADC_Start_2
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable8_7  ;; 0x40012404
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0xF402 0x2270      AND      R2,R2,#0xF0000
   \   00000042   0x1E52             SUBS     R2,R2,#+1
   \   00000044   0x4192             SBCS     R2,R2,R2
   \   00000046   0x0FD2             LSRS     R2,R2,#+31
   \   00000048   0xE000             B.N      ??HAL_ADC_Start_3
   \                     ??HAL_ADC_Start_2: (+1)
   \   0000004A   0x2201             MOVS     R2,#+1
   \                     ??HAL_ADC_Start_3: (+1)
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0x6AA2             LDR      R2,[R4, #+40]
   \   00000050   0xD00D             BEQ.N    ??HAL_ADC_Start_4
    795              {
    796                /* Set ADC state (ADC independent or master) */
    797                CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   \   00000052   0xF422 0x1280      BIC      R2,R2,#0x100000
   \   00000056   0x62A2             STR      R2,[R4, #+40]
    798                
    799                /* If conversions on group regular are also triggering group injected,  */
    800                /* update ADC state.                                                    */
    801                if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   00000058   0x6822             LDR      R2,[R4, #+0]
   \   0000005A   0x6852             LDR      R2,[R2, #+4]
   \   0000005C   0x0552             LSLS     R2,R2,#+21
   \   0000005E   0xD51F             BPL.N    ??HAL_ADC_Start_5
    802                {
    803                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   00000060   0x6AA2             LDR      R2,[R4, #+40]
   \   00000062   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000066   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000006A   0x62A2             STR      R2,[R4, #+40]
   \   0000006C   0xE018             B.N      ??HAL_ADC_Start_5
    804                }
    805              }
    806              else
    807              {
    808                /* Set ADC state (ADC slave) */
    809                SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   \                     ??HAL_ADC_Start_4: (+1)
   \   0000006E   0xF442 0x1280      ORR      R2,R2,#0x100000
   \   00000072   0x62A2             STR      R2,[R4, #+40]
    810                
    811                /* If conversions on group regular are also triggering group injected,  */
    812                /* update ADC state.                                                    */
    813                if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
   \   00000074   0x6822             LDR      R2,[R4, #+0]
   \   00000076   0x.... 0x....      LDR.W    R3,??DataTable8_8  ;; 0x40012400
   \   0000007A   0x429A             CMP      R2,R3
   \   0000007C   0xD001             BEQ.N    ??HAL_ADC_Start_6
   \   0000007E   0x428A             CMP      R2,R1
   \   00000080   0xD105             BNE.N    ??HAL_ADC_Start_7
   \                     ??HAL_ADC_Start_6: (+1)
   \   00000082   0x.... 0x....      LDR.W    R2,??DataTable8_7  ;; 0x40012404
   \   00000086   0x6812             LDR      R2,[R2, #+0]
   \   00000088   0xF402 0x6280      AND      R2,R2,#0x400
   \   0000008C   0xE000             B.N      ??HAL_ADC_Start_8
   \                     ??HAL_ADC_Start_7: (+1)
   \   0000008E   0x2200             MOVS     R2,#+0
   \                     ??HAL_ADC_Start_8: (+1)
   \   00000090   0x2A00             CMP      R2,#+0
   \   00000092   0xD005             BEQ.N    ??HAL_ADC_Start_5
    814                {
    815                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   0000009A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000009E   0x62A2             STR      R2,[R4, #+40]
    816                }
    817              }
    818              
    819              /* State machine update: Check if an injected conversion is ongoing */
    820              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_5: (+1)
   \   000000A0   0x6AA2             LDR      R2,[R4, #+40]
   \   000000A2   0x04D2             LSLS     R2,R2,#+19
   \   000000A4   0xD504             BPL.N    ??HAL_ADC_Start_9
    821              {
    822                /* Reset ADC error code fields related to conversions on group regular */
    823                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   000000A6   0x6AE2             LDR      R2,[R4, #+44]
   \   000000A8   0xF022 0x0206      BIC      R2,R2,#0x6
   \   000000AC   0x62E2             STR      R2,[R4, #+44]
   \   000000AE   0xE001             B.N      ??HAL_ADC_Start_10
    824              }
    825              else
    826              {
    827                /* Reset ADC all error code fields */
    828                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_9: (+1)
   \   000000B0   0x2200             MOVS     R2,#+0
   \   000000B2   0x62E2             STR      R2,[R4, #+44]
    829              }
    830              
    831              /* Process unlocked */
    832              /* Unlock before starting ADC conversions: in case of potential           */
    833              /* interruption, to let the process to ADC IRQ Handler.                   */
    834              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_10: (+1)
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0xF884 0x2024      STRB     R2,[R4, #+36]
    835            
    836              /* Clear regular group conversion flag */
    837              /* (To ensure of no unknown state from potential previous ADC operations) */
    838              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   000000BA   0xF06F 0x0202      MVN      R2,#+2
   \   000000BE   0x6823             LDR      R3,[R4, #+0]
   \   000000C0   0x601A             STR      R2,[R3, #+0]
    839              
    840              /* Enable conversion of regular group.                                    */
    841              /* If software start has been selected, conversion starts immediately.    */
    842              /* If external trigger has been selected, conversion will start at next   */
    843              /* trigger event.                                                         */
    844              /* Case of multimode enabled:                                             */ 
    845              /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
    846              /*  - if ADC is master, ADC is enabled and conversion is started.         */
    847              /* If ADC is master, ADC is enabled and conversion is started.            */
    848              /* Note: Alternate trigger for single conversion could be to force an     */
    849              /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
    850              if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
    851                  ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
   \   000000C2   0x6822             LDR      R2,[R4, #+0]
   \   000000C4   0x6893             LDR      R3,[R2, #+8]
   \   000000C6   0xF403 0x2360      AND      R3,R3,#0xE0000
   \   000000CA   0xF5B3 0x2F60      CMP      R3,#+917504
   \   000000CE   0xD112             BNE.N    ??HAL_ADC_Start_11
   \   000000D0   0x428A             CMP      R2,R1
   \   000000D2   0xD108             BNE.N    ??HAL_ADC_Start_12
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x40012404
   \   000000D8   0x6809             LDR      R1,[R1, #+0]
   \   000000DA   0xF401 0x2170      AND      R1,R1,#0xF0000
   \   000000DE   0x1E49             SUBS     R1,R1,#+1
   \   000000E0   0x4189             SBCS     R1,R1,R1
   \   000000E2   0x0FC9             LSRS     R1,R1,#+31
   \   000000E4   0xE000             B.N      ??HAL_ADC_Start_13
   \                     ??HAL_ADC_Start_12: (+1)
   \   000000E6   0x2101             MOVS     R1,#+1
   \                     ??HAL_ADC_Start_13: (+1)
   \   000000E8   0x2900             CMP      R1,#+0
   \   000000EA   0xD004             BEQ.N    ??HAL_ADC_Start_11
    852              {
    853                /* Start ADC conversion on regular group with SW start */
    854                SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
   \   000000EC   0x6891             LDR      R1,[R2, #+8]
   \   000000EE   0xF441 0x01A0      ORR      R1,R1,#0x500000
   \   000000F2   0x6091             STR      R1,[R2, #+8]
   \   000000F4   0xBD10             POP      {R4,PC}
    855              }
    856              else
    857              {
    858                /* Start ADC conversion on regular group with external trigger */
    859                SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
   \                     ??HAL_ADC_Start_11: (+1)
   \   000000F6   0x6891             LDR      R1,[R2, #+8]
   \   000000F8   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   000000FC   0x6091             STR      R1,[R2, #+8]
   \   000000FE   0xBD10             POP      {R4,PC}
    860              }
    861            }
    862            else
    863            {
    864              /* Process unlocked */
    865              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_1: (+1)
   \   00000100   0x2100             MOVS     R1,#+0
   \   00000102   0xF884 0x1024      STRB     R1,[R4, #+36]
    866            }
    867              
    868            /* Return function status */
    869            return tmp_hal_status;
   \   00000106   0xBD10             POP      {R4,PC}          ;; return
    870          }
    871          
    872          /**
    873            * @brief  Stop ADC conversion of regular group (and injected channels in 
    874            *         case of auto_injection mode), disable ADC peripheral.
    875            * @note:  ADC peripheral disable is forcing stop of potential 
    876            *         conversion on injected group. If injected group is under use, it
    877            *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
    878            * @param  hadc: ADC handle
    879            * @retval HAL status.
    880            */

   \                                 In section .text, align 2, keep-with-next
    881          HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
    882          {
   \                     HAL_ADC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    883            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    884            
    885            /* Check the parameters */
    886            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    887               
    888            /* Process locked */
    889            __HAL_LOCK(hadc);
   \   00000004   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_ADC_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_ADC_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0024      STRB     R0,[R4, #+36]
    890            
    891            /* Stop potential conversion on going, on regular and injected groups */
    892            /* Disable ADC peripheral */
    893            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       ADC_ConversionStop_Disable
    894            
    895            /* Check if ADC is effectively disabled */
    896            if (tmp_hal_status == HAL_OK)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE.N    ??HAL_ADC_Stop_1
    897            {
    898              /* Set ADC state */
    899              ADC_STATE_CLR_SET(hadc->State,
    900                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    901                                HAL_ADC_STATE_READY);
   \   00000020   0xF104 0x0124      ADD      R1,R4,#+36
   \   00000024   0x684A             LDR      R2,[R1, #+4]
   \   00000026   0xF422 0x5288      BIC      R2,R2,#0x1100
   \   0000002A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000002E   0x604A             STR      R2,[R1, #+4]
    902            }
    903            
    904            /* Process unlocked */
    905            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_1: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF884 0x1024      STRB     R1,[R4, #+36]
    906            
    907            /* Return function status */
    908            return tmp_hal_status;
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    909          }
    910          
    911          /**
    912            * @brief  Wait for regular group conversion to be completed.
    913            * @note   This function cannot be used in a particular setup: ADC configured 
    914            *         in DMA mode.
    915            *         In this case, DMA resets the flag EOC and polling cannot be
    916            *         performed on each conversion.
    917            * @note   On STM32F1 devices, limitation in case of sequencer enabled
    918            *         (several ranks selected): polling cannot be done on each 
    919            *         conversion inside the sequence. In this case, polling is replaced by
    920            *         wait for maximum conversion time.
    921            * @param  hadc: ADC handle
    922            * @param  Timeout: Timeout value in millisecond.
    923            * @retval HAL status
    924            */

   \                                 In section .text, align 2, keep-with-next
    925          HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    926          {
   \                     HAL_ADC_PollForConversion: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    927            uint32_t tickstart = 0;
    928            
    929            /* Variables for polling in case of scan mode enabled and polling for each  */
    930            /* conversion.                                                              */
    931            __IO uint32_t Conversion_Timeout_CPU_cycles = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    932            uint32_t Conversion_Timeout_CPU_cycles_max = 0;
    933           
    934            /* Check the parameters */
    935            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    936            
    937            /* Get tick count */
    938            tickstart = HAL_GetTick();
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x4606             MOV      R6,R0
    939            
    940            /* Verification that ADC configuration is compliant with polling for        */
    941            /* each conversion:                                                         */
    942            /* Particular case is ADC configured in DMA mode                            */
    943            if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6881             LDR      R1,[R0, #+8]
   \   00000014   0x05C9             LSLS     R1,R1,#+23
   \   00000016   0xD508             BPL.N    ??HAL_ADC_PollForConversion_0
    944            {
    945              /* Update ADC state machine to error */
    946              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \   00000018   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000001E   0x62A0             STR      R0,[R4, #+40]
    947              
    948              /* Process unlocked */
    949              __HAL_UNLOCK(hadc);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF884 0x0024      STRB     R0,[R4, #+36]
    950              
    951              return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
    952            }
    953            
    954            /* Polling for end of conversion: differentiation if single/sequence        */
    955            /* conversion.                                                              */
    956            /*  - If single conversion for regular group (Scan mode disabled or enabled */
    957            /*    with NbrOfConversion =1), flag EOC is used to determine the           */
    958            /*    conversion completion.                                                */
    959            /*  - If sequence conversion for regular group (scan mode enabled and       */
    960            /*    NbrOfConversion >=2), flag EOC is set only at the end of the          */
    961            /*    sequence.                                                             */
    962            /*    To poll for each conversion, the maximum conversion time is computed  */
    963            /*    from ADC conversion time (selected sampling time + conversion time of */
    964            /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
    965            /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
    966            /*    As flag EOC is not set after each conversion, no timeout status can   */
    967            /*    be set.                                                               */
    968            if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
    969                HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
   \                     ??HAL_ADC_PollForConversion_0: (+1)
   \   0000002A   0x6841             LDR      R1,[R0, #+4]
   \   0000002C   0x05C9             LSLS     R1,R1,#+23
   \   0000002E   0xD41A             BMI.N    ??HAL_ADC_PollForConversion_1
   \   00000030   0x6AC0             LDR      R0,[R0, #+44]
   \   00000032   0xF410 0x0F70      TST      R0,#0xF00000
   \   00000036   0xD116             BNE.N    ??HAL_ADC_PollForConversion_1
    970            {
    971              /* Wait until End of Conversion flag is raised */
    972              while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
   \                     ??HAL_ADC_PollForConversion_2: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0780             LSLS     R0,R0,#+30
   \   0000003E   0xD464             BMI.N    ??HAL_ADC_PollForConversion_3
    973              {
    974                /* Check if timeout is disabled (set to infinite wait) */
    975                if(Timeout != HAL_MAX_DELAY)
   \   00000040   0xF115 0x0F01      CMN      R5,#+1
   \   00000044   0xD0F8             BEQ.N    ??HAL_ADC_PollForConversion_2
    976                {
    977                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD004             BEQ.N    ??HAL_ADC_PollForConversion_4
   \   0000004A   0x.... 0x....      BL       HAL_GetTick
   \   0000004E   0x1B80             SUBS     R0,R0,R6
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD2F1             BCS.N    ??HAL_ADC_PollForConversion_2
    978                  {
    979                    /* Update ADC state machine to timeout */
    980                    SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADC_PollForConversion_4: (+1)
   \   00000054   0x6AA0             LDR      R0,[R4, #+40]
   \   00000056   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000005A   0x62A0             STR      R0,[R4, #+40]
    981                    
    982                    /* Process unlocked */
    983                    __HAL_UNLOCK(hadc);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF884 0x0024      STRB     R0,[R4, #+36]
    984                    
    985                    return HAL_TIMEOUT;
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}
    986                  }
    987                }
    988              }
    989            }
    990            else
    991            {
    992              /* Replace polling by wait for maximum conversion time */
    993              /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
    994              /*    and ADC maximum conversion cycles on all channels.                  */
    995              /*  - Wait for the expected ADC clock cycles delay                        */
    996              Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
    997                                                    / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
    998                                                   * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
   \                     ??HAL_ADC_PollForConversion_1: (+1)
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       HAL_RCCEx_GetPeriphCLKFreq
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x690A             LDR      R2,[R1, #+16]
   \   00000070   0x.... 0x....      LDR.W    R3,??DataTable8_9  ;; 0x24924924
   \   00000074   0x421A             TST      R2,R3
   \   00000076   0xD112             BNE.N    ??HAL_ADC_PollForConversion_5
   \   00000078   0x68CA             LDR      R2,[R1, #+12]
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable8_10  ;; 0x924924
   \   0000007E   0x421A             TST      R2,R3
   \   00000080   0xD10D             BNE.N    ??HAL_ADC_PollForConversion_5
   \   00000082   0x690A             LDR      R2,[R1, #+16]
   \   00000084   0x.... 0x....      LDR.W    R3,??DataTable8_11  ;; 0x12492492
   \   00000088   0x421A             TST      R2,R3
   \   0000008A   0xD106             BNE.N    ??HAL_ADC_PollForConversion_6
   \   0000008C   0x68C9             LDR      R1,[R1, #+12]
   \   0000008E   0x.... 0x....      LDR.W    R2,??DataTable8_12  ;; 0x492492
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD101             BNE.N    ??HAL_ADC_PollForConversion_6
   \   00000096   0x2114             MOVS     R1,#+20
   \   00000098   0xE016             B.N      ??HAL_ADC_PollForConversion_7
   \                     ??HAL_ADC_PollForConversion_6: (+1)
   \   0000009A   0x2129             MOVS     R1,#+41
   \   0000009C   0xE014             B.N      ??HAL_ADC_PollForConversion_7
   \                     ??HAL_ADC_PollForConversion_5: (+1)
   \   0000009E   0x690A             LDR      R2,[R1, #+16]
   \   000000A0   0x.... 0x....      LDR.W    R3,??DataTable8_11  ;; 0x12492492
   \   000000A4   0x421A             TST      R2,R3
   \   000000A6   0xD104             BNE.N    ??HAL_ADC_PollForConversion_8
   \   000000A8   0x68CA             LDR      R2,[R1, #+12]
   \   000000AA   0x.... 0x....      LDR.W    R3,??DataTable8_12  ;; 0x492492
   \   000000AE   0x421A             TST      R2,R3
   \   000000B0   0xD007             BEQ.N    ??HAL_ADC_PollForConversion_9
   \                     ??HAL_ADC_PollForConversion_8: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable8_13  ;; 0x249249
   \   000000B6   0x690B             LDR      R3,[R1, #+16]
   \   000000B8   0x4213             TST      R3,R2
   \   000000BA   0xD104             BNE.N    ??HAL_ADC_PollForConversion_10
   \   000000BC   0x68C9             LDR      R1,[R1, #+12]
   \   000000BE   0x4211             TST      R1,R2
   \   000000C0   0xD101             BNE.N    ??HAL_ADC_PollForConversion_10
   \                     ??HAL_ADC_PollForConversion_9: (+1)
   \   000000C2   0x2154             MOVS     R1,#+84
   \   000000C4   0xE000             B.N      ??HAL_ADC_PollForConversion_7
   \                     ??HAL_ADC_PollForConversion_10: (+1)
   \   000000C6   0x21FC             MOVS     R1,#+252
   \                     ??HAL_ADC_PollForConversion_7: (+1)
   \   000000C8   0x.... 0x....      LDR.W    R2,??DataTable8_14
   \   000000CC   0x6812             LDR      R2,[R2, #+0]
   \   000000CE   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   000000D2   0xFB01 0xF700      MUL      R7,R1,R0
   \   000000D6   0xE002             B.N      ??HAL_ADC_PollForConversion_11
    999              
   1000              while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
   1001              {
   1002                /* Check if timeout is disabled (set to infinite wait) */
   1003                if(Timeout != HAL_MAX_DELAY)
   1004                {
   1005                  if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
   1006                  {
   1007                    /* Update ADC state machine to timeout */
   1008                    SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   1009                    
   1010                    /* Process unlocked */
   1011                    __HAL_UNLOCK(hadc);
   1012                    
   1013                    return HAL_TIMEOUT;
   1014                  }
   1015                }
   1016                Conversion_Timeout_CPU_cycles ++;
   \                     ??HAL_ADC_PollForConversion_12: (+1)
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \                     ??HAL_ADC_PollForConversion_11: (+1)
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x42B8             CMP      R0,R7
   \   000000E2   0xD212             BCS.N    ??HAL_ADC_PollForConversion_3
   \   000000E4   0xF115 0x0F01      CMN      R5,#+1
   \   000000E8   0xD0F6             BEQ.N    ??HAL_ADC_PollForConversion_12
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xD004             BEQ.N    ??HAL_ADC_PollForConversion_13
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x1B80             SUBS     R0,R0,R6
   \   000000F4   0x4285             CMP      R5,R0
   \   000000F6   0xD2EF             BCS.N    ??HAL_ADC_PollForConversion_12
   \                     ??HAL_ADC_PollForConversion_13: (+1)
   \   000000F8   0x6AA0             LDR      R0,[R4, #+40]
   \   000000FA   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000FE   0x62A0             STR      R0,[R4, #+40]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   00000106   0x2003             MOVS     R0,#+3
   \   00000108   0xBDF2             POP      {R1,R4-R7,PC}
   1017              }
   1018            }
   1019            
   1020            /* Clear regular group conversion flag */
   1021            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   \                     ??HAL_ADC_PollForConversion_3: (+1)
   \   0000010A   0xF06F 0x0012      MVN      R0,#+18
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0x6008             STR      R0,[R1, #+0]
   1022            
   1023            /* Update ADC state machine */
   1024            SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \   00000112   0x6AA0             LDR      R0,[R4, #+40]
   \   00000114   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000118   0x62A0             STR      R0,[R4, #+40]
   1025            
   1026            /* Determine whether any further conversion upcoming on group regular       */
   1027            /* by external trigger, continuous mode or scan sequence on going.          */
   1028            /* Note: On STM32F1 devices, in case of sequencer enabled                   */
   1029            /*       (several ranks selected), end of conversion flag is raised         */
   1030            /*       at the end of the sequence.                                        */
   1031            if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
   1032               (hadc->Init.ContinuousConvMode == DISABLE)   )
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6880             LDR      R0,[R0, #+8]
   \   0000011E   0xF400 0x2060      AND      R0,R0,#0xE0000
   \   00000122   0xF5B0 0x2F60      CMP      R0,#+917504
   \   00000126   0xD10D             BNE.N    ??HAL_ADC_PollForConversion_14
   \   00000128   0x68E0             LDR      R0,[R4, #+12]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD10A             BNE.N    ??HAL_ADC_PollForConversion_14
   1033            {   
   1034              /* Set ADC state */
   1035              CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \   0000012E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000130   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000134   0x62A0             STR      R0,[R4, #+40]
   1036          
   1037              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   00000136   0x6AA0             LDR      R0,[R4, #+40]
   \   00000138   0x04C0             LSLS     R0,R0,#+19
   \   0000013A   0xD403             BMI.N    ??HAL_ADC_PollForConversion_14
   1038              { 
   1039                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   0000013C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000013E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000142   0x62A0             STR      R0,[R4, #+40]
   1040              }
   1041            }
   1042            
   1043            /* Return ADC state */
   1044            return HAL_OK;
   \                     ??HAL_ADC_PollForConversion_14: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1045          }
   1046          
   1047          /**
   1048            * @brief  Poll for conversion event.
   1049            * @param  hadc: ADC handle
   1050            * @param  EventType: the ADC event type.
   1051            *          This parameter can be one of the following values:
   1052            *            @arg ADC_AWD_EVENT: ADC Analog watchdog event.
   1053            * @param  Timeout: Timeout value in millisecond.
   1054            * @retval HAL status
   1055            */

   \                                 In section .text, align 2, keep-with-next
   1056          HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
   1057          {
   \                     HAL_ADC_PollForEvent: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1058            uint32_t tickstart = 0; 
   1059          
   1060            /* Check the parameters */
   1061            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1062            assert_param(IS_ADC_EVENT_TYPE(EventType));
   1063            
   1064            /* Get tick count */
   1065            tickstart = HAL_GetTick();
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x4607             MOV      R7,R0
   1066            
   1067            /* Check selected event flag */
   1068            while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
   \                     ??HAL_ADC_PollForEvent_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x4028             ANDS     R0,R5,R0
   \   00000014   0x42A8             CMP      R0,R5
   \   00000016   0xD012             BEQ.N    ??HAL_ADC_PollForEvent_1
   1069            {
   1070              /* Check if timeout is disabled (set to infinite wait) */
   1071              if(Timeout != HAL_MAX_DELAY)
   \   00000018   0xF116 0x0F01      CMN      R6,#+1
   \   0000001C   0xD0F7             BEQ.N    ??HAL_ADC_PollForEvent_0
   1072              {
   1073                if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD004             BEQ.N    ??HAL_ADC_PollForEvent_2
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x1BC0             SUBS     R0,R0,R7
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD2F0             BCS.N    ??HAL_ADC_PollForEvent_0
   1074                {
   1075                  /* Update ADC state machine to timeout */
   1076                  SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADC_PollForEvent_2: (+1)
   \   0000002C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002E   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000032   0x62A0             STR      R0,[R4, #+40]
   1077                  
   1078                  /* Process unlocked */
   1079                  __HAL_UNLOCK(hadc);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0024      STRB     R0,[R4, #+36]
   1080                  
   1081                  return HAL_TIMEOUT;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}
   1082                }
   1083              }
   1084            }
   1085            
   1086            /* Analog watchdog (level out of window) event */
   1087            /* Set ADC state */
   1088            SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   \                     ??HAL_ADC_PollForEvent_1: (+1)
   \   0000003E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000040   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000044   0x62A0             STR      R0,[R4, #+40]
   1089              
   1090            /* Clear ADC analog watchdog flag */
   1091            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   \   00000046   0xF06F 0x0001      MVN      R0,#+1
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1092            
   1093            /* Return ADC state */
   1094            return HAL_OK;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1095          }
   1096          
   1097          /**
   1098            * @brief  Enables ADC, starts conversion of regular group with interruption.
   1099            *         Interruptions enabled in this function:
   1100            *          - EOC (end of conversion of regular group)
   1101            *         Each of these interruptions has its dedicated callback function.
   1102            * @param  hadc: ADC handle
   1103            * @retval HAL status
   1104            */

   \                                 In section .text, align 2, keep-with-next
   1105          HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
   1106          {
   \                     HAL_ADC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1107            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1108            
   1109            /* Check the parameters */
   1110            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1111            
   1112            /* Process locked */
   1113            __HAL_LOCK(hadc);
   \   00000004   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_ADC_Start_IT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_ADC_Start_IT_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0024      STRB     R0,[R4, #+36]
   1114              
   1115            /* Enable the ADC peripheral */
   1116            tmp_hal_status = ADC_Enable(hadc);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       ADC_Enable
   1117            
   1118            /* Start conversion if ADC is effectively enabled */
   1119            if (tmp_hal_status == HAL_OK)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD174             BNE.N    ??HAL_ADC_Start_IT_1
   1120            {
   1121              /* Set ADC state                                                          */
   1122              /* - Clear state bitfield related to regular group conversion results     */
   1123              /* - Set state bitfield related to regular operation                      */
   1124              ADC_STATE_CLR_SET(hadc->State,
   1125                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
   1126                                HAL_ADC_STATE_REG_BUSY);
   \   00000020   0x6AA1             LDR      R1,[R4, #+40]
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable8_15  ;; 0xfffff1fe
   \   00000026   0x4011             ANDS     R1,R2,R1
   \   00000028   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000002C   0x62A1             STR      R1,[R4, #+40]
   1127              
   1128              /* Set group injected state (from auto-injection) and multimode state     */
   1129              /* for all cases of multimode: independent mode, multimode ADC master     */
   1130              /* or multimode ADC slave (for devices with several ADCs):                */
   1131              if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x40012800
   \   00000032   0x6822             LDR      R2,[R4, #+0]
   \   00000034   0x428A             CMP      R2,R1
   \   00000036   0xD108             BNE.N    ??HAL_ADC_Start_IT_2
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable8_7  ;; 0x40012404
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0xF402 0x2270      AND      R2,R2,#0xF0000
   \   00000042   0x1E52             SUBS     R2,R2,#+1
   \   00000044   0x4192             SBCS     R2,R2,R2
   \   00000046   0x0FD2             LSRS     R2,R2,#+31
   \   00000048   0xE000             B.N      ??HAL_ADC_Start_IT_3
   \                     ??HAL_ADC_Start_IT_2: (+1)
   \   0000004A   0x2201             MOVS     R2,#+1
   \                     ??HAL_ADC_Start_IT_3: (+1)
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0x6AA2             LDR      R2,[R4, #+40]
   \   00000050   0xD00D             BEQ.N    ??HAL_ADC_Start_IT_4
   1132              {
   1133                /* Set ADC state (ADC independent or master) */
   1134                CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   \   00000052   0xF422 0x1280      BIC      R2,R2,#0x100000
   \   00000056   0x62A2             STR      R2,[R4, #+40]
   1135                
   1136                /* If conversions on group regular are also triggering group injected,  */
   1137                /* update ADC state.                                                    */
   1138                if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   00000058   0x6822             LDR      R2,[R4, #+0]
   \   0000005A   0x6852             LDR      R2,[R2, #+4]
   \   0000005C   0x0552             LSLS     R2,R2,#+21
   \   0000005E   0xD51F             BPL.N    ??HAL_ADC_Start_IT_5
   1139                {
   1140                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   00000060   0x6AA2             LDR      R2,[R4, #+40]
   \   00000062   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000066   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000006A   0x62A2             STR      R2,[R4, #+40]
   \   0000006C   0xE018             B.N      ??HAL_ADC_Start_IT_5
   1141                }
   1142              }
   1143              else
   1144              {
   1145                /* Set ADC state (ADC slave) */
   1146                SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   \                     ??HAL_ADC_Start_IT_4: (+1)
   \   0000006E   0xF442 0x1280      ORR      R2,R2,#0x100000
   \   00000072   0x62A2             STR      R2,[R4, #+40]
   1147                
   1148                /* If conversions on group regular are also triggering group injected,  */
   1149                /* update ADC state.                                                    */
   1150                if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
   \   00000074   0x6822             LDR      R2,[R4, #+0]
   \   00000076   0x.... 0x....      LDR.W    R3,??DataTable8_8  ;; 0x40012400
   \   0000007A   0x429A             CMP      R2,R3
   \   0000007C   0xD001             BEQ.N    ??HAL_ADC_Start_IT_6
   \   0000007E   0x428A             CMP      R2,R1
   \   00000080   0xD105             BNE.N    ??HAL_ADC_Start_IT_7
   \                     ??HAL_ADC_Start_IT_6: (+1)
   \   00000082   0x.... 0x....      LDR.W    R2,??DataTable8_7  ;; 0x40012404
   \   00000086   0x6812             LDR      R2,[R2, #+0]
   \   00000088   0xF402 0x6280      AND      R2,R2,#0x400
   \   0000008C   0xE000             B.N      ??HAL_ADC_Start_IT_8
   \                     ??HAL_ADC_Start_IT_7: (+1)
   \   0000008E   0x2200             MOVS     R2,#+0
   \                     ??HAL_ADC_Start_IT_8: (+1)
   \   00000090   0x2A00             CMP      R2,#+0
   \   00000092   0xD005             BEQ.N    ??HAL_ADC_Start_IT_5
   1151                {
   1152                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   0000009A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000009E   0x62A2             STR      R2,[R4, #+40]
   1153                }
   1154              }
   1155              
   1156              /* State machine update: Check if an injected conversion is ongoing */
   1157              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_IT_5: (+1)
   \   000000A0   0x6AA2             LDR      R2,[R4, #+40]
   \   000000A2   0x04D2             LSLS     R2,R2,#+19
   \   000000A4   0xD504             BPL.N    ??HAL_ADC_Start_IT_9
   1158              {
   1159                /* Reset ADC error code fields related to conversions on group regular */
   1160                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   000000A6   0x6AE2             LDR      R2,[R4, #+44]
   \   000000A8   0xF022 0x0206      BIC      R2,R2,#0x6
   \   000000AC   0x62E2             STR      R2,[R4, #+44]
   \   000000AE   0xE001             B.N      ??HAL_ADC_Start_IT_10
   1161              }
   1162              else
   1163              {
   1164                /* Reset ADC all error code fields */
   1165                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_IT_9: (+1)
   \   000000B0   0x2200             MOVS     R2,#+0
   \   000000B2   0x62E2             STR      R2,[R4, #+44]
   1166              }
   1167              
   1168              /* Process unlocked */
   1169              /* Unlock before starting ADC conversions: in case of potential           */
   1170              /* interruption, to let the process to ADC IRQ Handler.                   */
   1171              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_IT_10: (+1)
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0xF884 0x2024      STRB     R2,[R4, #+36]
   1172              
   1173              /* Clear regular group conversion flag and overrun flag */
   1174              /* (To ensure of no unknown state from potential previous ADC operations) */
   1175              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   000000BA   0xF06F 0x0202      MVN      R2,#+2
   \   000000BE   0x6823             LDR      R3,[R4, #+0]
   \   000000C0   0x601A             STR      R2,[R3, #+0]
   1176              
   1177              /* Enable end of conversion interrupt for regular group */
   1178              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
   \   000000C2   0x6822             LDR      R2,[R4, #+0]
   \   000000C4   0x6853             LDR      R3,[R2, #+4]
   \   000000C6   0xF043 0x0320      ORR      R3,R3,#0x20
   \   000000CA   0x6053             STR      R3,[R2, #+4]
   1179              
   1180              /* Enable conversion of regular group.                                    */
   1181              /* If software start has been selected, conversion starts immediately.    */
   1182              /* If external trigger has been selected, conversion will start at next   */
   1183              /* trigger event.                                                         */
   1184              /* Case of multimode enabled:                                             */ 
   1185              /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
   1186              /*  - if ADC is master, ADC is enabled and conversion is started.         */
   1187              if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
   1188                  ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
   \   000000CC   0x6822             LDR      R2,[R4, #+0]
   \   000000CE   0x6893             LDR      R3,[R2, #+8]
   \   000000D0   0xF403 0x2360      AND      R3,R3,#0xE0000
   \   000000D4   0xF5B3 0x2F60      CMP      R3,#+917504
   \   000000D8   0xD112             BNE.N    ??HAL_ADC_Start_IT_11
   \   000000DA   0x428A             CMP      R2,R1
   \   000000DC   0xD108             BNE.N    ??HAL_ADC_Start_IT_12
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x40012404
   \   000000E2   0x6809             LDR      R1,[R1, #+0]
   \   000000E4   0xF401 0x2170      AND      R1,R1,#0xF0000
   \   000000E8   0x1E49             SUBS     R1,R1,#+1
   \   000000EA   0x4189             SBCS     R1,R1,R1
   \   000000EC   0x0FC9             LSRS     R1,R1,#+31
   \   000000EE   0xE000             B.N      ??HAL_ADC_Start_IT_13
   \                     ??HAL_ADC_Start_IT_12: (+1)
   \   000000F0   0x2101             MOVS     R1,#+1
   \                     ??HAL_ADC_Start_IT_13: (+1)
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD004             BEQ.N    ??HAL_ADC_Start_IT_11
   1189              {
   1190                /* Start ADC conversion on regular group with SW start */
   1191                SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
   \   000000F6   0x6891             LDR      R1,[R2, #+8]
   \   000000F8   0xF441 0x01A0      ORR      R1,R1,#0x500000
   \   000000FC   0x6091             STR      R1,[R2, #+8]
   \   000000FE   0xBD10             POP      {R4,PC}
   1192              }
   1193              else
   1194              {
   1195                /* Start ADC conversion on regular group with external trigger */
   1196                SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
   \                     ??HAL_ADC_Start_IT_11: (+1)
   \   00000100   0x6891             LDR      R1,[R2, #+8]
   \   00000102   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   00000106   0x6091             STR      R1,[R2, #+8]
   \   00000108   0xBD10             POP      {R4,PC}
   1197              }
   1198            }
   1199            else
   1200            {
   1201              /* Process unlocked */
   1202              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_IT_1: (+1)
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0xF884 0x1024      STRB     R1,[R4, #+36]
   1203            }
   1204            
   1205            /* Return function status */
   1206            return tmp_hal_status;
   \   00000110   0xBD10             POP      {R4,PC}          ;; return
   1207          }
   1208          
   1209          /**
   1210            * @brief  Stop ADC conversion of regular group (and injected group in 
   1211            *         case of auto_injection mode), disable interrution of 
   1212            *         end-of-conversion, disable ADC peripheral.
   1213            * @param  hadc: ADC handle
   1214            * @retval None
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216          HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
   1217          {
   \                     HAL_ADC_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1218            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1219            
   1220            /* Check the parameters */
   1221            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1222               
   1223            /* Process locked */
   1224            __HAL_LOCK(hadc);
   \   00000004   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_ADC_Stop_IT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_ADC_Stop_IT_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0024      STRB     R0,[R4, #+36]
   1225            
   1226            /* Stop potential conversion on going, on regular and injected groups */
   1227            /* Disable ADC peripheral */
   1228            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       ADC_ConversionStop_Disable
   1229            
   1230            /* Check if ADC is effectively disabled */
   1231            if (tmp_hal_status == HAL_OK)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10A             BNE.N    ??HAL_ADC_Stop_IT_1
   1232            {
   1233              /* Disable ADC end of conversion interrupt for regular group */
   1234              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x684A             LDR      R2,[R1, #+4]
   \   00000024   0xF022 0x0220      BIC      R2,R2,#0x20
   \   00000028   0x604A             STR      R2,[R1, #+4]
   1235              
   1236              /* Set ADC state */
   1237              ADC_STATE_CLR_SET(hadc->State,
   1238                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1239                                HAL_ADC_STATE_READY);
   \   0000002A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000002C   0xF421 0x5188      BIC      R1,R1,#0x1100
   \   00000030   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000034   0x62A1             STR      R1,[R4, #+40]
   1240            }
   1241            
   1242            /* Process unlocked */
   1243            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_IT_1: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF884 0x1024      STRB     R1,[R4, #+36]
   1244            
   1245            /* Return function status */
   1246            return tmp_hal_status;
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1247          }
   1248          
   1249          /**
   1250            * @brief  Enables ADC, starts conversion of regular group and transfers result
   1251            *         through DMA.
   1252            *         Interruptions enabled in this function:
   1253            *          - DMA transfer complete
   1254            *          - DMA half transfer
   1255            *         Each of these interruptions has its dedicated callback function.
   1256            * @note   For devices with several ADCs: This function is for single-ADC mode 
   1257            *         only. For multimode, use the dedicated MultimodeStart function.
   1258            * @note   On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending
   1259            *         on devices) have DMA capability.
   1260            *         ADC2 converted data can be transferred in dual ADC mode using DMA
   1261            *         of ADC1 (ADC master in multimode).
   1262            *         In case of using ADC1 with DMA on a device featuring 2 ADC
   1263            *         instances: ADC1 conversion register DR contains ADC1 conversion 
   1264            *         result (ADC1 register DR bits 0 to 11) and, additionally, ADC2 last
   1265            *         conversion result (ADC1 register DR bits 16 to 27). Therefore, to
   1266            *         have DMA transferring the conversion results of ADC1 only, DMA must
   1267            *         be configured to transfer size: half word.
   1268            * @param  hadc: ADC handle
   1269            * @param  pData: The destination Buffer address.
   1270            * @param  Length: The length of data to be transferred from ADC peripheral to memory.
   1271            * @retval None
   1272            */

   \                                 In section .text, align 2, keep-with-next
   1273          HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
   1274          {
   \                     HAL_ADC_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   1275            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1276            
   1277            /* Check the parameters */
   1278            assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
   1279              
   1280            /* Verification if multimode is disabled (for devices with several ADC)     */
   1281            /* If multimode is enabled, dedicated function multimode conversion         */
   1282            /* start DMA must be used.                                                  */
   1283            if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable8_8  ;; 0x40012400
   \   00000010   0x42B8             CMP      R0,R7
   \   00000012   0xD003             BEQ.N    ??HAL_ADC_Start_DMA_0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x40012800
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD105             BNE.N    ??HAL_ADC_Start_DMA_1
   \                     ??HAL_ADC_Start_DMA_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x40012404
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF400 0x2070      AND      R0,R0,#0xF0000
   \   00000026   0xE000             B.N      ??HAL_ADC_Start_DMA_2
   \                     ??HAL_ADC_Start_DMA_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Start_DMA_2: (+1)
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF040 0x808D      BNE.W    ??HAL_ADC_Start_DMA_3
   1284            {
   1285              /* Process locked */
   1286              __HAL_LOCK(hadc);
   \   00000030   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_ADC_Start_DMA_4
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE089             B.N      ??HAL_ADC_Start_DMA_5
   \                     ??HAL_ADC_Start_DMA_4: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF884 0x0024      STRB     R0,[R4, #+36]
   1287              
   1288              /* Enable the ADC peripheral */
   1289              tmp_hal_status = ADC_Enable(hadc);
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       ADC_Enable
   \   00000048   0x4680             MOV      R8,R0
   1290              
   1291              /* Start conversion if ADC is effectively enabled */
   1292              if (tmp_hal_status == HAL_OK)
   \   0000004A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004E   0xD178             BNE.N    ??HAL_ADC_Start_DMA_6
   1293              {
   1294                /* Set ADC state                                                        */
   1295                /* - Clear state bitfield related to regular group conversion results   */
   1296                /* - Set state bitfield related to regular operation                    */
   1297                ADC_STATE_CLR_SET(hadc->State,
   1298                                  HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
   1299                                  HAL_ADC_STATE_REG_BUSY);
   \   00000050   0x6AA0             LDR      R0,[R4, #+40]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable8_15  ;; 0xfffff1fe
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000005C   0x62A0             STR      R0,[R4, #+40]
   1300              
   1301              /* Set group injected state (from auto-injection) and multimode state     */
   1302              /* for all cases of multimode: independent mode, multimode ADC master     */
   1303              /* or multimode ADC slave (for devices with several ADCs):                */
   1304              if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x40012800
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD108             BNE.N    ??HAL_ADC_Start_DMA_7
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x40012404
   \   0000006C   0x6809             LDR      R1,[R1, #+0]
   \   0000006E   0xF401 0x2170      AND      R1,R1,#0xF0000
   \   00000072   0x1E49             SUBS     R1,R1,#+1
   \   00000074   0x4189             SBCS     R1,R1,R1
   \   00000076   0x0FC9             LSRS     R1,R1,#+31
   \   00000078   0xE000             B.N      ??HAL_ADC_Start_DMA_8
   \                     ??HAL_ADC_Start_DMA_7: (+1)
   \   0000007A   0x2101             MOVS     R1,#+1
   \                     ??HAL_ADC_Start_DMA_8: (+1)
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD00E             BEQ.N    ??HAL_ADC_Start_DMA_9
   1305              {
   1306                /* Set ADC state (ADC independent or master) */
   1307                CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   \   00000080   0x6AA0             LDR      R0,[R4, #+40]
   \   00000082   0xF420 0x1080      BIC      R0,R0,#0x100000
   \   00000086   0x62A0             STR      R0,[R4, #+40]
   1308                
   1309                /* If conversions on group regular are also triggering group injected,  */
   1310                /* update ADC state.                                                    */
   1311                if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0x0540             LSLS     R0,R0,#+21
   \   0000008E   0xD51E             BPL.N    ??HAL_ADC_Start_DMA_10
   1312                {
   1313                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   00000090   0x6AA0             LDR      R0,[R4, #+40]
   \   00000092   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   00000096   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000009A   0x62A0             STR      R0,[R4, #+40]
   \   0000009C   0xE017             B.N      ??HAL_ADC_Start_DMA_10
   1314                }
   1315              }
   1316              else
   1317              {
   1318                /* Set ADC state (ADC slave) */
   1319                SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   \                     ??HAL_ADC_Start_DMA_9: (+1)
   \   0000009E   0x6AA1             LDR      R1,[R4, #+40]
   \   000000A0   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   000000A4   0x62A1             STR      R1,[R4, #+40]
   1320                
   1321                /* If conversions on group regular are also triggering group injected,  */
   1322                /* update ADC state.                                                    */
   1323                if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x42B9             CMP      R1,R7
   \   000000AA   0xD001             BEQ.N    ??HAL_ADC_Start_DMA_11
   \   000000AC   0x4281             CMP      R1,R0
   \   000000AE   0xD105             BNE.N    ??HAL_ADC_Start_DMA_12
   \                     ??HAL_ADC_Start_DMA_11: (+1)
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x40012404
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF400 0x6080      AND      R0,R0,#0x400
   \   000000BA   0xE000             B.N      ??HAL_ADC_Start_DMA_13
   \                     ??HAL_ADC_Start_DMA_12: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Start_DMA_13: (+1)
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD005             BEQ.N    ??HAL_ADC_Start_DMA_10
   1324                {
   1325                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   000000C8   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   000000CC   0x62A0             STR      R0,[R4, #+40]
   1326                }
   1327              }
   1328                
   1329                /* State machine update: Check if an injected conversion is ongoing */
   1330                if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_DMA_10: (+1)
   \   000000CE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D0   0x04C0             LSLS     R0,R0,#+19
   \   000000D2   0xD504             BPL.N    ??HAL_ADC_Start_DMA_14
   1331                {
   1332                  /* Reset ADC error code fields related to conversions on group regular */
   1333                  CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   000000D4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D6   0xF020 0x0006      BIC      R0,R0,#0x6
   \   000000DA   0x62E0             STR      R0,[R4, #+44]
   \   000000DC   0xE001             B.N      ??HAL_ADC_Start_DMA_15
   1334                }
   1335                else
   1336                {
   1337                  /* Reset ADC all error code fields */
   1338                  ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_DMA_14: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x62E0             STR      R0,[R4, #+44]
   1339                }
   1340                
   1341                /* Process unlocked */
   1342                /* Unlock before starting ADC conversions: in case of potential         */
   1343                /* interruption, to let the process to ADC IRQ Handler.                 */
   1344                __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_DMA_15: (+1)
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF884 0x0024      STRB     R0,[R4, #+36]
   1345                
   1346                /* Set the DMA transfer complete callback */
   1347                hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
   \   000000E8   0x.... 0x....      ADR.W    R0,ADC_DMAConvCplt
   \   000000EC   0x6A21             LDR      R1,[R4, #+32]
   \   000000EE   0x6288             STR      R0,[R1, #+40]
   1348          
   1349                /* Set the DMA half transfer complete callback */
   1350                hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
   \   000000F0   0x.... 0x....      ADR.W    R0,ADC_DMAHalfConvCplt
   \   000000F4   0x6A21             LDR      R1,[R4, #+32]
   \   000000F6   0x62C8             STR      R0,[R1, #+44]
   1351                
   1352                /* Set the DMA error callback */
   1353                hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
   \   000000F8   0x.... 0x....      ADR.W    R0,ADC_DMAError
   \   000000FC   0x6A21             LDR      R1,[R4, #+32]
   \   000000FE   0x6308             STR      R0,[R1, #+48]
   1354          
   1355                
   1356                /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */
   1357                /* start (in case of SW start):                                         */
   1358                
   1359                /* Clear regular group conversion flag and overrun flag */
   1360                /* (To ensure of no unknown state from potential previous ADC           */
   1361                /* operations)                                                          */
   1362                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   00000100   0xF06F 0x0002      MVN      R0,#+2
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6008             STR      R0,[R1, #+0]
   1363                
   1364                /* Enable ADC DMA mode */
   1365                SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6881             LDR      R1,[R0, #+8]
   \   0000010C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000110   0x6081             STR      R1,[R0, #+8]
   1366                
   1367                /* Start the DMA channel */
   1368                HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
   \   00000112   0x4633             MOV      R3,R6
   \   00000114   0x462A             MOV      R2,R5
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000011C   0x6A20             LDR      R0,[R4, #+32]
   \   0000011E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1369                
   1370                /* Enable conversion of regular group.                                  */
   1371                /* If software start has been selected, conversion starts immediately.  */
   1372                /* If external trigger has been selected, conversion will start at next */
   1373                /* trigger event.                                                       */
   1374                if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6881             LDR      R1,[R0, #+8]
   \   00000126   0xF401 0x2160      AND      R1,R1,#0xE0000
   \   0000012A   0xF5B1 0x2F60      CMP      R1,#+917504
   \   0000012E   0x6881             LDR      R1,[R0, #+8]
   \   00000130   0xD103             BNE.N    ??HAL_ADC_Start_DMA_16
   1375                {
   1376                  /* Start ADC conversion on regular group with SW start */
   1377                  SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
   \   00000132   0xF441 0x01A0      ORR      R1,R1,#0x500000
   \   00000136   0x6081             STR      R1,[R0, #+8]
   \   00000138   0xE009             B.N      ??HAL_ADC_Start_DMA_17
   1378                }
   1379                else
   1380                {
   1381                  /* Start ADC conversion on regular group with external trigger */
   1382                  SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
   \                     ??HAL_ADC_Start_DMA_16: (+1)
   \   0000013A   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   0000013E   0x6081             STR      R1,[R0, #+8]
   \   00000140   0xE005             B.N      ??HAL_ADC_Start_DMA_17
   1383                }
   1384              }
   1385              else
   1386              {
   1387                /* Process unlocked */
   1388                __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_DMA_6: (+1)
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   00000148   0xE001             B.N      ??HAL_ADC_Start_DMA_17
   1389              }
   1390            }
   1391            else
   1392            {
   1393              tmp_hal_status = HAL_ERROR;
   \                     ??HAL_ADC_Start_DMA_3: (+1)
   \   0000014A   0xF04F 0x0801      MOV      R8,#+1
   1394            }
   1395            
   1396            /* Return function status */
   1397            return tmp_hal_status;
   \                     ??HAL_ADC_Start_DMA_17: (+1)
   \   0000014E   0x4640             MOV      R0,R8
   \                     ??HAL_ADC_Start_DMA_5: (+1)
   \   00000150   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1398          }
   1399          
   1400          /**
   1401            * @brief  Stop ADC conversion of regular group (and injected group in 
   1402            *         case of auto_injection mode), disable ADC DMA transfer, disable 
   1403            *         ADC peripheral.
   1404            * @note:  ADC peripheral disable is forcing stop of potential 
   1405            *         conversion on injected group. If injected group is under use, it
   1406            *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
   1407            * @note   For devices with several ADCs: This function is for single-ADC mode 
   1408            *         only. For multimode, use the dedicated MultimodeStop function.
   1409            * @note   On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending
   1410            *         on devices) have DMA capability.
   1411            * @param  hadc: ADC handle
   1412            * @retval HAL status.
   1413            */

   \                                 In section .text, align 2, keep-with-next
   1414          HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
   1415          {
   \                     HAL_ADC_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1416            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1417            
   1418            /* Check the parameters */
   1419            assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
   1420               
   1421            /* Process locked */
   1422            __HAL_LOCK(hadc);
   \   00000004   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_ADC_Stop_DMA_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_ADC_Stop_DMA_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0024      STRB     R0,[R4, #+36]
   1423            
   1424            /* Stop potential conversion on going, on regular and injected groups */
   1425            /* Disable ADC peripheral */
   1426            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       ADC_ConversionStop_Disable
   1427            
   1428            /* Check if ADC is effectively disabled */
   1429            if (tmp_hal_status == HAL_OK)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD113             BNE.N    ??HAL_ADC_Stop_DMA_1
   1430            {
   1431              /* Disable ADC DMA mode */
   1432              CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6881             LDR      R1,[R0, #+8]
   \   00000024   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000028   0x6081             STR      R1,[R0, #+8]
   1433              
   1434              /* Disable the DMA channel (in case of DMA in circular mode or stop while */
   1435              /* DMA transfer is on going)                                              */
   1436              tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
   \   0000002A   0x6A20             LDR      R0,[R4, #+32]
   \   0000002C   0x.... 0x....      BL       HAL_DMA_Abort
   1437              
   1438              /* Check if DMA channel effectively disabled */
   1439              if (tmp_hal_status == HAL_OK)
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0x6AA1             LDR      R1,[R4, #+40]
   \   00000034   0xD105             BNE.N    ??HAL_ADC_Stop_DMA_2
   1440              {
   1441                /* Set ADC state */
   1442                ADC_STATE_CLR_SET(hadc->State,
   1443                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1444                                  HAL_ADC_STATE_READY);
   \   00000036   0xF421 0x5188      BIC      R1,R1,#0x1100
   \   0000003A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000003E   0x62A1             STR      R1,[R4, #+40]
   \   00000040   0xE002             B.N      ??HAL_ADC_Stop_DMA_1
   1445              }
   1446              else
   1447              {
   1448                /* Update ADC state machine to error */
   1449                SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
   \                     ??HAL_ADC_Stop_DMA_2: (+1)
   \   00000042   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000046   0x62A1             STR      R1,[R4, #+40]
   1450              }
   1451            }
   1452              
   1453            /* Process unlocked */
   1454            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_DMA_1: (+1)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF884 0x1024      STRB     R1,[R4, #+36]
   1455              
   1456            /* Return function status */
   1457            return tmp_hal_status;
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   1458          }
   1459          
   1460          /**
   1461            * @brief  Get ADC regular group conversion result.
   1462            * @note   Reading register DR automatically clears ADC flag EOC
   1463            *         (ADC group regular end of unitary conversion).
   1464            * @note   This function does not clear ADC flag EOS 
   1465            *         (ADC group regular end of sequence conversion).
   1466            *         Occurrence of flag EOS rising:
   1467            *          - If sequencer is composed of 1 rank, flag EOS is equivalent
   1468            *            to flag EOC.
   1469            *          - If sequencer is composed of several ranks, during the scan
   1470            *            sequence flag EOC only is raised, at the end of the scan sequence
   1471            *            both flags EOC and EOS are raised.
   1472            *         To clear this flag, either use function: 
   1473            *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
   1474            *         model polling: @ref HAL_ADC_PollForConversion() 
   1475            *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
   1476            * @param  hadc: ADC handle
   1477            * @retval ADC group regular conversion data
   1478            */

   \                                 In section .text, align 2, keep-with-next
   1479          uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
   1480          {
   1481            /* Check the parameters */
   1482            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1483          
   1484            /* Note: EOC flag is not cleared here by software because automatically     */
   1485            /*       cleared by hardware when reading register DR.                      */
   1486            
   1487            /* Return ADC converted value */ 
   1488            return hadc->Instance->DR;
   \                     HAL_ADC_GetValue: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6CC0             LDR      R0,[R0, #+76]
   \   00000004   0x4770             BX       LR               ;; return
   1489          }
   1490          
   1491          /**
   1492            * @brief  Handles ADC interrupt request  
   1493            * @param  hadc: ADC handle
   1494            * @retval None
   1495            */

   \                                 In section .text, align 2, keep-with-next
   1496          void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
   1497          {
   \                     HAL_ADC_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1498            /* Check the parameters */
   1499            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1500            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
   1501            assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
   1502            
   1503            
   1504            /* ========== Check End of Conversion flag for regular group ========== */
   1505            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x0689             LSLS     R1,R1,#+26
   \   0000000A   0xD529             BPL.N    ??HAL_ADC_IRQHandler_0
   1506            {
   1507              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD526             BPL.N    ??HAL_ADC_IRQHandler_0
   1508              {
   1509                /* Update state machine on conversion status if not in error state */
   1510                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \   00000012   0x6AA0             LDR      R0,[R4, #+40]
   \   00000014   0x06C0             LSLS     R0,R0,#+27
   \   00000016   0xD403             BMI.N    ??HAL_ADC_IRQHandler_1
   1511                {
   1512                  /* Set ADC state */
   1513                  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
   \   00000018   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001A   0xF440 0x7000      ORR      R0,R0,#0x200
   \   0000001E   0x62A0             STR      R0,[R4, #+40]
   1514                }
   1515                
   1516                /* Determine whether any further conversion upcoming on group regular   */
   1517                /* by external trigger, continuous mode or scan sequence on going.      */
   1518                /* Note: On STM32F1 devices, in case of sequencer enabled               */
   1519                /*       (several ranks selected), end of conversion flag is raised     */
   1520                /*       at the end of the sequence.                                    */
   1521                if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
   1522                   (hadc->Init.ContinuousConvMode == DISABLE)   )
   \                     ??HAL_ADC_IRQHandler_1: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6881             LDR      R1,[R0, #+8]
   \   00000024   0xF401 0x2160      AND      R1,R1,#0xE0000
   \   00000028   0xF5B1 0x2F60      CMP      R1,#+917504
   \   0000002C   0xD111             BNE.N    ??HAL_ADC_IRQHandler_2
   \   0000002E   0x68E1             LDR      R1,[R4, #+12]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD10E             BNE.N    ??HAL_ADC_IRQHandler_2
   1523                {
   1524                  /* Disable ADC end of conversion interrupt on group regular */
   1525                  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \   00000034   0x6841             LDR      R1,[R0, #+4]
   \   00000036   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000003A   0x6041             STR      R1,[R0, #+4]
   1526                  
   1527                  /* Set ADC state */
   1528                  CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \   0000003C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000003E   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000042   0x62A0             STR      R0,[R4, #+40]
   1529                  
   1530                  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   00000044   0x6AA0             LDR      R0,[R4, #+40]
   \   00000046   0x04C0             LSLS     R0,R0,#+19
   \   00000048   0xD403             BMI.N    ??HAL_ADC_IRQHandler_2
   1531                  {
   1532                    SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   0000004A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000050   0x62A0             STR      R0,[R4, #+40]
   1533                  }
   1534                }
   1535          
   1536                /* Conversion complete callback */
   1537                HAL_ADC_ConvCpltCallback(hadc);
   \                     ??HAL_ADC_IRQHandler_2: (+1)
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   1538                
   1539                /* Clear regular group conversion flag */
   1540                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   \   00000058   0xF06F 0x0012      MVN      R0,#+18
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   1541              }
   1542            }
   1543            
   1544            /* ========== Check End of Conversion flag for injected group ========== */
   1545            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
   \                     ??HAL_ADC_IRQHandler_0: (+1)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6841             LDR      R1,[R0, #+4]
   \   00000064   0x0609             LSLS     R1,R1,#+24
   \   00000066   0xD532             BPL.N    ??HAL_ADC_IRQHandler_3
   1546            {
   1547              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x0740             LSLS     R0,R0,#+29
   \   0000006C   0xD52F             BPL.N    ??HAL_ADC_IRQHandler_3
   1548              {
   1549                /* Update state machine on conversion status if not in error state */
   1550                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \   0000006E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000070   0x06C0             LSLS     R0,R0,#+27
   \   00000072   0xD403             BMI.N    ??HAL_ADC_IRQHandler_4
   1551                {
   1552                  /* Set ADC state */
   1553                  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   \   00000074   0x6AA0             LDR      R0,[R4, #+40]
   \   00000076   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   0000007A   0x62A0             STR      R0,[R4, #+40]
   1554                }
   1555          
   1556                /* Determine whether any further conversion upcoming on group injected  */
   1557                /* by external trigger, scan sequence on going or by automatic injected */
   1558                /* conversion from group regular (same conditions as group regular      */
   1559                /* interruption disabling above).                                       */
   1560                /* Note: On STM32F1 devices, in case of sequencer enabled               */
   1561                /*       (several ranks selected), end of conversion flag is raised     */
   1562                /*       at the end of the sequence.                                    */
   1563                if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
   1564                   (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
   1565                   (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
   1566                    (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
   \                     ??HAL_ADC_IRQHandler_4: (+1)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6881             LDR      R1,[R0, #+8]
   \   00000080   0xF401 0x41E0      AND      R1,R1,#0x7000
   \   00000084   0xF5B1 0x4FE0      CMP      R1,#+28672
   \   00000088   0xD00B             BEQ.N    ??HAL_ADC_IRQHandler_5
   \   0000008A   0x6841             LDR      R1,[R0, #+4]
   \   0000008C   0x0549             LSLS     R1,R1,#+21
   \   0000008E   0xD417             BMI.N    ??HAL_ADC_IRQHandler_6
   \   00000090   0x6881             LDR      R1,[R0, #+8]
   \   00000092   0xF401 0x2160      AND      R1,R1,#0xE0000
   \   00000096   0xF5B1 0x2F60      CMP      R1,#+917504
   \   0000009A   0xD111             BNE.N    ??HAL_ADC_IRQHandler_6
   \   0000009C   0x68E1             LDR      R1,[R4, #+12]
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD10E             BNE.N    ??HAL_ADC_IRQHandler_6
   1567                {
   1568                  /* Disable ADC end of conversion interrupt on group injected */
   1569                  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   \                     ??HAL_ADC_IRQHandler_5: (+1)
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0xF021 0x0180      BIC      R1,R1,#0x80
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   1570                  
   1571                  /* Set ADC state */
   1572                  CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
   \   000000AA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000AC   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   000000B0   0x62A0             STR      R0,[R4, #+40]
   1573          
   1574                  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   000000B2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000B4   0x05C0             LSLS     R0,R0,#+23
   \   000000B6   0xD403             BMI.N    ??HAL_ADC_IRQHandler_6
   1575                  { 
   1576                    SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   000000B8   0x6AA0             LDR      R0,[R4, #+40]
   \   000000BA   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000BE   0x62A0             STR      R0,[R4, #+40]
   1577                  }
   1578                }
   1579          
   1580                /* Conversion complete callback */ 
   1581                HAL_ADCEx_InjectedConvCpltCallback(hadc);
   \                     ??HAL_ADC_IRQHandler_6: (+1)
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       HAL_ADCEx_InjectedConvCpltCallback
   1582                
   1583                /* Clear injected group conversion flag */
   1584                __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
   \   000000C6   0xF06F 0x000C      MVN      R0,#+12
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   1585              }
   1586            }
   1587             
   1588            /* ========== Check Analog watchdog flags ========== */
   1589            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
   \                     ??HAL_ADC_IRQHandler_3: (+1)
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6841             LDR      R1,[R0, #+4]
   \   000000D2   0x0649             LSLS     R1,R1,#+25
   \   000000D4   0xD50D             BPL.N    ??HAL_ADC_IRQHandler_7
   1590            {
   1591              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x07C0             LSLS     R0,R0,#+31
   \   000000DA   0xD50A             BPL.N    ??HAL_ADC_IRQHandler_7
   1592              {
   1593                /* Set ADC state */
   1594                SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   \   000000DC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000DE   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   000000E2   0x62A0             STR      R0,[R4, #+40]
   1595                
   1596                /* Level out of window callback */ 
   1597                HAL_ADC_LevelOutOfWindowCallback(hadc);
   \   000000E4   0x4620             MOV      R0,R4
   \   000000E6   0x.... 0x....      BL       HAL_ADC_LevelOutOfWindowCallback
   1598                
   1599                /* Clear the ADC analog watchdog flag */
   1600                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   \   000000EA   0xF06F 0x0001      MVN      R0,#+1
   \   000000EE   0x6821             LDR      R1,[R4, #+0]
   \   000000F0   0x6008             STR      R0,[R1, #+0]
   1601              }
   1602            }
   1603            
   1604          }
   \                     ??HAL_ADC_IRQHandler_7: (+1)
   \   000000F2   0xBD10             POP      {R4,PC}          ;; return
   1605          
   1606          /**
   1607            * @brief  Conversion complete callback in non blocking mode 
   1608            * @param  hadc: ADC handle
   1609            * @retval None
   1610            */

   \                                 In section .text, align 2, keep-with-next
   1611          __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
   1612          {
   1613            /* Prevent unused argument(s) compilation warning */
   1614            UNUSED(hadc);
   1615            /* NOTE : This function should not be modified. When the callback is needed,
   1616                      function HAL_ADC_ConvCpltCallback must be implemented in the user file.
   1617             */
   1618          }
   \                     HAL_ADC_ConvCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1619          
   1620          /**
   1621            * @brief  Conversion DMA half-transfer callback in non blocking mode 
   1622            * @param  hadc: ADC handle
   1623            * @retval None
   1624            */

   \                                 In section .text, align 2, keep-with-next
   1625          __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
   1626          {
   1627            /* Prevent unused argument(s) compilation warning */
   1628            UNUSED(hadc);
   1629            /* NOTE : This function should not be modified. When the callback is needed,
   1630                      function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
   1631            */
   1632          }
   \                     HAL_ADC_ConvHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1633          
   1634          /**
   1635            * @brief  Analog watchdog callback in non blocking mode. 
   1636            * @param  hadc: ADC handle
   1637            * @retval None
   1638            */

   \                                 In section .text, align 2, keep-with-next
   1639          __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
   1640          {
   1641            /* Prevent unused argument(s) compilation warning */
   1642            UNUSED(hadc);
   1643            /* NOTE : This function should not be modified. When the callback is needed,
   1644                      function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
   1645            */
   1646          }
   \                     HAL_ADC_LevelOutOfWindowCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1647          
   1648          /**
   1649            * @brief  ADC error callback in non blocking mode
   1650            *        (ADC conversion with interruption or transfer by DMA)
   1651            * @param  hadc: ADC handle
   1652            * @retval None
   1653            */

   \                                 In section .text, align 2, keep-with-next
   1654          __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
   1655          {
   1656            /* Prevent unused argument(s) compilation warning */
   1657            UNUSED(hadc);
   1658            /* NOTE : This function should not be modified. When the callback is needed,
   1659                      function HAL_ADC_ErrorCallback must be implemented in the user file.
   1660            */
   1661          }
   \                     HAL_ADC_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1662          
   1663          
   1664          /**
   1665            * @}
   1666            */
   1667          
   1668          /** @defgroup ADC_Exported_Functions_Group3 Peripheral Control functions
   1669           *  @brief    Peripheral Control functions
   1670           *
   1671          @verbatim   
   1672           ===============================================================================
   1673                       ##### Peripheral Control functions #####
   1674           ===============================================================================  
   1675              [..]  This section provides functions allowing to:
   1676                (+) Configure channels on regular group
   1677                (+) Configure the analog watchdog
   1678                
   1679          @endverbatim
   1680            * @{
   1681            */
   1682          
   1683          /**
   1684            * @brief  Configures the the selected channel to be linked to the regular
   1685            *         group.
   1686            * @note   In case of usage of internal measurement channels:
   1687            *         Vbat/VrefInt/TempSensor.
   1688            *         These internal paths can be be disabled using function 
   1689            *         HAL_ADC_DeInit().
   1690            * @note   Possibility to update parameters on the fly:
   1691            *         This function initializes channel into regular group, following  
   1692            *         calls to this function can be used to reconfigure some parameters 
   1693            *         of structure "ADC_ChannelConfTypeDef" on the fly, without reseting 
   1694            *         the ADC.
   1695            *         The setting of these parameters is conditioned to ADC state.
   1696            *         For parameters constraints, see comments of structure 
   1697            *         "ADC_ChannelConfTypeDef".
   1698            * @param  hadc: ADC handle
   1699            * @param  sConfig: Structure of ADC channel for regular group.
   1700            * @retval HAL status
   1701            */

   \                                 In section .text, align 2, keep-with-next
   1702          HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
   1703          { 
   \                     HAL_ADC_ConfigChannel: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
   \   00000002   0x460A             MOV      R2,R1
   1704            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2100             MOVS     R1,#+0
   1705            __IO uint32_t wait_loop_index = 0;
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0x9300             STR      R3,[SP, #+0]
   1706            
   1707            /* Check the parameters */
   1708            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1709            assert_param(IS_ADC_CHANNEL(sConfig->Channel));
   1710            assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
   1711            assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
   1712            
   1713            /* Process locked */
   1714            __HAL_LOCK(hadc);
   \   0000000A   0xF990 0x3024      LDRSB    R3,[R0, #+36]
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xD101             BNE.N    ??HAL_ADC_ConfigChannel_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE070             B.N      ??HAL_ADC_ConfigChannel_1
   \                     ??HAL_ADC_ConfigChannel_0: (+1)
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0xF880 0x3024      STRB     R3,[R0, #+36]
   1715            
   1716            
   1717            /* Regular sequence configuration */
   1718            /* For Rank 1 to 6 */
   1719            if (sConfig->Rank < 7)
   \   0000001C   0x6856             LDR      R6,[R2, #+4]
   \   0000001E   0x6814             LDR      R4,[R2, #+0]
   \   00000020   0x6803             LDR      R3,[R0, #+0]
   \   00000022   0x251F             MOVS     R5,#+31
   \   00000024   0x2E07             CMP      R6,#+7
   \   00000026   0xD20A             BCS.N    ??HAL_ADC_ConfigChannel_2
   1720            {
   1721              MODIFY_REG(hadc->Instance->SQR3                        ,
   1722                         ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
   1723                         ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
   \   00000028   0x1E76             SUBS     R6,R6,#+1
   \   0000002A   0xEB06 0x0686      ADD      R6,R6,R6, LSL #+2
   \   0000002E   0x6B5F             LDR      R7,[R3, #+52]
   \   00000030   0x40B5             LSLS     R5,R5,R6
   \   00000032   0xEA27 0x0505      BIC      R5,R7,R5
   \   00000036   0x40B4             LSLS     R4,R4,R6
   \   00000038   0x432C             ORRS     R4,R4,R5
   \   0000003A   0x635C             STR      R4,[R3, #+52]
   \   0000003C   0xE016             B.N      ??HAL_ADC_ConfigChannel_3
   1724            }
   1725            /* For Rank 7 to 12 */
   1726            else if (sConfig->Rank < 13)
   \                     ??HAL_ADC_ConfigChannel_2: (+1)
   \   0000003E   0x2E0D             CMP      R6,#+13
   \   00000040   0xD20A             BCS.N    ??HAL_ADC_ConfigChannel_4
   1727            {
   1728              MODIFY_REG(hadc->Instance->SQR2                        ,
   1729                         ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank)    ,
   1730                         ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
   \   00000042   0x1FF6             SUBS     R6,R6,#+7
   \   00000044   0xEB06 0x0686      ADD      R6,R6,R6, LSL #+2
   \   00000048   0x6B1F             LDR      R7,[R3, #+48]
   \   0000004A   0x40B5             LSLS     R5,R5,R6
   \   0000004C   0xEA27 0x0505      BIC      R5,R7,R5
   \   00000050   0x40B4             LSLS     R4,R4,R6
   \   00000052   0x432C             ORRS     R4,R4,R5
   \   00000054   0x631C             STR      R4,[R3, #+48]
   \   00000056   0xE009             B.N      ??HAL_ADC_ConfigChannel_3
   1731            }
   1732            /* For Rank 13 to 16 */
   1733            else
   1734            {
   1735              MODIFY_REG(hadc->Instance->SQR1                        ,
   1736                         ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank)   ,
   1737                         ADC_SQR1_RK(sConfig->Channel, sConfig->Rank) );
   \                     ??HAL_ADC_ConfigChannel_4: (+1)
   \   00000058   0x3E0D             SUBS     R6,R6,#+13
   \   0000005A   0xEB06 0x0686      ADD      R6,R6,R6, LSL #+2
   \   0000005E   0x6ADF             LDR      R7,[R3, #+44]
   \   00000060   0x40B5             LSLS     R5,R5,R6
   \   00000062   0xEA27 0x0505      BIC      R5,R7,R5
   \   00000066   0x40B4             LSLS     R4,R4,R6
   \   00000068   0x432C             ORRS     R4,R4,R5
   \   0000006A   0x62DC             STR      R4,[R3, #+44]
   1738            }
   1739            
   1740            
   1741            /* Channel sampling time configuration */
   1742            /* For channels 10 to 17 */
   1743            if (sConfig->Channel >= ADC_CHANNEL_10)
   \                     ??HAL_ADC_ConfigChannel_3: (+1)
   \   0000006C   0x6894             LDR      R4,[R2, #+8]
   \   0000006E   0x6803             LDR      R3,[R0, #+0]
   \   00000070   0x6815             LDR      R5,[R2, #+0]
   \   00000072   0x2607             MOVS     R6,#+7
   \   00000074   0x2D0A             CMP      R5,#+10
   \   00000076   0xD30A             BCC.N    ??HAL_ADC_ConfigChannel_5
   1744            {
   1745              MODIFY_REG(hadc->Instance->SMPR1                             ,
   1746                         ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel)      ,
   1747                         ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
   \   00000078   0x3D0A             SUBS     R5,R5,#+10
   \   0000007A   0xEB05 0x0545      ADD      R5,R5,R5, LSL #+1
   \   0000007E   0x68DF             LDR      R7,[R3, #+12]
   \   00000080   0x40AE             LSLS     R6,R6,R5
   \   00000082   0xEA27 0x0606      BIC      R6,R7,R6
   \   00000086   0x40AC             LSLS     R4,R4,R5
   \   00000088   0x4334             ORRS     R4,R4,R6
   \   0000008A   0x60DC             STR      R4,[R3, #+12]
   \   0000008C   0xE008             B.N      ??HAL_ADC_ConfigChannel_6
   1748            }
   1749            else /* For channels 0 to 9 */
   1750            {
   1751              MODIFY_REG(hadc->Instance->SMPR2                             ,
   1752                         ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel)       ,
   1753                         ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
   \                     ??HAL_ADC_ConfigChannel_5: (+1)
   \   0000008E   0xEB05 0x0545      ADD      R5,R5,R5, LSL #+1
   \   00000092   0x691F             LDR      R7,[R3, #+16]
   \   00000094   0x40AE             LSLS     R6,R6,R5
   \   00000096   0xEA27 0x0606      BIC      R6,R7,R6
   \   0000009A   0x40AC             LSLS     R4,R4,R5
   \   0000009C   0x4334             ORRS     R4,R4,R6
   \   0000009E   0x611C             STR      R4,[R3, #+16]
   1754            }
   1755            
   1756            /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
   1757            /* and VREFINT measurement path.                                            */
   1758            if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
   1759                (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
   \                     ??HAL_ADC_ConfigChannel_6: (+1)
   \   000000A0   0x6813             LDR      R3,[R2, #+0]
   \   000000A2   0x2B10             CMP      R3,#+16
   \   000000A4   0xD001             BEQ.N    ??HAL_ADC_ConfigChannel_7
   \   000000A6   0x2B11             CMP      R3,#+17
   \   000000A8   0xD122             BNE.N    ??HAL_ADC_ConfigChannel_8
   1760            {
   1761              /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
   1762              /* measurement channels (VrefInt/TempSensor). If these channels are       */
   1763              /* intended to be set on other ADC instances, an error is reported.       */
   1764              if (hadc->Instance == ADC1)
   \                     ??HAL_ADC_ConfigChannel_7: (+1)
   \   000000AA   0x6803             LDR      R3,[R0, #+0]
   \   000000AC   0x....             LDR.N    R4,??DataTable8_8  ;; 0x40012400
   \   000000AE   0x42A3             CMP      R3,R4
   \   000000B0   0xD119             BNE.N    ??HAL_ADC_ConfigChannel_9
   1765              {
   1766                if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
   \   000000B2   0x689C             LDR      R4,[R3, #+8]
   \   000000B4   0x0224             LSLS     R4,R4,#+8
   \   000000B6   0xD41B             BMI.N    ??HAL_ADC_ConfigChannel_8
   1767                {
   1768                  SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
   \   000000B8   0x689C             LDR      R4,[R3, #+8]
   \   000000BA   0xF444 0x0400      ORR      R4,R4,#0x800000
   \   000000BE   0x609C             STR      R4,[R3, #+8]
   1769                  
   1770                  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
   \   000000C0   0x6812             LDR      R2,[R2, #+0]
   \   000000C2   0x2A10             CMP      R2,#+16
   \   000000C4   0xD114             BNE.N    ??HAL_ADC_ConfigChannel_8
   1771                  {
   1772                    /* Delay for temperature sensor stabilization time */
   1773                    /* Compute number of CPU cycles to wait for */
   1774                    wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
   \   000000C6   0x....             LDR.N    R2,??DataTable8_14
   \   000000C8   0x6812             LDR      R2,[R2, #+0]
   \   000000CA   0x....             LDR.N    R3,??DataTable8_16  ;; 0xf4240
   \   000000CC   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000D0   0xEB02 0x0382      ADD      R3,R2,R2, LSL #+2
   \   000000D4   0x005A             LSLS     R2,R3,#+1
   \   000000D6   0x9200             STR      R2,[SP, #+0]
   1775                    while(wait_loop_index != 0)
   \                     ??HAL_ADC_ConfigChannel_10: (+1)
   \   000000D8   0x9A00             LDR      R2,[SP, #+0]
   \   000000DA   0x2A00             CMP      R2,#+0
   \   000000DC   0xD008             BEQ.N    ??HAL_ADC_ConfigChannel_8
   1776                    {
   1777                      wait_loop_index--;
   \   000000DE   0x9A00             LDR      R2,[SP, #+0]
   \   000000E0   0x1E52             SUBS     R2,R2,#+1
   \   000000E2   0x9200             STR      R2,[SP, #+0]
   \   000000E4   0xE7F8             B.N      ??HAL_ADC_ConfigChannel_10
   1778                    }
   1779                  }
   1780                }
   1781              }
   1782              else
   1783              {
   1784                /* Update ADC state machine to error */
   1785                SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADC_ConfigChannel_9: (+1)
   \   000000E6   0x6A81             LDR      R1,[R0, #+40]
   \   000000E8   0xF041 0x0120      ORR      R1,R1,#0x20
   \   000000EC   0x6281             STR      R1,[R0, #+40]
   1786                
   1787                tmp_hal_status = HAL_ERROR;
   \   000000EE   0x2101             MOVS     R1,#+1
   1788              }
   1789            }
   1790            
   1791            /* Process unlocked */
   1792            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_ConfigChannel_8: (+1)
   \   000000F0   0x2200             MOVS     R2,#+0
   \   000000F2   0xF880 0x2024      STRB     R2,[R0, #+36]
   1793            
   1794            /* Return function status */
   1795            return tmp_hal_status;
   \   000000F6   0x4608             MOV      R0,R1
   \                     ??HAL_ADC_ConfigChannel_1: (+1)
   \   000000F8   0xBCF2             POP      {R1,R4-R7}
   \   000000FA   0x4770             BX       LR               ;; return
   1796          }
   1797          
   1798          /**
   1799            * @brief  Configures the analog watchdog.
   1800            * @note   Analog watchdog thresholds can be modified while ADC conversion
   1801            *         is on going.
   1802            *         In this case, some constraints must be taken into account:
   1803            *         the programmed threshold values are effective from the next
   1804            *         ADC EOC (end of unitary conversion).
   1805            *         Considering that registers write delay may happen due to
   1806            *         bus activity, this might cause an uncertainty on the
   1807            *         effective timing of the new programmed threshold values.
   1808            * @param  hadc: ADC handle
   1809            * @param  AnalogWDGConfig: Structure of ADC analog watchdog configuration
   1810            * @retval HAL status
   1811            */

   \                                 In section .text, align 2, keep-with-next
   1812          HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
   1813          {
   \                     HAL_ADC_AnalogWDGConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1814            /* Check the parameters */
   1815            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1816            assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
   1817            assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
   1818            assert_param(IS_ADC_RANGE(AnalogWDGConfig->HighThreshold));
   1819            assert_param(IS_ADC_RANGE(AnalogWDGConfig->LowThreshold));
   1820            
   1821            if((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
   1822               (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
   1823               (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)  )
   1824            {
   1825              assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
   1826            }
   1827            
   1828            /* Process locked */
   1829            __HAL_LOCK(hadc);
   \   00000002   0xF990 0x2024      LDRSB    R2,[R0, #+36]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_ADC_AnalogWDGConfig_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE021             B.N      ??HAL_ADC_AnalogWDGConfig_1
   \                     ??HAL_ADC_AnalogWDGConfig_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x2024      STRB     R2,[R0, #+36]
   1830            
   1831            /* Analog watchdog configuration */
   1832          
   1833            /* Configure ADC Analog watchdog interrupt */
   1834            if(AnalogWDGConfig->ITMode == ENABLE)
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x688B             LDR      R3,[R1, #+8]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0x6853             LDR      R3,[R2, #+4]
   \   0000001C   0xD103             BNE.N    ??HAL_ADC_AnalogWDGConfig_2
   1835            {
   1836              /* Enable the ADC Analog watchdog interrupt */
   1837              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
   \   0000001E   0xF043 0x0340      ORR      R3,R3,#0x40
   \   00000022   0x6053             STR      R3,[R2, #+4]
   \   00000024   0xE002             B.N      ??HAL_ADC_AnalogWDGConfig_3
   1838            }
   1839            else
   1840            {
   1841              /* Disable the ADC Analog watchdog interrupt */
   1842              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
   \                     ??HAL_ADC_AnalogWDGConfig_2: (+1)
   \   00000026   0xF023 0x0340      BIC      R3,R3,#0x40
   \   0000002A   0x6053             STR      R3,[R2, #+4]
   1843            }
   1844            
   1845            /* Configuration of analog watchdog:                                        */
   1846            /*  - Set the analog watchdog enable mode: regular and/or injected groups,  */
   1847            /*    one or all channels.                                                  */
   1848            /*  - Set the Analog watchdog channel (is not used if watchdog              */
   1849            /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */
   1850            MODIFY_REG(hadc->Instance->CR1            ,
   1851                       ADC_CR1_AWDSGL |
   1852                       ADC_CR1_JAWDEN |
   1853                       ADC_CR1_AWDEN  |
   1854                       ADC_CR1_AWDCH                  ,
   1855                       AnalogWDGConfig->WatchdogMode |
   1856                       AnalogWDGConfig->Channel        );
   \                     ??HAL_ADC_AnalogWDGConfig_3: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x6853             LDR      R3,[R2, #+4]
   \   00000030   0x....             LDR.N    R4,??DataTable8_17  ;; 0xff3ffde0
   \   00000032   0x4023             ANDS     R3,R4,R3
   \   00000034   0x680C             LDR      R4,[R1, #+0]
   \   00000036   0x4323             ORRS     R3,R4,R3
   \   00000038   0x684C             LDR      R4,[R1, #+4]
   \   0000003A   0x4323             ORRS     R3,R4,R3
   \   0000003C   0x6053             STR      R3,[R2, #+4]
   1857            
   1858            /* Set the high threshold */
   1859            WRITE_REG(hadc->Instance->HTR, AnalogWDGConfig->HighThreshold);
   \   0000003E   0x68CA             LDR      R2,[R1, #+12]
   \   00000040   0x6803             LDR      R3,[R0, #+0]
   \   00000042   0x625A             STR      R2,[R3, #+36]
   1860            
   1861            /* Set the low threshold */
   1862            WRITE_REG(hadc->Instance->LTR, AnalogWDGConfig->LowThreshold);
   \   00000044   0x6909             LDR      R1,[R1, #+16]
   \   00000046   0x6802             LDR      R2,[R0, #+0]
   \   00000048   0x6291             STR      R1,[R2, #+40]
   1863          
   1864            /* Process unlocked */
   1865            __HAL_UNLOCK(hadc);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF880 0x1024      STRB     R1,[R0, #+36]
   1866            
   1867            /* Return function status */
   1868            return HAL_OK;
   \   00000050   0x4608             MOV      R0,R1
   \                     ??HAL_ADC_AnalogWDGConfig_1: (+1)
   \   00000052   0xBC10             POP      {R4}
   \   00000054   0x4770             BX       LR               ;; return
   1869          }
   1870          
   1871          
   1872          /**
   1873            * @}
   1874            */
   1875          
   1876          
   1877          /** @defgroup ADC_Exported_Functions_Group4 Peripheral State functions
   1878           *  @brief    Peripheral State functions
   1879           *
   1880          @verbatim
   1881           ===============================================================================
   1882                      ##### Peripheral State and Errors functions #####
   1883           ===============================================================================  
   1884              [..]
   1885              This subsection provides functions to get in run-time the status of the  
   1886              peripheral.
   1887                (+) Check the ADC state
   1888                (+) Check the ADC error code
   1889          
   1890          @endverbatim
   1891            * @{
   1892            */
   1893          
   1894          /**
   1895            * @brief  return the ADC state
   1896            * @param  hadc: ADC handle
   1897            * @retval HAL state
   1898            */

   \                                 In section .text, align 2, keep-with-next
   1899          uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
   1900          {
   1901            /* Return ADC state */
   1902            return hadc->State;
   \                     HAL_ADC_GetState: (+1)
   \   00000000   0x6A80             LDR      R0,[R0, #+40]
   \   00000002   0x4770             BX       LR               ;; return
   1903          }
   1904          
   1905          /**
   1906            * @brief  Return the ADC error code
   1907            * @param  hadc: ADC handle
   1908            * @retval ADC Error Code
   1909            */

   \                                 In section .text, align 2, keep-with-next
   1910          uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
   1911          {
   1912            return hadc->ErrorCode;
   \                     HAL_ADC_GetError: (+1)
   \   00000000   0x6AC0             LDR      R0,[R0, #+44]
   \   00000002   0x4770             BX       LR               ;; return
   1913          }
   1914          
   1915          /**
   1916            * @}
   1917            */
   1918          
   1919          /**
   1920            * @}
   1921            */
   1922          
   1923          /** @defgroup ADC_Private_Functions ADC Private Functions
   1924            * @{
   1925            */
   1926          
   1927          /**
   1928            * @brief  Enable the selected ADC.
   1929            * @note   Prerequisite condition to use this function: ADC must be disabled
   1930            *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
   1931            * @param  hadc: ADC handle
   1932            * @retval HAL status.
   1933            */

   \                                 In section .text, align 2, keep-with-next
   1934          HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
   1935          {
   \                     ADC_Enable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1936            uint32_t tickstart = 0;
   1937            __IO uint32_t wait_loop_index = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1938            
   1939            /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
   1940            /* enabling phase not yet completed: flag ADC ready not yet set).           */
   1941            /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
   1942            /* causes: ADC clock not running, ...).                                     */
   1943            if (ADC_IS_ENABLE(hadc) == RESET)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6881             LDR      R1,[R0, #+8]
   \   0000000C   0x07C9             LSLS     R1,R1,#+31
   \   0000000E   0xD429             BMI.N    ??ADC_Enable_0
   1944            {
   1945              /* Enable the Peripheral */
   1946              __HAL_ADC_ENABLE(hadc);
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000016   0x6081             STR      R1,[R0, #+8]
   1947              
   1948              /* Delay for ADC stabilization time */
   1949              /* Compute number of CPU cycles to wait for */
   1950              wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
   \   00000018   0x....             LDR.N    R0,??DataTable8_14
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x....             LDR.N    R1,??DataTable8_16  ;; 0xf4240
   \   0000001E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xE002             B.N      ??ADC_Enable_1
   1951              while(wait_loop_index != 0)
   1952              {
   1953                wait_loop_index--;
   \                     ??ADC_Enable_2: (+1)
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   1954              }
   \                     ??ADC_Enable_1: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F9             BNE.N    ??ADC_Enable_2
   1955              
   1956              /* Get tick count */
   1957              tickstart = HAL_GetTick();
   \   00000032   0x.... 0x....      BL       HAL_GetTick
   \   00000036   0x4605             MOV      R5,R0
   1958          
   1959              /* Wait for ADC effectively enabled */
   1960              while(ADC_IS_ENABLE(hadc) == RESET)
   \                     ??ADC_Enable_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x07C0             LSLS     R0,R0,#+31
   \   0000003E   0xD411             BMI.N    ??ADC_Enable_0
   1961              {
   1962                if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
   \   00000040   0x.... 0x....      BL       HAL_GetTick
   \   00000044   0x1B40             SUBS     R0,R0,R5
   \   00000046   0x2803             CMP      R0,#+3
   \   00000048   0xD3F6             BCC.N    ??ADC_Enable_3
   1963                {
   1964                  /* Update ADC state machine to error */
   1965                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   \   0000004A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004C   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000050   0x62A0             STR      R0,[R4, #+40]
   1966                
   1967                  /* Set ADC error code to ADC IP internal error */
   1968                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   00000052   0x6AE0             LDR      R0,[R4, #+44]
   \   00000054   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000058   0x62E0             STR      R0,[R4, #+44]
   1969                  
   1970                  /* Process unlocked */
   1971                  __HAL_UNLOCK(hadc);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF884 0x0024      STRB     R0,[R4, #+36]
   1972                
   1973                  return HAL_ERROR;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}
   1974                }
   1975              }
   1976            }
   1977             
   1978            /* Return HAL status */
   1979            return HAL_OK;
   \                     ??ADC_Enable_0: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1980          }
   1981          
   1982          /**
   1983            * @brief  Stop ADC conversion and disable the selected ADC
   1984            * @note   Prerequisite condition to use this function: ADC conversions must be
   1985            *         stopped to disable the ADC.
   1986            * @param  hadc: ADC handle
   1987            * @retval HAL status.
   1988            */

   \                                 In section .text, align 2, keep-with-next
   1989          HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
   1990          {
   \                     ADC_ConversionStop_Disable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1991            uint32_t tickstart = 0;
   1992            
   1993            /* Verification if ADC is not already disabled */
   1994            if (ADC_IS_ENABLE(hadc) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0x07C9             LSLS     R1,R1,#+31
   \   0000000A   0xD519             BPL.N    ??ADC_ConversionStop_Disable_0
   1995            {
   1996              /* Disable the ADC peripheral */
   1997              __HAL_ADC_DISABLE(hadc);
   \   0000000C   0x6881             LDR      R1,[R0, #+8]
   \   0000000E   0x0849             LSRS     R1,R1,#+1
   \   00000010   0x0049             LSLS     R1,R1,#+1
   \   00000012   0x6081             STR      R1,[R0, #+8]
   1998               
   1999              /* Get tick count */
   2000              tickstart = HAL_GetTick();
   \   00000014   0x.... 0x....      BL       HAL_GetTick
   \   00000018   0x4605             MOV      R5,R0
   2001              
   2002              /* Wait for ADC effectively disabled */
   2003              while(ADC_IS_ENABLE(hadc) != RESET)
   \                     ??ADC_ConversionStop_Disable_1: (+1)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD50E             BPL.N    ??ADC_ConversionStop_Disable_0
   2004              {
   2005                if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x1B40             SUBS     R0,R0,R5
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD3F6             BCC.N    ??ADC_ConversionStop_Disable_1
   2006                {
   2007                  /* Update ADC state machine to error */
   2008                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   \   0000002C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002E   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000032   0x62A0             STR      R0,[R4, #+40]
   2009                  
   2010                  /* Set ADC error code to ADC IP internal error */
   2011                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   \   00000034   0x6AE0             LDR      R0,[R4, #+44]
   \   00000036   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000003A   0x62E0             STR      R0,[R4, #+44]
   2012                  
   2013                  return HAL_ERROR;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}
   2014                }
   2015              }
   2016            }
   2017            
   2018            /* Return HAL status */
   2019            return HAL_OK;
   \                     ??ADC_ConversionStop_Disable_0: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2020          }
   2021          
   2022          /**
   2023            * @brief  DMA transfer complete callback. 
   2024            * @param  hdma: pointer to DMA handle.
   2025            * @retval None
   2026            */

   \                                 In section .text, align 4, keep-with-next
   2027          void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
   2028          {
   \                     ADC_DMAConvCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2029            /* Retrieve ADC handle corresponding to current DMA handle */
   2030            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A41             LDR      R1,[R0, #+36]
   2031           
   2032            /* Update state machine on conversion status if not in error state */
   2033            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
   \   00000004   0x6A8A             LDR      R2,[R1, #+40]
   \   00000006   0xF012 0x0F50      TST      R2,#0x50
   \   0000000A   0xD11C             BNE.N    ??ADC_DMAConvCplt_0
   2034            {
   2035              /* Update ADC state machine */
   2036              SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \   0000000C   0x6A88             LDR      R0,[R1, #+40]
   \   0000000E   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000012   0x6288             STR      R0,[R1, #+40]
   2037              
   2038              /* Determine whether any further conversion upcoming on group regular     */
   2039              /* by external trigger, continuous mode or scan sequence on going.        */
   2040              /* Note: On STM32F1 devices, in case of sequencer enabled                 */
   2041              /*       (several ranks selected), end of conversion flag is raised       */
   2042              /*       at the end of the sequence.                                      */
   2043              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
   2044                 (hadc->Init.ContinuousConvMode == DISABLE)   )
   \   00000014   0x6808             LDR      R0,[R1, #+0]
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0xF400 0x2060      AND      R0,R0,#0xE0000
   \   0000001C   0xF5B0 0x2F60      CMP      R0,#+917504
   \   00000020   0xD10D             BNE.N    ??ADC_DMAConvCplt_1
   \   00000022   0x68C8             LDR      R0,[R1, #+12]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD10A             BNE.N    ??ADC_DMAConvCplt_1
   2045              {
   2046                /* Set ADC state */
   2047                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \   00000028   0x6A88             LDR      R0,[R1, #+40]
   \   0000002A   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000002E   0x6288             STR      R0,[R1, #+40]
   2048                
   2049                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   00000030   0x6A88             LDR      R0,[R1, #+40]
   \   00000032   0x04C0             LSLS     R0,R0,#+19
   \   00000034   0xD403             BMI.N    ??ADC_DMAConvCplt_1
   2050                {
   2051                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   00000036   0x6A88             LDR      R0,[R1, #+40]
   \   00000038   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000003C   0x6288             STR      R0,[R1, #+40]
   2052                }
   2053              }
   2054              
   2055              /* Conversion complete callback */
   2056              HAL_ADC_ConvCpltCallback(hadc); 
   \                     ??ADC_DMAConvCplt_1: (+1)
   \   0000003E   0x4608             MOV      R0,R1
   \   00000040   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   \   00000044   0xBD01             POP      {R0,PC}
   2057            }
   2058            else
   2059            {
   2060              /* Call DMA error callback */
   2061              hadc->DMA_Handle->XferErrorCallback(hdma);
   \                     ??ADC_DMAConvCplt_0: (+1)
   \   00000046   0x6A09             LDR      R1,[R1, #+32]
   \   00000048   0x6B09             LDR      R1,[R1, #+48]
   \   0000004A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000004E   0x4708             BX       R1
   2062            }
   2063          }
   2064          
   2065          /**
   2066            * @brief  DMA half transfer complete callback. 
   2067            * @param  hdma: pointer to DMA handle.
   2068            * @retval None
   2069            */

   \                                 In section .text, align 4, keep-with-next
   2070          void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
   2071          {
   \                     ADC_DMAHalfConvCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2072            /* Retrieve ADC handle corresponding to current DMA handle */
   2073            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2074            
   2075            /* Half conversion callback */
   2076            HAL_ADC_ConvHalfCpltCallback(hadc); 
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   \   00000004   0x.... 0x....      BL       HAL_ADC_ConvHalfCpltCallback
   2077          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2078          
   2079          /**
   2080            * @brief  DMA error callback 
   2081            * @param  hdma: pointer to DMA handle.
   2082            * @retval None
   2083            */

   \                                 In section .text, align 4, keep-with-next
   2084          void ADC_DMAError(DMA_HandleTypeDef *hdma)   
   2085          {
   \                     ADC_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2086            /* Retrieve ADC handle corresponding to current DMA handle */
   2087            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   2088            
   2089            /* Set ADC state */
   2090            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
   \   00000004   0x6A81             LDR      R1,[R0, #+40]
   \   00000006   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000000A   0x6281             STR      R1,[R0, #+40]
   2091            
   2092            /* Set ADC error code to DMA error */
   2093            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
   \   0000000C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000000E   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000012   0x62C1             STR      R1,[R0, #+44]
   2094            
   2095            /* Error callback */
   2096            HAL_ADC_ErrorCallback(hadc); 
   \   00000014   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   2097          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0xFFE1F7FD         DC32     0xffe1f7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xFF1F0EFE         DC32     0xff1f0efe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0xFF3F0000         DC32     0xff3f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0xFF0106F0         DC32     0xff0106f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0xFFFFFDFE         DC32     0xfffffdfe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40012800         DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x40012404         DC32     0x40012404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x24924924         DC32     0x24924924

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x00924924         DC32     0x924924

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x12492492         DC32     0x12492492

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x00492492         DC32     0x492492

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x00249249         DC32     0x249249

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0xFFFFF1FE         DC32     0xfffff1fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0xFF3FFDE0         DC32     0xff3ffde0
   2098          
   2099          /**
   2100            * @}
   2101            */
   2102          
   2103          #endif /* HAL_ADC_MODULE_ENABLED */
   2104          /**
   2105            * @}
   2106            */
   2107          
   2108          /**
   2109            * @}
   2110            */
   2111          
   2112          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_ConversionStop_Disable
        16   -> HAL_GetTick
       8   ADC_DMAConvCplt
         0   -- Indirect call
         8   -> HAL_ADC_ConvCpltCallback
       8   ADC_DMAError
         8   -> HAL_ADC_ErrorCallback
       8   ADC_DMAHalfConvCplt
         8   -> HAL_ADC_ConvHalfCpltCallback
      16   ADC_Enable
        16   -> HAL_GetTick
       4   HAL_ADC_AnalogWDGConfig
      20   HAL_ADC_ConfigChannel
       0   HAL_ADC_ConvCpltCallback
       0   HAL_ADC_ConvHalfCpltCallback
      16   HAL_ADC_DeInit
        16   -> ADC_ConversionStop_Disable
        16   -> HAL_ADC_MspDeInit
       0   HAL_ADC_ErrorCallback
       0   HAL_ADC_GetError
       0   HAL_ADC_GetState
       0   HAL_ADC_GetValue
       8   HAL_ADC_IRQHandler
         8   -> HAL_ADCEx_InjectedConvCpltCallback
         8   -> HAL_ADC_ConvCpltCallback
         8   -> HAL_ADC_LevelOutOfWindowCallback
      16   HAL_ADC_Init
        16   -> ADC_ConversionStop_Disable
        16   -> HAL_ADC_MspInit
       0   HAL_ADC_LevelOutOfWindowCallback
       0   HAL_ADC_MspDeInit
       0   HAL_ADC_MspInit
      24   HAL_ADC_PollForConversion
        24   -> HAL_GetTick
        24   -> HAL_RCCEx_GetPeriphCLKFreq
      24   HAL_ADC_PollForEvent
        24   -> HAL_GetTick
       8   HAL_ADC_Start
         8   -> ADC_Enable
      24   HAL_ADC_Start_DMA
        24   -> ADC_Enable
        24   -> HAL_DMA_Start_IT
       8   HAL_ADC_Start_IT
         8   -> ADC_Enable
       8   HAL_ADC_Stop
         8   -> ADC_ConversionStop_Disable
       8   HAL_ADC_Stop_DMA
         8   -> ADC_ConversionStop_Disable
         8   -> HAL_DMA_Abort
       8   HAL_ADC_Stop_IT
         8   -> ADC_ConversionStop_Disable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      68  ADC_ConversionStop_Disable
      80  ADC_DMAConvCplt
      26  ADC_DMAError
      10  ADC_DMAHalfConvCplt
     104  ADC_Enable
      86  HAL_ADC_AnalogWDGConfig
     252  HAL_ADC_ConfigChannel
       2  HAL_ADC_ConvCpltCallback
       2  HAL_ADC_ConvHalfCpltCallback
     222  HAL_ADC_DeInit
       2  HAL_ADC_ErrorCallback
       4  HAL_ADC_GetError
       4  HAL_ADC_GetState
       6  HAL_ADC_GetValue
     244  HAL_ADC_IRQHandler
     292  HAL_ADC_Init
       2  HAL_ADC_LevelOutOfWindowCallback
       2  HAL_ADC_MspDeInit
       2  HAL_ADC_MspInit
     328  HAL_ADC_PollForConversion
      82  HAL_ADC_PollForEvent
     264  HAL_ADC_Start
     340  HAL_ADC_Start_DMA
     274  HAL_ADC_Start_IT
      56  HAL_ADC_Stop
      80  HAL_ADC_Stop_DMA
      62  HAL_ADC_Stop_IT

 
 2 968 bytes in section .text
 
 2 968 bytes of CODE memory

Errors: none
Warnings: none
