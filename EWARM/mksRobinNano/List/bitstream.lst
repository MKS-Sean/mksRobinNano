###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:01
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\bitstream.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\bitstream.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\bitstream.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\bitstream.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\QRENCODE\bitstream.c
      1          /*
      2           * qrencode - QR Code encoder
      3           *
      4           * Binary sequence class.
      5           * Copyright (C) 2006-2011 Kentaro Fukuchi <kentaro@fukuchi.org>
      6           *
      7           * This library is free software; you can redistribute it and/or
      8           * modify it under the terms of the GNU Lesser General Public
      9           * License as published by the Free Software Foundation; either
     10           * version 2.1 of the License, or any later version.
     11           *
     12           * This library is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
     15           * Lesser General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU Lesser General Public
     18           * License along with this library; if not, write to the Free Software
     19           * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
     20           */
     21          
     22          #if HAVE_CONFIG_H
     23          # include "config.h"
     24          #endif
     25          #include <stdio.h>
     26          #include <stdlib.h>
     27          #include <string.h>
     28          
     29          #include "bitstream.h"
     30          

   \                                 In section .text, align 2, keep-with-next
     31          BitStream *BitStream_new(void)
     32          {
   \                     BitStream_new: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     33          	BitStream *bstream;
     34          
     35          	bstream = (BitStream *)malloc(sizeof(BitStream));
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0x.... 0x....      BL       malloc
     36          	if(bstream == NULL) return NULL;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??BitStream_new_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
     37          
     38          	bstream->length = 0;
   \                     ??BitStream_new_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6001             STR      R1,[R0, #+0]
     39          	bstream->data = NULL;
   \   00000014   0x6041             STR      R1,[R0, #+4]
     40          
     41          	return bstream;
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
     42          }
     43          

   \                                 In section .text, align 2, keep-with-next
     44          static int BitStream_allocate(BitStream *bstream, int length)
     45          {
   \                     BitStream_allocate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     46          	unsigned char *data;
     47          
     48          	if(bstream == NULL) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??BitStream_allocate_0
     49          		return -1;
     50          	}
     51          
     52          	data = (unsigned char *)malloc(length);
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       malloc
   \   00000010   0x0006             MOVS     R6,R0
     53          	if(data == NULL) {
   \   00000012   0xD102             BNE.N    ??BitStream_allocate_1
     54          		return -1;
   \                     ??BitStream_allocate_0: (+1)
   \   00000014   0xF04F 0x30FF      MOV      R0,#-1
   \   00000018   0xBD70             POP      {R4-R6,PC}
     55          	}
     56          
     57          	if(bstream->data) {
   \                     ??BitStream_allocate_1: (+1)
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??BitStream_allocate_2
     58          		free(bstream->data);
   \   00000020   0x.... 0x....      BL       free
     59          	}
     60          	bstream->length = length;
   \                     ??BitStream_allocate_2: (+1)
   \   00000024   0x6025             STR      R5,[R4, #+0]
     61          	bstream->data = data;
   \   00000026   0x6066             STR      R6,[R4, #+4]
     62          
     63          	return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
     64          }
     65          

   \                                 In section .text, align 2, keep-with-next
     66          static BitStream *BitStream_newFromNum(int bits, unsigned int num)
     67          {
   \                     BitStream_newFromNum: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     68          	unsigned int mask;
     69          	int i;
     70          	unsigned char *p;
     71          	BitStream *bstream;
     72          
     73          	bstream = BitStream_new();
   \   00000006   0x.... 0x....      BL       BitStream_new
   \   0000000A   0x0006             MOVS     R6,R0
     74          	if(bstream == NULL) return NULL;
   \   0000000C   0xD101             BNE.N    ??BitStream_newFromNum_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD70             POP      {R4-R6,PC}
     75          
     76          	if(BitStream_allocate(bstream, bits)) {
   \                     ??BitStream_newFromNum_0: (+1)
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x.... 0x....      BL       BitStream_allocate
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??BitStream_newFromNum_1
     77          		BitStream_free(bstream);
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       BitStream_free
     78          		return NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}
     79          	}
     80          
     81          	p = bstream->data;
   \                     ??BitStream_newFromNum_1: (+1)
   \   00000026   0x6870             LDR      R0,[R6, #+4]
     82          	mask = 1 << (bits - 1);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x4622             MOV      R2,R4
   \   0000002C   0x1E52             SUBS     R2,R2,#+1
   \   0000002E   0x4091             LSLS     R1,R1,R2
     83          	for(i=0; i<bits; i++) {
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0xE009             B.N      ??BitStream_newFromNum_2
     84          		if(num & mask) {
   \                     ??BitStream_newFromNum_3: (+1)
   \   00000034   0xEA01 0x0305      AND      R3,R1,R5
   \   00000038   0x1E5B             SUBS     R3,R3,#+1
   \   0000003A   0x419B             SBCS     R3,R3,R3
   \   0000003C   0x43DB             MVNS     R3,R3
   \   0000003E   0x0FDB             LSRS     R3,R3,#+31
   \   00000040   0xF800 0x3B01      STRB     R3,[R0], #+1
     85          			*p = 1;
     86          		} else {
     87          			*p = 0;
     88          		}
     89          		p++;
     90          		mask = mask >> 1;
   \   00000044   0x0849             LSRS     R1,R1,#+1
     91          	}
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \                     ??BitStream_newFromNum_2: (+1)
   \   00000048   0x42A2             CMP      R2,R4
   \   0000004A   0xDBF3             BLT.N    ??BitStream_newFromNum_3
     92          
     93          	return bstream;
   \   0000004C   0x4630             MOV      R0,R6
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          static BitStream *BitStream_newFromBytes(int size, unsigned char *data)
     97          {
   \                     BitStream_newFromBytes: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     98          	unsigned char mask;
     99          	int i, j;
    100          	unsigned char *p;
    101          	BitStream *bstream;
    102          
    103          	bstream = BitStream_new();
   \   00000006   0x.... 0x....      BL       BitStream_new
   \   0000000A   0x0006             MOVS     R6,R0
    104          	if(bstream == NULL) return NULL;
   \   0000000C   0xD101             BNE.N    ??BitStream_newFromBytes_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}
    105          
    106          	if(BitStream_allocate(bstream, size * 8)) {
   \                     ??BitStream_newFromBytes_0: (+1)
   \   00000012   0x00E1             LSLS     R1,R4,#+3
   \   00000014   0x.... 0x....      BL       BitStream_allocate
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD004             BEQ.N    ??BitStream_newFromBytes_1
    107          		BitStream_free(bstream);
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       BitStream_free
    108          		return NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}
    109          	}
    110          
    111          	p = bstream->data;
   \                     ??BitStream_newFromBytes_1: (+1)
   \   00000026   0x6870             LDR      R0,[R6, #+4]
    112          	for(i=0; i<size; i++) {
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xE011             B.N      ??BitStream_newFromBytes_2
    113          		mask = 0x80;
    114          		for(j=0; j<8; j++) {
    115          			if(data[i] & mask) {
   \                     ??BitStream_newFromBytes_3: (+1)
   \   0000002C   0x5D4F             LDRB     R7,[R1, R5]
   \   0000002E   0x4017             ANDS     R7,R2,R7
   \   00000030   0x46BC             MOV      R12,R7
   \   00000032   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   00000036   0xEB6C 0x0C0C      SBC      R12,R12,R12
   \   0000003A   0xEA6F 0x0C0C      MVN      R12,R12
   \   0000003E   0xEA4F 0x7CDC      LSR      R12,R12,#+31
   \   00000042   0xF800 0xCB01      STRB     R12,[R0], #+1
    116          				*p = 1;
    117          			} else {
    118          				*p = 0;
    119          			}
    120          			p++;
    121          			mask = mask >> 1;
   \   00000046   0x1052             ASRS     R2,R2,#+1
    122          		}
   \   00000048   0x1C5B             ADDS     R3,R3,#+1
   \                     ??BitStream_newFromBytes_4: (+1)
   \   0000004A   0x2B08             CMP      R3,#+8
   \   0000004C   0xDBEE             BLT.N    ??BitStream_newFromBytes_3
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \                     ??BitStream_newFromBytes_2: (+1)
   \   00000050   0x42A1             CMP      R1,R4
   \   00000052   0xDA02             BGE.N    ??BitStream_newFromBytes_5
   \   00000054   0x2280             MOVS     R2,#+128
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0xE7F7             B.N      ??BitStream_newFromBytes_4
    123          	}
    124          
    125          	return bstream;
   \                     ??BitStream_newFromBytes_5: (+1)
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          int BitStream_append(BitStream *bstream, BitStream *arg)
    129          {
   \                     BitStream_append: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    130          	unsigned char *data;
    131          
    132          	if(arg == NULL) {
   \   00000006   0xD102             BNE.N    ??BitStream_append_0
    133          		return -1;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    134          	}
    135          	if(arg->length == 0) {
   \                     ??BitStream_append_0: (+1)
   \   0000000E   0x6829             LDR      R1,[R5, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD101             BNE.N    ??BitStream_append_1
    136          		return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD70             POP      {R4-R6,PC}
    137          	}
    138          	if(bstream->length == 0) {
   \                     ??BitStream_append_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD10E             BNE.N    ??BitStream_append_2
    139          		if(BitStream_allocate(bstream, arg->length)) {
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       BitStream_allocate
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD002             BEQ.N    ??BitStream_append_3
    140          			return -1;
   \   00000028   0xF04F 0x30FF      MOV      R0,#-1
   \   0000002C   0xBD70             POP      {R4-R6,PC}
    141          		}
    142          		memcpy(bstream->data, arg->data, arg->length);
   \                     ??BitStream_append_3: (+1)
   \   0000002E   0x682A             LDR      R2,[R5, #+0]
   \   00000030   0x6869             LDR      R1,[R5, #+4]
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x.... 0x....      BL       memcpy
    143          		return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD70             POP      {R4-R6,PC}
    144          	}
    145          
    146          	data = (unsigned char *)malloc(bstream->length + arg->length);
   \                     ??BitStream_append_2: (+1)
   \   0000003C   0x1808             ADDS     R0,R1,R0
   \   0000003E   0x.... 0x....      BL       malloc
   \   00000042   0x0006             MOVS     R6,R0
    147          	if(data == NULL) {
   \   00000044   0xD102             BNE.N    ??BitStream_append_4
    148          		return -1;
   \   00000046   0xF04F 0x30FF      MOV      R0,#-1
   \   0000004A   0xBD70             POP      {R4-R6,PC}
    149          	}
    150          	memcpy(data, bstream->data, bstream->length);
   \                     ??BitStream_append_4: (+1)
   \   0000004C   0x6822             LDR      R2,[R4, #+0]
   \   0000004E   0x6861             LDR      R1,[R4, #+4]
   \   00000050   0x.... 0x....      BL       memcpy
    151          	memcpy(data + bstream->length, arg->data, arg->length);
   \   00000054   0x682A             LDR      R2,[R5, #+0]
   \   00000056   0x6869             LDR      R1,[R5, #+4]
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x1980             ADDS     R0,R0,R6
   \   0000005C   0x.... 0x....      BL       memcpy
    152          
    153          	free(bstream->data);
   \   00000060   0x6860             LDR      R0,[R4, #+4]
   \   00000062   0x.... 0x....      BL       free
    154          	bstream->length += arg->length;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6829             LDR      R1,[R5, #+0]
   \   0000006A   0x1808             ADDS     R0,R1,R0
   \   0000006C   0x6020             STR      R0,[R4, #+0]
    155          	bstream->data = data;
   \   0000006E   0x6066             STR      R6,[R4, #+4]
    156          
    157          	return 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    158          }
    159          

   \                                 In section .text, align 2, keep-with-next
    160          int BitStream_appendNum(BitStream *bstream, int bits, unsigned int num)
    161          {
   \                     BitStream_appendNum: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
    162          	BitStream *b;
    163          	int ret;
    164          
    165          	if(bits == 0) return 0;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??BitStream_appendNum_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    166          
    167          	b = BitStream_newFromNum(bits, num);
   \                     ??BitStream_appendNum_0: (+1)
   \   00000010   0x.... 0x....      BL       BitStream_newFromNum
   \   00000014   0x0005             MOVS     R5,R0
    168          	if(b == NULL) return -1;
   \   00000016   0xD102             BNE.N    ??BitStream_appendNum_1
   \   00000018   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
    169          
    170          	ret = BitStream_append(bstream, b);
   \                     ??BitStream_appendNum_1: (+1)
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       BitStream_append
   \   00000026   0x4604             MOV      R4,R0
    171          	BitStream_free(b);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       BitStream_free
    172          
    173          	return ret;
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          int BitStream_appendBytes(BitStream *bstream, int size, unsigned char *data)
    177          {
   \                     BitStream_appendBytes: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
    178          	BitStream *b;
    179          	int ret;
    180          
    181          	if(size == 0) return 0;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??BitStream_appendBytes_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    182          
    183          	b = BitStream_newFromBytes(size, data);
   \                     ??BitStream_appendBytes_0: (+1)
   \   00000010   0x.... 0x....      BL       BitStream_newFromBytes
   \   00000014   0x0005             MOVS     R5,R0
    184          	if(b == NULL) return -1;
   \   00000016   0xD102             BNE.N    ??BitStream_appendBytes_1
   \   00000018   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
    185          
    186          	ret = BitStream_append(bstream, b);
   \                     ??BitStream_appendBytes_1: (+1)
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       BitStream_append
   \   00000026   0x4604             MOV      R4,R0
    187          	BitStream_free(b);
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       BitStream_free
    188          
    189          	return ret;
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          unsigned char *BitStream_toByte(BitStream *bstream)
    193          {
   \                     BitStream_toByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    194          	int i, j, size, bytes;
    195          	unsigned char *data, v;
    196          	unsigned char *p;
    197          
    198          	size = BitStream_size(bstream);
   \   00000004   0x682C             LDR      R4,[R5, #+0]
    199          	if(size == 0) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??BitStream_toByte_0
    200          		return NULL;
    201          	}
    202          	data = (unsigned char *)malloc((size + 7) / 8);
   \   0000000A   0x1DE0             ADDS     R0,R4,#+7
   \   0000000C   0x1081             ASRS     R1,R0,#+2
   \   0000000E   0xEB00 0x7051      ADD      R0,R0,R1, LSR #+29
   \   00000012   0x10C0             ASRS     R0,R0,#+3
   \   00000014   0x.... 0x....      BL       malloc
    203          	if(data == NULL) {
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??BitStream_toByte_1
    204          		return NULL;
   \                     ??BitStream_toByte_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}
    205          	}
    206          
    207          	bytes = size  / 8;
   \                     ??BitStream_toByte_1: (+1)
   \   00000020   0x10A1             ASRS     R1,R4,#+2
   \   00000022   0xEB04 0x7151      ADD      R1,R4,R1, LSR #+29
   \   00000026   0x10C9             ASRS     R1,R1,#+3
    208          
    209          	p = bstream->data;
   \   00000028   0x686A             LDR      R2,[R5, #+4]
    210          	for(i=0; i<bytes; i++) {
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0xE008             B.N      ??BitStream_toByte_2
    211          		v = 0;
    212          		for(j=0; j<8; j++) {
    213          			v = v << 1;
    214          			v |= *p;
   \                     ??BitStream_toByte_3: (+1)
   \   0000002E   0xF812 0x7B01      LDRB     R7,[R2], #+1
   \   00000032   0xEA47 0x0545      ORR      R5,R7,R5, LSL #+1
    215          			p++;
    216          		}
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \                     ??BitStream_toByte_4: (+1)
   \   00000038   0x2E08             CMP      R6,#+8
   \   0000003A   0xDBF8             BLT.N    ??BitStream_toByte_3
    217          		data[i] = v;
   \   0000003C   0x541D             STRB     R5,[R3, R0]
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??BitStream_toByte_2: (+1)
   \   00000040   0x428B             CMP      R3,R1
   \   00000042   0xDA02             BGE.N    ??BitStream_toByte_5
   \   00000044   0x2500             MOVS     R5,#+0
   \   00000046   0x462E             MOV      R6,R5
   \   00000048   0xE7F6             B.N      ??BitStream_toByte_4
    218          	}
    219          	if(size & 7) {
   \                     ??BitStream_toByte_5: (+1)
   \   0000004A   0xF014 0x0F07      TST      R4,#0x7
   \   0000004E   0xD00C             BEQ.N    ??BitStream_toByte_6
    220          		v = 0;
   \   00000050   0x2500             MOVS     R5,#+0
    221          		for(j=0; j<(size & 7); j++) {
   \   00000052   0x462E             MOV      R6,R5
   \   00000054   0xE004             B.N      ??BitStream_toByte_7
    222          			v = v << 1;
    223          			v |= *p;
   \                     ??BitStream_toByte_8: (+1)
   \   00000056   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \   0000005A   0xEA43 0x0545      ORR      R5,R3,R5, LSL #+1
    224          			p++;
    225          		}
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \                     ??BitStream_toByte_7: (+1)
   \   00000060   0xF004 0x0307      AND      R3,R4,#0x7
   \   00000064   0x429E             CMP      R6,R3
   \   00000066   0xDBF6             BLT.N    ??BitStream_toByte_8
    226          		data[bytes] = v;
   \   00000068   0x540D             STRB     R5,[R1, R0]
    227          	}
    228          
    229          	return data;
   \                     ??BitStream_toByte_6: (+1)
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    230          }
    231          

   \                                 In section .text, align 2, keep-with-next
    232          void BitStream_free(BitStream *bstream)
    233          {
   \                     BitStream_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    234          	if(bstream != NULL) {
   \   00000004   0xD007             BEQ.N    ??BitStream_free_0
    235          		free(bstream->data);
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x.... 0x....      BL       free
    236          		free(bstream);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      free
    237          	}
    238          }
   \                     ??BitStream_free_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BitStream_allocate
        16   -> free
        16   -> malloc
      16   BitStream_append
        16   -> BitStream_allocate
        16   -> free
        16   -> malloc
        16   -> memcpy
      16   BitStream_appendBytes
        16   -> BitStream_append
        16   -> BitStream_free
        16   -> BitStream_newFromBytes
      16   BitStream_appendNum
        16   -> BitStream_append
        16   -> BitStream_free
        16   -> BitStream_newFromNum
       8   BitStream_free
         0   -> free
         8   -> free
       8   BitStream_new
         8   -> malloc
      24   BitStream_newFromBytes
        24   -> BitStream_allocate
        24   -> BitStream_free
        24   -> BitStream_new
      16   BitStream_newFromNum
        16   -> BitStream_allocate
        16   -> BitStream_free
        16   -> BitStream_new
      24   BitStream_toByte
        24   -> malloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      44  BitStream_allocate
     116  BitStream_append
      50  BitStream_appendBytes
      50  BitStream_appendNum
      24  BitStream_free
      24  BitStream_new
      94  BitStream_newFromBytes
      80  BitStream_newFromNum
     108  BitStream_toByte

 
 590 bytes in section .text
 
 590 bytes of CODE memory

Errors: none
Warnings: none
