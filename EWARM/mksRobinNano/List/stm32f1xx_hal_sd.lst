###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:06
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_sd.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_sd.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_hal_sd.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_hal_sd.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_sd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_sd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   SD card HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Secure Digital (SD) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              This driver implements a high level communication layer for read and write from/to 
     21              this memory. The needed STM32 hardware resources (SDIO and GPIO) are performed by 
     22              the user in HAL_SD_MspInit() function (MSP layer).                             
     23              Basically, the MSP layer configuration should be the same as we provide in the 
     24              examples.
     25              You can easily tailor this configuration according to hardware resources.
     26          
     27            [..]
     28              This driver is a generic layered driver for SDIO memories which uses the HAL 
     29              SDIO driver functions to interface with SD and uSD cards devices. 
     30              It is used as follows:
     31           
     32              (#)Initialize the SDIO low level resources by implement the HAL_SD_MspInit() API:
     33                  (##) Enable the SDIO interface clock using __HAL_RCC_SDIO_CLK_ENABLE(); 
     34                  (##) SDIO pins configuration for SD card
     35                      (+++) Enable the clock for the SDIO GPIOs using the functions __HAL_RCC_GPIOx_CLK_ENABLE();   
     36                      (+++) Configure these SDIO pins as alternate function pull-up using HAL_GPIO_Init()
     37                            and according to your pin assignment;
     38                  (##) DMA Configuration if you need to use DMA process (HAL_SD_ReadBlocks_DMA()
     39                       and HAL_SD_WriteBlocks_DMA() APIs).
     40                      (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE(); 
     41                      (+++) Configure the DMA using the function HAL_DMA_Init() with predeclared and filled. 
     42                  (##) NVIC configuration if you need to use interrupt process when using DMA transfer.
     43                      (+++) Configure the SDIO and DMA interrupt priorities using functions
     44                            HAL_NVIC_SetPriority(); DMA priority is superior to SDIO's priority
     45                      (+++) Enable the NVIC DMA and SDIO IRQs using function HAL_NVIC_EnableIRQ()
     46                      (+++) SDIO interrupts are managed using the macros __HAL_SD_SDIO_ENABLE_IT() 
     47                            and __HAL_SD_SDIO_DISABLE_IT() inside the communication process.
     48                      (+++) SDIO interrupts pending bits are managed using the macros __HAL_SD_SDIO_GET_IT()
     49                            and __HAL_SD_SDIO_CLEAR_IT()
     50              (#) At this stage, you can perform SD read/write/erase operations after SD card initialization  
     51          
     52                   
     53            *** SD Card Initialization and configuration ***
     54            ================================================    
     55            [..]
     56              To initialize the SD Card, use the HAL_SD_Init() function.  It Initializes 
     57              the SD Card and put it into StandBy State (Ready for data transfer). 
     58              This function provide the following operations:
     59            
     60              (#) Apply the SD Card initialization process at 400KHz and check the SD Card 
     61                  type (Standard Capacity or High Capacity). You can change or adapt this 
     62                  frequency by adjusting the "ClockDiv" field. 
     63                  The SD Card frequency (SDIO_CK) is computed as follows:
     64            
     65                     SDIO_CK = SDIOCLK / (ClockDiv + 2)
     66            
     67                  In initialization mode and according to the SD Card standard, 
     68                  make sure that the SDIO_CK frequency doesn't exceed 400KHz.
     69            
     70              (#) Get the SD CID and CSD data. All these information are managed by the SDCardInfo 
     71                  structure. This structure provide also ready computed SD Card capacity 
     72                  and Block size.
     73                  
     74                  -@- These information are stored in SD handle structure in case of future use.  
     75            
     76              (#) Configure the SD Card Data transfer frequency. The card transfer 
     77                  frequency is set to SDIOCLK / (SDIO_TRANSFER_CLK_DIV + 2). You can change or adapt this frequency by adjusting 
     78                  the "ClockDiv" field.
     79                  The SD Card frequency (SDIO_CK) is computed as follows:
     80          
     81                     SDIO_CK = SDIOCLK / (ClockDiv + 2) 
     82          
     83                  In transfer mode and according to the SD Card standard, make sure that the 
     84                  SDIO_CK frequency doesn't exceed 25MHz and 50MHz in High-speed mode switch.
     85            
     86              (#) Select the corresponding SD Card according to the address read with the step 2.
     87              
     88              (#) Configure the SD Card in wide bus mode: 4-bits data.
     89            
     90            *** SD Card Read operation ***
     91            ==============================
     92            [..] 
     93              (+) You can read from SD card in polling mode by using function HAL_SD_ReadBlocks(). 
     94                  This function support only 512-bytes block length (the block size should be 
     95                  chosen as 512 bytes).
     96                  You can choose either one block read operation or multiple block read operation 
     97                  by adjusting the "NumberOfBlocks" parameter.
     98          
     99              (+) You can read from SD card in DMA mode by using function HAL_SD_ReadBlocks_DMA().
    100                  This function support only 512-bytes block length (the block size should be 
    101                  chosen as 512 bytes).
    102                  You can choose either one block read operation or multiple block read operation 
    103                  by adjusting the "NumberOfBlocks" parameter.
    104                  After this, you have to call the function HAL_SD_CheckReadOperation(), to insure
    105                  that the read transfer is done correctly in both DMA and SD sides.
    106            
    107            *** SD Card Write operation ***
    108            =============================== 
    109            [..] 
    110              (+) You can write to SD card in polling mode by using function HAL_SD_WriteBlocks(). 
    111                  This function support only 512-bytes block length (the block size should be 
    112                  chosen as 512 bytes).
    113                  You can choose either one block read operation or multiple block read operation 
    114                  by adjusting the "NumberOfBlocks" parameter.
    115          
    116              (+) You can write to SD card in DMA mode by using function HAL_SD_WriteBlocks_DMA().
    117                  This function support only 512-bytes block length (the block size should be 
    118                  chosen as 512 byte).
    119                  You can choose either one block read operation or multiple block read operation 
    120                  by adjusting the "NumberOfBlocks" parameter.
    121                  After this, you have to call the function HAL_SD_CheckWriteOperation(), to insure
    122                  that the write transfer is done correctly in both DMA and SD sides.  
    123            
    124            *** SD card status ***
    125            ====================== 
    126            [..]
    127              (+) At any time, you can check the SD Card status and get the SD card state 
    128                  by using the HAL_SD_GetStatus() function. This function checks first if the 
    129                  SD card is still connected and then get the internal SD Card transfer state.     
    130              (+) You can also get the SD card SD Status register by using the HAL_SD_SendSDStatus() 
    131                  function.    
    132          
    133            *** SD HAL driver macros list ***
    134            ==================================
    135            [..]
    136              Below the list of most used macros in SD HAL driver.
    137              (+) __HAL_SD_SDIO_ENABLE : Enable the SD device
    138              (+) __HAL_SD_SDIO_DISABLE : Disable the SD device
    139              (+) __HAL_SD_SDIO_DMA_ENABLE: Enable the SDIO DMA transfer
    140              (+) __HAL_SD_SDIO_DMA_DISABLE: Disable the SDIO DMA transfer
    141              (+) __HAL_SD_SDIO_ENABLE_IT: Enable the SD device interrupt
    142              (+) __HAL_SD_SDIO_DISABLE_IT: Disable the SD device interrupt
    143              (+) __HAL_SD_SDIO_GET_FLAG:Check whether the specified SD flag is set or not
    144              (+) __HAL_SD_SDIO_CLEAR_FLAG: Clear the SD's pending flags
    145                
    146              -@- You can refer to the SD HAL driver header file for more useful macros 
    147          
    148            @endverbatim
    149            ******************************************************************************
    150            * @attention
    151            *
    152            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    153            *
    154            * Redistribution and use in source and binary forms, with or without modification,
    155            * are permitted provided that the following conditions are met:
    156            *   1. Redistributions of source code must retain the above copyright notice,
    157            *      this list of conditions and the following disclaimer.
    158            *   2. Redistributions in binary form must reproduce the above copyright notice,
    159            *      this list of conditions and the following disclaimer in the documentation
    160            *      and/or other materials provided with the distribution.
    161            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    162            *      may be used to endorse or promote products derived from this software
    163            *      without specific prior written permission.
    164            *
    165            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    166            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    167            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    168            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    169            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    170            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    171            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    172            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    173            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    174            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    175            *
    176            ******************************************************************************
    177            */ 
    178          
    179          /* Includes ------------------------------------------------------------------*/
    180          #include "stm32f1xx_hal.h"
    181          
    182          #ifdef HAL_SD_MODULE_ENABLED
    183          
    184          #if defined(STM32F103xE) || defined(STM32F103xG)
    185          
    186          /** @addtogroup STM32F1xx_HAL_Driver
    187            * @{
    188            */
    189          
    190          /** @defgroup SD SD
    191            * @brief SD HAL module driver
    192            * @{
    193            */
    194          
    195          /* Private typedef -----------------------------------------------------------*/
    196          /* Private define ------------------------------------------------------------*/
    197          
    198          /** @defgroup SD_Private_Define SD Private Constant
    199            * @{
    200            */
    201          /** 
    202            * @brief  SDIO Data block size 
    203            */ 
    204          #define DATA_BLOCK_SIZE                  ((uint32_t)(9 << 4))
    205          /** 
    206            * @brief  SDIO Static flags, TimeOut, FIFO Address  
    207            */
    208          #define SDIO_STATIC_FLAGS               ((uint32_t)(SDIO_FLAG_CCRCFAIL | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_CTIMEOUT |\
    209                                                              SDIO_FLAG_DTIMEOUT | SDIO_FLAG_TXUNDERR | SDIO_FLAG_RXOVERR  |\
    210                                                              SDIO_FLAG_CMDREND  | SDIO_FLAG_CMDSENT  | SDIO_FLAG_DATAEND  |\
    211                                                              SDIO_FLAG_DBCKEND))  
    212          
    213          #define SDIO_CMD0TIMEOUT                ((uint32_t)0x00010000)
    214          
    215          /** 
    216            * @brief  Mask for errors Card Status R1 (OCR Register) 
    217            */
    218          #define SD_OCR_ADDR_OUT_OF_RANGE        ((uint32_t)0x80000000)
    219          #define SD_OCR_ADDR_MISALIGNED          ((uint32_t)0x40000000)
    220          #define SD_OCR_BLOCK_LEN_ERR            ((uint32_t)0x20000000)
    221          #define SD_OCR_ERASE_SEQ_ERR            ((uint32_t)0x10000000)
    222          #define SD_OCR_BAD_ERASE_PARAM          ((uint32_t)0x08000000)
    223          #define SD_OCR_WRITE_PROT_VIOLATION     ((uint32_t)0x04000000)
    224          #define SD_OCR_LOCK_UNLOCK_FAILED       ((uint32_t)0x01000000)
    225          #define SD_OCR_COM_CRC_FAILED           ((uint32_t)0x00800000)
    226          #define SD_OCR_ILLEGAL_CMD              ((uint32_t)0x00400000)
    227          #define SD_OCR_CARD_ECC_FAILED          ((uint32_t)0x00200000)
    228          #define SD_OCR_CC_ERROR                 ((uint32_t)0x00100000)
    229          #define SD_OCR_GENERAL_UNKNOWN_ERROR    ((uint32_t)0x00080000)
    230          #define SD_OCR_STREAM_READ_UNDERRUN     ((uint32_t)0x00040000)
    231          #define SD_OCR_STREAM_WRITE_OVERRUN     ((uint32_t)0x00020000)
    232          #define SD_OCR_CID_CSD_OVERWRITE       ((uint32_t)0x00010000)
    233          #define SD_OCR_WP_ERASE_SKIP            ((uint32_t)0x00008000)
    234          #define SD_OCR_CARD_ECC_DISABLED        ((uint32_t)0x00004000)
    235          #define SD_OCR_ERASE_RESET              ((uint32_t)0x00002000)
    236          #define SD_OCR_AKE_SEQ_ERROR            ((uint32_t)0x00000008)
    237          #define SD_OCR_ERRORBITS                ((uint32_t)0xFDFFE008)
    238          
    239          /** 
    240            * @brief  Masks for R6 Response 
    241            */
    242          #define SD_R6_GENERAL_UNKNOWN_ERROR     ((uint32_t)0x00002000)
    243          #define SD_R6_ILLEGAL_CMD               ((uint32_t)0x00004000)
    244          #define SD_R6_COM_CRC_FAILED            ((uint32_t)0x00008000)
    245          
    246          #define SD_VOLTAGE_WINDOW_SD            ((uint32_t)0x80100000)
    247          #define SD_HIGH_CAPACITY                ((uint32_t)0x40000000)
    248          #define SD_STD_CAPACITY                 ((uint32_t)0x00000000)
    249          #define SD_CHECK_PATTERN                ((uint32_t)0x000001AA)
    250          
    251          #define SD_MAX_VOLT_TRIAL               ((uint32_t)0x0000FFFF)
    252          #define SD_ALLZERO                      ((uint32_t)0x00000000)
    253          
    254          #define SD_WIDE_BUS_SUPPORT             ((uint32_t)0x00040000)
    255          #define SD_SINGLE_BUS_SUPPORT           ((uint32_t)0x00010000)
    256          #define SD_CARD_LOCKED                  ((uint32_t)0x02000000)
    257          
    258          #define SD_DATATIMEOUT                  ((uint32_t)0xFFFFFFFF)
    259          #define SD_0TO7BITS                     ((uint32_t)0x000000FF)
    260          #define SD_8TO15BITS                    ((uint32_t)0x0000FF00)
    261          #define SD_16TO23BITS                   ((uint32_t)0x00FF0000)
    262          #define SD_24TO31BITS                   ((uint32_t)0xFF000000)
    263          #define SD_MAX_DATA_LENGTH              ((uint32_t)0x01FFFFFF)
    264          
    265          #define SD_HALFFIFO                     ((uint32_t)0x00000008)
    266          #define SD_HALFFIFOBYTES                ((uint32_t)0x00000020)
    267          
    268          /** 
    269            * @brief  Command Class Supported 
    270            */
    271          #define SD_CCCC_LOCK_UNLOCK             ((uint32_t)0x00000080)
    272          #define SD_CCCC_WRITE_PROT              ((uint32_t)0x00000040)
    273          #define SD_CCCC_ERASE                   ((uint32_t)0x00000020)
    274          
    275          /** 
    276            * @brief  Following commands are SD Card Specific commands.
    277            *         SDIO_APP_CMD should be sent before sending these commands. 
    278            */
    279          #define SD_SDIO_SEND_IF_COND            ((uint32_t)SD_CMD_HS_SEND_EXT_CSD)
    280          
    281          /**
    282            * @}
    283            */
    284            
    285          /* Private macro -------------------------------------------------------------*/
    286          /* Private variables ---------------------------------------------------------*/
    287          /* Private function prototypes -----------------------------------------------*/
    288          /* Private functions ---------------------------------------------------------*/
    289          
    290          /** @defgroup SD_Private_Functions SD Private Functions
    291            * @{
    292            */
    293            
    294          static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd);
    295          static HAL_SD_ErrorTypedef SD_Select_Deselect(SD_HandleTypeDef *hsd, uint64_t Addr);
    296          static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd); 
    297          static HAL_SD_ErrorTypedef SD_PowerOFF(SD_HandleTypeDef *hsd);
    298          static HAL_SD_ErrorTypedef SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus);
    299          static HAL_SD_CardStateTypedef SD_GetState(SD_HandleTypeDef *hsd);
    300          static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus);
    301          static HAL_SD_ErrorTypedef SD_CmdError(SD_HandleTypeDef *hsd);
    302          static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD);
    303          static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd);
    304          static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd);
    305          static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd);
    306          static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA);
    307          static HAL_SD_ErrorTypedef SD_WideBus_Enable(SD_HandleTypeDef *hsd);
    308          static HAL_SD_ErrorTypedef SD_WideBus_Disable(SD_HandleTypeDef *hsd);
    309          static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR);  
    310          static void SD_DMA_RxCplt(DMA_HandleTypeDef *hdma);
    311          static void SD_DMA_RxError(DMA_HandleTypeDef *hdma);
    312          static void SD_DMA_TxCplt(DMA_HandleTypeDef *hdma);
    313          static void SD_DMA_TxError(DMA_HandleTypeDef *hdma);
    314          
    315          /**
    316            * @}
    317            */
    318            
    319          /** @defgroup SD_Exported_Functions SD Exported Functions
    320            * @{
    321            */
    322          
    323          /** @defgroup SD_Exported_Functions_Group1 Initialization and de-initialization functions 
    324           *  @brief    Initialization and Configuration functions 
    325           *
    326          @verbatim    
    327           ===============================================================================
    328                        ##### Initialization and de-initialization functions #####
    329           ===============================================================================
    330            [..]  
    331              This section provides functions allowing to initialize/de-initialize the SD
    332              card device to be ready for use.
    333                
    334           
    335          @endverbatim
    336            * @{
    337            */
    338          
    339          /**
    340            * @brief  Initializes the SD card according to the specified parameters in the 
    341                      SD_HandleTypeDef and create the associated handle.
    342            * @param  hsd: SD handle
    343            * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
    344            * @retval HAL SD error state
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
    347          { 
   \                     HAL_SD_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    348            __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x000C      STRB     R0,[SP, #+12]
    349            SD_InitTypeDef tmpinit = {0};
   \   0000000E   0xA803             ADD      R0,SP,#+12
   \   00000010   0x2118             MOVS     R1,#+24
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    350            
    351            /* Initialize the low level hardware (MSP) */
    352            HAL_SD_MspInit(hsd);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_SD_MspInit
    353            
    354            /* Default SDIO peripheral configuration for SD card initialization */
    355            tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9003             STR      R0,[SP, #+12]
    356            tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
   \   00000020   0x9004             STR      R0,[SP, #+16]
    357            tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
   \   00000022   0x9005             STR      R0,[SP, #+20]
    358            tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
   \   00000024   0x9006             STR      R0,[SP, #+24]
    359            tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
   \   00000026   0x9007             STR      R0,[SP, #+28]
    360            tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
   \   00000028   0x2066             MOVS     R0,#+102
   \   0000002A   0x9008             STR      R0,[SP, #+32]
    361            
    362            /* Initialize SDIO peripheral interface with default configuration */
    363            SDIO_Init(hsd->Instance, tmpinit);
   \   0000002C   0xA903             ADD      R1,SP,#+12
   \   0000002E   0xB083             SUB      SP,SP,#+12
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x2218             MOVS     R2,#+24
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000038   0xBC0E             POP      {R1-R3}
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       SDIO_Init
    364            
    365            /* Identify card operating voltage */
    366            errorstate = SD_PowerON(hsd); 
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       SD_PowerON
   \   00000046   0xF88D 0x000C      STRB     R0,[SP, #+12]
    367            
    368            if(errorstate != SD_OK)     
   \   0000004A   0xF99D 0x000C      LDRSB    R0,[SP, #+12]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??HAL_SD_Init_0
    369            {
    370              return errorstate;
   \   00000052   0xF99D 0x000C      LDRSB    R0,[SP, #+12]
   \   00000056   0xE02A             B.N      ??HAL_SD_Init_1
    371            }
    372            
    373            /* Initialize the present SDIO card(s) and put them in idle state */
    374            errorstate = SD_Initialize_Cards(hsd);
   \                     ??HAL_SD_Init_0: (+1)
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       SD_Initialize_Cards
   \   0000005E   0xF88D 0x000C      STRB     R0,[SP, #+12]
    375            
    376            if (errorstate != SD_OK)
   \   00000062   0xF99D 0x000C      LDRSB    R0,[SP, #+12]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??HAL_SD_Init_2
    377            {
    378              return errorstate;
   \   0000006A   0xF99D 0x000C      LDRSB    R0,[SP, #+12]
   \   0000006E   0xE01E             B.N      ??HAL_SD_Init_1
    379            }
    380            
    381            /* Read CSD/CID MSD registers */
    382            errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
   \                     ??HAL_SD_Init_2: (+1)
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       HAL_SD_Get_CardInfo
   \   00000078   0xF88D 0x000C      STRB     R0,[SP, #+12]
    383            
    384            if (errorstate == SD_OK)
   \   0000007C   0xF99D 0x000C      LDRSB    R0,[SP, #+12]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD108             BNE.N    ??HAL_SD_Init_3
    385            {
    386              /* Select the Card */
    387              errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16));
   \   00000084   0xF8B5 0x0054      LDRH     R0,[R5, #+84]
   \   00000088   0x0402             LSLS     R2,R0,#+16
   \   0000008A   0x2300             MOVS     R3,#+0
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       SD_Select_Deselect
   \   00000092   0xF88D 0x000C      STRB     R0,[SP, #+12]
    388            }
    389            
    390            /* Configure SDIO peripheral interface */
    391            SDIO_Init(hsd->Instance, hsd->Init);   
   \                     ??HAL_SD_Init_3: (+1)
   \   00000096   0x1D21             ADDS     R1,R4,#+4
   \   00000098   0xB083             SUB      SP,SP,#+12
   \   0000009A   0x4668             MOV      R0,SP
   \   0000009C   0x2218             MOVS     R2,#+24
   \   0000009E   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000A2   0xBC0E             POP      {R1-R3}
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       SDIO_Init
    392            
    393            return errorstate;
   \   000000AA   0xF99D 0x000C      LDRSB    R0,[SP, #+12]
   \                     ??HAL_SD_Init_1: (+1)
   \   000000AE   0xB009             ADD      SP,SP,#+36
   \   000000B0   0xBD30             POP      {R4,R5,PC}       ;; return
    394          }
    395          
    396          /**
    397            * @brief  De-Initializes the SD card.
    398            * @param  hsd: SD handle
    399            * @retval HAL status
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
    402          {
   \                     HAL_SD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    403            
    404            /* Set SD power state to off */ 
    405            SD_PowerOFF(hsd);
   \   00000004   0x.... 0x....      BL       SD_PowerOFF
    406            
    407            /* De-Initialize the MSP layer */
    408            HAL_SD_MspDeInit(hsd);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       HAL_SD_MspDeInit
    409            
    410            return HAL_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    411          }
    412          
    413          
    414          /**
    415            * @brief  Initializes the SD MSP.
    416            * @param  hsd: SD handle
    417            * @retval None
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          __weak void HAL_SD_MspInit(SD_HandleTypeDef *hsd)
    420          {
    421            /* Prevent unused argument(s) compilation warning */
    422            UNUSED(hsd);
    423            /* NOTE : This function Should not be modified, when the callback is needed,
    424                      the HAL_SD_MspInit could be implemented in the user file
    425             */
    426          }
   \                     HAL_SD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    427          
    428          /**
    429            * @brief  De-Initialize SD MSP.
    430            * @param  hsd: SD handle
    431            * @retval None
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          __weak void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd)
    434          {
    435            /* Prevent unused argument(s) compilation warning */
    436            UNUSED(hsd);
    437            /* NOTE : This function Should not be modified, when the callback is needed,
    438                      the HAL_SD_MspDeInit could be implemented in the user file
    439             */
    440          }
   \                     HAL_SD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    441          
    442          /**
    443            * @}
    444            */
    445          
    446          /** @defgroup SD_Exported_Functions_Group2 IO operation functions 
    447           *  @brief   Data transfer functions 
    448           *
    449          @verbatim   
    450           ===============================================================================
    451                                ##### IO operation functions #####
    452           =============================================================================== 
    453            [..]
    454              This subsection provides a set of functions allowing to manage the data 
    455              transfer from/to SD card.
    456          
    457          @endverbatim
    458            * @{
    459            */
    460          
    461          /**
    462            * @brief  Reads block(s) from a specified address in a card. The Data transfer 
    463            *         is managed by polling mode.  
    464            * @param  hsd: SD handle
    465            * @param  pReadBuffer: pointer to the buffer that will contain the received data
    466            * @param  ReadAddr: Address from where data is to be read  
    467            * @param  BlockSize: SD card Data block size (in bytes)
    468            *          This parameter should be 512
    469            * @param  NumberOfBlocks: Number of SD blocks to read   
    470            * @retval SD Card error state
    471            */

   \                                 In section .text, align 2, keep-with-next
    472          HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
    473          {
   \                     HAL_SD_ReadBlocks: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461D             MOV      R5,R3
    474            SDIO_CmdInitTypeDef  sdio_cmdinitstructure = {0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    475            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000016   0xA805             ADD      R0,SP,#+20
   \   00000018   0x2118             MOVS     R1,#+24
   \   0000001A   0x.... 0x....      BL       __aeabi_memclr4
    476            HAL_SD_ErrorTypedef errorstate = SD_OK;
    477            uint32_t count = 0, *tempbuff = (uint32_t *)pReadBuffer;
    478            
    479            /* Initialize data control register */
    480            hsd->Instance->DCTRL = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6839             LDR      R1,[R7, #+0]
   \   00000022   0x62C8             STR      R0,[R1, #+44]
   \   00000024   0xF8DD 0xA050      LDR      R10,[SP, #+80]
    481            
    482            if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   \   00000028   0x6A38             LDR      R0,[R7, #+32]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD104             BNE.N    ??HAL_SD_ReadBlocks_0
    483            {
    484              BlockSize = 512;
   \   0000002E   0xF44F 0x7A00      MOV      R10,#+512
    485              ReadAddr /= 512;
   \   00000032   0x0A64             LSRS     R4,R4,#+9
   \   00000034   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
    486            }
    487            
    488            /* Set Block Size for Card */ 
    489            sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
   \                     ??HAL_SD_ReadBlocks_0: (+1)
   \   00000038   0xF8CD 0xA000      STR      R10,[SP, #+0]
    490            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x9001             STR      R0,[SP, #+4]
    491            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0x9002             STR      R0,[SP, #+8]
    492            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9003             STR      R0,[SP, #+12]
    493            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000048   0xF44F 0x6080      MOV      R0,#+1024
   \   0000004C   0x9004             STR      R0,[SP, #+16]
    494            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x6838             LDR      R0,[R7, #+0]
   \   00000052   0x.... 0x....      BL       SDIO_SendCommand
    495            
    496            /* Check for error conditions */
    497            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   00000056   0x2110             MOVS     R1,#+16
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       SD_CmdResp1Error
   \   0000005E   0x4683             MOV      R11,R0
    498            
    499            if (errorstate != SD_OK)
   \   00000060   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000064   0xD149             BNE.N    ??HAL_SD_ReadBlocks_1
    500            {
    501              return errorstate;
    502            }
    503            
    504            /* Configure the SD DPSM (Data Path State Machine) */
    505            sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   00000066   0xF04F 0x38FF      MOV      R8,#-1
   \   0000006A   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \   0000006E   0xF8DD 0x9054      LDR      R9,[SP, #+84]
    506            sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
   \   00000072   0xFB0A 0xF009      MUL      R0,R10,R9
   \   00000076   0x9006             STR      R0,[SP, #+24]
    507            sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
   \   00000078   0x2090             MOVS     R0,#+144
   \   0000007A   0x9007             STR      R0,[SP, #+28]
    508            sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0x9008             STR      R0,[SP, #+32]
    509            sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x9009             STR      R0,[SP, #+36]
    510            sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x900A             STR      R0,[SP, #+40]
    511            SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   00000088   0xA905             ADD      R1,SP,#+20
   \   0000008A   0x6838             LDR      R0,[R7, #+0]
   \   0000008C   0x.... 0x....      BL       SDIO_DataConfig
    512            
    513            if(NumberOfBlocks > 1)
   \   00000090   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000094   0xD302             BCC.N    ??HAL_SD_ReadBlocks_2
    514            {
    515              /* Send CMD18 READ_MULT_BLOCK with argument data address */
    516              sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
   \   00000096   0x2012             MOVS     R0,#+18
   \   00000098   0x9001             STR      R0,[SP, #+4]
   \   0000009A   0xE001             B.N      ??HAL_SD_ReadBlocks_3
    517            }
    518            else
    519            {
    520              /* Send CMD17 READ_SINGLE_BLOCK */
    521              sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
   \                     ??HAL_SD_ReadBlocks_2: (+1)
   \   0000009C   0x2011             MOVS     R0,#+17
   \   0000009E   0x9001             STR      R0,[SP, #+4]
    522            }
    523            
    524            sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
   \                     ??HAL_SD_ReadBlocks_3: (+1)
   \   000000A0   0x9400             STR      R4,[SP, #+0]
    525            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000A2   0xA900             ADD      R1,SP,#+0
   \   000000A4   0x6838             LDR      R0,[R7, #+0]
   \   000000A6   0x.... 0x....      BL       SDIO_SendCommand
    526            
    527            /* Read block(s) in polling mode */
    528            if(NumberOfBlocks > 1)
   \   000000AA   0xF1B9 0x0F02      CMP      R9,#+2
   \   000000AE   0xD31C             BCC.N    ??HAL_SD_ReadBlocks_4
    529            {
    530              /* Check for error conditions */
    531              errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
   \   000000B0   0x2112             MOVS     R1,#+18
   \   000000B2   0x4638             MOV      R0,R7
   \   000000B4   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000B8   0x4683             MOV      R11,R0
    532              
    533              if (errorstate != SD_OK)
   \   000000BA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000BE   0xD11C             BNE.N    ??HAL_SD_ReadBlocks_1
   \   000000C0   0xE008             B.N      ??HAL_SD_ReadBlocks_5
    534              {
    535                return errorstate;
    536              }
    537              
    538              /* Poll on SDIO flags */
    539              while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
    540              {
    541                if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
    542                {
    543                  /* Read data from SDIO Rx FIFO */
    544                  for (count = 0; count < 8; count++)
    545                  {
    546                    *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_ReadBlocks_6: (+1)
   \   000000C2   0x6838             LDR      R0,[R7, #+0]
   \   000000C4   0x.... 0x....      BL       SDIO_ReadFIFO
   \   000000C8   0xF846 0x0024      STR      R0,[R6, R4, LSL #+2]
    547                  }
   \   000000CC   0x1C64             ADDS     R4,R4,#+1
   \                     ??HAL_SD_ReadBlocks_7: (+1)
   \   000000CE   0x2C08             CMP      R4,#+8
   \   000000D0   0xD3F7             BCC.N    ??HAL_SD_ReadBlocks_6
    548                  
    549                  tempbuff += 8;
   \   000000D2   0x3620             ADDS     R6,R6,#+32
   \                     ??HAL_SD_ReadBlocks_5: (+1)
   \   000000D4   0x6838             LDR      R0,[R7, #+0]
   \   000000D6   0x6B41             LDR      R1,[R0, #+52]
   \   000000D8   0xF240 0x322A      MOVW     R2,#+810
   \   000000DC   0x4211             TST      R1,R2
   \   000000DE   0xD122             BNE.N    ??HAL_SD_ReadBlocks_8
   \   000000E0   0x6B40             LDR      R0,[R0, #+52]
   \   000000E2   0x0400             LSLS     R0,R0,#+16
   \   000000E4   0xD5F6             BPL.N    ??HAL_SD_ReadBlocks_5
   \   000000E6   0x2400             MOVS     R4,#+0
   \   000000E8   0xE7F1             B.N      ??HAL_SD_ReadBlocks_7
    550                }
    551              }      
    552            }
    553            else
    554            {
    555              /* Check for error conditions */
    556              errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK); 
   \                     ??HAL_SD_ReadBlocks_4: (+1)
   \   000000EA   0x2111             MOVS     R1,#+17
   \   000000EC   0x4638             MOV      R0,R7
   \   000000EE   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000F2   0x4683             MOV      R11,R0
    557              
    558              if (errorstate != SD_OK)
   \   000000F4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000F8   0xD00A             BEQ.N    ??HAL_SD_ReadBlocks_9
    559              {
    560                return errorstate;
   \                     ??HAL_SD_ReadBlocks_1: (+1)
   \   000000FA   0x4658             MOV      R0,R11
   \   000000FC   0xE054             B.N      ??HAL_SD_ReadBlocks_10
    561              }    
    562              
    563              /* In case of single block transfer, no need of stop transfer at all */
    564              while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
    565              {
    566                if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
    567                {
    568                  /* Read data from SDIO Rx FIFO */
    569                  for (count = 0; count < 8; count++)
    570                  {
    571                    *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_ReadBlocks_11: (+1)
   \   000000FE   0x6838             LDR      R0,[R7, #+0]
   \   00000100   0x.... 0x....      BL       SDIO_ReadFIFO
   \   00000104   0xF846 0x0024      STR      R0,[R6, R4, LSL #+2]
    572                  }
   \   00000108   0x1C64             ADDS     R4,R4,#+1
   \                     ??HAL_SD_ReadBlocks_12: (+1)
   \   0000010A   0x2C08             CMP      R4,#+8
   \   0000010C   0xD3F7             BCC.N    ??HAL_SD_ReadBlocks_11
    573                  
    574                  tempbuff += 8;
   \   0000010E   0x3620             ADDS     R6,R6,#+32
   \                     ??HAL_SD_ReadBlocks_9: (+1)
   \   00000110   0x6838             LDR      R0,[R7, #+0]
   \   00000112   0x6B41             LDR      R1,[R0, #+52]
   \   00000114   0xF240 0x622A      MOVW     R2,#+1578
   \   00000118   0x4211             TST      R1,R2
   \   0000011A   0xD104             BNE.N    ??HAL_SD_ReadBlocks_8
   \   0000011C   0x6B40             LDR      R0,[R0, #+52]
   \   0000011E   0x0400             LSLS     R0,R0,#+16
   \   00000120   0xD5F6             BPL.N    ??HAL_SD_ReadBlocks_9
   \   00000122   0x2400             MOVS     R4,#+0
   \   00000124   0xE7F1             B.N      ??HAL_SD_ReadBlocks_12
    575                }
    576              }
    577            }
    578            
    579            /* Send stop transmission command in case of multiblock read */
    580            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1))
   \                     ??HAL_SD_ReadBlocks_8: (+1)
   \   00000126   0x6838             LDR      R0,[R7, #+0]
   \   00000128   0x6B40             LDR      R0,[R0, #+52]
   \   0000012A   0x05C0             LSLS     R0,R0,#+23
   \   0000012C   0xD50D             BPL.N    ??HAL_SD_ReadBlocks_13
   \   0000012E   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000132   0xD30A             BCC.N    ??HAL_SD_ReadBlocks_13
    581            {    
    582              if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) ||\
    583                (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
    584                  (hsd->CardType == HIGH_CAPACITY_SD_CARD))
   \   00000134   0x6A38             LDR      R0,[R7, #+32]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD003             BEQ.N    ??HAL_SD_ReadBlocks_14
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD001             BEQ.N    ??HAL_SD_ReadBlocks_14
   \   0000013E   0x2802             CMP      R0,#+2
   \   00000140   0xD103             BNE.N    ??HAL_SD_ReadBlocks_13
    585              {
    586                /* Send stop transmission command */
    587                errorstate = HAL_SD_StopTransfer(hsd);
   \                     ??HAL_SD_ReadBlocks_14: (+1)
   \   00000142   0x4638             MOV      R0,R7
   \   00000144   0x.... 0x....      BL       HAL_SD_StopTransfer
   \   00000148   0x4683             MOV      R11,R0
    588              }
    589            }
    590            
    591            /* Get error state */
    592            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
   \                     ??HAL_SD_ReadBlocks_13: (+1)
   \   0000014A   0x6838             LDR      R0,[R7, #+0]
   \   0000014C   0x6B41             LDR      R1,[R0, #+52]
   \   0000014E   0x0709             LSLS     R1,R1,#+28
   \   00000150   0xD503             BPL.N    ??HAL_SD_ReadBlocks_15
    593            {
    594              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
   \   00000152   0x2108             MOVS     R1,#+8
   \   00000154   0x6381             STR      R1,[R0, #+56]
    595              
    596              errorstate = SD_DATA_TIMEOUT;
    597              
    598              return errorstate;
   \   00000156   0x2004             MOVS     R0,#+4
   \   00000158   0xE026             B.N      ??HAL_SD_ReadBlocks_10
    599            }
    600            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
   \                     ??HAL_SD_ReadBlocks_15: (+1)
   \   0000015A   0x6B41             LDR      R1,[R0, #+52]
   \   0000015C   0x0789             LSLS     R1,R1,#+30
   \   0000015E   0xD503             BPL.N    ??HAL_SD_ReadBlocks_16
    601            {
    602              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
   \   00000160   0x2102             MOVS     R1,#+2
   \   00000162   0x6381             STR      R1,[R0, #+56]
    603              
    604              errorstate = SD_DATA_CRC_FAIL;
    605              
    606              return errorstate;
   \   00000164   0x4608             MOV      R0,R1
   \   00000166   0xE01F             B.N      ??HAL_SD_ReadBlocks_10
    607            }
    608            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
   \                     ??HAL_SD_ReadBlocks_16: (+1)
   \   00000168   0x6B41             LDR      R1,[R0, #+52]
   \   0000016A   0x0689             LSLS     R1,R1,#+26
   \   0000016C   0xD503             BPL.N    ??HAL_SD_ReadBlocks_17
    609            {
    610              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
   \   0000016E   0x2120             MOVS     R1,#+32
   \   00000170   0x6381             STR      R1,[R0, #+56]
    611              
    612              errorstate = SD_RX_OVERRUN;
    613              
    614              return errorstate;
   \   00000172   0x2006             MOVS     R0,#+6
   \   00000174   0xE018             B.N      ??HAL_SD_ReadBlocks_10
    615            }
    616            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
   \                     ??HAL_SD_ReadBlocks_17: (+1)
   \   00000176   0x6B41             LDR      R1,[R0, #+52]
   \   00000178   0x0589             LSLS     R1,R1,#+22
   \   0000017A   0xD504             BPL.N    ??HAL_SD_ReadBlocks_18
    617            {
    618              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
   \   0000017C   0xF44F 0x7100      MOV      R1,#+512
   \   00000180   0x6381             STR      R1,[R0, #+56]
    619              
    620              errorstate = SD_START_BIT_ERR;
    621              
    622              return errorstate;
   \   00000182   0x2007             MOVS     R0,#+7
   \   00000184   0xE010             B.N      ??HAL_SD_ReadBlocks_10
    623            }
    624            else
    625            {
    626              /* No error flag set */
    627            }
    628            
    629            count = SD_DATATIMEOUT;
   \                     ??HAL_SD_ReadBlocks_18: (+1)
   \   00000186   0x4644             MOV      R4,R8
   \   00000188   0xE004             B.N      ??HAL_SD_ReadBlocks_19
    630            
    631            /* Empty FIFO if there is still any data */
    632            while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0))
    633            {
    634              *tempbuff = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_ReadBlocks_20: (+1)
   \   0000018A   0x.... 0x....      BL       SDIO_ReadFIFO
   \   0000018E   0xF846 0x0B04      STR      R0,[R6], #+4
    635              tempbuff++;
    636              count--;
   \   00000192   0x1E64             SUBS     R4,R4,#+1
    637            }
   \                     ??HAL_SD_ReadBlocks_19: (+1)
   \   00000194   0x6838             LDR      R0,[R7, #+0]
   \   00000196   0x6B41             LDR      R1,[R0, #+52]
   \   00000198   0x0289             LSLS     R1,R1,#+10
   \   0000019A   0xD501             BPL.N    ??HAL_SD_ReadBlocks_21
   \   0000019C   0x2C00             CMP      R4,#+0
   \   0000019E   0xD1F4             BNE.N    ??HAL_SD_ReadBlocks_20
    638            
    639            /* Clear all the static flags */
    640            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??HAL_SD_ReadBlocks_21: (+1)
   \   000001A0   0xF240 0x51FF      MOVW     R1,#+1535
   \   000001A4   0x6381             STR      R1,[R0, #+56]
    641            
    642            return errorstate;
   \   000001A6   0x4658             MOV      R0,R11
   \                     ??HAL_SD_ReadBlocks_10: (+1)
   \   000001A8   0xB00B             ADD      SP,SP,#+44
   \   000001AA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    643          }
    644          
    645          /**
    646            * @brief  Allows to write block(s) to a specified address in a card. The Data
    647            *         transfer is managed by polling mode.  
    648            * @param  hsd: SD handle
    649            * @param  pWriteBuffer: pointer to the buffer that will contain the data to transmit
    650            * @param  WriteAddr: Address from where data is to be written 
    651            * @param  BlockSize: SD card Data block size (in bytes)
    652            *          This parameter should be 512.
    653            * @param  NumberOfBlocks: Number of SD blocks to write 
    654            * @retval SD Card error state
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
    657          {
   \                     HAL_SD_WriteBlocks: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461D             MOV      R5,R3
    658            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    659            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000016   0xA806             ADD      R0,SP,#+24
   \   00000018   0x2118             MOVS     R1,#+24
   \   0000001A   0x.... 0x....      BL       __aeabi_memclr4
    660            HAL_SD_ErrorTypedef errorstate = SD_OK;
    661            uint32_t totalnumberofbytes = 0, bytestransferred = 0, count = 0, restwords = 0;
   \   0000001E   0xF04F 0x0800      MOV      R8,#+0
    662            uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
    663            uint8_t cardstate  = 0;
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0xF88D 0x0000      STRB     R0,[SP, #+0]
    664            
    665            /* Initialize data control register */
    666            hsd->Instance->DCTRL = 0;
   \   00000028   0x6839             LDR      R1,[R7, #+0]
   \   0000002A   0x62C8             STR      R0,[R1, #+44]
   \   0000002C   0xF8DD 0x9050      LDR      R9,[SP, #+80]
    667            
    668            if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   \   00000030   0x6A38             LDR      R0,[R7, #+32]
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD104             BNE.N    ??HAL_SD_WriteBlocks_0
    669            {
    670              BlockSize = 512;
   \   00000036   0xF44F 0x7900      MOV      R9,#+512
    671              WriteAddr /= 512;
   \   0000003A   0x0A64             LSRS     R4,R4,#+9
   \   0000003C   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
    672            }
    673            
    674            /* Set Block Size for Card */ 
    675            sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
   \                     ??HAL_SD_WriteBlocks_0: (+1)
   \   00000040   0xF8CD 0x9004      STR      R9,[SP, #+4]
    676            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   00000044   0x2010             MOVS     R0,#+16
   \   00000046   0x9002             STR      R0,[SP, #+8]
    677            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x9003             STR      R0,[SP, #+12]
    678            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x9004             STR      R0,[SP, #+16]
    679            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000050   0xF44F 0x6080      MOV      R0,#+1024
   \   00000054   0x9005             STR      R0,[SP, #+20]
    680            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000056   0xA901             ADD      R1,SP,#+4
   \   00000058   0x6838             LDR      R0,[R7, #+0]
   \   0000005A   0x.... 0x....      BL       SDIO_SendCommand
    681            
    682            /* Check for error conditions */
    683            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   0000005E   0x2110             MOVS     R1,#+16
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       SD_CmdResp1Error
    684            
    685            if (errorstate != SD_OK)
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xF040 0x80D6      BNE.W    ??HAL_SD_WriteBlocks_1
   \   0000006C   0xF8DD 0xA054      LDR      R10,[SP, #+84]
    686            {
    687              return errorstate;
    688            }
    689            
    690            if(NumberOfBlocks > 1)
   \   00000070   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000074   0xD302             BCC.N    ??HAL_SD_WriteBlocks_2
    691            {
    692              /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
    693              sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
   \   00000076   0x2019             MOVS     R0,#+25
   \   00000078   0x9002             STR      R0,[SP, #+8]
   \   0000007A   0xE001             B.N      ??HAL_SD_WriteBlocks_3
    694            }
    695            else
    696            {
    697              /* Send CMD24 WRITE_SINGLE_BLOCK */
    698              sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
   \                     ??HAL_SD_WriteBlocks_2: (+1)
   \   0000007C   0x2018             MOVS     R0,#+24
   \   0000007E   0x9002             STR      R0,[SP, #+8]
    699            }
    700            
    701            sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
   \                     ??HAL_SD_WriteBlocks_3: (+1)
   \   00000080   0x9401             STR      R4,[SP, #+4]
    702            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000082   0xA901             ADD      R1,SP,#+4
   \   00000084   0x6838             LDR      R0,[R7, #+0]
   \   00000086   0x.... 0x....      BL       SDIO_SendCommand
    703            
    704            /* Check for error conditions */
    705            if(NumberOfBlocks > 1)
   \   0000008A   0xF1BA 0x0F02      CMP      R10,#+2
   \   0000008E   0xD304             BCC.N    ??HAL_SD_WriteBlocks_4
    706            {
    707              errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
   \   00000090   0x2119             MOVS     R1,#+25
   \   00000092   0x4638             MOV      R0,R7
   \   00000094   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000098   0xE003             B.N      ??HAL_SD_WriteBlocks_5
    708            }
    709            else
    710            {
    711              errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
   \                     ??HAL_SD_WriteBlocks_4: (+1)
   \   0000009A   0x2118             MOVS     R1,#+24
   \   0000009C   0x4638             MOV      R0,R7
   \   0000009E   0x.... 0x....      BL       SD_CmdResp1Error
    712            }  
    713            
    714            if (errorstate != SD_OK)
   \                     ??HAL_SD_WriteBlocks_5: (+1)
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xF040 0x80B8      BNE.W    ??HAL_SD_WriteBlocks_1
    715            {
    716              return errorstate;
    717            }
    718            
    719            /* Set total number of bytes to write */
    720            totalnumberofbytes = NumberOfBlocks * BlockSize;
   \   000000A8   0xFB09 0xF40A      MUL      R4,R9,R10
    721            
    722            /* Configure the SD DPSM (Data Path State Machine) */ 
    723            sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   000000AC   0xF04F 0x30FF      MOV      R0,#-1
   \   000000B0   0x9006             STR      R0,[SP, #+24]
    724            sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
   \   000000B2   0x9407             STR      R4,[SP, #+28]
    725            sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
   \   000000B4   0x2090             MOVS     R0,#+144
   \   000000B6   0x9008             STR      R0,[SP, #+32]
    726            sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
   \   000000B8   0x4640             MOV      R0,R8
   \   000000BA   0x9009             STR      R0,[SP, #+36]
    727            sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   000000BC   0x900A             STR      R0,[SP, #+40]
    728            sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x900B             STR      R0,[SP, #+44]
    729            SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   000000C2   0xA906             ADD      R1,SP,#+24
   \   000000C4   0x6838             LDR      R0,[R7, #+0]
   \   000000C6   0x.... 0x....      BL       SDIO_DataConfig
    730            
    731            /* Write block(s) in polling mode */
    732            if(NumberOfBlocks > 1)
   \   000000CA   0xF1BA 0x0F02      CMP      R10,#+2
   \   000000CE   0xD33D             BCC.N    ??HAL_SD_WriteBlocks_6
   \   000000D0   0xE00C             B.N      ??HAL_SD_WriteBlocks_7
    733            {
    734              while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
    735              {
    736                if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
    737                {
    738                  if ((totalnumberofbytes - bytestransferred) < 32)
    739                  {
    740                    restwords = ((totalnumberofbytes - bytestransferred) % 4 == 0) ? ((totalnumberofbytes - bytestransferred) / 4) : (( totalnumberofbytes -  bytestransferred) / 4 + 1);
    741                    
    742                    /* Write data to SDIO Tx FIFO */
    743                    for (count = 0; count < restwords; count++)
    744                    {
    745                      SDIO_WriteFIFO(hsd->Instance, tempbuff);
    746                      tempbuff++;
    747                      bytestransferred += 4;
    748                    }
    749                  }
    750                  else
    751                  {
    752                    /* Write data to SDIO Tx FIFO */
    753                    for (count = 0; count < 8; count++)
    754                    {
    755                      SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
   \                     ??HAL_SD_WriteBlocks_8: (+1)
   \   000000D2   0xEB06 0x0189      ADD      R1,R6,R9, LSL #+2
   \   000000D6   0x6838             LDR      R0,[R7, #+0]
   \   000000D8   0x.... 0x....      BL       SDIO_WriteFIFO
    756                    }
   \   000000DC   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??HAL_SD_WriteBlocks_9: (+1)
   \   000000E0   0xF1B9 0x0F08      CMP      R9,#+8
   \   000000E4   0xD3F5             BCC.N    ??HAL_SD_WriteBlocks_8
    757                    
    758                    tempbuff += 8;
   \   000000E6   0x3620             ADDS     R6,R6,#+32
    759                    bytestransferred += 32;
   \   000000E8   0xF108 0x0820      ADD      R8,R8,#+32
   \                     ??HAL_SD_WriteBlocks_7: (+1)
   \   000000EC   0x6838             LDR      R0,[R7, #+0]
   \   000000EE   0x6B41             LDR      R1,[R0, #+52]
   \   000000F0   0xF240 0x321A      MOVW     R2,#+794
   \   000000F4   0x4211             TST      R1,R2
   \   000000F6   0xD14C             BNE.N    ??HAL_SD_WriteBlocks_10
   \   000000F8   0x6B40             LDR      R0,[R0, #+52]
   \   000000FA   0x0440             LSLS     R0,R0,#+17
   \   000000FC   0xD5F6             BPL.N    ??HAL_SD_WriteBlocks_7
   \   000000FE   0xEBA4 0x0008      SUB      R0,R4,R8
   \   00000102   0x2820             CMP      R0,#+32
   \   00000104   0xD212             BCS.N    ??HAL_SD_WriteBlocks_11
   \   00000106   0x0885             LSRS     R5,R0,#+2
   \   00000108   0xF010 0x0F03      TST      R0,#0x3
   \   0000010C   0xD000             BEQ.N    ??HAL_SD_WriteBlocks_12
   \   0000010E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_SD_WriteBlocks_12: (+1)
   \   00000110   0xF04F 0x0900      MOV      R9,#+0
   \                     ??HAL_SD_WriteBlocks_13: (+1)
   \   00000114   0x45A9             CMP      R9,R5
   \   00000116   0xD2E9             BCS.N    ??HAL_SD_WriteBlocks_7
   \   00000118   0x4631             MOV      R1,R6
   \   0000011A   0x6838             LDR      R0,[R7, #+0]
   \   0000011C   0x.... 0x....      BL       SDIO_WriteFIFO
   \   00000120   0x1D36             ADDS     R6,R6,#+4
   \   00000122   0xF108 0x0804      ADD      R8,R8,#+4
   \   00000126   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000012A   0xE7F3             B.N      ??HAL_SD_WriteBlocks_13
   \                     ??HAL_SD_WriteBlocks_11: (+1)
   \   0000012C   0xF04F 0x0900      MOV      R9,#+0
   \   00000130   0xE7D6             B.N      ??HAL_SD_WriteBlocks_9
    760                  }
    761                }
    762              }   
    763            }
    764            else
    765            {
    766              /* In case of single data block transfer no need of stop command at all */ 
    767              while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
    768              {
    769                if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
    770                {
    771                  if ((totalnumberofbytes - bytestransferred) < 32)
    772                  {
    773                    restwords = ((totalnumberofbytes - bytestransferred) % 4 == 0) ? ((totalnumberofbytes - bytestransferred) / 4) : (( totalnumberofbytes -  bytestransferred) / 4 + 1);
    774                    
    775                    /* Write data to SDIO Tx FIFO */
    776                    for (count = 0; count < restwords; count++)
    777                    {
    778                      SDIO_WriteFIFO(hsd->Instance, tempbuff);
    779                      tempbuff++; 
    780                      bytestransferred += 4;
    781                    }
    782                  }
    783                  else
    784                  {
    785                    /* Write data to SDIO Tx FIFO */
    786                    for (count = 0; count < 8; count++)
    787                    {
    788                      SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
   \                     ??HAL_SD_WriteBlocks_14: (+1)
   \   00000132   0xEB06 0x0189      ADD      R1,R6,R9, LSL #+2
   \   00000136   0x6838             LDR      R0,[R7, #+0]
   \   00000138   0x.... 0x....      BL       SDIO_WriteFIFO
    789                    }
   \   0000013C   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??HAL_SD_WriteBlocks_15: (+1)
   \   00000140   0xF1B9 0x0F08      CMP      R9,#+8
   \   00000144   0xD3F5             BCC.N    ??HAL_SD_WriteBlocks_14
    790                    
    791                    tempbuff += 8;
   \   00000146   0x3620             ADDS     R6,R6,#+32
    792                    bytestransferred += 32;
   \   00000148   0xF108 0x0820      ADD      R8,R8,#+32
   \                     ??HAL_SD_WriteBlocks_6: (+1)
   \   0000014C   0x6838             LDR      R0,[R7, #+0]
   \   0000014E   0x6B41             LDR      R1,[R0, #+52]
   \   00000150   0xF240 0x621A      MOVW     R2,#+1562
   \   00000154   0x4211             TST      R1,R2
   \   00000156   0xD11C             BNE.N    ??HAL_SD_WriteBlocks_10
   \   00000158   0x6B40             LDR      R0,[R0, #+52]
   \   0000015A   0x0440             LSLS     R0,R0,#+17
   \   0000015C   0xD5F6             BPL.N    ??HAL_SD_WriteBlocks_6
   \   0000015E   0xEBA4 0x0008      SUB      R0,R4,R8
   \   00000162   0x2820             CMP      R0,#+32
   \   00000164   0xD212             BCS.N    ??HAL_SD_WriteBlocks_16
   \   00000166   0x0885             LSRS     R5,R0,#+2
   \   00000168   0xF010 0x0F03      TST      R0,#0x3
   \   0000016C   0xD000             BEQ.N    ??HAL_SD_WriteBlocks_17
   \   0000016E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_SD_WriteBlocks_17: (+1)
   \   00000170   0xF04F 0x0900      MOV      R9,#+0
   \                     ??HAL_SD_WriteBlocks_18: (+1)
   \   00000174   0x45A9             CMP      R9,R5
   \   00000176   0xD2E9             BCS.N    ??HAL_SD_WriteBlocks_6
   \   00000178   0x4631             MOV      R1,R6
   \   0000017A   0x6838             LDR      R0,[R7, #+0]
   \   0000017C   0x.... 0x....      BL       SDIO_WriteFIFO
   \   00000180   0x1D36             ADDS     R6,R6,#+4
   \   00000182   0xF108 0x0804      ADD      R8,R8,#+4
   \   00000186   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000018A   0xE7F3             B.N      ??HAL_SD_WriteBlocks_18
   \                     ??HAL_SD_WriteBlocks_16: (+1)
   \   0000018C   0xF04F 0x0900      MOV      R9,#+0
   \   00000190   0xE7D6             B.N      ??HAL_SD_WriteBlocks_15
    793                  }
    794                }
    795              }  
    796            }
    797            
    798            /* Send stop transmission command in case of multiblock write */
    799            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1))
   \                     ??HAL_SD_WriteBlocks_10: (+1)
   \   00000192   0x6838             LDR      R0,[R7, #+0]
   \   00000194   0x6B40             LDR      R0,[R0, #+52]
   \   00000196   0x05C0             LSLS     R0,R0,#+23
   \   00000198   0xD50C             BPL.N    ??HAL_SD_WriteBlocks_19
   \   0000019A   0xF1BA 0x0F02      CMP      R10,#+2
   \   0000019E   0xD309             BCC.N    ??HAL_SD_WriteBlocks_19
    800            {    
    801              if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
    802                (hsd->CardType == HIGH_CAPACITY_SD_CARD))
   \   000001A0   0x6A38             LDR      R0,[R7, #+32]
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD003             BEQ.N    ??HAL_SD_WriteBlocks_20
   \   000001A6   0x2801             CMP      R0,#+1
   \   000001A8   0xD001             BEQ.N    ??HAL_SD_WriteBlocks_20
   \   000001AA   0x2802             CMP      R0,#+2
   \   000001AC   0xD102             BNE.N    ??HAL_SD_WriteBlocks_19
    803              {
    804                /* Send stop transmission command */
    805                errorstate = HAL_SD_StopTransfer(hsd);
   \                     ??HAL_SD_WriteBlocks_20: (+1)
   \   000001AE   0x4638             MOV      R0,R7
   \   000001B0   0x.... 0x....      BL       HAL_SD_StopTransfer
    806              }
    807            }
    808            
    809            /* Get error state */
    810            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
   \                     ??HAL_SD_WriteBlocks_19: (+1)
   \   000001B4   0x6838             LDR      R0,[R7, #+0]
   \   000001B6   0x6B41             LDR      R1,[R0, #+52]
   \   000001B8   0x0709             LSLS     R1,R1,#+28
   \   000001BA   0xD503             BPL.N    ??HAL_SD_WriteBlocks_21
    811            {
    812              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
   \   000001BC   0x2108             MOVS     R1,#+8
   \   000001BE   0x6381             STR      R1,[R0, #+56]
    813              
    814              errorstate = SD_DATA_TIMEOUT;
    815              
    816              return errorstate;
   \   000001C0   0x2004             MOVS     R0,#+4
   \   000001C2   0xE029             B.N      ??HAL_SD_WriteBlocks_1
    817            }
    818            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
   \                     ??HAL_SD_WriteBlocks_21: (+1)
   \   000001C4   0x6B41             LDR      R1,[R0, #+52]
   \   000001C6   0x0789             LSLS     R1,R1,#+30
   \   000001C8   0xD503             BPL.N    ??HAL_SD_WriteBlocks_22
    819            {
    820              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
   \   000001CA   0x2102             MOVS     R1,#+2
   \   000001CC   0x6381             STR      R1,[R0, #+56]
    821              
    822              errorstate = SD_DATA_CRC_FAIL;
    823              
    824              return errorstate;
   \   000001CE   0x4608             MOV      R0,R1
   \   000001D0   0xE022             B.N      ??HAL_SD_WriteBlocks_1
    825            }
    826            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
   \                     ??HAL_SD_WriteBlocks_22: (+1)
   \   000001D2   0x6B41             LDR      R1,[R0, #+52]
   \   000001D4   0x06C9             LSLS     R1,R1,#+27
   \   000001D6   0xD503             BPL.N    ??HAL_SD_WriteBlocks_23
    827            {
    828              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
   \   000001D8   0x2110             MOVS     R1,#+16
   \   000001DA   0x6381             STR      R1,[R0, #+56]
    829              
    830              errorstate = SD_TX_UNDERRUN;
    831              
    832              return errorstate;
   \   000001DC   0x2005             MOVS     R0,#+5
   \   000001DE   0xE01B             B.N      ??HAL_SD_WriteBlocks_1
    833            }
    834            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
   \                     ??HAL_SD_WriteBlocks_23: (+1)
   \   000001E0   0x6B41             LDR      R1,[R0, #+52]
   \   000001E2   0x0589             LSLS     R1,R1,#+22
   \   000001E4   0xD504             BPL.N    ??HAL_SD_WriteBlocks_24
    835            {
    836              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
   \   000001E6   0xF44F 0x7100      MOV      R1,#+512
   \   000001EA   0x6381             STR      R1,[R0, #+56]
    837              
    838              errorstate = SD_START_BIT_ERR;
    839              
    840              return errorstate;
   \   000001EC   0x2007             MOVS     R0,#+7
   \   000001EE   0xE013             B.N      ??HAL_SD_WriteBlocks_1
    841            }
    842            else
    843            {
    844              /* No error flag set */
    845            }
    846            
    847            /* Clear all the static flags */
    848            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??HAL_SD_WriteBlocks_24: (+1)
   \   000001F0   0xF240 0x51FF      MOVW     R1,#+1535
   \   000001F4   0x6381             STR      R1,[R0, #+56]
    849            
    850            /* Wait till the card is in programming state */
    851            errorstate = SD_IsCardProgramming(hsd, &cardstate);
   \   000001F6   0xA900             ADD      R1,SP,#+0
   \   000001F8   0x4638             MOV      R0,R7
   \   000001FA   0x.... 0x....      BL       SD_IsCardProgramming
   \   000001FE   0xE003             B.N      ??HAL_SD_WriteBlocks_25
    852            
    853            while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
    854            {
    855              errorstate = SD_IsCardProgramming(hsd, &cardstate);
   \                     ??HAL_SD_WriteBlocks_26: (+1)
   \   00000200   0xA900             ADD      R1,SP,#+0
   \   00000202   0x4638             MOV      R0,R7
   \   00000204   0x.... 0x....      BL       SD_IsCardProgramming
    856            }
   \                     ??HAL_SD_WriteBlocks_25: (+1)
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD105             BNE.N    ??HAL_SD_WriteBlocks_1
   \   0000020C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000210   0x2907             CMP      R1,#+7
   \   00000212   0xD0F5             BEQ.N    ??HAL_SD_WriteBlocks_26
   \   00000214   0x2906             CMP      R1,#+6
   \   00000216   0xD0F3             BEQ.N    ??HAL_SD_WriteBlocks_26
    857            
    858            return errorstate;
   \                     ??HAL_SD_WriteBlocks_1: (+1)
   \   00000218   0xB00C             ADD      SP,SP,#+48
   \   0000021A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    859          }
    860          
    861          
    862          /**
    863            * @brief  Reads block(s) from a specified address in a card. The Data transfer 
    864            *         is managed by DMA mode. 
    865            * @note   This API should be followed by the function HAL_SD_CheckReadOperation()
    866            *         to check the completion of the read process   
    867            * @param  hsd: SD handle                 
    868            * @param  pReadBuffer: Pointer to the buffer that will contain the received data
    869            * @param  ReadAddr: Address from where data is to be read  
    870            * @param  BlockSize: SD card Data block size 
    871            * @note   BlockSize must be 512 bytes.
    872            * @param  NumberOfBlocks: Number of blocks to read.
    873            * @retval SD Card error state
    874            */

   \                                 In section .text, align 2, keep-with-next
    875          HAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
    876          {
   \                     HAL_SD_ReadBlocks_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461D             MOV      R5,R3
    877          	
    878          	
    879            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    880            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000016   0xA805             ADD      R0,SP,#+20
   \   00000018   0x2118             MOVS     R1,#+24
   \   0000001A   0x.... 0x....      BL       __aeabi_memclr4
    881            HAL_SD_ErrorTypedef errorstate = SD_OK;
    882            
    883            /* Initialize data control register */
    884            hsd->Instance->DCTRL = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6831             LDR      R1,[R6, #+0]
   \   00000022   0x62C8             STR      R0,[R1, #+44]
    885            
    886            /* Initialize handle flags */
    887            hsd->SdTransferCplt  = 0;
   \   00000024   0x64B0             STR      R0,[R6, #+72]
    888            hsd->DmaTransferCplt = 0;
   \   00000026   0x6530             STR      R0,[R6, #+80]
    889            hsd->SdTransferErr   = SD_OK; 
   \   00000028   0x64F0             STR      R0,[R6, #+76]
   \   0000002A   0x9F13             LDR      R7,[SP, #+76]
    890            
    891            /* Initialize SD Read operation */
    892            if(NumberOfBlocks > 1)
   \   0000002C   0x2F02             CMP      R7,#+2
   \   0000002E   0x4180             SBCS     R0,R0,R0
   \   00000030   0x43C0             MVNS     R0,R0
   \   00000032   0x0FC0             LSRS     R0,R0,#+31
   \   00000034   0x6570             STR      R0,[R6, #+84]
    893            {
    894              hsd->SdOperation = SD_READ_MULTIPLE_BLOCK;
    895            }
    896            else
    897            {
    898              hsd->SdOperation = SD_READ_SINGLE_BLOCK;
    899            }
    900            
    901            /* Enable transfer interrupts */
    902            __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
    903                                          SDIO_IT_DTIMEOUT |\
    904                                          SDIO_IT_DATAEND  |\
    905                                          SDIO_IT_RXOVERR  |\
    906                                          SDIO_IT_STBITERR));
   \   00000036   0x6830             LDR      R0,[R6, #+0]
   \   00000038   0x6BC1             LDR      R1,[R0, #+60]
   \   0000003A   0xF240 0x322A      MOVW     R2,#+810
   \   0000003E   0x4311             ORRS     R1,R2,R1
   \   00000040   0x63C1             STR      R1,[R0, #+60]
    907          	
    908          	SD_DMA_DIR(hsd,0);
                 	^
Warning[Pe223]: function "SD_DMA_DIR" declared implicitly
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       SD_DMA_DIR
    909            /* Enable SDIO DMA transfer */
    910            __HAL_SD_SDIO_DMA_ENABLE(hsd);
   \   0000004A   0x6830             LDR      R0,[R6, #+0]
   \   0000004C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000004E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000052   0x62C1             STR      R1,[R0, #+44]
    911            
    912            /* Configure DMA user callbacks */
    913            hsd->hdmarx->XferCpltCallback  = SD_DMA_RxCplt;
   \   00000054   0x.... 0x....      ADR.W    R0,SD_DMA_RxCplt
   \   00000058   0x6DB1             LDR      R1,[R6, #+88]
   \   0000005A   0x6288             STR      R0,[R1, #+40]
    914            hsd->hdmarx->XferErrorCallback = SD_DMA_RxError;
   \   0000005C   0x.... 0x....      ADR.W    R0,SD_DMA_RxError
   \   00000060   0x6DB1             LDR      R1,[R6, #+88]
   \   00000062   0x6308             STR      R0,[R1, #+48]
   \   00000064   0xF8DD 0x8048      LDR      R8,[SP, #+72]
    915            
    916            /* Enable the DMA Channel */
    917            HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pReadBuffer, (uint32_t)(BlockSize * NumberOfBlocks)/4);
   \   00000068   0xFB07 0xF008      MUL      R0,R7,R8
   \   0000006C   0x0883             LSRS     R3,R0,#+2
   \   0000006E   0x464A             MOV      R2,R9
   \   00000070   0x6830             LDR      R0,[R6, #+0]
   \   00000072   0xF100 0x0180      ADD      R1,R0,#+128
   \   00000076   0x6DB0             LDR      R0,[R6, #+88]
   \   00000078   0x.... 0x....      BL       HAL_DMA_Start_IT
    918            
    919            if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   \   0000007C   0x6A30             LDR      R0,[R6, #+32]
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD104             BNE.N    ??HAL_SD_ReadBlocks_DMA_0
    920            {
    921              BlockSize = 512;
   \   00000082   0xF44F 0x7800      MOV      R8,#+512
    922              ReadAddr /= 512;
   \   00000086   0x0A64             LSRS     R4,R4,#+9
   \   00000088   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
    923            }
    924            
    925            /* Set Block Size for Card */ 
    926            sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
   \                     ??HAL_SD_ReadBlocks_DMA_0: (+1)
   \   0000008C   0xF8CD 0x8000      STR      R8,[SP, #+0]
    927            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   00000090   0x2010             MOVS     R0,#+16
   \   00000092   0x9001             STR      R0,[SP, #+4]
    928            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000094   0x2040             MOVS     R0,#+64
   \   00000096   0x9002             STR      R0,[SP, #+8]
    929            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x9003             STR      R0,[SP, #+12]
    930            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   0000009C   0xF44F 0x6080      MOV      R0,#+1024
   \   000000A0   0x9004             STR      R0,[SP, #+16]
    931            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000A2   0xA900             ADD      R1,SP,#+0
   \   000000A4   0x6830             LDR      R0,[R6, #+0]
   \   000000A6   0x.... 0x....      BL       SDIO_SendCommand
    932            
    933            /* Check for error conditions */
    934            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   000000AA   0x2110             MOVS     R1,#+16
   \   000000AC   0x4630             MOV      R0,R6
   \   000000AE   0x.... 0x....      BL       SD_CmdResp1Error
    935            
    936            if (errorstate != SD_OK)
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD129             BNE.N    ??HAL_SD_ReadBlocks_DMA_1
    937            {
    938              return errorstate;
    939            }
    940            
    941            /* Configure the SD DPSM (Data Path State Machine) */ 
    942            sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   000000B6   0xF04F 0x30FF      MOV      R0,#-1
   \   000000BA   0x9005             STR      R0,[SP, #+20]
    943            sdio_datainitstructure.DataLength    = BlockSize * NumberOfBlocks;
   \   000000BC   0xFB07 0xF008      MUL      R0,R7,R8
   \   000000C0   0x9006             STR      R0,[SP, #+24]
    944            sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
   \   000000C2   0x2090             MOVS     R0,#+144
   \   000000C4   0x9007             STR      R0,[SP, #+28]
    945            sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
   \   000000C6   0x2002             MOVS     R0,#+2
   \   000000C8   0x9008             STR      R0,[SP, #+32]
    946            sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x9009             STR      R0,[SP, #+36]
    947            sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x900A             STR      R0,[SP, #+40]
    948            SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   000000D2   0xA905             ADD      R1,SP,#+20
   \   000000D4   0x6830             LDR      R0,[R6, #+0]
   \   000000D6   0x.... 0x....      BL       SDIO_DataConfig
    949            
    950            /* Check number of blocks command */
    951            if(NumberOfBlocks > 1)
   \   000000DA   0x2F02             CMP      R7,#+2
   \   000000DC   0xD302             BCC.N    ??HAL_SD_ReadBlocks_DMA_2
    952            {
    953              /* Send CMD18 READ_MULT_BLOCK with argument data address */
    954              sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
   \   000000DE   0x2012             MOVS     R0,#+18
   \   000000E0   0x9001             STR      R0,[SP, #+4]
   \   000000E2   0xE001             B.N      ??HAL_SD_ReadBlocks_DMA_3
    955            }
    956            else
    957            {
    958              /* Send CMD17 READ_SINGLE_BLOCK */
    959              sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;
   \                     ??HAL_SD_ReadBlocks_DMA_2: (+1)
   \   000000E4   0x2011             MOVS     R0,#+17
   \   000000E6   0x9001             STR      R0,[SP, #+4]
    960            }
    961            
    962            sdio_cmdinitstructure.Argument = (uint32_t)ReadAddr;
   \                     ??HAL_SD_ReadBlocks_DMA_3: (+1)
   \   000000E8   0x9400             STR      R4,[SP, #+0]
    963            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000EA   0xA900             ADD      R1,SP,#+0
   \   000000EC   0x6830             LDR      R0,[R6, #+0]
   \   000000EE   0x.... 0x....      BL       SDIO_SendCommand
    964            
    965            /* Check for error conditions */
    966            if(NumberOfBlocks > 1)
   \   000000F2   0x2F02             CMP      R7,#+2
   \   000000F4   0xD304             BCC.N    ??HAL_SD_ReadBlocks_DMA_4
    967            {
    968              errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
   \   000000F6   0x2112             MOVS     R1,#+18
   \   000000F8   0x4630             MOV      R0,R6
   \   000000FA   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000FE   0xE003             B.N      ??HAL_SD_ReadBlocks_DMA_5
    969            }
    970            else
    971            {
    972              errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK);
   \                     ??HAL_SD_ReadBlocks_DMA_4: (+1)
   \   00000100   0x2111             MOVS     R1,#+17
   \   00000102   0x4630             MOV      R0,R6
   \   00000104   0x.... 0x....      BL       SD_CmdResp1Error
    973            }
    974            
    975            /* Update the SD transfer error in SD handle */
    976            hsd->SdTransferErr = errorstate;
   \                     ??HAL_SD_ReadBlocks_DMA_5: (+1)
   \   00000108   0x64F0             STR      R0,[R6, #+76]
    977            
    978            return errorstate;
   \                     ??HAL_SD_ReadBlocks_DMA_1: (+1)
   \   0000010A   0xB00B             ADD      SP,SP,#+44
   \   0000010C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    979          }
    980          
    981          
    982          /**
    983            * @brief  Writes block(s) to a specified address in a card. The Data transfer 
    984            *         is managed by DMA mode. 
    985            * @note   This API should be followed by the function HAL_SD_CheckWriteOperation()
    986            *         to check the completion of the write process (by SD current status polling).  
    987            * @param  hsd: SD handle
    988            * @param  pWriteBuffer: pointer to the buffer that will contain the data to transmit
    989            * @param  WriteAddr: Address from where data is to be read   
    990            * @param  BlockSize: the SD card Data block size 
    991            * @note   BlockSize must be 512 bytes.
    992            * @param  NumberOfBlocks: Number of blocks to write
    993            * @retval SD Card error state
    994            */

   \                                 In section .text, align 2, keep-with-next
    995          HAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
    996          {
   \                     HAL_SD_WriteBlocks_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461D             MOV      R5,R3
    997            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    998            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000016   0xA805             ADD      R0,SP,#+20
   \   00000018   0x2118             MOVS     R1,#+24
   \   0000001A   0x.... 0x....      BL       __aeabi_memclr4
    999            HAL_SD_ErrorTypedef errorstate = SD_OK;
   1000            
   1001            /* Initialize data control register */
   1002            hsd->Instance->DCTRL = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6831             LDR      R1,[R6, #+0]
   \   00000022   0x62C8             STR      R0,[R1, #+44]
   1003            
   1004            /* Initialize handle flags */
   1005            hsd->SdTransferCplt  = 0;
   \   00000024   0x64B0             STR      R0,[R6, #+72]
   1006            hsd->DmaTransferCplt = 0;
   \   00000026   0x6530             STR      R0,[R6, #+80]
   1007            hsd->SdTransferErr   = SD_OK;
   \   00000028   0x64F0             STR      R0,[R6, #+76]
   \   0000002A   0x9F13             LDR      R7,[SP, #+76]
   1008            
   1009            /* Initialize SD Write operation */
   1010            if(NumberOfBlocks > 1)
   \   0000002C   0x2F02             CMP      R7,#+2
   \   0000002E   0xD302             BCC.N    ??HAL_SD_WriteBlocks_DMA_0
   1011            {
   1012              hsd->SdOperation = SD_WRITE_MULTIPLE_BLOCK;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x6570             STR      R0,[R6, #+84]
   \   00000034   0xE001             B.N      ??HAL_SD_WriteBlocks_DMA_1
   1013            }
   1014            else
   1015            {
   1016              hsd->SdOperation = SD_WRITE_SINGLE_BLOCK;
   \                     ??HAL_SD_WriteBlocks_DMA_0: (+1)
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x6570             STR      R0,[R6, #+84]
   1017            }  
   1018            
   1019            /* Enable transfer interrupts */
   1020            __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
   1021                                          SDIO_IT_DTIMEOUT |\
   1022                                          SDIO_IT_DATAEND  |\
   1023                                          SDIO_IT_TXUNDERR |\
   1024                                          SDIO_IT_STBITERR)); 
   \                     ??HAL_SD_WriteBlocks_DMA_1: (+1)
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0x6BC1             LDR      R1,[R0, #+60]
   \   0000003E   0xF240 0x321A      MOVW     R2,#+794
   \   00000042   0x4311             ORRS     R1,R2,R1
   \   00000044   0x63C1             STR      R1,[R0, #+60]
   1025            SD_DMA_DIR(hsd,1);
                   ^
Warning[Pe223]: function "SD_DMA_DIR" declared implicitly
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       SD_DMA_DIR
   1026            /* Configure DMA user callbacks */
   1027            hsd->hdmatx->XferCpltCallback  = SD_DMA_TxCplt;
   \   0000004E   0x.... 0x....      ADR.W    R0,SD_DMA_TxCplt
   \   00000052   0x6DF1             LDR      R1,[R6, #+92]
   \   00000054   0x6288             STR      R0,[R1, #+40]
   1028            hsd->hdmatx->XferErrorCallback = SD_DMA_TxError;
   \   00000056   0x.... 0x....      ADR.W    R0,SD_DMA_TxError
   \   0000005A   0x6DF1             LDR      R1,[R6, #+92]
   \   0000005C   0x6308             STR      R0,[R1, #+48]
   \   0000005E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   1029            
   1030            /* Enable the DMA Channel */
   1031            HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pWriteBuffer, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BlockSize * NumberOfBlocks)/4);
   \   00000062   0xFB07 0xF008      MUL      R0,R7,R8
   \   00000066   0x0883             LSRS     R3,R0,#+2
   \   00000068   0x6830             LDR      R0,[R6, #+0]
   \   0000006A   0xF100 0x0280      ADD      R2,R0,#+128
   \   0000006E   0x4649             MOV      R1,R9
   \   00000070   0x6DF0             LDR      R0,[R6, #+92]
   \   00000072   0x.... 0x....      BL       HAL_DMA_Start_IT
   1032          
   1033            /* Enable SDIO DMA transfer */
   1034            __HAL_SD_SDIO_DMA_ENABLE(hsd);
   \   00000076   0x6830             LDR      R0,[R6, #+0]
   \   00000078   0x6AC1             LDR      R1,[R0, #+44]
   \   0000007A   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000007E   0x62C1             STR      R1,[R0, #+44]
   1035            
   1036            if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   \   00000080   0x6A30             LDR      R0,[R6, #+32]
   \   00000082   0x2802             CMP      R0,#+2
   \   00000084   0xD104             BNE.N    ??HAL_SD_WriteBlocks_DMA_2
   1037            {
   1038              BlockSize = 512;
   \   00000086   0xF44F 0x7800      MOV      R8,#+512
   1039              WriteAddr /= 512;
   \   0000008A   0x0A64             LSRS     R4,R4,#+9
   \   0000008C   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1040            }
   1041          
   1042            /* Set Block Size for Card */ 
   1043            sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
   \                     ??HAL_SD_WriteBlocks_DMA_2: (+1)
   \   00000090   0xF8CD 0x8000      STR      R8,[SP, #+0]
   1044            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   00000094   0x2010             MOVS     R0,#+16
   \   00000096   0x9001             STR      R0,[SP, #+4]
   1045            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000098   0x2040             MOVS     R0,#+64
   \   0000009A   0x9002             STR      R0,[SP, #+8]
   1046            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9003             STR      R0,[SP, #+12]
   1047            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   000000A0   0xF44F 0x6080      MOV      R0,#+1024
   \   000000A4   0x9004             STR      R0,[SP, #+16]
   1048            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000A6   0xA900             ADD      R1,SP,#+0
   \   000000A8   0x6830             LDR      R0,[R6, #+0]
   \   000000AA   0x.... 0x....      BL       SDIO_SendCommand
   1049          
   1050            /* Check for error conditions */
   1051            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   000000AE   0x2110             MOVS     R1,#+16
   \   000000B0   0x4630             MOV      R0,R6
   \   000000B2   0x.... 0x....      BL       SD_CmdResp1Error
   1052          
   1053            if (errorstate != SD_OK)
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD12B             BNE.N    ??HAL_SD_WriteBlocks_DMA_3
   1054            {
   1055              return errorstate;
   1056            }
   1057            
   1058            /* Check number of blocks command */
   1059            if(NumberOfBlocks <= 1)
   \   000000BA   0x2F02             CMP      R7,#+2
   \   000000BC   0xD202             BCS.N    ??HAL_SD_WriteBlocks_DMA_4
   1060            {
   1061              /* Send CMD24 WRITE_SINGLE_BLOCK */
   1062              sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
   \   000000BE   0x2018             MOVS     R0,#+24
   \   000000C0   0x9001             STR      R0,[SP, #+4]
   \   000000C2   0xE001             B.N      ??HAL_SD_WriteBlocks_DMA_5
   1063            }
   1064            else
   1065            {
   1066              /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
   1067              sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
   \                     ??HAL_SD_WriteBlocks_DMA_4: (+1)
   \   000000C4   0x2019             MOVS     R0,#+25
   \   000000C6   0x9001             STR      R0,[SP, #+4]
   1068            }
   1069            
   1070            sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
   \                     ??HAL_SD_WriteBlocks_DMA_5: (+1)
   \   000000C8   0x9400             STR      R4,[SP, #+0]
   1071            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x6830             LDR      R0,[R6, #+0]
   \   000000CE   0x.... 0x....      BL       SDIO_SendCommand
   1072          
   1073            /* Check for error conditions */
   1074            if(NumberOfBlocks > 1)
   \   000000D2   0x2F02             CMP      R7,#+2
   \   000000D4   0xD304             BCC.N    ??HAL_SD_WriteBlocks_DMA_6
   1075            {
   1076              errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
   \   000000D6   0x2119             MOVS     R1,#+25
   \   000000D8   0x4630             MOV      R0,R6
   \   000000DA   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000DE   0xE003             B.N      ??HAL_SD_WriteBlocks_DMA_7
   1077            }
   1078            else
   1079            {
   1080              errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
   \                     ??HAL_SD_WriteBlocks_DMA_6: (+1)
   \   000000E0   0x2118             MOVS     R1,#+24
   \   000000E2   0x4630             MOV      R0,R6
   \   000000E4   0x.... 0x....      BL       SD_CmdResp1Error
   1081            }
   1082            
   1083            if (errorstate != SD_OK)
   \                     ??HAL_SD_WriteBlocks_DMA_7: (+1)
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD112             BNE.N    ??HAL_SD_WriteBlocks_DMA_3
   1084            {
   1085              return errorstate;
   1086            }
   1087            
   1088            /* Configure the SD DPSM (Data Path State Machine) */ 
   1089            sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   000000EC   0xF04F 0x30FF      MOV      R0,#-1
   \   000000F0   0x9005             STR      R0,[SP, #+20]
   1090            sdio_datainitstructure.DataLength    = BlockSize * NumberOfBlocks;
   \   000000F2   0xFB07 0xF008      MUL      R0,R7,R8
   \   000000F6   0x9006             STR      R0,[SP, #+24]
   1091            sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
   \   000000F8   0x2090             MOVS     R0,#+144
   \   000000FA   0x9007             STR      R0,[SP, #+28]
   1092            sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x9008             STR      R0,[SP, #+32]
   1093            sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   00000100   0x9009             STR      R0,[SP, #+36]
   1094            sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x900A             STR      R0,[SP, #+40]
   1095            SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   00000106   0xA905             ADD      R1,SP,#+20
   \   00000108   0x6830             LDR      R0,[R6, #+0]
   \   0000010A   0x.... 0x....      BL       SDIO_DataConfig
   1096            
   1097            hsd->SdTransferErr = errorstate;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x64F0             STR      R0,[R6, #+76]
   1098            
   1099            return errorstate;
   \                     ??HAL_SD_WriteBlocks_DMA_3: (+1)
   \   00000112   0xB00B             ADD      SP,SP,#+44
   \   00000114   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1100          }
   1101          
   1102          /**
   1103            * @brief  This function waits until the SD DMA data read transfer is finished. 
   1104            *         This API should be called after HAL_SD_ReadBlocks_DMA() function
   1105            *         to insure that all data sent by the card is already transferred by the 
   1106            *         DMA controller.
   1107            * @param  hsd: SD handle
   1108            * @param  Timeout: Timeout duration  
   1109            * @retval SD Card error state
   1110            */

   \                                 In section .text, align 2, keep-with-next
   1111          HAL_SD_ErrorTypedef HAL_SD_CheckReadOperation(SD_HandleTypeDef *hsd, uint32_t Timeout)
   1112          {
   \                     HAL_SD_CheckReadOperation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1113            HAL_SD_ErrorTypedef errorstate = SD_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   1114            uint32_t timeout = Timeout;
   1115            uint32_t tmp1, tmp2;
   1116            HAL_SD_ErrorTypedef tmp3;
   1117            
   1118            /* Wait for DMA/SD transfer end or SD error variables to be in SD handle */
   1119            tmp1 = hsd->DmaTransferCplt; 
   \   00000008   0x6D22             LDR      R2,[R4, #+80]
   1120            tmp2 = hsd->SdTransferCplt;
   \   0000000A   0x6CA3             LDR      R3,[R4, #+72]
   1121            tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
   \   0000000C   0x6CE6             LDR      R6,[R4, #+76]
   \   0000000E   0xE003             B.N      ??HAL_SD_CheckReadOperation_0
   1122              
   1123            while (((tmp1 & tmp2) == 0) && (tmp3 == SD_OK) && (timeout > 0))
   1124            {
   1125              tmp1 = hsd->DmaTransferCplt; 
   \                     ??HAL_SD_CheckReadOperation_1: (+1)
   \   00000010   0x6D22             LDR      R2,[R4, #+80]
   1126              tmp2 = hsd->SdTransferCplt;
   \   00000012   0x6CA3             LDR      R3,[R4, #+72]
   1127              tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;    
   \   00000014   0x6CE6             LDR      R6,[R4, #+76]
   1128              timeout--;
   \   00000016   0x1E49             SUBS     R1,R1,#+1
   1129            }
   \                     ??HAL_SD_CheckReadOperation_0: (+1)
   \   00000018   0x421A             TST      R2,R3
   \   0000001A   0xD106             BNE.N    ??HAL_SD_CheckReadOperation_2
   \   0000001C   0xB276             SXTB     R6,R6
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD103             BNE.N    ??HAL_SD_CheckReadOperation_2
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD1F4             BNE.N    ??HAL_SD_CheckReadOperation_1
   1130            
   1131            timeout = Timeout;
   \   00000026   0xE000             B.N      ??HAL_SD_CheckReadOperation_2
   1132            
   1133            /* Wait until the Rx transfer is no longer active */
   1134            while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXACT)) && (timeout > 0))
   1135            {
   1136              timeout--;  
   \                     ??HAL_SD_CheckReadOperation_3: (+1)
   \   00000028   0x1E6D             SUBS     R5,R5,#+1
   1137            }
   \                     ??HAL_SD_CheckReadOperation_2: (+1)
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6B49             LDR      R1,[R1, #+52]
   \   0000002E   0x0489             LSLS     R1,R1,#+18
   \   00000030   0xD501             BPL.N    ??HAL_SD_CheckReadOperation_4
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD1F8             BNE.N    ??HAL_SD_CheckReadOperation_3
   1138            
   1139            /* Send stop command in multiblock read */
   1140            if (hsd->SdOperation == SD_READ_MULTIPLE_BLOCK)
   \                     ??HAL_SD_CheckReadOperation_4: (+1)
   \   00000036   0x6D61             LDR      R1,[R4, #+84]
   \   00000038   0x2901             CMP      R1,#+1
   \   0000003A   0xD102             BNE.N    ??HAL_SD_CheckReadOperation_5
   1141            {
   1142              errorstate = HAL_SD_StopTransfer(hsd);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_SD_StopTransfer
   1143            }
   1144            
   1145            if ((timeout == 0) && (errorstate == SD_OK))
   \                     ??HAL_SD_CheckReadOperation_5: (+1)
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD102             BNE.N    ??HAL_SD_CheckReadOperation_6
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD100             BNE.N    ??HAL_SD_CheckReadOperation_6
   1146            {
   1147              errorstate = SD_DATA_TIMEOUT;
   \   0000004A   0x2004             MOVS     R0,#+4
   1148            }
   1149            
   1150            /* Clear all the static flags */
   1151            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??HAL_SD_CheckReadOperation_6: (+1)
   \   0000004C   0xF240 0x51FF      MOVW     R1,#+1535
   \   00000050   0x6822             LDR      R2,[R4, #+0]
   \   00000052   0x6391             STR      R1,[R2, #+56]
   1152            
   1153            /* Return error state */
   1154            if (hsd->SdTransferErr != SD_OK)
   \   00000054   0x6CE1             LDR      R1,[R4, #+76]
   \   00000056   0x2900             CMP      R1,#+0
   \   00000058   0xD001             BEQ.N    ??HAL_SD_CheckReadOperation_7
   1155            {
   1156              return (HAL_SD_ErrorTypedef)(hsd->SdTransferErr);
   \   0000005A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000005C   0xB240             SXTB     R0,R0
   1157            }
   1158            
   1159            return errorstate;
   \                     ??HAL_SD_CheckReadOperation_7: (+1)
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   1160          }
   1161          
   1162          /**
   1163            * @brief  This function waits until the SD DMA data write transfer is finished. 
   1164            *         This API should be called after HAL_SD_WriteBlocks_DMA() function
   1165            *         to insure that all data sent by the card is already transferred by the 
   1166            *         DMA controller.
   1167            * @param  hsd: SD handle
   1168            * @param  Timeout: Timeout duration  
   1169            * @retval SD Card error state
   1170            */

   \                                 In section .text, align 2, keep-with-next
   1171          HAL_SD_ErrorTypedef HAL_SD_CheckWriteOperation(SD_HandleTypeDef *hsd, uint32_t Timeout)
   1172          {
   \                     HAL_SD_CheckWriteOperation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   1173            HAL_SD_ErrorTypedef errorstate = SD_OK;
   \   00000006   0x2500             MOVS     R5,#+0
   1174            uint32_t timeout = Timeout;
   \   00000008   0x4630             MOV      R0,R6
   1175            uint32_t tmp1, tmp2;
   1176            HAL_SD_ErrorTypedef tmp3;
   1177          
   1178            /* Wait for DMA/SD transfer end or SD error variables to be in SD handle */
   1179            tmp1 = hsd->DmaTransferCplt; 
   \   0000000A   0x6D21             LDR      R1,[R4, #+80]
   1180            tmp2 = hsd->SdTransferCplt;
   \   0000000C   0x6CA2             LDR      R2,[R4, #+72]
   1181            tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
   \   0000000E   0x6CE3             LDR      R3,[R4, #+76]
   \   00000010   0xE003             B.N      ??HAL_SD_CheckWriteOperation_0
   1182              
   1183            while (((tmp1 & tmp2) == 0) && (tmp3 == SD_OK) && (timeout > 0))
   1184            {
   1185              tmp1 = hsd->DmaTransferCplt; 
   \                     ??HAL_SD_CheckWriteOperation_1: (+1)
   \   00000012   0x6D21             LDR      R1,[R4, #+80]
   1186              tmp2 = hsd->SdTransferCplt;
   \   00000014   0x6CA2             LDR      R2,[R4, #+72]
   1187              tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
   \   00000016   0x6CE3             LDR      R3,[R4, #+76]
   1188              timeout--;
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   1189            }
   \                     ??HAL_SD_CheckWriteOperation_0: (+1)
   \   0000001A   0x4211             TST      R1,R2
   \   0000001C   0xD106             BNE.N    ??HAL_SD_CheckWriteOperation_2
   \   0000001E   0xB25B             SXTB     R3,R3
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD103             BNE.N    ??HAL_SD_CheckWriteOperation_2
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD1F4             BNE.N    ??HAL_SD_CheckWriteOperation_1
   1190            
   1191            timeout = Timeout;
   \   00000028   0xE000             B.N      ??HAL_SD_CheckWriteOperation_2
   1192            
   1193            /* Wait until the Tx transfer is no longer active */
   1194            while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXACT))  && (timeout > 0))
   1195            {
   1196              timeout--;  
   \                     ??HAL_SD_CheckWriteOperation_3: (+1)
   \   0000002A   0x1E76             SUBS     R6,R6,#+1
   1197            }
   \                     ??HAL_SD_CheckWriteOperation_2: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6B40             LDR      R0,[R0, #+52]
   \   00000030   0x04C0             LSLS     R0,R0,#+19
   \   00000032   0xD501             BPL.N    ??HAL_SD_CheckWriteOperation_4
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD1F8             BNE.N    ??HAL_SD_CheckWriteOperation_3
   1198          
   1199            /* Send stop command in multiblock write */
   1200            if (hsd->SdOperation == SD_WRITE_MULTIPLE_BLOCK)
   \                     ??HAL_SD_CheckWriteOperation_4: (+1)
   \   00000038   0x6D60             LDR      R0,[R4, #+84]
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD103             BNE.N    ??HAL_SD_CheckWriteOperation_5
   1201            {
   1202              errorstate = HAL_SD_StopTransfer(hsd);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       HAL_SD_StopTransfer
   \   00000044   0x4605             MOV      R5,R0
   1203            }
   1204            
   1205            if ((timeout == 0) && (errorstate == SD_OK))
   \                     ??HAL_SD_CheckWriteOperation_5: (+1)
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD102             BNE.N    ??HAL_SD_CheckWriteOperation_6
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD100             BNE.N    ??HAL_SD_CheckWriteOperation_6
   1206            {
   1207              errorstate = SD_DATA_TIMEOUT;
   \   0000004E   0x2504             MOVS     R5,#+4
   1208            }
   1209            
   1210            /* Clear all the static flags */
   1211            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??HAL_SD_CheckWriteOperation_6: (+1)
   \   00000050   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6388             STR      R0,[R1, #+56]
   1212            
   1213            /* Return error state */
   1214            if (hsd->SdTransferErr != SD_OK)
   \   00000058   0x6CE0             LDR      R0,[R4, #+76]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD002             BEQ.N    ??HAL_SD_CheckWriteOperation_7
   1215            {
   1216              return (HAL_SD_ErrorTypedef)(hsd->SdTransferErr);
   \   0000005E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000060   0xB240             SXTB     R0,R0
   \   00000062   0xBD70             POP      {R4-R6,PC}
   1217            }
   1218            
   1219            /* Wait until write is complete */
   1220            while(HAL_SD_GetStatus(hsd) != SD_TRANSFER_OK)
   \                     ??HAL_SD_CheckWriteOperation_7: (+1)
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       HAL_SD_GetStatus
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1FA             BNE.N    ??HAL_SD_CheckWriteOperation_7
   1221            {    
   1222            }
   1223          
   1224            return errorstate; 
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
   1225          }
   1226          
   1227          /**
   1228            * @brief  Erases the specified memory area of the given SD card.
   1229            * @param  hsd: SD handle 
   1230            * @param  Startaddr: Start byte address
   1231            * @param  Endaddr: End byte address
   1232            * @retval SD Card error state
   1233            */

   \                                 In section .text, align 2, keep-with-next
   1234          HAL_SD_ErrorTypedef HAL_SD_Erase(SD_HandleTypeDef *hsd, uint64_t Startaddr, uint64_t Endaddr)
   1235          {
   \                     HAL_SD_Erase: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
   1236            HAL_SD_ErrorTypedef errorstate = SD_OK;
   1237            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   0000000C   0xA802             ADD      R0,SP,#+8
   \   0000000E   0x2114             MOVS     R1,#+20
   \   00000010   0x.... 0x....      BL       __aeabi_memclr4
   1238            
   1239            uint32_t delay         = 0;
   \   00000014   0xF04F 0x0900      MOV      R9,#+0
   1240            __IO uint32_t maxdelay = 0;
   \   00000018   0x4648             MOV      R0,R9
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   1241            uint8_t cardstate      = 0;
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1242            
   1243            /* Check if the card command class supports erase command */
   1244            if (((hsd->CSD[1] >> 20) & SD_CCCC_ERASE) == 0)
   \   00000020   0xF8D8 0x002C      LDR      R0,[R8, #+44]
   \   00000024   0x0D00             LSRS     R0,R0,#+20
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD401             BMI.N    ??HAL_SD_Erase_0
   1245            {
   1246              errorstate = SD_REQUEST_NOT_APPLICABLE;
   1247              
   1248              return errorstate;
   \   0000002A   0x2025             MOVS     R0,#+37
   \   0000002C   0xE072             B.N      ??HAL_SD_Erase_1
   1249            }
   1250            
   1251            /* Get max delay value */
   1252            maxdelay = 120000 / (((hsd->Instance->CLKCR) & 0xFF) + 2);
   \                     ??HAL_SD_Erase_0: (+1)
   \   0000002E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0x1d4c0
   \   00000036   0x6842             LDR      R2,[R0, #+4]
   \   00000038   0xB2D2             UXTB     R2,R2
   \   0000003A   0x1C92             ADDS     R2,R2,#+2
   \   0000003C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000040   0x9101             STR      R1,[SP, #+4]
   1253            
   1254            if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
   \   00000042   0x4649             MOV      R1,R9
   \   00000044   0x.... 0x....      BL       SDIO_GetResponse
   \   00000048   0x0180             LSLS     R0,R0,#+6
   \   0000004A   0xD501             BPL.N    ??HAL_SD_Erase_2
   1255            {
   1256              errorstate = SD_LOCK_UNLOCK_FAILED;
   1257              
   1258              return errorstate;
   \   0000004C   0x200E             MOVS     R0,#+14
   \   0000004E   0xE061             B.N      ??HAL_SD_Erase_1
   1259            }
   1260            
   1261            /* Get start and end block for high capacity cards */
   1262            if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   \                     ??HAL_SD_Erase_2: (+1)
   \   00000050   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   00000054   0xE9DD 0x670E      LDRD     R6,R7,[SP, #+56]
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xD105             BNE.N    ??HAL_SD_Erase_3
   1263            {
   1264              Startaddr /= 512;
   \   0000005C   0x0A64             LSRS     R4,R4,#+9
   \   0000005E   0xEA44 0x54C5      ORR      R4,R4,R5, LSL #+23
   1265              Endaddr   /= 512;
   \   00000062   0x0A76             LSRS     R6,R6,#+9
   \   00000064   0xEA46 0x56C7      ORR      R6,R6,R7, LSL #+23
   1266            }
   1267            
   1268            /* According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
   1269            if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
   1270              (hsd->CardType == HIGH_CAPACITY_SD_CARD))
   \                     ??HAL_SD_Erase_3: (+1)
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD003             BEQ.N    ??HAL_SD_Erase_4
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD001             BEQ.N    ??HAL_SD_Erase_4
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0xD122             BNE.N    ??HAL_SD_Erase_5
   1271            {
   1272              /* Send CMD32 SD_ERASE_GRP_START with argument as addr  */
   1273              sdio_cmdinitstructure.Argument         =(uint32_t)Startaddr;
   \                     ??HAL_SD_Erase_4: (+1)
   \   00000074   0x9402             STR      R4,[SP, #+8]
   1274              sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_ERASE_GRP_START;
   \   00000076   0x2020             MOVS     R0,#+32
   \   00000078   0x9003             STR      R0,[SP, #+12]
   1275              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   0000007A   0x2040             MOVS     R0,#+64
   \   0000007C   0x9004             STR      R0,[SP, #+16]
   1276              sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0x9005             STR      R0,[SP, #+20]
   1277              sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000082   0xF44F 0x6080      MOV      R0,#+1024
   \   00000086   0x9006             STR      R0,[SP, #+24]
   1278              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000088   0xA902             ADD      R1,SP,#+8
   \   0000008A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000008E   0x.... 0x....      BL       SDIO_SendCommand
   1279              
   1280              /* Check for error conditions */
   1281              errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_ERASE_GRP_START);
   \   00000092   0x2120             MOVS     R1,#+32
   \   00000094   0x4640             MOV      R0,R8
   \   00000096   0x.... 0x....      BL       SD_CmdResp1Error
   1282              
   1283              if (errorstate != SD_OK)
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD13A             BNE.N    ??HAL_SD_Erase_1
   1284              {
   1285                return errorstate;
   1286              }
   1287              
   1288              /* Send CMD33 SD_ERASE_GRP_END with argument as addr  */
   1289              sdio_cmdinitstructure.Argument         = (uint32_t)Endaddr;
   \   0000009E   0x9602             STR      R6,[SP, #+8]
   1290              sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_ERASE_GRP_END;
   \   000000A0   0x2021             MOVS     R0,#+33
   \   000000A2   0x9003             STR      R0,[SP, #+12]
   1291              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000A4   0xA902             ADD      R1,SP,#+8
   \   000000A6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000AA   0x.... 0x....      BL       SDIO_SendCommand
   1292              
   1293              /* Check for error conditions */
   1294              errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_ERASE_GRP_END);
   \   000000AE   0x2121             MOVS     R1,#+33
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0x.... 0x....      BL       SD_CmdResp1Error
   1295              
   1296              if (errorstate != SD_OK)
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD12C             BNE.N    ??HAL_SD_Erase_1
   1297              {
   1298                return errorstate;
   1299              }
   1300            }
   1301            
   1302            /* Send CMD38 ERASE */
   1303            sdio_cmdinitstructure.Argument         = 0;
   \                     ??HAL_SD_Erase_5: (+1)
   \   000000BA   0x4648             MOV      R0,R9
   \   000000BC   0x9002             STR      R0,[SP, #+8]
   1304            sdio_cmdinitstructure.CmdIndex         = SD_CMD_ERASE;
   \   000000BE   0x2026             MOVS     R0,#+38
   \   000000C0   0x9003             STR      R0,[SP, #+12]
   1305            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000C2   0xA902             ADD      R1,SP,#+8
   \   000000C4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C8   0x.... 0x....      BL       SDIO_SendCommand
   1306            
   1307            /* Check for error conditions */
   1308            errorstate = SD_CmdResp1Error(hsd, SD_CMD_ERASE);
   \   000000CC   0x2126             MOVS     R1,#+38
   \   000000CE   0x4640             MOV      R0,R8
   \   000000D0   0x.... 0x....      BL       SD_CmdResp1Error
   1309            
   1310            if (errorstate != SD_OK)
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD11D             BNE.N    ??HAL_SD_Erase_1
   \   000000D8   0xE001             B.N      ??HAL_SD_Erase_6
   1311            {
   1312              return errorstate;
   1313            }
   1314            
   1315            for (; delay < maxdelay; delay++)
   \                     ??HAL_SD_Erase_7: (+1)
   \   000000DA   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??HAL_SD_Erase_6: (+1)
   \   000000DE   0x9801             LDR      R0,[SP, #+4]
   \   000000E0   0x4581             CMP      R9,R0
   \   000000E2   0xD3FA             BCC.N    ??HAL_SD_Erase_7
   1316            {
   1317            }
   1318            
   1319            /* Wait untill the card is in programming state */
   1320            errorstate = SD_IsCardProgramming(hsd, &cardstate);
   \   000000E4   0xA900             ADD      R1,SP,#+0
   \   000000E6   0x4640             MOV      R0,R8
   \   000000E8   0x.... 0x....      BL       SD_IsCardProgramming
   1321            
   1322            delay = SD_DATATIMEOUT;
   \   000000EC   0xF04F 0x39FF      MOV      R9,#-1
   \   000000F0   0xE005             B.N      ??HAL_SD_Erase_8
   1323            
   1324            while ((delay > 0) && (errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
   1325            {
   1326              errorstate = SD_IsCardProgramming(hsd, &cardstate);
   \                     ??HAL_SD_Erase_9: (+1)
   \   000000F2   0xA900             ADD      R1,SP,#+0
   \   000000F4   0x4640             MOV      R0,R8
   \   000000F6   0x.... 0x....      BL       SD_IsCardProgramming
   1327              delay--;
   \   000000FA   0xF1A9 0x0901      SUB      R9,R9,#+1
   1328            }
   \                     ??HAL_SD_Erase_8: (+1)
   \   000000FE   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000102   0xD007             BEQ.N    ??HAL_SD_Erase_1
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD105             BNE.N    ??HAL_SD_Erase_1
   \   00000108   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000010C   0x2907             CMP      R1,#+7
   \   0000010E   0xD0F0             BEQ.N    ??HAL_SD_Erase_9
   \   00000110   0x2906             CMP      R1,#+6
   \   00000112   0xD0EE             BEQ.N    ??HAL_SD_Erase_9
   1329            
   1330            return errorstate;
   \                     ??HAL_SD_Erase_1: (+1)
   \   00000114   0xB007             ADD      SP,SP,#+28
   \   00000116   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1331          }
   1332          
   1333          /**
   1334            * @brief  This function handles SD card interrupt request.
   1335            * @param  hsd: SD handle
   1336            * @retval None
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
   1339          {  
   \                     HAL_SD_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1340            /* Check for SDIO interrupt flags */
   1341            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6B41             LDR      R1,[R0, #+52]
   \   00000008   0x05C9             LSLS     R1,R1,#+23
   \   0000000A   0xD50A             BPL.N    ??HAL_SD_IRQHandler_0
   1342            {
   1343              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_IT_DATAEND);  
   \   0000000C   0xF44F 0x7180      MOV      R1,#+256
   \   00000010   0x6381             STR      R1,[R0, #+56]
   1344                
   1345              /* SD transfer is complete */
   1346              hsd->SdTransferCplt = 1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x64A0             STR      R0,[R4, #+72]
   1347          
   1348              /* No transfer error */ 
   1349              hsd->SdTransferErr  = SD_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x64E0             STR      R0,[R4, #+76]
   1350          
   1351              HAL_SD_XferCpltCallback(hsd);  
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_SD_XferCpltCallback
   \   00000020   0xE036             B.N      ??HAL_SD_IRQHandler_1
   1352            }  
   1353            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DCRCFAIL))
   \                     ??HAL_SD_IRQHandler_0: (+1)
   \   00000022   0x6B41             LDR      R1,[R0, #+52]
   \   00000024   0x0789             LSLS     R1,R1,#+30
   \   00000026   0xD507             BPL.N    ??HAL_SD_IRQHandler_2
   1354            {
   1355              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x6381             STR      R1,[R0, #+56]
   1356              
   1357              hsd->SdTransferErr = SD_DATA_CRC_FAIL;
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x64E0             STR      R0,[R4, #+76]
   1358              
   1359              HAL_SD_XferErrorCallback(hsd);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_SD_XferErrorCallback
   \   00000036   0xE02B             B.N      ??HAL_SD_IRQHandler_1
   1360              
   1361            }
   1362            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DTIMEOUT))
   \                     ??HAL_SD_IRQHandler_2: (+1)
   \   00000038   0x6B41             LDR      R1,[R0, #+52]
   \   0000003A   0x0709             LSLS     R1,R1,#+28
   \   0000003C   0xD507             BPL.N    ??HAL_SD_IRQHandler_3
   1363            {
   1364              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
   \   0000003E   0x2108             MOVS     R1,#+8
   \   00000040   0x6381             STR      R1,[R0, #+56]
   1365              
   1366              hsd->SdTransferErr = SD_DATA_TIMEOUT;
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x64E0             STR      R0,[R4, #+76]
   1367              
   1368              HAL_SD_XferErrorCallback(hsd);
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_SD_XferErrorCallback
   \   0000004C   0xE020             B.N      ??HAL_SD_IRQHandler_1
   1369            }
   1370            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_RXOVERR))
   \                     ??HAL_SD_IRQHandler_3: (+1)
   \   0000004E   0x6B41             LDR      R1,[R0, #+52]
   \   00000050   0x0689             LSLS     R1,R1,#+26
   \   00000052   0xD507             BPL.N    ??HAL_SD_IRQHandler_4
   1371            {
   1372              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
   \   00000054   0x2120             MOVS     R1,#+32
   \   00000056   0x6381             STR      R1,[R0, #+56]
   1373              
   1374              hsd->SdTransferErr = SD_RX_OVERRUN;
   \   00000058   0x2006             MOVS     R0,#+6
   \   0000005A   0x64E0             STR      R0,[R4, #+76]
   1375              
   1376              HAL_SD_XferErrorCallback(hsd);
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       HAL_SD_XferErrorCallback
   \   00000062   0xE015             B.N      ??HAL_SD_IRQHandler_1
   1377            }
   1378            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_TXUNDERR))
   \                     ??HAL_SD_IRQHandler_4: (+1)
   \   00000064   0x6B41             LDR      R1,[R0, #+52]
   \   00000066   0x06C9             LSLS     R1,R1,#+27
   \   00000068   0xD507             BPL.N    ??HAL_SD_IRQHandler_5
   1379            {
   1380              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
   \   0000006A   0x2110             MOVS     R1,#+16
   \   0000006C   0x6381             STR      R1,[R0, #+56]
   1381              
   1382              hsd->SdTransferErr = SD_TX_UNDERRUN;
   \   0000006E   0x2005             MOVS     R0,#+5
   \   00000070   0x64E0             STR      R0,[R4, #+76]
   1383              
   1384              HAL_SD_XferErrorCallback(hsd);
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       HAL_SD_XferErrorCallback
   \   00000078   0xE00A             B.N      ??HAL_SD_IRQHandler_1
   1385            }
   1386            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_STBITERR))
   \                     ??HAL_SD_IRQHandler_5: (+1)
   \   0000007A   0x6B41             LDR      R1,[R0, #+52]
   \   0000007C   0x0589             LSLS     R1,R1,#+22
   \   0000007E   0xD507             BPL.N    ??HAL_SD_IRQHandler_1
   1387            {
   1388              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
   \   00000080   0xF44F 0x7100      MOV      R1,#+512
   \   00000084   0x6381             STR      R1,[R0, #+56]
   1389              
   1390              hsd->SdTransferErr = SD_START_BIT_ERR;
   \   00000086   0x2007             MOVS     R0,#+7
   \   00000088   0x64E0             STR      R0,[R4, #+76]
   1391              
   1392              HAL_SD_XferErrorCallback(hsd);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       HAL_SD_XferErrorCallback
   1393            }
   1394            else
   1395            {
   1396              /* No error flag set */
   1397            }
   1398          
   1399            /* Disable all SDIO peripheral interrupt sources */
   1400            __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
   1401                                          SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |\
   1402                                          SDIO_IT_RXOVERR  | SDIO_IT_STBITERR);                               
   \                     ??HAL_SD_IRQHandler_1: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6BC1             LDR      R1,[R0, #+60]
   \   00000094   0x.... 0x....      LDR.W    R2,??DataTable34_1  ;; 0xffff3cc5
   \   00000098   0x4011             ANDS     R1,R2,R1
   \   0000009A   0x63C1             STR      R1,[R0, #+60]
   1403          }
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
   1404          
   1405          
   1406          /**
   1407            * @brief  SD end of transfer callback.
   1408            * @param  hsd: SD handle 
   1409            * @retval None
   1410            */

   \                                 In section .text, align 2, keep-with-next
   1411          __weak void HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd)
   1412          {
   1413            /* Prevent unused argument(s) compilation warning */
   1414            UNUSED(hsd);
   1415            /* NOTE : This function Should not be modified, when the callback is needed,
   1416                      the HAL_SD_XferCpltCallback could be implemented in the user file
   1417             */ 
   1418          }
   \                     HAL_SD_XferCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1419          
   1420          /**
   1421            * @brief  SD Transfer Error callback.
   1422            * @param  hsd: SD handle
   1423            * @retval None
   1424            */

   \                                 In section .text, align 2, keep-with-next
   1425          __weak void HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd)
   1426          {
   1427            /* Prevent unused argument(s) compilation warning */
   1428            UNUSED(hsd);
   1429            /* NOTE : This function Should not be modified, when the callback is needed,
   1430                      the HAL_SD_XferErrorCallback could be implemented in the user file
   1431             */ 
   1432          }
   \                     HAL_SD_XferErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1433          
   1434          /**
   1435            * @brief  SD Transfer complete Rx callback in non blocking mode.
   1436            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1437            *                the configuration information for the specified DMA module.
   1438            * @retval None
   1439            */

   \                                 In section .text, align 2, keep-with-next
   1440          __weak void HAL_SD_DMA_RxCpltCallback(DMA_HandleTypeDef *hdma)
   1441          {
   1442            /* Prevent unused argument(s) compilation warning */
   1443            UNUSED(hdma);
   1444            /* NOTE : This function Should not be modified, when the callback is needed,
   1445                      the HAL_SD_DMA_RxCpltCallback could be implemented in the user file
   1446             */ 
   1447          }  
   \                     HAL_SD_DMA_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1448          
   1449          /**
   1450            * @brief  SD DMA transfer complete Rx error callback.
   1451            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1452            *                the configuration information for the specified DMA module.
   1453            * @retval None
   1454            */

   \                                 In section .text, align 2, keep-with-next
   1455          __weak void HAL_SD_DMA_RxErrorCallback(DMA_HandleTypeDef *hdma)
   1456          {
   1457            /* Prevent unused argument(s) compilation warning */
   1458            UNUSED(hdma);
   1459            /* NOTE : This function Should not be modified, when the callback is needed,
   1460                      the HAL_SD_DMA_RxErrorCallback could be implemented in the user file
   1461             */ 
   1462          }
   \                     HAL_SD_DMA_RxErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1463          
   1464          /**
   1465            * @brief  SD Transfer complete Tx callback in non blocking mode.
   1466            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1467            *                the configuration information for the specified DMA module.
   1468            * @retval None
   1469            */

   \                                 In section .text, align 2, keep-with-next
   1470          __weak void HAL_SD_DMA_TxCpltCallback(DMA_HandleTypeDef *hdma)
   1471          {
   1472            /* Prevent unused argument(s) compilation warning */
   1473            UNUSED(hdma);
   1474            /* NOTE : This function Should not be modified, when the callback is needed,
   1475                      the HAL_SD_DMA_TxCpltCallback could be implemented in the user file
   1476             */ 
   1477          }  
   \                     HAL_SD_DMA_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1478          
   1479          /**
   1480            * @brief  SD DMA transfer complete error Tx callback.
   1481            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1482            *                the configuration information for the specified DMA module.
   1483            * @retval None
   1484            */

   \                                 In section .text, align 2, keep-with-next
   1485          __weak void HAL_SD_DMA_TxErrorCallback(DMA_HandleTypeDef *hdma)
   1486          {
   1487            /* Prevent unused argument(s) compilation warning */
   1488            UNUSED(hdma);
   1489            /* NOTE : This function Should not be modified, when the callback is needed,
   1490                      the HAL_SD_DMA_TxErrorCallback could be implemented in the user file
   1491             */ 
   1492          }
   \                     HAL_SD_DMA_TxErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1493          
   1494          /**
   1495            * @}
   1496            */
   1497          
   1498          /** @defgroup SD_Exported_Functions_Group3 Peripheral Control functions 
   1499           *  @brief   management functions 
   1500           *
   1501          @verbatim   
   1502            ==============================================================================
   1503                                ##### Peripheral Control functions #####
   1504            ==============================================================================  
   1505            [..]
   1506              This subsection provides a set of functions allowing to control the SD card 
   1507              operations.
   1508          
   1509          @endverbatim
   1510            * @{
   1511            */
   1512          
   1513          /**
   1514            * @brief  Returns information about specific card.
   1515            * @param  hsd: SD handle
   1516            * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
   1517            *         contains all SD cardinformation  
   1518            * @retval SD Card error state
   1519            */

   \                                 In section .text, align 2, keep-with-next
   1520          HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
   1521          {
   \                     HAL_SD_Get_CardInfo: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1522            HAL_SD_ErrorTypedef errorstate = SD_OK;
   \   00000004   0xF04F 0x0C00      MOV      R12,#+0
   1523            uint32_t tmp = 0;
   1524            
   1525            pCardInfo->CardType = (uint8_t)(hsd->CardType);
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xF881 0x2056      STRB     R2,[R1, #+86]
   1526            pCardInfo->RCA      = (uint16_t)(hsd->RCA);
   \   0000000E   0x6A42             LDR      R2,[R0, #+36]
   \   00000010   0xF8A1 0x2054      STRH     R2,[R1, #+84]
   1527            
   1528            /* Byte 0 */
   1529            tmp = (hsd->CSD[0] & 0xFF000000) >> 24;
   \   00000014   0x6A82             LDR      R2,[R0, #+40]
   \   00000016   0x0E12             LSRS     R2,R2,#+24
   1530            pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0) >> 6);
   \   00000018   0xF3C2 0x1381      UBFX     R3,R2,#+6,#+2
   \   0000001C   0x700B             STRB     R3,[R1, #+0]
   1531            pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3C) >> 2);
   \   0000001E   0xF3C2 0x0383      UBFX     R3,R2,#+2,#+4
   \   00000022   0x704B             STRB     R3,[R1, #+1]
   1532            pCardInfo->SD_csd.Reserved1      = tmp & 0x03;
   \   00000024   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000028   0x708A             STRB     R2,[R1, #+2]
   1533            
   1534            /* Byte 1 */
   1535            tmp = (hsd->CSD[0] & 0x00FF0000) >> 16;
   1536            pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
   \   0000002A   0x6A82             LDR      R2,[R0, #+40]
   \   0000002C   0x0C12             LSRS     R2,R2,#+16
   \   0000002E   0x70CA             STRB     R2,[R1, #+3]
   1537            
   1538            /* Byte 2 */
   1539            tmp = (hsd->CSD[0] & 0x0000FF00) >> 8;
   1540            pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
   \   00000030   0x6A82             LDR      R2,[R0, #+40]
   \   00000032   0x0A12             LSRS     R2,R2,#+8
   \   00000034   0x710A             STRB     R2,[R1, #+4]
   1541            
   1542            /* Byte 3 */
   1543            tmp = hsd->CSD[0] & 0x000000FF;
   1544            pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
   \   00000036   0x6A82             LDR      R2,[R0, #+40]
   \   00000038   0x714A             STRB     R2,[R1, #+5]
   1545            
   1546            /* Byte 4 */
   1547            tmp = (hsd->CSD[1] & 0xFF000000) >> 24;
   1548            pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4);
   \   0000003A   0x6AC2             LDR      R2,[R0, #+44]
   \   0000003C   0x0E12             LSRS     R2,R2,#+24
   \   0000003E   0x0112             LSLS     R2,R2,#+4
   \   00000040   0x80CA             STRH     R2,[R1, #+6]
   1549            
   1550            /* Byte 5 */
   1551            tmp = (hsd->CSD[1] & 0x00FF0000) >> 16;
   \   00000042   0x6AC2             LDR      R2,[R0, #+44]
   \   00000044   0xF3C2 0x4207      UBFX     R2,R2,#+16,#+8
   1552            pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4);
   \   00000048   0x88CB             LDRH     R3,[R1, #+6]
   \   0000004A   0xF3C2 0x1403      UBFX     R4,R2,#+4,#+4
   \   0000004E   0x4323             ORRS     R3,R4,R3
   \   00000050   0x80CB             STRH     R3,[R1, #+6]
   1553            pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0F);
   \   00000052   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000056   0x720A             STRB     R2,[R1, #+8]
   1554            
   1555            /* Byte 6 */
   1556            tmp = (hsd->CSD[1] & 0x0000FF00) >> 8;
   \   00000058   0x6AC2             LDR      R2,[R0, #+44]
   \   0000005A   0xF3C2 0x2E07      UBFX     LR,R2,#+8,#+8
   1557            pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80) >> 7);
   \   0000005E   0xF3CE 0x12C0      UBFX     R2,LR,#+7,#+1
   \   00000062   0x724A             STRB     R2,[R1, #+9]
   1558            pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40) >> 6);
   \   00000064   0xF3CE 0x1280      UBFX     R2,LR,#+6,#+1
   \   00000068   0x728A             STRB     R2,[R1, #+10]
   1559            pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20) >> 5);
   \   0000006A   0xF3CE 0x1240      UBFX     R2,LR,#+5,#+1
   \   0000006E   0x72CA             STRB     R2,[R1, #+11]
   1560            pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10) >> 4);
   \   00000070   0xF3CE 0x1200      UBFX     R2,LR,#+4,#+1
   \   00000074   0x730A             STRB     R2,[R1, #+12]
   1561            pCardInfo->SD_csd.Reserved2       = 0; /*!< Reserved */
   \   00000076   0x4662             MOV      R2,R12
   \   00000078   0x734A             STRB     R2,[R1, #+13]
   1562            
   1563            if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
   \   0000007A   0x6A02             LDR      R2,[R0, #+32]
   \   0000007C   0x2A00             CMP      R2,#+0
   \   0000007E   0xD001             BEQ.N    ??HAL_SD_Get_CardInfo_0
   \   00000080   0x2A01             CMP      R2,#+1
   \   00000082   0xD14D             BNE.N    ??HAL_SD_Get_CardInfo_1
   1564            {
   1565              pCardInfo->SD_csd.DeviceSize = (tmp & 0x03) << 10;
   \                     ??HAL_SD_Get_CardInfo_0: (+1)
   \   00000084   0xF00E 0x0203      AND      R2,LR,#0x3
   \   00000088   0x0292             LSLS     R2,R2,#+10
   \   0000008A   0x610A             STR      R2,[R1, #+16]
   1566              
   1567              /* Byte 7 */
   1568              tmp = (uint8_t)(hsd->CSD[1] & 0x000000FF);
   1569              pCardInfo->SD_csd.DeviceSize |= (tmp) << 2;
   \   0000008C   0x690A             LDR      R2,[R1, #+16]
   \   0000008E   0xF890 0x302C      LDRB     R3,[R0, #+44]
   \   00000092   0xEA42 0x0283      ORR      R2,R2,R3, LSL #+2
   \   00000096   0x610A             STR      R2,[R1, #+16]
   1570              
   1571              /* Byte 8 */
   1572              tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000) >> 24);
   \   00000098   0x6B02             LDR      R2,[R0, #+48]
   \   0000009A   0x0E12             LSRS     R2,R2,#+24
   1573              pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0) >> 6;
   \   0000009C   0x690B             LDR      R3,[R1, #+16]
   \   0000009E   0xF3C2 0x1481      UBFX     R4,R2,#+6,#+2
   \   000000A2   0x4323             ORRS     R3,R4,R3
   \   000000A4   0x610B             STR      R3,[R1, #+16]
   1574              
   1575              pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38) >> 3;
   \   000000A6   0xF3C2 0x03C2      UBFX     R3,R2,#+3,#+3
   \   000000AA   0x750B             STRB     R3,[R1, #+20]
   1576              pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07);
   \   000000AC   0xF002 0x0207      AND      R2,R2,#0x7
   \   000000B0   0x754A             STRB     R2,[R1, #+21]
   1577              
   1578              /* Byte 9 */
   1579              tmp = (uint8_t)((hsd->CSD[2] & 0x00FF0000) >> 16);
   \   000000B2   0x6B02             LDR      R2,[R0, #+48]
   \   000000B4   0x0C12             LSRS     R2,R2,#+16
   \   000000B6   0xB2D2             UXTB     R2,R2
   1580              pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0) >> 5;
   \   000000B8   0xF3C2 0x1342      UBFX     R3,R2,#+5,#+3
   \   000000BC   0x758B             STRB     R3,[R1, #+22]
   1581              pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1C) >> 2;
   \   000000BE   0xF3C2 0x0382      UBFX     R3,R2,#+2,#+3
   \   000000C2   0x75CB             STRB     R3,[R1, #+23]
   1582              pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03) << 1;
   \   000000C4   0xF002 0x0203      AND      R2,R2,#0x3
   \   000000C8   0x0052             LSLS     R2,R2,#+1
   \   000000CA   0x760A             STRB     R2,[R1, #+24]
   1583              /* Byte 10 */
   1584              tmp = (uint8_t)((hsd->CSD[2] & 0x0000FF00) >> 8);
   \   000000CC   0x6B02             LDR      R2,[R0, #+48]
   \   000000CE   0xEA4F 0x2E12      LSR      LR,R2,#+8
   \   000000D2   0xFA5F 0xFE8E      UXTB     LR,LR
   1585              pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80) >> 7;
   \   000000D6   0x7E0A             LDRB     R2,[R1, #+24]
   \   000000D8   0xF3CE 0x13C0      UBFX     R3,LR,#+7,#+1
   \   000000DC   0x431A             ORRS     R2,R3,R2
   \   000000DE   0x760A             STRB     R2,[R1, #+24]
   1586              
   1587              pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1) ;
   \   000000E0   0x690A             LDR      R2,[R1, #+16]
   \   000000E2   0x1C56             ADDS     R6,R2,#+1
   \   000000E4   0x4667             MOV      R7,R12
   \   000000E6   0xE9C1 0x6712      STRD     R6,R7,[R1, #+72]
   1588              pCardInfo->CardCapacity *= (1 << (pCardInfo->SD_csd.DeviceSizeMul + 2));
   \   000000EA   0xF04F 0x0801      MOV      R8,#+1
   \   000000EE   0x7E0A             LDRB     R2,[R1, #+24]
   \   000000F0   0x1C92             ADDS     R2,R2,#+2
   \   000000F2   0xFA08 0xF202      LSL      R2,R8,R2
   \   000000F6   0x17D3             ASRS     R3,R2,#+31
   \   000000F8   0xFBA2 0x4506      UMULL    R4,R5,R2,R6
   \   000000FC   0xFB03 0x5506      MLA      R5,R3,R6,R5
   \   00000100   0xE9C1 0x4512      STRD     R4,R5,[R1, #+72]
   1589              pCardInfo->CardBlockSize = 1 << (pCardInfo->SD_csd.RdBlockLen);
   \   00000104   0xF991 0x2008      LDRSB    R2,[R1, #+8]
   \   00000108   0xFA08 0xF202      LSL      R2,R8,R2
   \   0000010C   0x650A             STR      R2,[R1, #+80]
   1590              pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
   \   0000010E   0xE9D1 0x4512      LDRD     R4,R5,[R1, #+72]
   \   00000112   0xFBA2 0x6704      UMULL    R6,R7,R2,R4
   \   00000116   0xFB02 0x7705      MLA      R7,R2,R5,R7
   \   0000011A   0xE9C1 0x6712      STRD     R6,R7,[R1, #+72]
   \   0000011E   0xE029             B.N      ??HAL_SD_Get_CardInfo_2
   1591            }
   1592            else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   \                     ??HAL_SD_Get_CardInfo_1: (+1)
   \   00000120   0x2A02             CMP      R2,#+2
   \   00000122   0xD125             BNE.N    ??HAL_SD_Get_CardInfo_3
   1593            {
   1594              /* Byte 7 */
   1595              tmp = (uint8_t)(hsd->CSD[1] & 0x000000FF);
   1596              pCardInfo->SD_csd.DeviceSize = (tmp & 0x3F) << 16;
   \   00000124   0xF890 0x202C      LDRB     R2,[R0, #+44]
   \   00000128   0xF002 0x023F      AND      R2,R2,#0x3F
   \   0000012C   0x0412             LSLS     R2,R2,#+16
   \   0000012E   0x610A             STR      R2,[R1, #+16]
   1597              
   1598              /* Byte 8 */
   1599              tmp = (uint8_t)((hsd->CSD[2] & 0xFF000000) >> 24);
   1600              
   1601              pCardInfo->SD_csd.DeviceSize |= (tmp << 8);
   \   00000130   0x690A             LDR      R2,[R1, #+16]
   \   00000132   0x6B03             LDR      R3,[R0, #+48]
   \   00000134   0x0E1B             LSRS     R3,R3,#+24
   \   00000136   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000013A   0x610A             STR      R2,[R1, #+16]
   1602              
   1603              /* Byte 9 */
   1604              tmp = (uint8_t)((hsd->CSD[2] & 0x00FF0000) >> 16);
   1605              
   1606              pCardInfo->SD_csd.DeviceSize |= (tmp);
   \   0000013C   0x690A             LDR      R2,[R1, #+16]
   \   0000013E   0x6B03             LDR      R3,[R0, #+48]
   \   00000140   0x0C1B             LSRS     R3,R3,#+16
   \   00000142   0xB2DB             UXTB     R3,R3
   \   00000144   0x431A             ORRS     R2,R3,R2
   \   00000146   0x610A             STR      R2,[R1, #+16]
   1607              
   1608              /* Byte 10 */
   1609              tmp = (uint8_t)((hsd->CSD[2] & 0x0000FF00) >> 8);
   \   00000148   0x6B02             LDR      R2,[R0, #+48]
   \   0000014A   0xEA4F 0x2E12      LSR      LR,R2,#+8
   \   0000014E   0xFA5F 0xFE8E      UXTB     LR,LR
   1610              
   1611              pCardInfo->CardCapacity = (uint64_t)(((uint64_t)pCardInfo->SD_csd.DeviceSize + 1) * 512 * 1024);
   \   00000152   0x690A             LDR      R2,[R1, #+16]
   \   00000154   0x4663             MOV      R3,R12
   \   00000156   0x1C52             ADDS     R2,R2,#+1
   \   00000158   0xF143 0x0300      ADC      R3,R3,#+0
   \   0000015C   0x04DB             LSLS     R3,R3,#+19
   \   0000015E   0xEA43 0x3352      ORR      R3,R3,R2, LSR #+13
   \   00000162   0x04D2             LSLS     R2,R2,#+19
   \   00000164   0xE9C1 0x2312      STRD     R2,R3,[R1, #+72]
   1612              pCardInfo->CardBlockSize = 512;    
   \   00000168   0xF44F 0x7200      MOV      R2,#+512
   \   0000016C   0x650A             STR      R2,[R1, #+80]
   \   0000016E   0xE001             B.N      ??HAL_SD_Get_CardInfo_2
   1613            }
   1614            else
   1615            {
   1616              /* Not supported card type */
   1617              errorstate = SD_ERROR;
   \                     ??HAL_SD_Get_CardInfo_3: (+1)
   \   00000170   0xF04F 0x0C29      MOV      R12,#+41
   1618            }
   1619              
   1620            pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40) >> 6;
   \                     ??HAL_SD_Get_CardInfo_2: (+1)
   \   00000174   0xF3CE 0x1280      UBFX     R2,LR,#+6,#+1
   \   00000178   0x764A             STRB     R2,[R1, #+25]
   1621            pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3F) << 1;
   \   0000017A   0xF00E 0x023F      AND      R2,LR,#0x3F
   \   0000017E   0x0052             LSLS     R2,R2,#+1
   \   00000180   0x768A             STRB     R2,[R1, #+26]
   1622            
   1623            /* Byte 11 */
   1624            tmp = (uint8_t)(hsd->CSD[2] & 0x000000FF);
   \   00000182   0xF890 0x2030      LDRB     R2,[R0, #+48]
   1625            pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80) >> 7;
   \   00000186   0x7E8B             LDRB     R3,[R1, #+26]
   \   00000188   0xF3C2 0x14C0      UBFX     R4,R2,#+7,#+1
   \   0000018C   0x4323             ORRS     R3,R4,R3
   \   0000018E   0x768B             STRB     R3,[R1, #+26]
   1626            pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7F);
   \   00000190   0xF002 0x027F      AND      R2,R2,#0x7F
   \   00000194   0x76CA             STRB     R2,[R1, #+27]
   1627            
   1628            /* Byte 12 */
   1629            tmp = (uint8_t)((hsd->CSD[3] & 0xFF000000) >> 24);
   \   00000196   0x6B42             LDR      R2,[R0, #+52]
   \   00000198   0x0E12             LSRS     R2,R2,#+24
   1630            pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80) >> 7;
   \   0000019A   0xF3C2 0x13C0      UBFX     R3,R2,#+7,#+1
   \   0000019E   0x770B             STRB     R3,[R1, #+28]
   1631            pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60) >> 5;
   \   000001A0   0xF3C2 0x1341      UBFX     R3,R2,#+5,#+2
   \   000001A4   0x774B             STRB     R3,[R1, #+29]
   1632            pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1C) >> 2;
   \   000001A6   0xF3C2 0x0382      UBFX     R3,R2,#+2,#+3
   \   000001AA   0x778B             STRB     R3,[R1, #+30]
   1633            pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03) << 2;
   \   000001AC   0xF002 0x0203      AND      R2,R2,#0x3
   \   000001B0   0x0092             LSLS     R2,R2,#+2
   \   000001B2   0x77CA             STRB     R2,[R1, #+31]
   1634            
   1635            /* Byte 13 */
   1636            tmp = (uint8_t)((hsd->CSD[3] & 0x00FF0000) >> 16);
   \   000001B4   0x6B42             LDR      R2,[R0, #+52]
   \   000001B6   0x0C12             LSRS     R2,R2,#+16
   \   000001B8   0xB2D2             UXTB     R2,R2
   1637            pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0) >> 6;
   \   000001BA   0x7FCB             LDRB     R3,[R1, #+31]
   \   000001BC   0xF3C2 0x1481      UBFX     R4,R2,#+6,#+2
   \   000001C0   0x4323             ORRS     R3,R4,R3
   \   000001C2   0x77CB             STRB     R3,[R1, #+31]
   1638            pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20) >> 5;
   \   000001C4   0xF3C2 0x1340      UBFX     R3,R2,#+5,#+1
   \   000001C8   0xF881 0x3020      STRB     R3,[R1, #+32]
   1639            pCardInfo->SD_csd.Reserved3           = 0;
   \   000001CC   0x2300             MOVS     R3,#+0
   \   000001CE   0xF881 0x3021      STRB     R3,[R1, #+33]
   1640            pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01);
   \   000001D2   0xF002 0x0201      AND      R2,R2,#0x1
   \   000001D6   0xF881 0x2022      STRB     R2,[R1, #+34]
   1641            
   1642            /* Byte 14 */
   1643            tmp = (uint8_t)((hsd->CSD[3] & 0x0000FF00) >> 8);
   \   000001DA   0x6B42             LDR      R2,[R0, #+52]
   \   000001DC   0x0A12             LSRS     R2,R2,#+8
   \   000001DE   0xB2D2             UXTB     R2,R2
   1644            pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80) >> 7;
   \   000001E0   0xF3C2 0x13C0      UBFX     R3,R2,#+7,#+1
   \   000001E4   0xF881 0x3023      STRB     R3,[R1, #+35]
   1645            pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40) >> 6;
   \   000001E8   0xF3C2 0x1380      UBFX     R3,R2,#+6,#+1
   \   000001EC   0xF881 0x3024      STRB     R3,[R1, #+36]
   1646            pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20) >> 5;
   \   000001F0   0xF3C2 0x1340      UBFX     R3,R2,#+5,#+1
   \   000001F4   0xF881 0x3025      STRB     R3,[R1, #+37]
   1647            pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10) >> 4;
   \   000001F8   0xF3C2 0x1300      UBFX     R3,R2,#+4,#+1
   \   000001FC   0xF881 0x3026      STRB     R3,[R1, #+38]
   1648            pCardInfo->SD_csd.FileFormat       = (tmp & 0x0C) >> 2;
   \   00000200   0xF3C2 0x0381      UBFX     R3,R2,#+2,#+2
   \   00000204   0xF881 0x3027      STRB     R3,[R1, #+39]
   1649            pCardInfo->SD_csd.ECC              = (tmp & 0x03);
   \   00000208   0xF002 0x0203      AND      R2,R2,#0x3
   \   0000020C   0xF881 0x2028      STRB     R2,[R1, #+40]
   1650            
   1651            /* Byte 15 */
   1652            tmp = (uint8_t)(hsd->CSD[3] & 0x000000FF);
   1653            pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFE) >> 1;
   \   00000210   0xF890 0x2034      LDRB     R2,[R0, #+52]
   \   00000214   0x0852             LSRS     R2,R2,#+1
   \   00000216   0xF881 0x2029      STRB     R2,[R1, #+41]
   1654            pCardInfo->SD_csd.Reserved4 = 1;
   \   0000021A   0x2201             MOVS     R2,#+1
   \   0000021C   0xF881 0x202A      STRB     R2,[R1, #+42]
   1655            
   1656            /* Byte 0 */
   1657            tmp = (uint8_t)((hsd->CID[0] & 0xFF000000) >> 24);
   1658            pCardInfo->SD_cid.ManufacturerID = tmp;
   \   00000220   0x6B82             LDR      R2,[R0, #+56]
   \   00000222   0x0E12             LSRS     R2,R2,#+24
   \   00000224   0xF881 0x202C      STRB     R2,[R1, #+44]
   1659            
   1660            /* Byte 1 */
   1661            tmp = (uint8_t)((hsd->CID[0] & 0x00FF0000) >> 16);
   1662            pCardInfo->SD_cid.OEM_AppliID = tmp << 8;
   \   00000228   0x6B82             LDR      R2,[R0, #+56]
   \   0000022A   0x0C12             LSRS     R2,R2,#+16
   \   0000022C   0xB2D2             UXTB     R2,R2
   \   0000022E   0x0212             LSLS     R2,R2,#+8
   \   00000230   0x85CA             STRH     R2,[R1, #+46]
   1663            
   1664            /* Byte 2 */
   1665            tmp = (uint8_t)((hsd->CID[0] & 0x000000FF00) >> 8);
   1666            pCardInfo->SD_cid.OEM_AppliID |= tmp;
   \   00000232   0x8DCA             LDRH     R2,[R1, #+46]
   \   00000234   0x6B83             LDR      R3,[R0, #+56]
   \   00000236   0x0A1B             LSRS     R3,R3,#+8
   \   00000238   0xB2DB             UXTB     R3,R3
   \   0000023A   0x431A             ORRS     R2,R3,R2
   \   0000023C   0x85CA             STRH     R2,[R1, #+46]
   1667            
   1668            /* Byte 3 */
   1669            tmp = (uint8_t)(hsd->CID[0] & 0x000000FF);
   1670            pCardInfo->SD_cid.ProdName1 = tmp << 24;
   \   0000023E   0xF890 0x2038      LDRB     R2,[R0, #+56]
   \   00000242   0x0612             LSLS     R2,R2,#+24
   \   00000244   0x630A             STR      R2,[R1, #+48]
   1671            
   1672            /* Byte 4 */
   1673            tmp = (uint8_t)((hsd->CID[1] & 0xFF000000) >> 24);
   1674            pCardInfo->SD_cid.ProdName1 |= tmp << 16;
   \   00000246   0x6B0A             LDR      R2,[R1, #+48]
   \   00000248   0x6BC3             LDR      R3,[R0, #+60]
   \   0000024A   0x0E1B             LSRS     R3,R3,#+24
   \   0000024C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000250   0x630A             STR      R2,[R1, #+48]
   1675            
   1676            /* Byte 5 */
   1677            tmp = (uint8_t)((hsd->CID[1] & 0x00FF0000) >> 16);
   1678            pCardInfo->SD_cid.ProdName1 |= tmp << 8;
   \   00000252   0x6B0A             LDR      R2,[R1, #+48]
   \   00000254   0x6BC3             LDR      R3,[R0, #+60]
   \   00000256   0x0C1B             LSRS     R3,R3,#+16
   \   00000258   0xB2DB             UXTB     R3,R3
   \   0000025A   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000025E   0x630A             STR      R2,[R1, #+48]
   1679            
   1680            /* Byte 6 */
   1681            tmp = (uint8_t)((hsd->CID[1] & 0x0000FF00) >> 8);
   1682            pCardInfo->SD_cid.ProdName1 |= tmp;
   \   00000260   0x6B0A             LDR      R2,[R1, #+48]
   \   00000262   0x6BC3             LDR      R3,[R0, #+60]
   \   00000264   0x0A1B             LSRS     R3,R3,#+8
   \   00000266   0xB2DB             UXTB     R3,R3
   \   00000268   0x431A             ORRS     R2,R3,R2
   \   0000026A   0x630A             STR      R2,[R1, #+48]
   1683            
   1684            /* Byte 7 */
   1685            tmp = (uint8_t)(hsd->CID[1] & 0x000000FF);
   1686            pCardInfo->SD_cid.ProdName2 = tmp;
   \   0000026C   0x6BC2             LDR      R2,[R0, #+60]
   \   0000026E   0xF881 0x2034      STRB     R2,[R1, #+52]
   1687            
   1688            /* Byte 8 */
   1689            tmp = (uint8_t)((hsd->CID[2] & 0xFF000000) >> 24);
   1690            pCardInfo->SD_cid.ProdRev = tmp;
   \   00000272   0x6C02             LDR      R2,[R0, #+64]
   \   00000274   0x0E12             LSRS     R2,R2,#+24
   \   00000276   0xF881 0x2035      STRB     R2,[R1, #+53]
   1691            
   1692            /* Byte 9 */
   1693            tmp = (uint8_t)((hsd->CID[2] & 0x00FF0000) >> 16);
   1694            pCardInfo->SD_cid.ProdSN = tmp << 24;
   \   0000027A   0x6C02             LDR      R2,[R0, #+64]
   \   0000027C   0x0C12             LSRS     R2,R2,#+16
   \   0000027E   0xB2D2             UXTB     R2,R2
   \   00000280   0x0612             LSLS     R2,R2,#+24
   \   00000282   0x638A             STR      R2,[R1, #+56]
   1695            
   1696            /* Byte 10 */
   1697            tmp = (uint8_t)((hsd->CID[2] & 0x0000FF00) >> 8);
   1698            pCardInfo->SD_cid.ProdSN |= tmp << 16;
   \   00000284   0x6B8A             LDR      R2,[R1, #+56]
   \   00000286   0x6C03             LDR      R3,[R0, #+64]
   \   00000288   0x0A1B             LSRS     R3,R3,#+8
   \   0000028A   0xB2DB             UXTB     R3,R3
   \   0000028C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000290   0x638A             STR      R2,[R1, #+56]
   1699            
   1700            /* Byte 11 */
   1701            tmp = (uint8_t)(hsd->CID[2] & 0x000000FF);
   1702            pCardInfo->SD_cid.ProdSN |= tmp << 8;
   \   00000292   0x6B8A             LDR      R2,[R1, #+56]
   \   00000294   0xF890 0x3040      LDRB     R3,[R0, #+64]
   \   00000298   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000029C   0x638A             STR      R2,[R1, #+56]
   1703            
   1704            /* Byte 12 */
   1705            tmp = (uint8_t)((hsd->CID[3] & 0xFF000000) >> 24);
   1706            pCardInfo->SD_cid.ProdSN |= tmp;
   \   0000029E   0x6B8A             LDR      R2,[R1, #+56]
   \   000002A0   0x6C43             LDR      R3,[R0, #+68]
   \   000002A2   0xEA52 0x6213      ORRS     R2,R2,R3, LSR #+24
   \   000002A6   0x638A             STR      R2,[R1, #+56]
   1707            
   1708            /* Byte 13 */
   1709            tmp = (uint8_t)((hsd->CID[3] & 0x00FF0000) >> 16);
   \   000002A8   0x6C42             LDR      R2,[R0, #+68]
   \   000002AA   0x0C12             LSRS     R2,R2,#+16
   \   000002AC   0xB2D2             UXTB     R2,R2
   1710            pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0) >> 4;
   \   000002AE   0xF891 0x303C      LDRB     R3,[R1, #+60]
   \   000002B2   0xF3C2 0x1403      UBFX     R4,R2,#+4,#+4
   \   000002B6   0x4323             ORRS     R3,R4,R3
   \   000002B8   0xF881 0x303C      STRB     R3,[R1, #+60]
   1711            pCardInfo->SD_cid.ManufactDate = (tmp & 0x0F) << 8;
   \   000002BC   0xF002 0x020F      AND      R2,R2,#0xF
   \   000002C0   0x0212             LSLS     R2,R2,#+8
   \   000002C2   0x87CA             STRH     R2,[R1, #+62]
   1712            
   1713            /* Byte 14 */
   1714            tmp = (uint8_t)((hsd->CID[3] & 0x0000FF00) >> 8);
   1715            pCardInfo->SD_cid.ManufactDate |= tmp;
   \   000002C4   0x8FCA             LDRH     R2,[R1, #+62]
   \   000002C6   0x6C43             LDR      R3,[R0, #+68]
   \   000002C8   0x0A1B             LSRS     R3,R3,#+8
   \   000002CA   0xB2DB             UXTB     R3,R3
   \   000002CC   0x431A             ORRS     R2,R3,R2
   \   000002CE   0x87CA             STRH     R2,[R1, #+62]
   1716            
   1717            /* Byte 15 */
   1718            tmp = (uint8_t)(hsd->CID[3] & 0x000000FF);
   1719            pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFE) >> 1;
   \   000002D0   0xF890 0x0044      LDRB     R0,[R0, #+68]
   \   000002D4   0x0840             LSRS     R0,R0,#+1
   \   000002D6   0xF881 0x0040      STRB     R0,[R1, #+64]
   1720            pCardInfo->SD_cid.Reserved2 = 1;
   \   000002DA   0x2001             MOVS     R0,#+1
   \   000002DC   0xF881 0x0041      STRB     R0,[R1, #+65]
   1721            
   1722            return errorstate;
   \   000002E0   0x4660             MOV      R0,R12
   \   000002E2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1723          }
   1724          
   1725          /**
   1726            * @brief  Enables wide bus operation for the requested card if supported by 
   1727            *         card.
   1728            * @param  hsd: SD handle       
   1729            * @param  WideMode: Specifies the SD card wide bus mode 
   1730            *          This parameter can be one of the following values:
   1731            *            @arg SDIO_BUS_WIDE_8B: 8-bit data transfer (Only for MMC)
   1732            *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
   1733            *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
   1734            * @retval SD Card error state
   1735            */

   \                                 In section .text, align 2, keep-with-next
   1736          HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
   1737          {
   \                     HAL_SD_WideBusOperation_Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   1738            HAL_SD_ErrorTypedef errorstate = SD_OK;
   1739            SDIO_InitTypeDef init = {0};
   \   00000008   0xA803             ADD      R0,SP,#+12
   \   0000000A   0x2118             MOVS     R1,#+24
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   1740            
   1741            /* MMC Card does not support this feature */
   1742            if (hsd->CardType == MULTIMEDIA_CARD)
   \   00000010   0x6A28             LDR      R0,[R5, #+32]
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xD101             BNE.N    ??HAL_SD_WideBusOperation_Config_0
   1743            {
   1744              errorstate = SD_UNSUPPORTED_FEATURE;
   \   00000016   0x2427             MOVS     R4,#+39
   \   00000018   0xE033             B.N      ??HAL_SD_WideBusOperation_Config_1
   1745            }
   1746            else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
   1747              (hsd->CardType == HIGH_CAPACITY_SD_CARD))
   \                     ??HAL_SD_WideBusOperation_Config_0: (+1)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??HAL_SD_WideBusOperation_Config_2
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD001             BEQ.N    ??HAL_SD_WideBusOperation_Config_2
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD12C             BNE.N    ??HAL_SD_WideBusOperation_Config_3
   1748            {
   1749              if (WideMode == SDIO_BUS_WIDE_8B)
   \                     ??HAL_SD_WideBusOperation_Config_2: (+1)
   \   00000026   0xF5B6 0x5F80      CMP      R6,#+4096
   \   0000002A   0xD101             BNE.N    ??HAL_SD_WideBusOperation_Config_4
   1750              {
   1751                errorstate = SD_UNSUPPORTED_FEATURE;
   \   0000002C   0x2427             MOVS     R4,#+39
   \   0000002E   0xE00F             B.N      ??HAL_SD_WideBusOperation_Config_5
   1752              }
   1753              else if (WideMode == SDIO_BUS_WIDE_4B)
   \                     ??HAL_SD_WideBusOperation_Config_4: (+1)
   \   00000030   0xF5B6 0x6F00      CMP      R6,#+2048
   \   00000034   0xD104             BNE.N    ??HAL_SD_WideBusOperation_Config_6
   1754              {
   1755                errorstate = SD_WideBus_Enable(hsd);
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       SD_WideBus_Enable
   \   0000003C   0x4604             MOV      R4,R0
   \   0000003E   0xE007             B.N      ??HAL_SD_WideBusOperation_Config_5
   1756              }
   1757              else if (WideMode == SDIO_BUS_WIDE_1B)
   \                     ??HAL_SD_WideBusOperation_Config_6: (+1)
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD104             BNE.N    ??HAL_SD_WideBusOperation_Config_7
   1758              {
   1759                errorstate = SD_WideBus_Disable(hsd);
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       SD_WideBus_Disable
   \   0000004A   0x4604             MOV      R4,R0
   \   0000004C   0xE000             B.N      ??HAL_SD_WideBusOperation_Config_5
   1760              }
   1761              else
   1762              {
   1763                /* WideMode is not a valid argument*/
   1764                errorstate = SD_INVALID_PARAMETER;
   \                     ??HAL_SD_WideBusOperation_Config_7: (+1)
   \   0000004E   0x2426             MOVS     R4,#+38
   1765              }
   1766                
   1767              if (errorstate == SD_OK)
   \                     ??HAL_SD_WideBusOperation_Config_5: (+1)
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD116             BNE.N    ??HAL_SD_WideBusOperation_Config_1
   1768              {
   1769                /* Configure the SDIO peripheral */
   1770                init.ClockEdge           = hsd->Init.ClockEdge;
   \   00000054   0x6868             LDR      R0,[R5, #+4]
   \   00000056   0x9003             STR      R0,[SP, #+12]
   1771                init.ClockBypass         = hsd->Init.ClockBypass;
   \   00000058   0x68A8             LDR      R0,[R5, #+8]
   \   0000005A   0x9004             STR      R0,[SP, #+16]
   1772                init.ClockPowerSave      = hsd->Init.ClockPowerSave;
   \   0000005C   0x68E8             LDR      R0,[R5, #+12]
   \   0000005E   0x9005             STR      R0,[SP, #+20]
   1773                init.BusWide             = WideMode;
   \   00000060   0x9606             STR      R6,[SP, #+24]
   1774                init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   \   00000062   0x6968             LDR      R0,[R5, #+20]
   \   00000064   0x9007             STR      R0,[SP, #+28]
   1775                init.ClockDiv            = hsd->Init.ClockDiv;
   \   00000066   0x69A8             LDR      R0,[R5, #+24]
   \   00000068   0x9008             STR      R0,[SP, #+32]
   1776                
   1777                /* Configure SDIO peripheral interface */
   1778                SDIO_Init(hsd->Instance, init);
   \   0000006A   0xA903             ADD      R1,SP,#+12
   \   0000006C   0xB083             SUB      SP,SP,#+12
   \   0000006E   0x4668             MOV      R0,SP
   \   00000070   0x2218             MOVS     R2,#+24
   \   00000072   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000076   0xBC0E             POP      {R1-R3}
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0x.... 0x....      BL       SDIO_Init
   \   0000007E   0xE000             B.N      ??HAL_SD_WideBusOperation_Config_1
   1779              }
   1780              else
   1781              {
   1782                /* An error occured while enabling/disabling the wide bus*/
   1783              }
   1784            }
   1785            else
   1786            {
   1787              /* Not supported card type */
   1788              errorstate = SD_ERROR;
   \                     ??HAL_SD_WideBusOperation_Config_3: (+1)
   \   00000080   0x2429             MOVS     R4,#+41
   1789            }
   1790            
   1791            return errorstate;
   \                     ??HAL_SD_WideBusOperation_Config_1: (+1)
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0xB00A             ADD      SP,SP,#+40
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
   1792          }
   1793          
   1794          /**
   1795            * @brief  Aborts an ongoing data transfer.
   1796            * @param  hsd: SD handle
   1797            * @retval SD Card error state
   1798            */

   \                                 In section .text, align 2, keep-with-next
   1799          HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
   1800          {
   \                     HAL_SD_StopTransfer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4604             MOV      R4,R0
   1801            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   1802            HAL_SD_ErrorTypedef errorstate = SD_OK;
   1803            
   1804            /* Send CMD12 STOP_TRANSMISSION  */
   1805            sdio_cmdinitstructure.Argument         = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
   1806            sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
   \   00000012   0x200C             MOVS     R0,#+12
   \   00000014   0x9001             STR      R0,[SP, #+4]
   1807            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x9002             STR      R0,[SP, #+8]
   1808            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   1809            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0x9004             STR      R0,[SP, #+16]
   1810            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       SDIO_SendCommand
   1811            
   1812            /* Check for error conditions */
   1813            errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
   1814            
   1815            return errorstate;
   \   0000002C   0x210C             MOVS     R1,#+12
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000034   0xB006             ADD      SP,SP,#+24
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1816          }
   1817          
   1818          /**
   1819            * @brief  Switches the SD card to High Speed mode.
   1820            *         This API must be used after "Transfer State"
   1821            * @note   This operation should be followed by the configuration 
   1822            *         of PLL to have SDIOCK clock between 67 and 75 MHz
   1823            * @param  hsd: SD handle
   1824            * @retval SD Card error state
   1825            */

   \                                 In section .text, align 2, keep-with-next
   1826          HAL_SD_ErrorTypedef HAL_SD_HighSpeed (SD_HandleTypeDef *hsd)
   1827          {
   \                     HAL_SD_HighSpeed: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB09E             SUB      SP,SP,#+120
   \   00000006   0x4604             MOV      R4,R0
   1828            HAL_SD_ErrorTypedef errorstate = SD_OK;
   1829            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   1830            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000010   0xA807             ADD      R0,SP,#+28
   \   00000012   0x2118             MOVS     R1,#+24
   \   00000014   0x.... 0x....      BL       __aeabi_memclr4
   1831            
   1832            uint8_t SD_hs[64]  = {0};
   \   00000018   0xA80D             ADD      R0,SP,#+52
   \   0000001A   0x2140             MOVS     R1,#+64
   \   0000001C   0x.... 0x....      BL       __aeabi_memclr4
   1833            uint32_t SD_scr[2] = {0, 0};
   \   00000020   0xA805             ADD      R0,SP,#+20
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x460A             MOV      R2,R1
   \   00000026   0xC006             STM      R0!,{R1,R2}
   1834            uint32_t SD_SPEC   = 0 ;
   1835            uint32_t count = 0, *tempbuff = (uint32_t *)SD_hs;
   \   00000028   0xAD0D             ADD      R5,SP,#+52
   1836            
   1837            /* Initialize the Data control register */
   1838            hsd->Instance->DCTRL = 0;
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x62C8             STR      R0,[R1, #+44]
   1839            
   1840            /* Get SCR Register */
   1841            errorstate = SD_FindSCR(hsd, SD_scr);
   \   00000030   0xA905             ADD      R1,SP,#+20
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       SD_FindSCR
   \   00000038   0x0007             MOVS     R7,R0
   1842            
   1843            if (errorstate != SD_OK)
   \   0000003A   0xF040 0x8086      BNE.W    ??HAL_SD_HighSpeed_0
   1844            {
   1845              return errorstate;
   1846            }
   1847            
   1848            /* Test the Version supported by the card*/ 
   1849            SD_SPEC = (SD_scr[1]  & 0x01000000) | (SD_scr[1]  & 0x02000000);
   1850            
   1851            if (SD_SPEC != SD_ALLZERO)
   \   0000003E   0x9806             LDR      R0,[SP, #+24]
   \   00000040   0xF010 0x7F40      TST      R0,#0x3000000
   \   00000044   0xF000 0x8081      BEQ.W    ??HAL_SD_HighSpeed_0
   1852            {
   1853              /* Set Block Size for Card */
   1854              sdio_cmdinitstructure.Argument         = (uint32_t)64;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   1855              sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   0000004C   0x2010             MOVS     R0,#+16
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   1856              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000050   0x2040             MOVS     R0,#+64
   \   00000052   0x9002             STR      R0,[SP, #+8]
   1857              sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9003             STR      R0,[SP, #+12]
   1858              sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000058   0xF44F 0x6080      MOV      R0,#+1024
   \   0000005C   0x9004             STR      R0,[SP, #+16]
   1859              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000005E   0xA900             ADD      R1,SP,#+0
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x.... 0x....      BL       SDIO_SendCommand
   1860              
   1861              /* Check for error conditions */
   1862              errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   00000066   0x2110             MOVS     R1,#+16
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       SD_CmdResp1Error
   \   0000006E   0x0007             MOVS     R7,R0
   1863              
   1864              if (errorstate != SD_OK)
   \   00000070   0xD16B             BNE.N    ??HAL_SD_HighSpeed_0
   1865              {
   1866                return errorstate;
   1867              }
   1868              
   1869              /* Configure the SD DPSM (Data Path State Machine) */
   1870              sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   00000072   0xF04F 0x36FF      MOV      R6,#-1
   \   00000076   0x9607             STR      R6,[SP, #+28]
   1871              sdio_datainitstructure.DataLength    = 64;
   \   00000078   0x2040             MOVS     R0,#+64
   \   0000007A   0x9008             STR      R0,[SP, #+32]
   1872              sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B ;
   \   0000007C   0x2060             MOVS     R0,#+96
   \   0000007E   0x9009             STR      R0,[SP, #+36]
   1873              sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x900A             STR      R0,[SP, #+40]
   1874              sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x900B             STR      R0,[SP, #+44]
   1875              sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x900C             STR      R0,[SP, #+48]
   1876              SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   0000008C   0xA907             ADD      R1,SP,#+28
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       SDIO_DataConfig
   1877              
   1878              /* Send CMD6 switch mode */
   1879              sdio_cmdinitstructure.Argument         = 0x80FFFF01;
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x80ffff01
   \   00000098   0x9000             STR      R0,[SP, #+0]
   1880              sdio_cmdinitstructure.CmdIndex         = SD_CMD_HS_SWITCH;
   \   0000009A   0x2006             MOVS     R0,#+6
   \   0000009C   0x9001             STR      R0,[SP, #+4]
   1881              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure); 
   \   0000009E   0xA900             ADD      R1,SP,#+0
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x.... 0x....      BL       SDIO_SendCommand
   1882              
   1883              /* Check for error conditions */
   1884              errorstate = SD_CmdResp1Error(hsd, SD_CMD_HS_SWITCH);
   \   000000A6   0x2106             MOVS     R1,#+6
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000AE   0x0007             MOVS     R7,R0
   1885              
   1886              if (errorstate != SD_OK)
   \   000000B0   0xD14B             BNE.N    ??HAL_SD_HighSpeed_0
   \   000000B2   0xE00A             B.N      ??HAL_SD_HighSpeed_1
   1887              {
   1888                return errorstate;
   1889              }
   1890                  
   1891              while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
   1892              {
   1893                if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
   1894                {
   1895                  for (count = 0; count < 8; count++)
   1896                  {
   1897                    *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_HighSpeed_2: (+1)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x.... 0x....      BL       SDIO_ReadFIFO
   \   000000BA   0xF845 0x0028      STR      R0,[R5, R8, LSL #+2]
   1898                  }
   \   000000BE   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??HAL_SD_HighSpeed_3: (+1)
   \   000000C2   0xF1B8 0x0F08      CMP      R8,#+8
   \   000000C6   0xD3F5             BCC.N    ??HAL_SD_HighSpeed_2
   1899                  
   1900                  tempbuff += 8;
   \   000000C8   0x3520             ADDS     R5,R5,#+32
   \                     ??HAL_SD_HighSpeed_1: (+1)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6B41             LDR      R1,[R0, #+52]
   \   000000CE   0xF240 0x622A      MOVW     R2,#+1578
   \   000000D2   0x4211             TST      R1,R2
   \   000000D4   0xD105             BNE.N    ??HAL_SD_HighSpeed_4
   \   000000D6   0x6B40             LDR      R0,[R0, #+52]
   \   000000D8   0x0400             LSLS     R0,R0,#+16
   \   000000DA   0xD5F6             BPL.N    ??HAL_SD_HighSpeed_1
   \   000000DC   0xF04F 0x0800      MOV      R8,#+0
   \   000000E0   0xE7EF             B.N      ??HAL_SD_HighSpeed_3
   1901                }
   1902              }
   1903              
   1904              if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
   \                     ??HAL_SD_HighSpeed_4: (+1)
   \   000000E2   0x6B41             LDR      R1,[R0, #+52]
   \   000000E4   0x0709             LSLS     R1,R1,#+28
   \   000000E6   0xD503             BPL.N    ??HAL_SD_HighSpeed_5
   1905              {
   1906                __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
   \   000000E8   0x2108             MOVS     R1,#+8
   \   000000EA   0x6381             STR      R1,[R0, #+56]
   1907                
   1908                errorstate = SD_DATA_TIMEOUT;
   1909                
   1910                return errorstate;
   \   000000EC   0x2004             MOVS     R0,#+4
   \   000000EE   0xE02D             B.N      ??HAL_SD_HighSpeed_6
   1911              }
   1912              else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
   \                     ??HAL_SD_HighSpeed_5: (+1)
   \   000000F0   0x6B41             LDR      R1,[R0, #+52]
   \   000000F2   0x0789             LSLS     R1,R1,#+30
   \   000000F4   0xD503             BPL.N    ??HAL_SD_HighSpeed_7
   1913              {
   1914                __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
   \   000000F6   0x2102             MOVS     R1,#+2
   \   000000F8   0x6381             STR      R1,[R0, #+56]
   1915                
   1916                errorstate = SD_DATA_CRC_FAIL;
   1917                
   1918                return errorstate;
   \   000000FA   0x4608             MOV      R0,R1
   \   000000FC   0xE026             B.N      ??HAL_SD_HighSpeed_6
   1919              }
   1920              else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
   \                     ??HAL_SD_HighSpeed_7: (+1)
   \   000000FE   0x6B41             LDR      R1,[R0, #+52]
   \   00000100   0x0689             LSLS     R1,R1,#+26
   \   00000102   0xD503             BPL.N    ??HAL_SD_HighSpeed_8
   1921              {
   1922                __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
   \   00000104   0x2120             MOVS     R1,#+32
   \   00000106   0x6381             STR      R1,[R0, #+56]
   1923                
   1924                errorstate = SD_RX_OVERRUN;
   1925                
   1926                return errorstate;
   \   00000108   0x2006             MOVS     R0,#+6
   \   0000010A   0xE01F             B.N      ??HAL_SD_HighSpeed_6
   1927              }
   1928              else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
   \                     ??HAL_SD_HighSpeed_8: (+1)
   \   0000010C   0x6B41             LDR      R1,[R0, #+52]
   \   0000010E   0x0589             LSLS     R1,R1,#+22
   \   00000110   0xD504             BPL.N    ??HAL_SD_HighSpeed_9
   1929              {
   1930                __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
   \   00000112   0xF44F 0x7100      MOV      R1,#+512
   \   00000116   0x6381             STR      R1,[R0, #+56]
   1931                
   1932                errorstate = SD_START_BIT_ERR;
   1933                
   1934                return errorstate;
   \   00000118   0x2007             MOVS     R0,#+7
   \   0000011A   0xE017             B.N      ??HAL_SD_HighSpeed_6
   1935              }
   1936              else
   1937              {
   1938                /* No error flag set */
   1939              }
   1940              
   1941              count = SD_DATATIMEOUT;
   \                     ??HAL_SD_HighSpeed_9: (+1)
   \   0000011C   0x46B0             MOV      R8,R6
   \   0000011E   0xE005             B.N      ??HAL_SD_HighSpeed_10
   1942              
   1943              while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0))
   1944              {
   1945                *tempbuff = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_HighSpeed_11: (+1)
   \   00000120   0x.... 0x....      BL       SDIO_ReadFIFO
   \   00000124   0xF845 0x0B04      STR      R0,[R5], #+4
   1946                tempbuff++;
   1947                count--;
   \   00000128   0xF1A8 0x0801      SUB      R8,R8,#+1
   1948              }
   \                     ??HAL_SD_HighSpeed_10: (+1)
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0x6B41             LDR      R1,[R0, #+52]
   \   00000130   0x0289             LSLS     R1,R1,#+10
   \   00000132   0xD502             BPL.N    ??HAL_SD_HighSpeed_12
   \   00000134   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000138   0xD1F2             BNE.N    ??HAL_SD_HighSpeed_11
   1949              
   1950              /* Clear all the static flags */
   1951              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??HAL_SD_HighSpeed_12: (+1)
   \   0000013A   0xF240 0x51FF      MOVW     R1,#+1535
   \   0000013E   0x6381             STR      R1,[R0, #+56]
   1952              
   1953              /* Test if the switch mode HS is ok */
   1954              if ((SD_hs[13]& 2) != 2)
   \   00000140   0xF89D 0x0041      LDRB     R0,[SP, #+65]
   \   00000144   0x0780             LSLS     R0,R0,#+30
   \   00000146   0xD400             BMI.N    ??HAL_SD_HighSpeed_0
   1955              {
   1956                errorstate = SD_UNSUPPORTED_FEATURE;
   \   00000148   0x2727             MOVS     R7,#+39
   1957              } 
   1958            }
   1959            
   1960            return errorstate;
   \                     ??HAL_SD_HighSpeed_0: (+1)
   \   0000014A   0x4638             MOV      R0,R7
   \                     ??HAL_SD_HighSpeed_6: (+1)
   \   0000014C   0xB01E             ADD      SP,SP,#+120
   \   0000014E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1961          }
   1962          
   1963          /**
   1964            * @}
   1965            */
   1966          
   1967          /** @defgroup SD_Exported_Functions_Group4 Peripheral State functions 
   1968           *  @brief   Peripheral State functions 
   1969           *
   1970          @verbatim   
   1971            ==============================================================================
   1972                                ##### Peripheral State functions #####
   1973            ==============================================================================  
   1974            [..]
   1975              This subsection permits to get in runtime the status of the peripheral 
   1976              and the data flow.
   1977          
   1978          @endverbatim
   1979            * @{
   1980            */
   1981          
   1982          /**
   1983            * @brief  Returns the current SD card's status.
   1984            * @param  hsd: SD handle
   1985            * @param  pSDstatus: Pointer to the buffer that will contain the SD card status 
   1986            *         SD Status register)
   1987            * @retval SD Card error state
   1988            */

   \                                 In section .text, align 2, keep-with-next
   1989          HAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
   1990          {
   \                     HAL_SD_SendSDStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   1991            SDIO_CmdInitTypeDef  sdio_cmdinitstructure = {0};
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x2114             MOVS     R1,#+20
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
   1992            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000012   0xA805             ADD      R0,SP,#+20
   \   00000014   0x2118             MOVS     R1,#+24
   \   00000016   0x.... 0x....      BL       __aeabi_memclr4
   1993            HAL_SD_ErrorTypedef errorstate = SD_OK;
   1994            uint32_t count = 0;
   1995            
   1996            /* Check SD response */
   1997            if ((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       SDIO_GetResponse
   \   00000022   0x0180             LSLS     R0,R0,#+6
   \   00000024   0xD501             BPL.N    ??HAL_SD_SendSDStatus_0
   1998            {
   1999              errorstate = SD_LOCK_UNLOCK_FAILED;
   2000              
   2001              return errorstate;
   \   00000026   0x200E             MOVS     R0,#+14
   \   00000028   0xE08B             B.N      ??HAL_SD_SendSDStatus_1
   2002            }
   2003            
   2004            /* Set block size for card if it is not equal to current block size for card */
   2005            sdio_cmdinitstructure.Argument         = 64;
   \                     ??HAL_SD_SendSDStatus_0: (+1)
   \   0000002A   0x2040             MOVS     R0,#+64
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   2006            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   0000002E   0x2010             MOVS     R0,#+16
   \   00000030   0x9001             STR      R0,[SP, #+4]
   2007            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000032   0x2040             MOVS     R0,#+64
   \   00000034   0x9002             STR      R0,[SP, #+8]
   2008            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9003             STR      R0,[SP, #+12]
   2009            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   0000003A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003E   0x9004             STR      R0,[SP, #+16]
   2010            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       SDIO_SendCommand
   2011            
   2012            /* Check for error conditions */
   2013            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   00000048   0x2110             MOVS     R1,#+16
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000050   0x0007             MOVS     R7,R0
   2014            
   2015            if (errorstate != SD_OK)
   \   00000052   0xD12D             BNE.N    ??HAL_SD_SendSDStatus_2
   2016            {
   2017              return errorstate;
   2018            }
   2019            
   2020            /* Send CMD55 */
   2021            sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
   \   00000054   0x6A60             LDR      R0,[R4, #+36]
   \   00000056   0x0400             LSLS     R0,R0,#+16
   \   00000058   0x9000             STR      R0,[SP, #+0]
   2022            sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
   \   0000005A   0x2037             MOVS     R0,#+55
   \   0000005C   0x9001             STR      R0,[SP, #+4]
   2023            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000005E   0xA900             ADD      R1,SP,#+0
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x.... 0x....      BL       SDIO_SendCommand
   2024            
   2025            /* Check for error conditions */
   2026            errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
   \   00000066   0x2137             MOVS     R1,#+55
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       SD_CmdResp1Error
   \   0000006E   0x0007             MOVS     R7,R0
   2027            
   2028            if (errorstate != SD_OK)
   \   00000070   0xD11E             BNE.N    ??HAL_SD_SendSDStatus_2
   2029            {
   2030              return errorstate;
   2031            }
   2032            
   2033            /* Configure the SD DPSM (Data Path State Machine) */ 
   2034            sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   00000072   0xF04F 0x36FF      MOV      R6,#-1
   \   00000076   0x9605             STR      R6,[SP, #+20]
   2035            sdio_datainitstructure.DataLength    = 64;
   \   00000078   0x2040             MOVS     R0,#+64
   \   0000007A   0x9006             STR      R0,[SP, #+24]
   2036            sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
   \   0000007C   0x2060             MOVS     R0,#+96
   \   0000007E   0x9007             STR      R0,[SP, #+28]
   2037            sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x9008             STR      R0,[SP, #+32]
   2038            sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9009             STR      R0,[SP, #+36]
   2039            sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x900A             STR      R0,[SP, #+40]
   2040            SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   0000008C   0xA905             ADD      R1,SP,#+20
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       SDIO_DataConfig
   2041            
   2042            /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
   2043            sdio_cmdinitstructure.Argument         = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x9000             STR      R0,[SP, #+0]
   2044            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
   \   00000098   0x200D             MOVS     R0,#+13
   \   0000009A   0x9001             STR      R0,[SP, #+4]
   2045            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000009C   0xA900             ADD      R1,SP,#+0
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       SDIO_SendCommand
   2046            
   2047            /* Check for error conditions */
   2048            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_STATUS);
   \   000000A4   0x210D             MOVS     R1,#+13
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000AC   0x0007             MOVS     R7,R0
   2049            
   2050            if (errorstate != SD_OK)
   \   000000AE   0xD00C             BEQ.N    ??HAL_SD_SendSDStatus_3
   2051            {
   2052              return errorstate;
   \                     ??HAL_SD_SendSDStatus_2: (+1)
   \   000000B0   0x4638             MOV      R0,R7
   \   000000B2   0xE046             B.N      ??HAL_SD_SendSDStatus_1
   2053            }
   2054            
   2055            /* Get status data */
   2056            while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
   2057            {
   2058              if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
   2059              {
   2060                for (count = 0; count < 8; count++)
   2061                {
   2062                  *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_SendSDStatus_4: (+1)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x.... 0x....      BL       SDIO_ReadFIFO
   \   000000BA   0xF845 0x0028      STR      R0,[R5, R8, LSL #+2]
   2063                }
   \   000000BE   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??HAL_SD_SendSDStatus_5: (+1)
   \   000000C2   0xF1B8 0x0F08      CMP      R8,#+8
   \   000000C6   0xD3F5             BCC.N    ??HAL_SD_SendSDStatus_4
   2064                
   2065                pSDstatus += 8;
   \   000000C8   0x3520             ADDS     R5,R5,#+32
   \                     ??HAL_SD_SendSDStatus_3: (+1)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6B41             LDR      R1,[R0, #+52]
   \   000000CE   0xF240 0x622A      MOVW     R2,#+1578
   \   000000D2   0x4211             TST      R1,R2
   \   000000D4   0xD105             BNE.N    ??HAL_SD_SendSDStatus_6
   \   000000D6   0x6B40             LDR      R0,[R0, #+52]
   \   000000D8   0x0400             LSLS     R0,R0,#+16
   \   000000DA   0xD5F6             BPL.N    ??HAL_SD_SendSDStatus_3
   \   000000DC   0xF04F 0x0800      MOV      R8,#+0
   \   000000E0   0xE7EF             B.N      ??HAL_SD_SendSDStatus_5
   2066              }
   2067            }
   2068            
   2069            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
   \                     ??HAL_SD_SendSDStatus_6: (+1)
   \   000000E2   0x6B41             LDR      R1,[R0, #+52]
   \   000000E4   0x0709             LSLS     R1,R1,#+28
   \   000000E6   0xD503             BPL.N    ??HAL_SD_SendSDStatus_7
   2070            {
   2071              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
   \   000000E8   0x2108             MOVS     R1,#+8
   \   000000EA   0x6381             STR      R1,[R0, #+56]
   2072              
   2073              errorstate = SD_DATA_TIMEOUT;
   2074              
   2075              return errorstate;
   \   000000EC   0x2004             MOVS     R0,#+4
   \   000000EE   0xE028             B.N      ??HAL_SD_SendSDStatus_1
   2076            }
   2077            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
   \                     ??HAL_SD_SendSDStatus_7: (+1)
   \   000000F0   0x6B41             LDR      R1,[R0, #+52]
   \   000000F2   0x0789             LSLS     R1,R1,#+30
   \   000000F4   0xD503             BPL.N    ??HAL_SD_SendSDStatus_8
   2078            {
   2079              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
   \   000000F6   0x2102             MOVS     R1,#+2
   \   000000F8   0x6381             STR      R1,[R0, #+56]
   2080              
   2081              errorstate = SD_DATA_CRC_FAIL;
   2082              
   2083              return errorstate;
   \   000000FA   0x4608             MOV      R0,R1
   \   000000FC   0xE021             B.N      ??HAL_SD_SendSDStatus_1
   2084            }
   2085            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
   \                     ??HAL_SD_SendSDStatus_8: (+1)
   \   000000FE   0x6B41             LDR      R1,[R0, #+52]
   \   00000100   0x0689             LSLS     R1,R1,#+26
   \   00000102   0xD503             BPL.N    ??HAL_SD_SendSDStatus_9
   2086            {
   2087              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
   \   00000104   0x2120             MOVS     R1,#+32
   \   00000106   0x6381             STR      R1,[R0, #+56]
   2088              
   2089              errorstate = SD_RX_OVERRUN;
   2090              
   2091              return errorstate;
   \   00000108   0x2006             MOVS     R0,#+6
   \   0000010A   0xE01A             B.N      ??HAL_SD_SendSDStatus_1
   2092            }
   2093            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
   \                     ??HAL_SD_SendSDStatus_9: (+1)
   \   0000010C   0x6B41             LDR      R1,[R0, #+52]
   \   0000010E   0x0589             LSLS     R1,R1,#+22
   \   00000110   0xD504             BPL.N    ??HAL_SD_SendSDStatus_10
   2094            {
   2095              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
   \   00000112   0xF44F 0x7100      MOV      R1,#+512
   \   00000116   0x6381             STR      R1,[R0, #+56]
   2096              
   2097              errorstate = SD_START_BIT_ERR;
   2098              
   2099              return errorstate;
   \   00000118   0x2007             MOVS     R0,#+7
   \   0000011A   0xE012             B.N      ??HAL_SD_SendSDStatus_1
   2100            }
   2101            else
   2102            {
   2103              /* No error flag set */
   2104            }
   2105            
   2106            count = SD_DATATIMEOUT;
   \                     ??HAL_SD_SendSDStatus_10: (+1)
   \   0000011C   0x46B0             MOV      R8,R6
   \   0000011E   0xE005             B.N      ??HAL_SD_SendSDStatus_11
   2107            while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0))
   2108            {
   2109              *pSDstatus = SDIO_ReadFIFO(hsd->Instance);
   \                     ??HAL_SD_SendSDStatus_12: (+1)
   \   00000120   0x.... 0x....      BL       SDIO_ReadFIFO
   \   00000124   0xF845 0x0B04      STR      R0,[R5], #+4
   2110              pSDstatus++;
   2111              count--;
   \   00000128   0xF1A8 0x0801      SUB      R8,R8,#+1
   2112            }
   \                     ??HAL_SD_SendSDStatus_11: (+1)
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0x6B41             LDR      R1,[R0, #+52]
   \   00000130   0x0289             LSLS     R1,R1,#+10
   \   00000132   0xD502             BPL.N    ??HAL_SD_SendSDStatus_13
   \   00000134   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000138   0xD1F2             BNE.N    ??HAL_SD_SendSDStatus_12
   2113            
   2114            /* Clear all the static status flags*/
   2115            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??HAL_SD_SendSDStatus_13: (+1)
   \   0000013A   0xF240 0x51FF      MOVW     R1,#+1535
   \   0000013E   0x6381             STR      R1,[R0, #+56]
   2116            
   2117            return errorstate;
   \   00000140   0x4638             MOV      R0,R7
   \                     ??HAL_SD_SendSDStatus_1: (+1)
   \   00000142   0xB00C             ADD      SP,SP,#+48
   \   00000144   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2118          }
   2119          
   2120          /**
   2121            * @brief  Gets the current sd card data status.
   2122            * @param  hsd: SD handle
   2123            * @retval Data Transfer state
   2124            */

   \                                 In section .text, align 2, keep-with-next
   2125          HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
   2126          {
   \                     HAL_SD_GetStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2127            HAL_SD_CardStateTypedef cardstate =  SD_CARD_TRANSFER;
   2128          
   2129            /* Get SD card state */
   2130            cardstate = SD_GetState(hsd);
   \   00000002   0x.... 0x....      BL       SD_GetState
   2131            
   2132            /* Find SD status according to card state*/
   2133            if (cardstate == SD_CARD_TRANSFER)
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xD101             BNE.N    ??HAL_SD_GetStatus_0
   2134            {
   2135              return SD_TRANSFER_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}
   2136            }
   2137            else if(cardstate == SD_CARD_ERROR)
   \                     ??HAL_SD_GetStatus_0: (+1)
   \   0000000E   0x28FF             CMP      R0,#+255
   \   00000010   0xD101             BNE.N    ??HAL_SD_GetStatus_1
   2138            {
   2139              return SD_TRANSFER_ERROR;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBD02             POP      {R1,PC}
   2140            }
   2141            else
   2142            {
   2143              return SD_TRANSFER_BUSY;
   \                     ??HAL_SD_GetStatus_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
   2144            }
   2145          }
   2146          
   2147          /**
   2148            * @brief  Gets the SD card status.
   2149            * @param  hsd: SD handle      
   2150            * @param  pCardStatus: Pointer to the HAL_SD_CardStatusTypedef structure that 
   2151            *         will contain the SD card status information 
   2152            * @retval SD Card error state
   2153            */

   \                                 In section .text, align 2, keep-with-next
   2154          HAL_SD_ErrorTypedef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypedef *pCardStatus)
   2155          {
   \                     HAL_SD_GetCardStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   \   00000004   0x460C             MOV      R4,R1
   2156            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2157            uint32_t tmp = 0;
   2158            uint32_t sd_status[16];
   2159            
   2160            errorstate = HAL_SD_SendSDStatus(hsd, sd_status);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x.... 0x....      BL       HAL_SD_SendSDStatus
   2161            
   2162            if (errorstate  != SD_OK)
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD133             BNE.N    ??HAL_SD_GetCardStatus_0
   2163            {
   2164              return errorstate;
   2165            }
   2166            
   2167            /* Byte 0 */
   2168            tmp = (sd_status[0] & 0xC0) >> 6;
   2169            pCardStatus->DAT_BUS_WIDTH = (uint8_t)tmp;
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0xF3C0 0x1081      UBFX     R0,R0,#+6,#+2
   \   00000016   0x7020             STRB     R0,[R4, #+0]
   2170            
   2171            /* Byte 0 */
   2172            tmp = (sd_status[0] & 0x20) >> 5;
   2173            pCardStatus->SECURED_MODE = (uint8_t)tmp;
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   0000001E   0x7060             STRB     R0,[R4, #+1]
   2174            
   2175            /* Byte 2 */
   2176            tmp = (sd_status[2] & 0xFF);
   2177            pCardStatus->SD_CARD_TYPE = (uint8_t)(tmp << 8);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8060             STRH     R0,[R4, #+2]
   2178            
   2179            /* Byte 3 */
   2180            tmp = (sd_status[3] & 0xFF);
   2181            pCardStatus->SD_CARD_TYPE |= (uint8_t)tmp;
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x8861             LDRH     R1,[R4, #+2]
   \   00000028   0x68C2             LDR      R2,[R0, #+12]
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x4311             ORRS     R1,R2,R1
   \   0000002E   0x8061             STRH     R1,[R4, #+2]
   2182            
   2183            /* Byte 4 */
   2184            tmp = (sd_status[4] & 0xFF);
   2185            pCardStatus->SIZE_OF_PROTECTED_AREA = (uint8_t)(tmp << 24);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6061             STR      R1,[R4, #+4]
   2186            
   2187            /* Byte 5 */
   2188            tmp = (sd_status[5] & 0xFF);
   2189            pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 16);
   \   00000034   0x6861             LDR      R1,[R4, #+4]
   \   00000036   0x6061             STR      R1,[R4, #+4]
   2190            
   2191            /* Byte 6 */
   2192            tmp = (sd_status[6] & 0xFF);
   2193            pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 8);
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0x6061             STR      R1,[R4, #+4]
   2194            
   2195            /* Byte 7 */
   2196            tmp = (sd_status[7] & 0xFF);
   2197            pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)tmp;
   \   0000003C   0x6861             LDR      R1,[R4, #+4]
   \   0000003E   0xAA07             ADD      R2,SP,#+28
   \   00000040   0x7812             LDRB     R2,[R2, #+0]
   \   00000042   0x4311             ORRS     R1,R2,R1
   \   00000044   0x6061             STR      R1,[R4, #+4]
   2198            
   2199            /* Byte 8 */
   2200            tmp = (sd_status[8] & 0xFF);
   2201            pCardStatus->SPEED_CLASS = (uint8_t)tmp;
   \   00000046   0x9908             LDR      R1,[SP, #+32]
   \   00000048   0x7221             STRB     R1,[R4, #+8]
   2202            
   2203            /* Byte 9 */
   2204            tmp = (sd_status[9] & 0xFF);
   2205            pCardStatus->PERFORMANCE_MOVE = (uint8_t)tmp;
   \   0000004A   0x9909             LDR      R1,[SP, #+36]
   \   0000004C   0x7261             STRB     R1,[R4, #+9]
   2206            
   2207            /* Byte 10 */
   2208            tmp = (sd_status[10] & 0xF0) >> 4;
   2209            pCardStatus->AU_SIZE = (uint8_t)tmp;
   \   0000004E   0x990A             LDR      R1,[SP, #+40]
   \   00000050   0xF3C1 0x1103      UBFX     R1,R1,#+4,#+4
   \   00000054   0x72A1             STRB     R1,[R4, #+10]
   2210            
   2211            /* Byte 11 */
   2212            tmp = (sd_status[11] & 0xFF);
   2213            pCardStatus->ERASE_SIZE = (uint8_t)(tmp << 8);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x81A1             STRH     R1,[R4, #+12]
   2214            
   2215            /* Byte 12 */
   2216            tmp = (sd_status[12] & 0xFF);
   2217            pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
   \   0000005A   0x89A1             LDRH     R1,[R4, #+12]
   \   0000005C   0x9A0C             LDR      R2,[SP, #+48]
   \   0000005E   0xB2D2             UXTB     R2,R2
   \   00000060   0x4311             ORRS     R1,R2,R1
   \   00000062   0x81A1             STRH     R1,[R4, #+12]
   2218            
   2219            /* Byte 13 */
   2220            tmp = (sd_status[13] & 0xFC) >> 2;
   2221            pCardStatus->ERASE_TIMEOUT = (uint8_t)tmp;
   \   00000064   0x6B41             LDR      R1,[R0, #+52]
   \   00000066   0xF3C1 0x0185      UBFX     R1,R1,#+2,#+6
   \   0000006A   0x73A1             STRB     R1,[R4, #+14]
   2222            
   2223            /* Byte 13 */
   2224            tmp = (sd_status[13] & 0x3);
   2225            pCardStatus->ERASE_OFFSET = (uint8_t)tmp;
   \   0000006C   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000070   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000074   0x73E0             STRB     R0,[R4, #+15]
   2226            
   2227            return errorstate;
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??HAL_SD_GetCardStatus_0: (+1)
   \   00000078   0xB010             ADD      SP,SP,#+64
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return
   2228          }
   2229                   
   2230          /**
   2231            * @}
   2232            */
   2233            
   2234          /**
   2235            * @}
   2236            */
   2237            
   2238          /** @addtogroup SD_Private_Functions
   2239            * @{
   2240            */
   2241          
   2242          /**
   2243            * @brief  SD DMA transfer complete Rx callback.
   2244            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2245            *                the configuration information for the specified DMA module.
   2246            * @retval None
   2247            */

   \                                 In section .text, align 4, keep-with-next
   2248          static void SD_DMA_RxCplt(DMA_HandleTypeDef *hdma)
   2249          {
   \                     SD_DMA_RxCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2250            SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   2251            
   2252            /* DMA transfer is complete */
   2253            hsd->DmaTransferCplt = 1;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x6501             STR      R1,[R0, #+80]
   2254            
   2255            /* Wait until SD transfer is complete */
   2256            while(hsd->SdTransferCplt == 0)
   \                     ??SD_DMA_RxCplt_0: (+1)
   \   00000008   0x6C81             LDR      R1,[R0, #+72]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD0FC             BEQ.N    ??SD_DMA_RxCplt_0
   2257            {
   2258            }
   2259          
   2260            /* Transfer complete user callback */
   2261            HAL_SD_DMA_RxCpltCallback(hsd->hdmarx);   
   \   0000000E   0x6D80             LDR      R0,[R0, #+88]
   \   00000010   0x.... 0x....      BL       HAL_SD_DMA_RxCpltCallback
   2262          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   2263          
   2264          /**
   2265            * @brief  SD DMA transfer Error Rx callback.
   2266            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2267            *                the configuration information for the specified DMA module.
   2268            * @retval None
   2269            */

   \                                 In section .text, align 4, keep-with-next
   2270          static void SD_DMA_RxError(DMA_HandleTypeDef *hdma)
   2271          {
   \                     SD_DMA_RxError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2272            SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   2273            
   2274            /* Transfer complete user callback */
   2275            HAL_SD_DMA_RxErrorCallback(hsd->hdmarx);
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   \   00000004   0x6D80             LDR      R0,[R0, #+88]
   \   00000006   0x.... 0x....      BL       HAL_SD_DMA_RxErrorCallback
   2276          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   2277          
   2278          /**
   2279            * @brief  SD DMA transfer complete Tx callback.
   2280            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2281            *                the configuration information for the specified DMA module.
   2282            * @retval None
   2283            */

   \                                 In section .text, align 4, keep-with-next
   2284          static void SD_DMA_TxCplt(DMA_HandleTypeDef *hdma)
   2285          {
   \                     SD_DMA_TxCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2286            SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   2287            
   2288            /* DMA transfer is complete */
   2289            hsd->DmaTransferCplt = 1;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x6501             STR      R1,[R0, #+80]
   2290            
   2291            /* Wait until SD transfer is complete */
   2292           	while(hsd->SdTransferCplt == 0)
   \                     ??SD_DMA_TxCplt_0: (+1)
   \   00000008   0x6C81             LDR      R1,[R0, #+72]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD0FC             BEQ.N    ??SD_DMA_TxCplt_0
   2293            {
   2294            }
   2295          
   2296            /* Transfer complete user callback */
   2297            HAL_SD_DMA_TxCpltCallback(hsd->hdmatx);  
   \   0000000E   0x6DC0             LDR      R0,[R0, #+92]
   \   00000010   0x.... 0x....      BL       HAL_SD_DMA_TxCpltCallback
   2298          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   2299          
   2300          /**
   2301            * @brief  SD DMA transfer Error Tx callback.
   2302            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2303            *                the configuration information for the specified DMA module.
   2304            * @retval None
   2305            */

   \                                 In section .text, align 4, keep-with-next
   2306          static void SD_DMA_TxError(DMA_HandleTypeDef *hdma)
   2307          {
   \                     SD_DMA_TxError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2308            SD_HandleTypeDef *hsd = ( SD_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2309            
   2310            /* Transfer complete user callback */
   2311            HAL_SD_DMA_TxErrorCallback(hsd->hdmatx);
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   \   00000004   0x6DC0             LDR      R0,[R0, #+92]
   \   00000006   0x.... 0x....      BL       HAL_SD_DMA_TxErrorCallback
   2312          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   2313          
   2314          /**
   2315            * @brief  Returns the SD current state.
   2316            * @param  hsd: SD handle
   2317            * @retval SD card current state
   2318            */

   \                                 In section .text, align 2, keep-with-next
   2319          static HAL_SD_CardStateTypedef SD_GetState(SD_HandleTypeDef *hsd)
   2320          {
   \                     SD_GetState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2321            uint32_t resp1 = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
   2322            
   2323            if (SD_SendStatus(hsd, &resp1) != SD_OK)
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x.... 0x....      BL       SD_SendStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??SD_GetState_0
   2324            {
   2325              return SD_CARD_ERROR;
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0xBD02             POP      {R1,PC}
   2326            }
   2327            else
   2328            {
   2329              return (HAL_SD_CardStateTypedef)((resp1 >> 9) & 0x0F);
   \                     ??SD_GetState_0: (+1)
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x0A40             LSRS     R0,R0,#+9
   \   00000018   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   2330            }
   2331          }
   2332          
   2333          /**
   2334            * @brief  Initializes all cards or single card as the case may be Card(s) come 
   2335            *         into standby state.
   2336            * @param  hsd: SD handle
   2337            * @retval SD Card error state
   2338            */

   \                                 In section .text, align 2, keep-with-next
   2339          static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
   2340          {
   \                     SD_Initialize_Cards: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   2341            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0}; 
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   2342            HAL_SD_ErrorTypedef errorstate = SD_OK;
   \   0000000E   0x2500             MOVS     R5,#+0
   2343            uint16_t sd_rca = 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2344            
   2345            if(SDIO_GetPowerState(hsd->Instance) == 0) /* Power off */
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       SDIO_GetPowerState
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE.N    ??SD_Initialize_Cards_0
   2346            {
   2347              errorstate = SD_REQUEST_NOT_APPLICABLE;
   2348              
   2349              return errorstate;
   \   00000020   0x2025             MOVS     R0,#+37
   \   00000022   0xE06C             B.N      ??SD_Initialize_Cards_1
   2350            }
   2351            
   2352            if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
   \                     ??SD_Initialize_Cards_0: (+1)
   \   00000024   0x6A20             LDR      R0,[R4, #+32]
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD027             BEQ.N    ??SD_Initialize_Cards_2
   2353            {
   2354              /* Send CMD2 ALL_SEND_CID */
   2355              sdio_cmdinitstructure.Argument         = 0;
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   2356              sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x9002             STR      R0,[SP, #+8]
   2357              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
   \   00000032   0x20C0             MOVS     R0,#+192
   \   00000034   0x9003             STR      R0,[SP, #+12]
   2358              sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x9004             STR      R0,[SP, #+16]
   2359              sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   0000003A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003E   0x9005             STR      R0,[SP, #+20]
   2360              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       SDIO_SendCommand
   2361              
   2362              /* Check for error conditions */
   2363              errorstate = SD_CmdResp2Error(hsd);
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       SD_CmdResp2Error
   \   0000004E   0x0005             MOVS     R5,R0
   2364              
   2365              if(errorstate != SD_OK)
   \   00000050   0xD154             BNE.N    ??SD_Initialize_Cards_3
   2366              {
   2367                return errorstate;
   2368              }
   2369              
   2370              /* Get Card identification number data */
   2371              hsd->CID[0] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       SDIO_GetResponse
   \   0000005A   0x63A0             STR      R0,[R4, #+56]
   2372              hsd->CID[1] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
   \   0000005C   0x2104             MOVS     R1,#+4
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x.... 0x....      BL       SDIO_GetResponse
   \   00000064   0x63E0             STR      R0,[R4, #+60]
   2373              hsd->CID[2] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       SDIO_GetResponse
   \   0000006E   0x6420             STR      R0,[R4, #+64]
   2374              hsd->CID[3] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
   \   00000070   0x210C             MOVS     R1,#+12
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x.... 0x....      BL       SDIO_GetResponse
   \   00000078   0x6460             STR      R0,[R4, #+68]
   2375            }
   2376            
   2377            if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
   2378               (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
   \                     ??SD_Initialize_Cards_2: (+1)
   \   0000007A   0x6A20             LDR      R0,[R4, #+32]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD005             BEQ.N    ??SD_Initialize_Cards_4
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD003             BEQ.N    ??SD_Initialize_Cards_4
   \   00000084   0x2806             CMP      R0,#+6
   \   00000086   0xD001             BEQ.N    ??SD_Initialize_Cards_4
   \   00000088   0x2802             CMP      R0,#+2
   \   0000008A   0xD10E             BNE.N    ??SD_Initialize_Cards_5
   2379            {
   2380              /* Send CMD3 SET_REL_ADDR with argument 0 */
   2381              /* SD Card publishes its RCA. */
   2382              sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
   \                     ??SD_Initialize_Cards_4: (+1)
   \   0000008C   0x2003             MOVS     R0,#+3
   \   0000008E   0x9002             STR      R0,[SP, #+8]
   2383              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000090   0x2040             MOVS     R0,#+64
   \   00000092   0x9003             STR      R0,[SP, #+12]
   2384              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x.... 0x....      BL       SDIO_SendCommand
   2385              
   2386              /* Check for error conditions */
   2387              errorstate = SD_CmdResp6Error(hsd, SD_CMD_SET_REL_ADDR, &sd_rca);
   \   0000009C   0xAA00             ADD      R2,SP,#+0
   \   0000009E   0x2103             MOVS     R1,#+3
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       SD_CmdResp6Error
   \   000000A6   0x0005             MOVS     R5,R0
   2388              
   2389              if(errorstate != SD_OK)
   \   000000A8   0xD128             BNE.N    ??SD_Initialize_Cards_3
   2390              {
   2391                return errorstate;
   2392              }
   2393            }
   2394            
   2395            if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
   \                     ??SD_Initialize_Cards_5: (+1)
   \   000000AA   0x6A20             LDR      R0,[R4, #+32]
   \   000000AC   0x2804             CMP      R0,#+4
   \   000000AE   0xD025             BEQ.N    ??SD_Initialize_Cards_3
   2396            {
   2397              /* Get the SD card RCA */
   2398              hsd->RCA = sd_rca;
   \   000000B0   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B4   0x6260             STR      R0,[R4, #+36]
   2399              
   2400              /* Send CMD9 SEND_CSD with argument as card's RCA */
   2401              sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
   \   000000B6   0x0400             LSLS     R0,R0,#+16
   \   000000B8   0x9001             STR      R0,[SP, #+4]
   2402              sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
   \   000000BA   0x2009             MOVS     R0,#+9
   \   000000BC   0x9002             STR      R0,[SP, #+8]
   2403              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
   \   000000BE   0x20C0             MOVS     R0,#+192
   \   000000C0   0x9003             STR      R0,[SP, #+12]
   2404              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000C2   0xA901             ADD      R1,SP,#+4
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x.... 0x....      BL       SDIO_SendCommand
   2405              
   2406              /* Check for error conditions */
   2407              errorstate = SD_CmdResp2Error(hsd);
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       SD_CmdResp2Error
   \   000000D0   0x0005             MOVS     R5,R0
   2408              
   2409              if(errorstate != SD_OK)
   \   000000D2   0xD113             BNE.N    ??SD_Initialize_Cards_3
   2410              {
   2411                return errorstate;
   2412              }
   2413              
   2414              /* Get Card Specific Data */
   2415              hsd->CSD[0] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x.... 0x....      BL       SDIO_GetResponse
   \   000000DC   0x62A0             STR      R0,[R4, #+40]
   2416              hsd->CSD[1] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
   \   000000DE   0x2104             MOVS     R1,#+4
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x.... 0x....      BL       SDIO_GetResponse
   \   000000E6   0x62E0             STR      R0,[R4, #+44]
   2417              hsd->CSD[2] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
   \   000000E8   0x2108             MOVS     R1,#+8
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x.... 0x....      BL       SDIO_GetResponse
   \   000000F0   0x6320             STR      R0,[R4, #+48]
   2418              hsd->CSD[3] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
   \   000000F2   0x210C             MOVS     R1,#+12
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x.... 0x....      BL       SDIO_GetResponse
   \   000000FA   0x6360             STR      R0,[R4, #+52]
   2419            }
   2420            
   2421            /* All cards are initialized */
   2422            return errorstate;
   \                     ??SD_Initialize_Cards_3: (+1)
   \   000000FC   0x4628             MOV      R0,R5
   \                     ??SD_Initialize_Cards_1: (+1)
   \   000000FE   0xB007             ADD      SP,SP,#+28
   \   00000100   0xBD30             POP      {R4,R5,PC}       ;; return
   2423          }
   2424          
   2425          /**
   2426            * @brief  Selects od Deselects the corresponding card.
   2427            * @param  hsd: SD handle
   2428            * @param  Addr: Address of the card to be selected  
   2429            * @retval SD Card error state
   2430            */

   \                                 In section .text, align 2, keep-with-next
   2431          static HAL_SD_ErrorTypedef SD_Select_Deselect(SD_HandleTypeDef *hsd, uint64_t Addr)
   2432          {
   \                     SD_Select_Deselect: (+1)
   \   00000000   0xB550             PUSH     {R4,R6,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x4614             MOV      R4,R2
   2433            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   2434            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2435            
   2436            /* Send CMD7 SDIO_SEL_DESEL_CARD */
   2437            sdio_cmdinitstructure.Argument         = (uint32_t)Addr;
   \   00000010   0x9400             STR      R4,[SP, #+0]
   2438            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
   \   00000012   0x2007             MOVS     R0,#+7
   \   00000014   0x9001             STR      R0,[SP, #+4]
   2439            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x9002             STR      R0,[SP, #+8]
   2440            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   2441            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0x9004             STR      R0,[SP, #+16]
   2442            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x6830             LDR      R0,[R6, #+0]
   \   00000028   0x.... 0x....      BL       SDIO_SendCommand
   2443            
   2444            /* Check for error conditions */
   2445            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
   2446            
   2447            return errorstate;
   \   0000002C   0x2107             MOVS     R1,#+7
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000034   0xB007             ADD      SP,SP,#+28
   \   00000036   0xBD50             POP      {R4,R6,PC}       ;; return
   2448          }
   2449          
   2450          /**
   2451            * @brief  Enquires cards about their operating voltage and configures clock
   2452            *         controls and stores SD information that will be needed in future
   2453            *         in the SD handle.
   2454            * @param  hsd: SD handle
   2455            * @retval SD Card error state
   2456            */

   \                                 In section .text, align 2, keep-with-next
   2457          static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
   2458          {
   \                     SD_PowerON: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   2459            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0}; 
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   2460            __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2461            uint32_t response = 0, count = 0, validvoltage = 0;
   \   00000016   0x4680             MOV      R8,R0
   \   00000018   0x4605             MOV      R5,R0
   \   0000001A   0x4681             MOV      R9,R0
   2462            uint32_t sdtype = SD_STD_CAPACITY;
   \   0000001C   0x4606             MOV      R6,R0
   2463            
   2464            /* Power ON Sequence -------------------------------------------------------*/
   2465            /* Disable SDIO Clock */
   2466            __HAL_SD_SDIO_DISABLE(hsd); 
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6841             LDR      R1,[R0, #+4]
   \   00000022   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000026   0x6041             STR      R1,[R0, #+4]
   2467            
   2468            /* Set Power State to ON */
   2469            SDIO_PowerState_ON(hsd->Instance);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       SDIO_PowerState_ON
   2470            
   2471            /* 1ms: required power up waiting time before starting the SD initialization 
   2472               sequence */
   2473            HAL_Delay(1);
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       HAL_Delay
   2474            
   2475            /* Enable SDIO Clock */
   2476            __HAL_SD_SDIO_ENABLE(hsd);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6841             LDR      R1,[R0, #+4]
   \   00000038   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000003C   0x6041             STR      R1,[R0, #+4]
   2477            
   2478            /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
   2479            /* No CMD response required */
   2480            sdio_cmdinitstructure.Argument         = 0;
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x9001             STR      R0,[SP, #+4]
   2481            sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
   \   00000042   0x9002             STR      R0,[SP, #+8]
   2482            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
   \   00000044   0x9003             STR      R0,[SP, #+12]
   2483            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000046   0x9004             STR      R0,[SP, #+16]
   2484            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000048   0xF44F 0x6780      MOV      R7,#+1024
   \   0000004C   0x9705             STR      R7,[SP, #+20]
   2485            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000004E   0xA901             ADD      R1,SP,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       SDIO_SendCommand
   2486            
   2487            /* Check for error conditions */
   2488            errorstate = SD_CmdError(hsd);
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       SD_CmdError
   \   0000005C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2489            
   2490            if(errorstate != SD_OK)
   \   00000060   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??SD_PowerON_0
   2491            {
   2492              /* CMD Response TimeOut (wait for CMDSENT flag) */
   2493              return errorstate;
   \   00000068   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000006C   0xE07D             B.N      ??SD_PowerON_1
   2494            }
   2495            
   2496            /* CMD8: SEND_IF_COND ------------------------------------------------------*/
   2497            /* Send CMD8 to verify SD card interface operating condition */
   2498            /* Argument: - [31:12]: Reserved (shall be set to '0')
   2499            - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
   2500            - [7:0]: Check Pattern (recommended 0xAA) */
   2501            /* CMD Response: R7 */
   2502            sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
   \                     ??SD_PowerON_0: (+1)
   \   0000006E   0xF44F 0x70D5      MOV      R0,#+426
   \   00000072   0x9001             STR      R0,[SP, #+4]
   2503            sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
   \   00000074   0x2008             MOVS     R0,#+8
   \   00000076   0x9002             STR      R0,[SP, #+8]
   2504            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000078   0x2040             MOVS     R0,#+64
   \   0000007A   0x9003             STR      R0,[SP, #+12]
   2505            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000007C   0xA901             ADD      R1,SP,#+4
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x.... 0x....      BL       SDIO_SendCommand
   2506            
   2507            /* Check for error conditions */ 
   2508            errorstate = SD_CmdResp7Error(hsd);
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       SD_CmdResp7Error
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2509            
   2510            if (errorstate == SD_OK)
   \   0000008E   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD103             BNE.N    ??SD_PowerON_2
   2511            {
   2512              /* SD Card 2.0 */
   2513              hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x6220             STR      R0,[R4, #+32]
   2514              sdtype        = SD_HIGH_CAPACITY;
   \   0000009A   0xF04F 0x4680      MOV      R6,#+1073741824
   2515            }
   2516            
   2517            /* Send CMD55 */
   2518            sdio_cmdinitstructure.Argument         = 0;
   \                     ??SD_PowerON_2: (+1)
   \   0000009E   0x4628             MOV      R0,R5
   \   000000A0   0x9001             STR      R0,[SP, #+4]
   2519            sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
   \   000000A2   0x2037             MOVS     R0,#+55
   \   000000A4   0x9002             STR      R0,[SP, #+8]
   2520            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   000000A6   0xA901             ADD      R1,SP,#+4
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x.... 0x....      BL       SDIO_SendCommand
   2521            
   2522            /* Check for error conditions */
   2523            errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
   \   000000AE   0x2137             MOVS     R1,#+55
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000B6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2524            
   2525            /* If errorstate is Command TimeOut, it is a MMC card */
   2526            /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
   2527               or SD card 1.x */
   2528            if(errorstate == SD_OK)
   \   000000BA   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD151             BNE.N    ??SD_PowerON_3
   \   000000C2   0xE007             B.N      ??SD_PowerON_4
   2529            {
   2530              /* SD CARD */
   2531              /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
   2532              while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
   2533              {
   2534                
   2535                /* SEND CMD55 APP_CMD with RCA as 0 */
   2536                sdio_cmdinitstructure.Argument         = 0;
   2537                sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
   2538                sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   2539                sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   2540                sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   2541                SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   2542                
   2543                /* Check for error conditions */
   2544                errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
   2545                
   2546                if(errorstate != SD_OK)
   2547                {
   2548                  return errorstate;
   2549                }
   2550                
   2551                /* Send CMD41 */
   2552                sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
   2553                sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
   2554                sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   2555                sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   2556                sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   2557                SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   2558                
   2559                /* Check for error conditions */
   2560                errorstate = SD_CmdResp3Error(hsd);
   2561                
   2562                if(errorstate != SD_OK)
   2563                {
   2564                  return errorstate;
   2565                }
   2566                
   2567                /* Get command response */
   2568                response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \                     ??SD_PowerON_5: (+1)
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x.... 0x....      BL       SDIO_GetResponse
   \   000000CC   0x4680             MOV      R8,R0
   2569                
   2570                /* Get operating voltage*/
   2571                validvoltage = (((response >> 31) == 1) ? 1 : 0);
   \   000000CE   0xEA4F 0x79D8      LSR      R9,R8,#+31
   2572                
   2573                count++;
   \   000000D2   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SD_PowerON_4: (+1)
   \   000000D4   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000D8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000DC   0xD136             BNE.N    ??SD_PowerON_6
   \   000000DE   0x4285             CMP      R5,R0
   \   000000E0   0xD234             BCS.N    ??SD_PowerON_6
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x9001             STR      R0,[SP, #+4]
   \   000000E6   0x2037             MOVS     R0,#+55
   \   000000E8   0x9002             STR      R0,[SP, #+8]
   \   000000EA   0x2040             MOVS     R0,#+64
   \   000000EC   0x9003             STR      R0,[SP, #+12]
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9004             STR      R0,[SP, #+16]
   \   000000F2   0x9705             STR      R7,[SP, #+20]
   \   000000F4   0xA901             ADD      R1,SP,#+4
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       SDIO_SendCommand
   \   000000FC   0x2137             MOVS     R1,#+55
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000104   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000108   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000010C   0x2800             CMP      R0,#+0
   \   0000010E   0xD002             BEQ.N    ??SD_PowerON_7
   \   00000110   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   00000114   0xE029             B.N      ??SD_PowerON_1
   \                     ??SD_PowerON_7: (+1)
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable35_1  ;; 0x80100000
   \   0000011A   0x4330             ORRS     R0,R0,R6
   \   0000011C   0x9001             STR      R0,[SP, #+4]
   \   0000011E   0x2029             MOVS     R0,#+41
   \   00000120   0x9002             STR      R0,[SP, #+8]
   \   00000122   0x2040             MOVS     R0,#+64
   \   00000124   0x9003             STR      R0,[SP, #+12]
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x9004             STR      R0,[SP, #+16]
   \   0000012A   0x9705             STR      R7,[SP, #+20]
   \   0000012C   0xA901             ADD      R1,SP,#+4
   \   0000012E   0x6820             LDR      R0,[R4, #+0]
   \   00000130   0x.... 0x....      BL       SDIO_SendCommand
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       SD_CmdResp3Error
   \   0000013A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000013E   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD0BE             BEQ.N    ??SD_PowerON_5
   \   00000146   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000014A   0xE00E             B.N      ??SD_PowerON_1
   2574              }
   2575              
   2576              if(count >= SD_MAX_VOLT_TRIAL)
   \                     ??SD_PowerON_6: (+1)
   \   0000014C   0x4285             CMP      R5,R0
   \   0000014E   0xD305             BCC.N    ??SD_PowerON_8
   2577              {
   2578                errorstate = SD_INVALID_VOLTRANGE;
   \   00000150   0x201B             MOVS     R0,#+27
   \   00000152   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2579                
   2580                return errorstate;
   \   00000156   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000015A   0xE006             B.N      ??SD_PowerON_1
   2581              }
   2582              
   2583              if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
   \                     ??SD_PowerON_8: (+1)
   \   0000015C   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   00000160   0xD501             BPL.N    ??SD_PowerON_3
   2584              {
   2585                hsd->CardType = HIGH_CAPACITY_SD_CARD;
   \   00000162   0x2002             MOVS     R0,#+2
   \   00000164   0x6220             STR      R0,[R4, #+32]
   2586              }
   2587              
   2588            } /* else MMC Card */
   2589            
   2590            return errorstate;
   \                     ??SD_PowerON_3: (+1)
   \   00000166   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \                     ??SD_PowerON_1: (+1)
   \   0000016A   0xB007             ADD      SP,SP,#+28
   \   0000016C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2591          }
   2592          
   2593          /**
   2594            * @brief  Turns the SDIO output signals off.
   2595            * @param  hsd: SD handle
   2596            * @retval SD Card error state
   2597            */

   \                                 In section .text, align 2, keep-with-next
   2598          static HAL_SD_ErrorTypedef SD_PowerOFF(SD_HandleTypeDef *hsd)
   2599          {
   \                     SD_PowerOFF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2600            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2601            
   2602            /* Set Power State to OFF */
   2603            SDIO_PowerState_OFF(hsd->Instance);
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x.... 0x....      BL       SDIO_PowerState_OFF
   2604            
   2605            return errorstate;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
   2606          }
   2607          
   2608          /**
   2609            * @brief  Returns the current card's status.
   2610            * @param  hsd: SD handle
   2611            * @param  pCardStatus: pointer to the buffer that will contain the SD card 
   2612            *         status (Card Status register)  
   2613            * @retval SD Card error state
   2614            */

   \                                 In section .text, align 2, keep-with-next
   2615          static HAL_SD_ErrorTypedef SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
   2616          {
   \                     SD_SendStatus: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   2617            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   2618            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2619            
   2620            if(pCardStatus == NULL)
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD101             BNE.N    ??SD_SendStatus_0
   2621            {
   2622              errorstate = SD_INVALID_PARAMETER;
   2623              
   2624              return errorstate;
   \   00000014   0x2026             MOVS     R0,#+38
   \   00000016   0xE01B             B.N      ??SD_SendStatus_1
   2625            }
   2626            
   2627            /* Send Status command */
   2628            sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
   \                     ??SD_SendStatus_0: (+1)
   \   00000018   0x6A60             LDR      R0,[R4, #+36]
   \   0000001A   0x0400             LSLS     R0,R0,#+16
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   2629            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
   \   0000001E   0x200D             MOVS     R0,#+13
   \   00000020   0x9001             STR      R0,[SP, #+4]
   2630            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0x9002             STR      R0,[SP, #+8]
   2631            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9003             STR      R0,[SP, #+12]
   2632            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   0000002A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000002E   0x9004             STR      R0,[SP, #+16]
   2633            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       SDIO_SendCommand
   2634            
   2635            /* Check for error conditions */
   2636            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
   \   00000038   0x210D             MOVS     R1,#+13
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       SD_CmdResp1Error
   2637            
   2638            if(errorstate != SD_OK)
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD105             BNE.N    ??SD_SendStatus_1
   2639            {
   2640              return errorstate;
   2641            }
   2642            
   2643            /* Get SD card status */
   2644            *pCardStatus = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       SDIO_GetResponse
   \   0000004C   0x6028             STR      R0,[R5, #+0]
   2645            
   2646            return errorstate;
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??SD_SendStatus_1: (+1)
   \   00000050   0xB005             ADD      SP,SP,#+20
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
   2647          }
   2648          
   2649          /**
   2650            * @brief  Checks for error conditions for CMD0.
   2651            * @param  hsd: SD handle
   2652            * @retval SD Card error state
   2653            */

   \                                 In section .text, align 2, keep-with-next
   2654          static HAL_SD_ErrorTypedef SD_CmdError(SD_HandleTypeDef *hsd)
   2655          {
   2656            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2657            uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
   \                     SD_CmdError: (+1)
   \   00000000   0xF44F 0x3180      MOV      R1,#+65536
   2658            
   2659            tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x6B52             LDR      R2,[R2, #+52]
   \   00000008   0x09D2             LSRS     R2,R2,#+7
   \   0000000A   0xF002 0x0201      AND      R2,R2,#0x1
   \   0000000E   0xE005             B.N      ??SD_CmdError_0
   2660              
   2661            while((timeout > 0) && (!tmp))
   2662            {
   2663              tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
   \                     ??SD_CmdError_1: (+1)
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x6B52             LDR      R2,[R2, #+52]
   \   00000014   0x09D2             LSRS     R2,R2,#+7
   \   00000016   0xF002 0x0201      AND      R2,R2,#0x1
   2664              timeout--;
   \   0000001A   0x1E49             SUBS     R1,R1,#+1
   2665            }
   \                     ??SD_CmdError_0: (+1)
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD001             BEQ.N    ??SD_CmdError_2
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD0F5             BEQ.N    ??SD_CmdError_1
   2666            
   2667            if(timeout == 0)
   \                     ??SD_CmdError_2: (+1)
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD101             BNE.N    ??SD_CmdError_3
   2668            {
   2669              errorstate = SD_CMD_RSP_TIMEOUT;
   2670              return errorstate;
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x4770             BX       LR
   2671            }
   2672            
   2673            /* Clear all the static flags */
   2674            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??SD_CmdError_3: (+1)
   \   0000002C   0xF240 0x51FF      MOVW     R1,#+1535
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x6381             STR      R1,[R0, #+56]
   2675            
   2676            return errorstate;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4770             BX       LR               ;; return
   2677          }
   2678          
   2679          /**
   2680            * @brief  Checks for error conditions for R7 response.
   2681            * @param  hsd: SD handle
   2682            * @retval SD Card error state
   2683            */

   \                                 In section .text, align 2, keep-with-next
   2684          static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
   2685          {
   2686            HAL_SD_ErrorTypedef errorstate = SD_ERROR;
   2687            uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
   \                     SD_CmdResp7Error: (+1)
   \   00000000   0xF44F 0x3180      MOV      R1,#+65536
   2688            
   2689            tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x6B52             LDR      R2,[R2, #+52]
   \   00000008   0xF002 0x0245      AND      R2,R2,#0x45
   \   0000000C   0x1E52             SUBS     R2,R2,#+1
   \   0000000E   0x4192             SBCS     R2,R2,R2
   \   00000010   0x43D2             MVNS     R2,R2
   \   00000012   0x0FD2             LSRS     R2,R2,#+31
   \   00000014   0xE006             B.N      ??SD_CmdResp7Error_0
   2690            
   2691            while((!tmp) && (timeout > 0))
   2692            {
   2693              tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
   \                     ??SD_CmdResp7Error_1: (+1)
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x6B5B             LDR      R3,[R3, #+52]
   \   0000001A   0xF013 0x0F45      TST      R3,#0x45
   \   0000001E   0xD000             BEQ.N    ??SD_CmdResp7Error_2
   \   00000020   0x2201             MOVS     R2,#+1
   2694              timeout--;
   \                     ??SD_CmdResp7Error_2: (+1)
   \   00000022   0x1E49             SUBS     R1,R1,#+1
   2695            }
   \                     ??SD_CmdResp7Error_0: (+1)
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xD101             BNE.N    ??SD_CmdResp7Error_3
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD1F4             BNE.N    ??SD_CmdResp7Error_1
   2696            
   2697            tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
   \                     ??SD_CmdResp7Error_3: (+1)
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x6B42             LDR      R2,[R0, #+52]
   \   00000030   0x0892             LSRS     R2,R2,#+2
   \   00000032   0xF002 0x0201      AND      R2,R2,#0x1
   2698            
   2699            if((timeout == 0) || tmp)
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD001             BEQ.N    ??SD_CmdResp7Error_4
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD003             BEQ.N    ??SD_CmdResp7Error_5
   2700            {
   2701              /* Card is not V2.0 compliant or card does not support the set voltage range */
   2702              errorstate = SD_CMD_RSP_TIMEOUT;
   2703              
   2704              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
   \                     ??SD_CmdResp7Error_4: (+1)
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x6381             STR      R1,[R0, #+56]
   2705              
   2706              return errorstate;
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0x4770             BX       LR
   2707            }
   2708            
   2709            if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
   \                     ??SD_CmdResp7Error_5: (+1)
   \   00000046   0x6B41             LDR      R1,[R0, #+52]
   \   00000048   0x0649             LSLS     R1,R1,#+25
   \   0000004A   0xD503             BPL.N    ??SD_CmdResp7Error_6
   2710            {
   2711              /* Card is SD V2.0 compliant */
   2712              errorstate = SD_OK;
   2713              
   2714              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
   \   0000004C   0x2140             MOVS     R1,#+64
   \   0000004E   0x6381             STR      R1,[R0, #+56]
   2715              
   2716              return errorstate;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR
   2717            }
   2718            
   2719            return errorstate;
   \                     ??SD_CmdResp7Error_6: (+1)
   \   00000054   0x2029             MOVS     R0,#+41
   \   00000056   0x4770             BX       LR               ;; return
   2720          }
   2721          
   2722          /**
   2723            * @brief  Checks for error conditions for R1 response.
   2724            * @param  hsd: SD handle
   2725            * @param  SD_CMD: The sent command index  
   2726            * @retval SD Card error state
   2727            */

   \                                 In section .text, align 2, keep-with-next
   2728          static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
   2729          {
   \                     SD_CmdResp1Error: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   2730            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2731            uint32_t response_r1 = 0;
   2732            
   2733            while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
   \                     ??SD_CmdResp1Error_0: (+1)
   \   00000008   0x6B41             LDR      R1,[R0, #+52]
   \   0000000A   0xF011 0x0F45      TST      R1,#0x45
   \   0000000E   0xD0FB             BEQ.N    ??SD_CmdResp1Error_0
   2734            {
   2735            }
   2736            
   2737            if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
   \   00000010   0x6B41             LDR      R1,[R0, #+52]
   \   00000012   0x0749             LSLS     R1,R1,#+29
   \   00000014   0xD503             BPL.N    ??SD_CmdResp1Error_1
   2738            {
   2739              errorstate = SD_CMD_RSP_TIMEOUT;
   2740              
   2741              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0x6381             STR      R1,[R0, #+56]
   2742              
   2743              return errorstate;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
   2744            }
   2745            else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
   \                     ??SD_CmdResp1Error_1: (+1)
   \   0000001E   0x6B41             LDR      R1,[R0, #+52]
   \   00000020   0x07C9             LSLS     R1,R1,#+31
   \   00000022   0xD503             BPL.N    ??SD_CmdResp1Error_2
   2746            {
   2747              errorstate = SD_CMD_CRC_FAIL;
   2748              
   2749              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x6381             STR      R1,[R0, #+56]
   2750              
   2751              return errorstate;
   \   00000028   0x4608             MOV      R0,R1
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
   2752            }
   2753            else
   2754            {
   2755              /* No error flag set */
   2756            }
   2757            
   2758            /* Check response received is of desired command */
   2759            if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
   \                     ??SD_CmdResp1Error_2: (+1)
   \   0000002C   0x.... 0x....      BL       SDIO_GetCommandResponse
   \   00000030   0x42A8             CMP      R0,R5
   \   00000032   0xD12E             BNE.N    ??SD_CmdResp1Error_3
   2760            {
   2761              errorstate = SD_ILLEGAL_CMD;
   2762              
   2763              return errorstate;
   2764            }
   2765            
   2766            /* Clear all the static flags */
   2767            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \   00000034   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6388             STR      R0,[R1, #+56]
   2768            
   2769            /* We have received response, retrieve it for analysis  */
   2770            response_r1 = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       SDIO_GetResponse
   2771            
   2772            if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable35_2  ;; 0xfdffe008
   \   00000048   0x4208             TST      R0,R1
   \   0000004A   0xD101             BNE.N    ??SD_CmdResp1Error_4
   2773            {
   2774              return errorstate;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}
   2775            }
   2776            
   2777            if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
   \                     ??SD_CmdResp1Error_4: (+1)
   \   00000050   0xD501             BPL.N    ??SD_CmdResp1Error_5
   2778            {
   2779              return(SD_ADDR_OUT_OF_RANGE);
   \   00000052   0x201C             MOVS     R0,#+28
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}
   2780            }
   2781            
   2782            if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
   \                     ??SD_CmdResp1Error_5: (+1)
   \   00000056   0x0041             LSLS     R1,R0,#+1
   \   00000058   0xD501             BPL.N    ??SD_CmdResp1Error_6
   2783            {
   2784              return(SD_ADDR_MISALIGNED);
   \   0000005A   0x2009             MOVS     R0,#+9
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}
   2785            }
   2786            
   2787            if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
   \                     ??SD_CmdResp1Error_6: (+1)
   \   0000005E   0x0081             LSLS     R1,R0,#+2
   \   00000060   0xD501             BPL.N    ??SD_CmdResp1Error_7
   2788            {
   2789              return(SD_BLOCK_LEN_ERR);
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}
   2790            }
   2791            
   2792            if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
   \                     ??SD_CmdResp1Error_7: (+1)
   \   00000066   0x00C1             LSLS     R1,R0,#+3
   \   00000068   0xD501             BPL.N    ??SD_CmdResp1Error_8
   2793            {
   2794              return(SD_ERASE_SEQ_ERR);
   \   0000006A   0x200B             MOVS     R0,#+11
   \   0000006C   0xBD32             POP      {R1,R4,R5,PC}
   2795            }
   2796            
   2797            if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
   \                     ??SD_CmdResp1Error_8: (+1)
   \   0000006E   0x0101             LSLS     R1,R0,#+4
   \   00000070   0xD501             BPL.N    ??SD_CmdResp1Error_9
   2798            {
   2799              return(SD_BAD_ERASE_PARAM);
   \   00000072   0x200C             MOVS     R0,#+12
   \   00000074   0xBD32             POP      {R1,R4,R5,PC}
   2800            }
   2801            
   2802            if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
   \                     ??SD_CmdResp1Error_9: (+1)
   \   00000076   0x0141             LSLS     R1,R0,#+5
   \   00000078   0xD501             BPL.N    ??SD_CmdResp1Error_10
   2803            {
   2804              return(SD_WRITE_PROT_VIOLATION);
   \   0000007A   0x200D             MOVS     R0,#+13
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}
   2805            }
   2806            
   2807            if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
   \                     ??SD_CmdResp1Error_10: (+1)
   \   0000007E   0x01C1             LSLS     R1,R0,#+7
   \   00000080   0xD501             BPL.N    ??SD_CmdResp1Error_11
   2808            {
   2809              return(SD_LOCK_UNLOCK_FAILED);
   \   00000082   0x200E             MOVS     R0,#+14
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}
   2810            }
   2811            
   2812            if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
   \                     ??SD_CmdResp1Error_11: (+1)
   \   00000086   0x0201             LSLS     R1,R0,#+8
   \   00000088   0xD501             BPL.N    ??SD_CmdResp1Error_12
   2813            {
   2814              return(SD_COM_CRC_FAILED);
   \   0000008A   0x200F             MOVS     R0,#+15
   \   0000008C   0xBD32             POP      {R1,R4,R5,PC}
   2815            }
   2816            
   2817            if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
   \                     ??SD_CmdResp1Error_12: (+1)
   \   0000008E   0x0241             LSLS     R1,R0,#+9
   \   00000090   0xD501             BPL.N    ??SD_CmdResp1Error_13
   2818            {
   2819              return(SD_ILLEGAL_CMD);
   \                     ??SD_CmdResp1Error_3: (+1)
   \   00000092   0x2010             MOVS     R0,#+16
   \   00000094   0xBD32             POP      {R1,R4,R5,PC}
   2820            }
   2821            
   2822            if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
   \                     ??SD_CmdResp1Error_13: (+1)
   \   00000096   0x0281             LSLS     R1,R0,#+10
   \   00000098   0xD501             BPL.N    ??SD_CmdResp1Error_14
   2823            {
   2824              return(SD_CARD_ECC_FAILED);
   \   0000009A   0x2011             MOVS     R0,#+17
   \   0000009C   0xBD32             POP      {R1,R4,R5,PC}
   2825            }
   2826            
   2827            if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
   \                     ??SD_CmdResp1Error_14: (+1)
   \   0000009E   0x02C1             LSLS     R1,R0,#+11
   \   000000A0   0xD501             BPL.N    ??SD_CmdResp1Error_15
   2828            {
   2829              return(SD_CC_ERROR);
   \   000000A2   0x2012             MOVS     R0,#+18
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}
   2830            }
   2831            
   2832            if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
   \                     ??SD_CmdResp1Error_15: (+1)
   \   000000A6   0x0301             LSLS     R1,R0,#+12
   \   000000A8   0xD501             BPL.N    ??SD_CmdResp1Error_16
   2833            {
   2834              return(SD_GENERAL_UNKNOWN_ERROR);
   \   000000AA   0x2013             MOVS     R0,#+19
   \   000000AC   0xBD32             POP      {R1,R4,R5,PC}
   2835            }
   2836            
   2837            if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
   \                     ??SD_CmdResp1Error_16: (+1)
   \   000000AE   0x0341             LSLS     R1,R0,#+13
   \   000000B0   0xD501             BPL.N    ??SD_CmdResp1Error_17
   2838            {
   2839              return(SD_STREAM_READ_UNDERRUN);
   \   000000B2   0x2014             MOVS     R0,#+20
   \   000000B4   0xBD32             POP      {R1,R4,R5,PC}
   2840            }
   2841            
   2842            if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
   \                     ??SD_CmdResp1Error_17: (+1)
   \   000000B6   0x0381             LSLS     R1,R0,#+14
   \   000000B8   0xD501             BPL.N    ??SD_CmdResp1Error_18
   2843            {
   2844              return(SD_STREAM_WRITE_OVERRUN);
   \   000000BA   0x2015             MOVS     R0,#+21
   \   000000BC   0xBD32             POP      {R1,R4,R5,PC}
   2845            }
   2846            
   2847            if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
   \                     ??SD_CmdResp1Error_18: (+1)
   \   000000BE   0x03C1             LSLS     R1,R0,#+15
   \   000000C0   0xD501             BPL.N    ??SD_CmdResp1Error_19
   2848            {
   2849              return(SD_CID_CSD_OVERWRITE);
   \   000000C2   0x2016             MOVS     R0,#+22
   \   000000C4   0xBD32             POP      {R1,R4,R5,PC}
   2850            }
   2851            
   2852            if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
   \                     ??SD_CmdResp1Error_19: (+1)
   \   000000C6   0x0401             LSLS     R1,R0,#+16
   \   000000C8   0xD501             BPL.N    ??SD_CmdResp1Error_20
   2853            {
   2854              return(SD_WP_ERASE_SKIP);
   \   000000CA   0x2017             MOVS     R0,#+23
   \   000000CC   0xBD32             POP      {R1,R4,R5,PC}
   2855            }
   2856            
   2857            if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
   \                     ??SD_CmdResp1Error_20: (+1)
   \   000000CE   0x0441             LSLS     R1,R0,#+17
   \   000000D0   0xD501             BPL.N    ??SD_CmdResp1Error_21
   2858            {
   2859              return(SD_CARD_ECC_DISABLED);
   \   000000D2   0x2018             MOVS     R0,#+24
   \   000000D4   0xBD32             POP      {R1,R4,R5,PC}
   2860            }
   2861            
   2862            if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
   \                     ??SD_CmdResp1Error_21: (+1)
   \   000000D6   0x0481             LSLS     R1,R0,#+18
   \   000000D8   0xD501             BPL.N    ??SD_CmdResp1Error_22
   2863            {
   2864              return(SD_ERASE_RESET);
   \   000000DA   0x2019             MOVS     R0,#+25
   \   000000DC   0xBD32             POP      {R1,R4,R5,PC}
   2865            }
   2866            
   2867            if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
   \                     ??SD_CmdResp1Error_22: (+1)
   \   000000DE   0x0700             LSLS     R0,R0,#+28
   \   000000E0   0xD501             BPL.N    ??SD_CmdResp1Error_23
   2868            {
   2869              return(SD_AKE_SEQ_ERROR);
   \   000000E2   0x201A             MOVS     R0,#+26
   \   000000E4   0xBD32             POP      {R1,R4,R5,PC}
   2870            }
   2871            
   2872            return errorstate;
   \                     ??SD_CmdResp1Error_23: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2873          }
   2874          
   2875          /**
   2876            * @brief  Checks for error conditions for R3 (OCR) response.
   2877            * @param  hsd: SD handle
   2878            * @retval SD Card error state
   2879            */

   \                                 In section .text, align 2, keep-with-next
   2880          static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
   2881          {
   \                     SD_CmdResp3Error: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   2882            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2883            
   2884            while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
   \                     ??SD_CmdResp3Error_0: (+1)
   \   00000002   0x6B4A             LDR      R2,[R1, #+52]
   \   00000004   0xF012 0x0F45      TST      R2,#0x45
   \   00000008   0xD0FB             BEQ.N    ??SD_CmdResp3Error_0
   2885            {
   2886            }
   2887            
   2888            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
   \   0000000A   0x6B48             LDR      R0,[R1, #+52]
   \   0000000C   0x0740             LSLS     R0,R0,#+29
   \   0000000E   0xD503             BPL.N    ??SD_CmdResp3Error_1
   2889            {
   2890              errorstate = SD_CMD_RSP_TIMEOUT;
   2891              
   2892              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x6388             STR      R0,[R1, #+56]
   2893              
   2894              return errorstate;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x4770             BX       LR
   2895            }
   2896            
   2897            /* Clear all the static flags */
   2898            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??SD_CmdResp3Error_1: (+1)
   \   00000018   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000001C   0x6388             STR      R0,[R1, #+56]
   2899            
   2900            return errorstate;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
   2901          }
   2902          
   2903          /**
   2904            * @brief  Checks for error conditions for R2 (CID or CSD) response.
   2905            * @param  hsd: SD handle
   2906            * @retval SD Card error state
   2907            */

   \                                 In section .text, align 2, keep-with-next
   2908          static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
   2909          {
   \                     SD_CmdResp2Error: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   2910            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2911            
   2912            while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
   \                     ??SD_CmdResp2Error_0: (+1)
   \   00000002   0x6B4A             LDR      R2,[R1, #+52]
   \   00000004   0xF012 0x0F45      TST      R2,#0x45
   \   00000008   0xD0FB             BEQ.N    ??SD_CmdResp2Error_0
   2913            {
   2914            }
   2915              
   2916            if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
   \   0000000A   0x6B48             LDR      R0,[R1, #+52]
   \   0000000C   0x0740             LSLS     R0,R0,#+29
   \   0000000E   0xD503             BPL.N    ??SD_CmdResp2Error_1
   2917            {
   2918              errorstate = SD_CMD_RSP_TIMEOUT;
   2919              
   2920              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x6388             STR      R0,[R1, #+56]
   2921              
   2922              return errorstate;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x4770             BX       LR
   2923            }
   2924            else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
   \                     ??SD_CmdResp2Error_1: (+1)
   \   00000018   0x6B48             LDR      R0,[R1, #+52]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD502             BPL.N    ??SD_CmdResp2Error_2
   2925            {
   2926              errorstate = SD_CMD_CRC_FAIL;
   2927              
   2928              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x6388             STR      R0,[R1, #+56]
   2929              
   2930              return errorstate;
   \   00000022   0x4770             BX       LR
   2931            }
   2932            else
   2933            {
   2934              /* No error flag set */
   2935            }
   2936            
   2937            /* Clear all the static flags */
   2938            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??SD_CmdResp2Error_2: (+1)
   \   00000024   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000028   0x6388             STR      R0,[R1, #+56]
   2939            
   2940            return errorstate;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
   2941          }
   2942          
   2943          /**
   2944            * @brief  Checks for error conditions for R6 (RCA) response.
   2945            * @param  hsd: SD handle
   2946            * @param  SD_CMD: The sent command index
   2947            * @param  pRCA: Pointer to the variable that will contain the SD card relative 
   2948            *         address RCA   
   2949            * @retval SD Card error state
   2950            */

   \                                 In section .text, align 2, keep-with-next
   2951          static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
   2952          {
   \                     SD_CmdResp6Error: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   2953            HAL_SD_ErrorTypedef errorstate = SD_OK;
   2954            uint32_t response_r1 = 0;
   2955            
   2956            while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
   \                     ??SD_CmdResp6Error_0: (+1)
   \   0000000A   0x6B41             LDR      R1,[R0, #+52]
   \   0000000C   0xF011 0x0F45      TST      R1,#0x45
   \   00000010   0xD0FB             BEQ.N    ??SD_CmdResp6Error_0
   2957            {
   2958            }
   2959            
   2960            if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
   \   00000012   0x6B41             LDR      R1,[R0, #+52]
   \   00000014   0x0749             LSLS     R1,R1,#+29
   \   00000016   0xD503             BPL.N    ??SD_CmdResp6Error_1
   2961            {
   2962              errorstate = SD_CMD_RSP_TIMEOUT;
   2963              
   2964              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x6381             STR      R1,[R0, #+56]
   2965              
   2966              return errorstate;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xBD70             POP      {R4-R6,PC}
   2967            }
   2968            else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
   \                     ??SD_CmdResp6Error_1: (+1)
   \   00000020   0x6B41             LDR      R1,[R0, #+52]
   \   00000022   0x07C9             LSLS     R1,R1,#+31
   \   00000024   0xD503             BPL.N    ??SD_CmdResp6Error_2
   2969            {
   2970              errorstate = SD_CMD_CRC_FAIL;
   2971              
   2972              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x6381             STR      R1,[R0, #+56]
   2973              
   2974              return errorstate;
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0xBD70             POP      {R4-R6,PC}
   2975            }
   2976            else
   2977            {
   2978              /* No error flag set */
   2979            }
   2980            
   2981            /* Check response received is of desired command */
   2982            if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
   \                     ??SD_CmdResp6Error_2: (+1)
   \   0000002E   0x.... 0x....      BL       SDIO_GetCommandResponse
   \   00000032   0x42B0             CMP      R0,R6
   \   00000034   0xD114             BNE.N    ??SD_CmdResp6Error_3
   2983            {
   2984              errorstate = SD_ILLEGAL_CMD;
   2985              
   2986              return errorstate;
   2987            }
   2988            
   2989            /* Clear all the static flags */
   2990            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \   00000036   0xF240 0x50FF      MOVW     R0,#+1535
   \   0000003A   0x6829             LDR      R1,[R5, #+0]
   \   0000003C   0x6388             STR      R0,[R1, #+56]
   2991            
   2992            /* We have received response, retrieve it.  */
   2993            response_r1 = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6828             LDR      R0,[R5, #+0]
   \   00000042   0x.... 0x....      BL       SDIO_GetResponse
   2994            
   2995            if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
   \   00000046   0xF410 0x4F60      TST      R0,#0xE000
   \   0000004A   0xD103             BNE.N    ??SD_CmdResp6Error_4
   2996            {
   2997              *pRCA = (uint16_t) (response_r1 >> 16);
   \   0000004C   0x0C00             LSRS     R0,R0,#+16
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   2998              
   2999              return errorstate;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD70             POP      {R4-R6,PC}
   3000            }
   3001            
   3002            if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
   \                     ??SD_CmdResp6Error_4: (+1)
   \   00000054   0x0481             LSLS     R1,R0,#+18
   \   00000056   0xD501             BPL.N    ??SD_CmdResp6Error_5
   3003            {
   3004              return(SD_GENERAL_UNKNOWN_ERROR);
   \   00000058   0x2013             MOVS     R0,#+19
   \   0000005A   0xBD70             POP      {R4-R6,PC}
   3005            }
   3006            
   3007            if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
   \                     ??SD_CmdResp6Error_5: (+1)
   \   0000005C   0x0441             LSLS     R1,R0,#+17
   \   0000005E   0xD501             BPL.N    ??SD_CmdResp6Error_6
   3008            {
   3009              return(SD_ILLEGAL_CMD);
   \                     ??SD_CmdResp6Error_3: (+1)
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0xBD70             POP      {R4-R6,PC}
   3010            }
   3011            
   3012            if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
   \                     ??SD_CmdResp6Error_6: (+1)
   \   00000064   0x0400             LSLS     R0,R0,#+16
   \   00000066   0xD501             BPL.N    ??SD_CmdResp6Error_7
   3013            {
   3014              return(SD_COM_CRC_FAILED);
   \   00000068   0x200F             MOVS     R0,#+15
   \   0000006A   0xBD70             POP      {R4-R6,PC}
   3015            }
   3016            
   3017            return errorstate;
   \                     ??SD_CmdResp6Error_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
   3018          }
   3019          
   3020          /**
   3021            * @brief  Enables the SDIO wide bus mode.
   3022            * @param  hsd: SD handle
   3023            * @retval SD Card error state
   3024            */

   \                                 In section .text, align 2, keep-with-next
   3025          static HAL_SD_ErrorTypedef SD_WideBus_Enable(SD_HandleTypeDef *hsd)
   3026          {
   \                     SD_WideBus_Enable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
   3027            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   3028            HAL_SD_ErrorTypedef errorstate = SD_OK;
   3029            
   3030            uint32_t scr[2] = {0, 0};
   \   0000000E   0xA805             ADD      R0,SP,#+20
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0xC006             STM      R0!,{R1,R2}
   3031            
   3032            if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       SDIO_GetResponse
   \   0000001C   0x0180             LSLS     R0,R0,#+6
   \   0000001E   0xD501             BPL.N    ??SD_WideBus_Enable_0
   3033            {
   3034              errorstate = SD_LOCK_UNLOCK_FAILED;
   3035              
   3036              return errorstate;
   \   00000020   0x200E             MOVS     R0,#+14
   \   00000022   0xE02F             B.N      ??SD_WideBus_Enable_1
   3037            }
   3038            
   3039            /* Get SCR Register */
   3040            errorstate = SD_FindSCR(hsd, scr);
   \                     ??SD_WideBus_Enable_0: (+1)
   \   00000024   0xA905             ADD      R1,SP,#+20
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       SD_FindSCR
   3041            
   3042            if(errorstate != SD_OK)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD129             BNE.N    ??SD_WideBus_Enable_1
   3043            {
   3044              return errorstate;
   3045            }
   3046            
   3047            /* If requested card supports wide bus operation */
   3048            if((scr[1] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
   \   00000030   0x9806             LDR      R0,[SP, #+24]
   \   00000032   0x0340             LSLS     R0,R0,#+13
   \   00000034   0xD525             BPL.N    ??SD_WideBus_Enable_2
   3049            {
   3050              /* Send CMD55 APP_CMD with argument as card's RCA.*/
   3051              sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
   \   00000036   0x6A60             LDR      R0,[R4, #+36]
   \   00000038   0x0400             LSLS     R0,R0,#+16
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   3052              sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
   \   0000003C   0x2037             MOVS     R0,#+55
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   3053              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0x9002             STR      R0,[SP, #+8]
   3054              sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9003             STR      R0,[SP, #+12]
   3055              sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000048   0xF44F 0x6080      MOV      R0,#+1024
   \   0000004C   0x9004             STR      R0,[SP, #+16]
   3056              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       SDIO_SendCommand
   3057              
   3058              /* Check for error conditions */
   3059              errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
   \   00000056   0x2137             MOVS     R1,#+55
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       SD_CmdResp1Error
   3060              
   3061              if(errorstate != SD_OK)
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD110             BNE.N    ??SD_WideBus_Enable_1
   3062              {
   3063                return errorstate;
   3064              }
   3065              
   3066              /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
   3067              sdio_cmdinitstructure.Argument         = 2;
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x9000             STR      R0,[SP, #+0]
   3068              sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
   \   00000066   0x2006             MOVS     R0,#+6
   \   00000068   0x9001             STR      R0,[SP, #+4]
   3069              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000006A   0xA900             ADD      R1,SP,#+0
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x.... 0x....      BL       SDIO_SendCommand
   3070              
   3071              /* Check for error conditions */
   3072              errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
   \   00000072   0x2106             MOVS     R1,#+6
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       SD_CmdResp1Error
   3073              
   3074              if(errorstate != SD_OK)
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD102             BNE.N    ??SD_WideBus_Enable_1
   3075              {
   3076                return errorstate;
   3077              }
   3078              
   3079              return errorstate;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??SD_WideBus_Enable_1
   3080            }
   3081            else
   3082            {
   3083              errorstate = SD_REQUEST_NOT_APPLICABLE;
   3084              
   3085              return errorstate;
   \                     ??SD_WideBus_Enable_2: (+1)
   \   00000082   0x2025             MOVS     R0,#+37
   \                     ??SD_WideBus_Enable_1: (+1)
   \   00000084   0xB008             ADD      SP,SP,#+32
   \   00000086   0xBD10             POP      {R4,PC}          ;; return
   3086            }
   3087          }   
   3088          
   3089          /**
   3090            * @brief  Disables the SDIO wide bus mode.
   3091            * @param  hsd: SD handle
   3092            * @retval SD Card error state
   3093            */

   \                                 In section .text, align 2, keep-with-next
   3094          static HAL_SD_ErrorTypedef SD_WideBus_Disable(SD_HandleTypeDef *hsd)
   3095          {
   \                     SD_WideBus_Disable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
   3096            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2114             MOVS     R1,#+20
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   3097            HAL_SD_ErrorTypedef errorstate = SD_OK;
   3098            
   3099            uint32_t scr[2] = {0, 0};
   \   0000000E   0xA805             ADD      R0,SP,#+20
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0xC006             STM      R0!,{R1,R2}
   3100            
   3101            if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       SDIO_GetResponse
   \   0000001C   0x0180             LSLS     R0,R0,#+6
   \   0000001E   0xD501             BPL.N    ??SD_WideBus_Disable_0
   3102            {
   3103              errorstate = SD_LOCK_UNLOCK_FAILED;
   3104              
   3105              return errorstate;
   \   00000020   0x200E             MOVS     R0,#+14
   \   00000022   0xE02F             B.N      ??SD_WideBus_Disable_1
   3106            }
   3107            
   3108            /* Get SCR Register */
   3109            errorstate = SD_FindSCR(hsd, scr);
   \                     ??SD_WideBus_Disable_0: (+1)
   \   00000024   0xA905             ADD      R1,SP,#+20
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       SD_FindSCR
   3110            
   3111            if(errorstate != SD_OK)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD129             BNE.N    ??SD_WideBus_Disable_1
   3112            {
   3113              return errorstate;
   3114            }
   3115            
   3116            /* If requested card supports 1 bit mode operation */
   3117            if((scr[1] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
   \   00000030   0x9806             LDR      R0,[SP, #+24]
   \   00000032   0x03C0             LSLS     R0,R0,#+15
   \   00000034   0xD525             BPL.N    ??SD_WideBus_Disable_2
   3118            {
   3119              /* Send CMD55 APP_CMD with argument as card's RCA */
   3120              sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
   \   00000036   0x6A60             LDR      R0,[R4, #+36]
   \   00000038   0x0400             LSLS     R0,R0,#+16
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   3121              sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
   \   0000003C   0x2037             MOVS     R0,#+55
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   3122              sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0x9002             STR      R0,[SP, #+8]
   3123              sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9003             STR      R0,[SP, #+12]
   3124              sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000048   0xF44F 0x6080      MOV      R0,#+1024
   \   0000004C   0x9004             STR      R0,[SP, #+16]
   3125              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       SDIO_SendCommand
   3126              
   3127              /* Check for error conditions */
   3128              errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
   \   00000056   0x2137             MOVS     R1,#+55
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       SD_CmdResp1Error
   3129              
   3130              if(errorstate != SD_OK)
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD110             BNE.N    ??SD_WideBus_Disable_1
   3131              {
   3132                return errorstate;
   3133              }
   3134              
   3135              /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
   3136              sdio_cmdinitstructure.Argument         = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9000             STR      R0,[SP, #+0]
   3137              sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
   \   00000066   0x2006             MOVS     R0,#+6
   \   00000068   0x9001             STR      R0,[SP, #+4]
   3138              SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000006A   0xA900             ADD      R1,SP,#+0
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x.... 0x....      BL       SDIO_SendCommand
   3139              
   3140              /* Check for error conditions */
   3141              errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
   \   00000072   0x2106             MOVS     R1,#+6
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       SD_CmdResp1Error
   3142              
   3143              if(errorstate != SD_OK)
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD102             BNE.N    ??SD_WideBus_Disable_1
   3144              {
   3145                return errorstate;
   3146              }
   3147              
   3148              return errorstate;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??SD_WideBus_Disable_1
   3149            }
   3150            else
   3151            {
   3152              errorstate = SD_REQUEST_NOT_APPLICABLE;
   3153              
   3154              return errorstate;
   \                     ??SD_WideBus_Disable_2: (+1)
   \   00000082   0x2025             MOVS     R0,#+37
   \                     ??SD_WideBus_Disable_1: (+1)
   \   00000084   0xB008             ADD      SP,SP,#+32
   \   00000086   0xBD10             POP      {R4,PC}          ;; return
   3155            }
   3156          }
   3157            
   3158            
   3159          /**
   3160            * @brief  Finds the SD card SCR register value.
   3161            * @param  hsd: SD handle
   3162            * @param  pSCR: pointer to the buffer that will contain the SCR value  
   3163            * @retval SD Card error state
   3164            */

   \                                 In section .text, align 2, keep-with-next
   3165          static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
   3166          {
   \                     SD_FindSCR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   3167            SDIO_CmdInitTypeDef  sdio_cmdinitstructure = {0};
   \   00000008   0xA802             ADD      R0,SP,#+8
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   3168            SDIO_DataInitTypeDef sdio_datainitstructure = {0};
   \   00000010   0xA807             ADD      R0,SP,#+28
   \   00000012   0x2118             MOVS     R1,#+24
   \   00000014   0x.... 0x....      BL       __aeabi_memclr4
   3169            HAL_SD_ErrorTypedef errorstate = SD_OK;
   3170            uint32_t index = 0;
   \   00000018   0x2600             MOVS     R6,#+0
   3171            uint32_t tempscr[2] = {0, 0};
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x4631             MOV      R1,R6
   \   0000001E   0x460A             MOV      R2,R1
   \   00000020   0xC006             STM      R0!,{R1,R2}
   3172            
   3173            /* Set Block Size To 8 Bytes */
   3174            /* Send CMD55 APP_CMD with argument as card's RCA */
   3175            sdio_cmdinitstructure.Argument         = (uint32_t)8;
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0x9002             STR      R0,[SP, #+8]
   3176            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
   \   00000026   0x2010             MOVS     R0,#+16
   \   00000028   0x9003             STR      R0,[SP, #+12]
   3177            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   0000002A   0x2040             MOVS     R0,#+64
   \   0000002C   0x9004             STR      R0,[SP, #+16]
   3178            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x9005             STR      R0,[SP, #+20]
   3179            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000032   0xF44F 0x6080      MOV      R0,#+1024
   \   00000036   0x9006             STR      R0,[SP, #+24]
   3180            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000038   0xA902             ADD      R1,SP,#+8
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       SDIO_SendCommand
   3181            
   3182            /* Check for error conditions */
   3183            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   \   00000040   0x2110             MOVS     R1,#+16
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000048   0x0007             MOVS     R7,R0
   3184            
   3185            if(errorstate != SD_OK)
   \   0000004A   0xD17A             BNE.N    ??SD_FindSCR_0
   3186            {
   3187              return errorstate;
   3188            }
   3189            
   3190            /* Send CMD55 APP_CMD with argument as card's RCA */
   3191            sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16);
   \   0000004C   0x6A60             LDR      R0,[R4, #+36]
   \   0000004E   0x0400             LSLS     R0,R0,#+16
   \   00000050   0x9002             STR      R0,[SP, #+8]
   3192            sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
   \   00000052   0x2037             MOVS     R0,#+55
   \   00000054   0x9003             STR      R0,[SP, #+12]
   3193            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000056   0xA902             ADD      R1,SP,#+8
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       SDIO_SendCommand
   3194            
   3195            /* Check for error conditions */
   3196            errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
   \   0000005E   0x2137             MOVS     R1,#+55
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       SD_CmdResp1Error
   \   00000066   0x0007             MOVS     R7,R0
   3197            
   3198            if(errorstate != SD_OK)
   \   00000068   0xD16B             BNE.N    ??SD_FindSCR_0
   3199            {
   3200              return errorstate;
   3201            }
   3202            sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
   \   0000006A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000006E   0x9007             STR      R0,[SP, #+28]
   3203            sdio_datainitstructure.DataLength    = 8;
   \   00000070   0x2008             MOVS     R0,#+8
   \   00000072   0x9008             STR      R0,[SP, #+32]
   3204            sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
   \   00000074   0x2030             MOVS     R0,#+48
   \   00000076   0x9009             STR      R0,[SP, #+36]
   3205            sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x900A             STR      R0,[SP, #+40]
   3206            sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0x900B             STR      R0,[SP, #+44]
   3207            sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x900C             STR      R0,[SP, #+48]
   3208            SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   \   00000084   0xA907             ADD      R1,SP,#+28
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       SDIO_DataConfig
   3209            
   3210            /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
   3211            sdio_cmdinitstructure.Argument         = 0;
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0x9002             STR      R0,[SP, #+8]
   3212            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
   \   00000090   0x2033             MOVS     R0,#+51
   \   00000092   0x9003             STR      R0,[SP, #+12]
   3213            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   00000094   0xA902             ADD      R1,SP,#+8
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x.... 0x....      BL       SDIO_SendCommand
   3214            
   3215            /* Check for error conditions */
   3216            errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_SEND_SCR);
   \   0000009C   0x2133             MOVS     R1,#+51
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       SD_CmdResp1Error
   \   000000A4   0x0007             MOVS     R7,R0
   3217            
   3218            if(errorstate != SD_OK)
   \   000000A6   0xD008             BEQ.N    ??SD_FindSCR_1
   3219            {
   3220              return errorstate;
   \   000000A8   0xE04B             B.N      ??SD_FindSCR_0
   3221            }
   3222            
   3223            while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
   3224            {
   3225              if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
   \                     ??SD_FindSCR_2: (+1)
   \   000000AA   0x0289             LSLS     R1,R1,#+10
   \   000000AC   0xD505             BPL.N    ??SD_FindSCR_1
   3226              {
   3227                *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
   \   000000AE   0x.... 0x....      BL       SDIO_ReadFIFO
   \   000000B2   0xA900             ADD      R1,SP,#+0
   \   000000B4   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   3228                index++;
   \   000000B8   0x1C76             ADDS     R6,R6,#+1
   3229              }
   3230            }
   \                     ??SD_FindSCR_1: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6B41             LDR      R1,[R0, #+52]
   \   000000BE   0xF240 0x622A      MOVW     R2,#+1578
   \   000000C2   0x4211             TST      R1,R2
   \   000000C4   0x6B41             LDR      R1,[R0, #+52]
   \   000000C6   0xD0F0             BEQ.N    ??SD_FindSCR_2
   3231            
   3232            if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
   \   000000C8   0x0709             LSLS     R1,R1,#+28
   \   000000CA   0xD503             BPL.N    ??SD_FindSCR_3
   3233            {
   3234              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
   \   000000CC   0x2108             MOVS     R1,#+8
   \   000000CE   0x6381             STR      R1,[R0, #+56]
   3235              
   3236              errorstate = SD_DATA_TIMEOUT;
   3237              
   3238              return errorstate;
   \   000000D0   0x2004             MOVS     R0,#+4
   \   000000D2   0xE036             B.N      ??SD_FindSCR_0
   3239            }
   3240            else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
   \                     ??SD_FindSCR_3: (+1)
   \   000000D4   0x6B41             LDR      R1,[R0, #+52]
   \   000000D6   0x0789             LSLS     R1,R1,#+30
   \   000000D8   0xD503             BPL.N    ??SD_FindSCR_4
   3241            {
   3242              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
   \   000000DA   0x2102             MOVS     R1,#+2
   \   000000DC   0x6381             STR      R1,[R0, #+56]
   3243              
   3244              errorstate = SD_DATA_CRC_FAIL;
   3245              
   3246              return errorstate;
   \   000000DE   0x4608             MOV      R0,R1
   \   000000E0   0xE02F             B.N      ??SD_FindSCR_0
   3247            }
   3248            else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
   \                     ??SD_FindSCR_4: (+1)
   \   000000E2   0x6B41             LDR      R1,[R0, #+52]
   \   000000E4   0x0689             LSLS     R1,R1,#+26
   \   000000E6   0xD503             BPL.N    ??SD_FindSCR_5
   3249            {
   3250              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
   \   000000E8   0x2120             MOVS     R1,#+32
   \   000000EA   0x6381             STR      R1,[R0, #+56]
   3251              
   3252              errorstate = SD_RX_OVERRUN;
   3253              
   3254              return errorstate;
   \   000000EC   0x2006             MOVS     R0,#+6
   \   000000EE   0xE028             B.N      ??SD_FindSCR_0
   3255            }
   3256            else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
   \                     ??SD_FindSCR_5: (+1)
   \   000000F0   0x6B41             LDR      R1,[R0, #+52]
   \   000000F2   0x0589             LSLS     R1,R1,#+22
   \   000000F4   0xD504             BPL.N    ??SD_FindSCR_6
   3257            {
   3258              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
   \   000000F6   0xF44F 0x7100      MOV      R1,#+512
   \   000000FA   0x6381             STR      R1,[R0, #+56]
   3259              
   3260              errorstate = SD_START_BIT_ERR;
   3261              
   3262              return errorstate;
   \   000000FC   0x2007             MOVS     R0,#+7
   \   000000FE   0xE020             B.N      ??SD_FindSCR_0
   3263            }
   3264            else
   3265            {
   3266              /* No error flag set */
   3267            }
   3268            
   3269            /* Clear all the static flags */
   3270            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \                     ??SD_FindSCR_6: (+1)
   \   00000100   0xF240 0x51FF      MOVW     R1,#+1535
   \   00000104   0x6381             STR      R1,[R0, #+56]
   3271            
   3272            *(pSCR + 1) = ((tempscr[0] & SD_0TO7BITS) << 24)  | ((tempscr[0] & SD_8TO15BITS) << 8) |\
   3273              ((tempscr[0] & SD_16TO23BITS) >> 8) | ((tempscr[0] & SD_24TO31BITS) >> 24);
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   \   00000108   0x4601             MOV      R1,R0
   \   0000010A   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   0000010E   0x0209             LSLS     R1,R1,#+8
   \   00000110   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000114   0x9900             LDR      R1,[SP, #+0]
   \   00000116   0x0A09             LSRS     R1,R1,#+8
   \   00000118   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   0000011C   0x4308             ORRS     R0,R1,R0
   \   0000011E   0x9900             LDR      R1,[SP, #+0]
   \   00000120   0xEA40 0x6011      ORR      R0,R0,R1, LSR #+24
   \   00000124   0x6068             STR      R0,[R5, #+4]
   \   00000126   0x9801             LDR      R0,[SP, #+4]
   \   00000128   0xF400 0x417F      AND      R1,R0,#0xFF00
   \   0000012C   0x0209             LSLS     R1,R1,#+8
   \   0000012E   0xEA41 0x6100      ORR      R1,R1,R0, LSL #+24
   \   00000132   0x0A02             LSRS     R2,R0,#+8
   \   00000134   0xF402 0x427F      AND      R2,R2,#0xFF00
   \   00000138   0x4311             ORRS     R1,R2,R1
   \   0000013A   0xEA41 0x6010      ORR      R0,R1,R0, LSR #+24
   \   0000013E   0x6028             STR      R0,[R5, #+0]
   3274            
   3275            *(pSCR) = ((tempscr[1] & SD_0TO7BITS) << 24)  | ((tempscr[1] & SD_8TO15BITS) << 8) |\
   3276              ((tempscr[1] & SD_16TO23BITS) >> 8) | ((tempscr[1] & SD_24TO31BITS) >> 24);
   3277            
   3278            return errorstate;
   \   00000140   0x4638             MOV      R0,R7
   \                     ??SD_FindSCR_0: (+1)
   \   00000142   0xB00D             ADD      SP,SP,#+52
   \   00000144   0xBDF0             POP      {R4-R7,PC}       ;; return
   3279          }
   3280          
   3281          /**
   3282            * @brief  Checks if the SD card is in programming state.
   3283            * @param  hsd: SD handle
   3284            * @param  pStatus: pointer to the variable that will contain the SD card state  
   3285            * @retval SD Card error state
   3286            */

   \                                 In section .text, align 2, keep-with-next
   3287          static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
   3288          {
   \                     SD_IsCardProgramming: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   3289            SDIO_CmdInitTypeDef sdio_cmdinitstructure = {0};
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
   3290            HAL_SD_ErrorTypedef errorstate = SD_OK;
   3291            __IO uint32_t responseR1 = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9000             STR      R0,[SP, #+0]
   3292            
   3293            sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
   \   00000014   0x6A68             LDR      R0,[R5, #+36]
   \   00000016   0x0400             LSLS     R0,R0,#+16
   \   00000018   0x9001             STR      R0,[SP, #+4]
   3294            sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
   \   0000001A   0x200D             MOVS     R0,#+13
   \   0000001C   0x9002             STR      R0,[SP, #+8]
   3295            sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
   \   0000001E   0x2040             MOVS     R0,#+64
   \   00000020   0x9003             STR      R0,[SP, #+12]
   3296            sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x9004             STR      R0,[SP, #+16]
   3297            sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   \   00000026   0xF44F 0x6080      MOV      R0,#+1024
   \   0000002A   0x9005             STR      R0,[SP, #+20]
   3298            SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x.... 0x....      BL       SDIO_SendCommand
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   3299            
   3300            while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
   \                     ??SD_IsCardProgramming_0: (+1)
   \   00000036   0x6B41             LDR      R1,[R0, #+52]
   \   00000038   0xF011 0x0F45      TST      R1,#0x45
   \   0000003C   0xD0FB             BEQ.N    ??SD_IsCardProgramming_0
   3301            {
   3302            }
   3303            
   3304            if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
   \   0000003E   0x6B41             LDR      R1,[R0, #+52]
   \   00000040   0x0749             LSLS     R1,R1,#+29
   \   00000042   0xD503             BPL.N    ??SD_IsCardProgramming_1
   3305            {
   3306              errorstate = SD_CMD_RSP_TIMEOUT;
   3307              
   3308              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
   \   00000044   0x2104             MOVS     R1,#+4
   \   00000046   0x6381             STR      R1,[R0, #+56]
   3309              
   3310              return errorstate;
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0xE07E             B.N      ??SD_IsCardProgramming_2
   3311            }
   3312            else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
   \                     ??SD_IsCardProgramming_1: (+1)
   \   0000004C   0x6B41             LDR      R1,[R0, #+52]
   \   0000004E   0x07C9             LSLS     R1,R1,#+31
   \   00000050   0xD503             BPL.N    ??SD_IsCardProgramming_3
   3313            {
   3314              errorstate = SD_CMD_CRC_FAIL;
   3315              
   3316              __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x6381             STR      R1,[R0, #+56]
   3317              
   3318              return errorstate;
   \   00000056   0x4608             MOV      R0,R1
   \   00000058   0xE077             B.N      ??SD_IsCardProgramming_2
   3319            }
   3320            else
   3321            {
   3322              /* No error flag set */
   3323            }
   3324            
   3325            /* Check response received is of desired command */
   3326            if((uint32_t)SDIO_GetCommandResponse(hsd->Instance) != SD_CMD_SEND_STATUS)
   \                     ??SD_IsCardProgramming_3: (+1)
   \   0000005A   0x.... 0x....      BL       SDIO_GetCommandResponse
   \   0000005E   0x280D             CMP      R0,#+13
   \   00000060   0xD13E             BNE.N    ??SD_IsCardProgramming_4
   3327            {
   3328              errorstate = SD_ILLEGAL_CMD;
   3329              
   3330              return errorstate;
   3331            }
   3332            
   3333            /* Clear all the static flags */
   3334            __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
   \   00000062   0xF240 0x50FF      MOVW     R0,#+1535
   \   00000066   0x6829             LDR      R1,[R5, #+0]
   \   00000068   0x6388             STR      R0,[R1, #+56]
   3335            
   3336            
   3337            /* We have received response, retrieve it for analysis */
   3338            responseR1 = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       SDIO_GetResponse
   \   00000072   0x9000             STR      R0,[SP, #+0]
   3339            
   3340            /* Find out card status */
   3341            *pStatus = (uint8_t)((responseR1 >> 9) & 0x0000000F);
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x0A40             LSRS     R0,R0,#+9
   \   00000078   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
   3342            
   3343            if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x....             LDR.N    R1,??DataTable35_2  ;; 0xfdffe008
   \   00000082   0x4208             TST      R0,R1
   \   00000084   0xD101             BNE.N    ??SD_IsCardProgramming_5
   3344            {
   3345              return errorstate;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE05F             B.N      ??SD_IsCardProgramming_2
   3346            }
   3347            
   3348            if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
   \                     ??SD_IsCardProgramming_5: (+1)
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD501             BPL.N    ??SD_IsCardProgramming_6
   3349            {
   3350              return(SD_ADDR_OUT_OF_RANGE);
   \   00000090   0x201C             MOVS     R0,#+28
   \   00000092   0xE05A             B.N      ??SD_IsCardProgramming_2
   3351            }
   3352            
   3353            if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
   \                     ??SD_IsCardProgramming_6: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x0040             LSLS     R0,R0,#+1
   \   00000098   0xD501             BPL.N    ??SD_IsCardProgramming_7
   3354            {
   3355              return(SD_ADDR_MISALIGNED);
   \   0000009A   0x2009             MOVS     R0,#+9
   \   0000009C   0xE055             B.N      ??SD_IsCardProgramming_2
   3356            }
   3357            
   3358            if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
   \                     ??SD_IsCardProgramming_7: (+1)
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x0080             LSLS     R0,R0,#+2
   \   000000A2   0xD501             BPL.N    ??SD_IsCardProgramming_8
   3359            {
   3360              return(SD_BLOCK_LEN_ERR);
   \   000000A4   0x200A             MOVS     R0,#+10
   \   000000A6   0xE050             B.N      ??SD_IsCardProgramming_2
   3361            }
   3362            
   3363            if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
   \                     ??SD_IsCardProgramming_8: (+1)
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
   \   000000AA   0x00C0             LSLS     R0,R0,#+3
   \   000000AC   0xD501             BPL.N    ??SD_IsCardProgramming_9
   3364            {
   3365              return(SD_ERASE_SEQ_ERR);
   \   000000AE   0x200B             MOVS     R0,#+11
   \   000000B0   0xE04B             B.N      ??SD_IsCardProgramming_2
   3366            }
   3367            
   3368            if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
   \                     ??SD_IsCardProgramming_9: (+1)
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x0100             LSLS     R0,R0,#+4
   \   000000B6   0xD501             BPL.N    ??SD_IsCardProgramming_10
   3369            {
   3370              return(SD_BAD_ERASE_PARAM);
   \   000000B8   0x200C             MOVS     R0,#+12
   \   000000BA   0xE046             B.N      ??SD_IsCardProgramming_2
   3371            }
   3372            
   3373            if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
   \                     ??SD_IsCardProgramming_10: (+1)
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0x0140             LSLS     R0,R0,#+5
   \   000000C0   0xD501             BPL.N    ??SD_IsCardProgramming_11
   3374            {
   3375              return(SD_WRITE_PROT_VIOLATION);
   \   000000C2   0x200D             MOVS     R0,#+13
   \   000000C4   0xE041             B.N      ??SD_IsCardProgramming_2
   3376            }
   3377            
   3378            if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
   \                     ??SD_IsCardProgramming_11: (+1)
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x01C0             LSLS     R0,R0,#+7
   \   000000CA   0xD501             BPL.N    ??SD_IsCardProgramming_12
   3379            {
   3380              return(SD_LOCK_UNLOCK_FAILED);
   \   000000CC   0x200E             MOVS     R0,#+14
   \   000000CE   0xE03C             B.N      ??SD_IsCardProgramming_2
   3381            }
   3382            
   3383            if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
   \                     ??SD_IsCardProgramming_12: (+1)
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0x0200             LSLS     R0,R0,#+8
   \   000000D4   0xD501             BPL.N    ??SD_IsCardProgramming_13
   3384            {
   3385              return(SD_COM_CRC_FAILED);
   \   000000D6   0x200F             MOVS     R0,#+15
   \   000000D8   0xE037             B.N      ??SD_IsCardProgramming_2
   3386            }
   3387            
   3388            if((responseR1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
   \                     ??SD_IsCardProgramming_13: (+1)
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x0240             LSLS     R0,R0,#+9
   \   000000DE   0xD501             BPL.N    ??SD_IsCardProgramming_14
   3389            {
   3390              return(SD_ILLEGAL_CMD);
   \                     ??SD_IsCardProgramming_4: (+1)
   \   000000E0   0x2010             MOVS     R0,#+16
   \   000000E2   0xE032             B.N      ??SD_IsCardProgramming_2
   3391            }
   3392            
   3393            if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
   \                     ??SD_IsCardProgramming_14: (+1)
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0x0280             LSLS     R0,R0,#+10
   \   000000E8   0xD501             BPL.N    ??SD_IsCardProgramming_15
   3394            {
   3395              return(SD_CARD_ECC_FAILED);
   \   000000EA   0x2011             MOVS     R0,#+17
   \   000000EC   0xE02D             B.N      ??SD_IsCardProgramming_2
   3396            }
   3397            
   3398            if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
   \                     ??SD_IsCardProgramming_15: (+1)
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x02C0             LSLS     R0,R0,#+11
   \   000000F2   0xD501             BPL.N    ??SD_IsCardProgramming_16
   3399            {
   3400              return(SD_CC_ERROR);
   \   000000F4   0x2012             MOVS     R0,#+18
   \   000000F6   0xE028             B.N      ??SD_IsCardProgramming_2
   3401            }
   3402            
   3403            if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
   \                     ??SD_IsCardProgramming_16: (+1)
   \   000000F8   0x9800             LDR      R0,[SP, #+0]
   \   000000FA   0x0300             LSLS     R0,R0,#+12
   \   000000FC   0xD501             BPL.N    ??SD_IsCardProgramming_17
   3404            {
   3405              return(SD_GENERAL_UNKNOWN_ERROR);
   \   000000FE   0x2013             MOVS     R0,#+19
   \   00000100   0xE023             B.N      ??SD_IsCardProgramming_2
   3406            }
   3407            
   3408            if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
   \                     ??SD_IsCardProgramming_17: (+1)
   \   00000102   0x9800             LDR      R0,[SP, #+0]
   \   00000104   0x0340             LSLS     R0,R0,#+13
   \   00000106   0xD501             BPL.N    ??SD_IsCardProgramming_18
   3409            {
   3410              return(SD_STREAM_READ_UNDERRUN);
   \   00000108   0x2014             MOVS     R0,#+20
   \   0000010A   0xE01E             B.N      ??SD_IsCardProgramming_2
   3411            }
   3412            
   3413            if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
   \                     ??SD_IsCardProgramming_18: (+1)
   \   0000010C   0x9800             LDR      R0,[SP, #+0]
   \   0000010E   0x0380             LSLS     R0,R0,#+14
   \   00000110   0xD501             BPL.N    ??SD_IsCardProgramming_19
   3414            {
   3415              return(SD_STREAM_WRITE_OVERRUN);
   \   00000112   0x2015             MOVS     R0,#+21
   \   00000114   0xE019             B.N      ??SD_IsCardProgramming_2
   3416            }
   3417            
   3418            if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
   \                     ??SD_IsCardProgramming_19: (+1)
   \   00000116   0x9800             LDR      R0,[SP, #+0]
   \   00000118   0x03C0             LSLS     R0,R0,#+15
   \   0000011A   0xD501             BPL.N    ??SD_IsCardProgramming_20
   3419            {
   3420              return(SD_CID_CSD_OVERWRITE);
   \   0000011C   0x2016             MOVS     R0,#+22
   \   0000011E   0xE014             B.N      ??SD_IsCardProgramming_2
   3421            }
   3422            
   3423            if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
   \                     ??SD_IsCardProgramming_20: (+1)
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   \   00000122   0x0400             LSLS     R0,R0,#+16
   \   00000124   0xD501             BPL.N    ??SD_IsCardProgramming_21
   3424            {
   3425              return(SD_WP_ERASE_SKIP);
   \   00000126   0x2017             MOVS     R0,#+23
   \   00000128   0xE00F             B.N      ??SD_IsCardProgramming_2
   3426            }
   3427            
   3428            if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
   \                     ??SD_IsCardProgramming_21: (+1)
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0x0440             LSLS     R0,R0,#+17
   \   0000012E   0xD501             BPL.N    ??SD_IsCardProgramming_22
   3429            {
   3430              return(SD_CARD_ECC_DISABLED);
   \   00000130   0x2018             MOVS     R0,#+24
   \   00000132   0xE00A             B.N      ??SD_IsCardProgramming_2
   3431            }
   3432            
   3433            if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
   \                     ??SD_IsCardProgramming_22: (+1)
   \   00000134   0x9800             LDR      R0,[SP, #+0]
   \   00000136   0x0480             LSLS     R0,R0,#+18
   \   00000138   0xD501             BPL.N    ??SD_IsCardProgramming_23
   3434            {
   3435              return(SD_ERASE_RESET);
   \   0000013A   0x2019             MOVS     R0,#+25
   \   0000013C   0xE005             B.N      ??SD_IsCardProgramming_2
   3436            }
   3437            
   3438            if((responseR1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
   \                     ??SD_IsCardProgramming_23: (+1)
   \   0000013E   0x9800             LDR      R0,[SP, #+0]
   \   00000140   0x0700             LSLS     R0,R0,#+28
   \   00000142   0xD501             BPL.N    ??SD_IsCardProgramming_24
   3439            {
   3440              return(SD_AKE_SEQ_ERROR);
   \   00000144   0x201A             MOVS     R0,#+26
   \   00000146   0xE000             B.N      ??SD_IsCardProgramming_2
   3441            }
   3442            
   3443            return errorstate;
   \                     ??SD_IsCardProgramming_24: (+1)
   \   00000148   0x2000             MOVS     R0,#+0
   \                     ??SD_IsCardProgramming_2: (+1)
   \   0000014A   0xB007             ADD      SP,SP,#+28
   \   0000014C   0xBD30             POP      {R4,R5,PC}       ;; return
   3444          }   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x0001D4C0         DC32     0x1d4c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0xFFFF3CC5         DC32     0xffff3cc5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x80FFFF01         DC32     0x80ffff01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x80100000         DC32     0x80100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0xFDFFE008         DC32     0xfdffe008

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_2`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_3`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_4`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_5`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_6`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_7`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_8`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_9`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_10`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_11`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_12`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_13`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_14`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000021   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000031   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0}>`:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_15`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_16`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_17`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_18`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_19`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_20`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_21`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0}>_1`:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_22`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0}>_2`:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_23`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_24`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0}>_3`:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>_25`:
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   3445          
   3446          /**
   3447            * @}
   3448            */
   3449            
   3450          #endif /* STM32F103xE || STM32F103xG */
   3451          
   3452          #endif /* HAL_SD_MODULE_ENABLED */
   3453          
   3454          /**
   3455            * @}
   3456            */
   3457          
   3458          /**
   3459            * @}
   3460            */
   3461          
   3462          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_SD_CheckReadOperation
        16   -> HAL_SD_StopTransfer
      16   HAL_SD_CheckWriteOperation
        16   -> HAL_SD_GetStatus
        16   -> HAL_SD_StopTransfer
       0   HAL_SD_DMA_RxCpltCallback
       0   HAL_SD_DMA_RxErrorCallback
       0   HAL_SD_DMA_TxCpltCallback
       0   HAL_SD_DMA_TxErrorCallback
       8   HAL_SD_DeInit
         8   -> HAL_SD_MspDeInit
         8   -> SD_PowerOFF
      56   HAL_SD_Erase
        56   -> SDIO_GetResponse
        56   -> SDIO_SendCommand
        56   -> SD_CmdResp1Error
        56   -> SD_IsCardProgramming
        56   -> __aeabi_memclr4
      72   HAL_SD_GetCardStatus
        72   -> HAL_SD_SendSDStatus
       8   HAL_SD_GetStatus
         8   -> SD_GetState
      24   HAL_SD_Get_CardInfo
     144   HAL_SD_HighSpeed
       144   -> SDIO_DataConfig
       144   -> SDIO_ReadFIFO
       144   -> SDIO_SendCommand
       144   -> SD_CmdResp1Error
       144   -> SD_FindSCR
       144   -> __aeabi_memclr4
       8   HAL_SD_IRQHandler
         8   -> HAL_SD_XferCpltCallback
         8   -> HAL_SD_XferErrorCallback
      60   HAL_SD_Init
        48   -> HAL_SD_Get_CardInfo
        48   -> HAL_SD_MspInit
        48   -> SDIO_Init
        48   -> SD_Initialize_Cards
        48   -> SD_PowerON
        48   -> SD_Select_Deselect
        48   -> __aeabi_memclr4
        60   -> __aeabi_memcpy4
       0   HAL_SD_MspDeInit
       0   HAL_SD_MspInit
      80   HAL_SD_ReadBlocks
        80   -> HAL_SD_StopTransfer
        80   -> SDIO_DataConfig
        80   -> SDIO_ReadFIFO
        80   -> SDIO_SendCommand
        80   -> SD_CmdResp1Error
        80   -> __aeabi_memclr4
      72   HAL_SD_ReadBlocks_DMA
        72   -> HAL_DMA_Start_IT
        72   -> SDIO_DataConfig
        72   -> SDIO_SendCommand
        72   -> SD_CmdResp1Error
        72   -> SD_DMA_DIR
        72   -> __aeabi_memclr4
      72   HAL_SD_SendSDStatus
        72   -> SDIO_DataConfig
        72   -> SDIO_GetResponse
        72   -> SDIO_ReadFIFO
        72   -> SDIO_SendCommand
        72   -> SD_CmdResp1Error
        72   -> __aeabi_memclr4
      32   HAL_SD_StopTransfer
        32   -> SDIO_SendCommand
        32   -> SD_CmdResp1Error
        32   -> __aeabi_memclr4
      68   HAL_SD_WideBusOperation_Config
        56   -> SDIO_Init
        56   -> SD_WideBus_Disable
        56   -> SD_WideBus_Enable
        56   -> __aeabi_memclr4
        68   -> __aeabi_memcpy4
      80   HAL_SD_WriteBlocks
        80   -> HAL_SD_StopTransfer
        80   -> SDIO_DataConfig
        80   -> SDIO_SendCommand
        80   -> SDIO_WriteFIFO
        80   -> SD_CmdResp1Error
        80   -> SD_IsCardProgramming
        80   -> __aeabi_memclr4
      72   HAL_SD_WriteBlocks_DMA
        72   -> HAL_DMA_Start_IT
        72   -> SDIO_DataConfig
        72   -> SDIO_SendCommand
        72   -> SD_CmdResp1Error
        72   -> SD_DMA_DIR
        72   -> __aeabi_memclr4
       0   HAL_SD_XferCpltCallback
       0   HAL_SD_XferErrorCallback
       0   SD_CmdError
      16   SD_CmdResp1Error
        16   -> SDIO_GetCommandResponse
        16   -> SDIO_GetResponse
       0   SD_CmdResp2Error
       0   SD_CmdResp3Error
      16   SD_CmdResp6Error
        16   -> SDIO_GetCommandResponse
        16   -> SDIO_GetResponse
       0   SD_CmdResp7Error
       8   SD_DMA_RxCplt
         8   -> HAL_SD_DMA_RxCpltCallback
       8   SD_DMA_RxError
         8   -> HAL_SD_DMA_RxErrorCallback
       8   SD_DMA_TxCplt
         8   -> HAL_SD_DMA_TxCpltCallback
       8   SD_DMA_TxError
         8   -> HAL_SD_DMA_TxErrorCallback
      72   SD_FindSCR
        72   -> SDIO_DataConfig
        72   -> SDIO_ReadFIFO
        72   -> SDIO_SendCommand
        72   -> SD_CmdResp1Error
        72   -> __aeabi_memclr4
       8   SD_GetState
         8   -> SD_SendStatus
      40   SD_Initialize_Cards
        40   -> SDIO_GetPowerState
        40   -> SDIO_GetResponse
        40   -> SDIO_SendCommand
        40   -> SD_CmdResp2Error
        40   -> SD_CmdResp6Error
        40   -> __aeabi_memclr4
      40   SD_IsCardProgramming
        40   -> SDIO_GetCommandResponse
        40   -> SDIO_GetResponse
        40   -> SDIO_SendCommand
        40   -> __aeabi_memclr4
       8   SD_PowerOFF
         8   -> SDIO_PowerState_OFF
      56   SD_PowerON
        56   -> HAL_Delay
        56   -> SDIO_GetResponse
        56   -> SDIO_PowerState_ON
        56   -> SDIO_SendCommand
        56   -> SD_CmdError
        56   -> SD_CmdResp1Error
        56   -> SD_CmdResp3Error
        56   -> SD_CmdResp7Error
        56   -> __aeabi_memclr4
      40   SD_Select_Deselect
        40   -> SDIO_SendCommand
        40   -> SD_CmdResp1Error
        40   -> __aeabi_memclr4
      32   SD_SendStatus
        32   -> SDIO_GetResponse
        32   -> SDIO_SendCommand
        32   -> SD_CmdResp1Error
        32   -> __aeabi_memclr4
      40   SD_WideBus_Disable
        40   -> SDIO_GetResponse
        40   -> SDIO_SendCommand
        40   -> SD_CmdResp1Error
        40   -> SD_FindSCR
        40   -> __aeabi_memclr4
      40   SD_WideBus_Enable
        40   -> SDIO_GetResponse
        40   -> SDIO_SendCommand
        40   -> SD_CmdResp1Error
        40   -> SD_FindSCR
        40   -> __aeabi_memclr4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {0, 0}>
       8  ?<Constant {0, 0}>_1
       8  ?<Constant {0, 0}>_2
       8  ?<Constant {0, 0}>_3
      24  ?<Constant {0}>
      20  ?<Constant {0}>_1
      24  ?<Constant {0}>_10
      20  ?<Constant {0}>_11
      20  ?<Constant {0}>_12
      24  ?<Constant {0}>_13
      64  ?<Constant {0}>_14
      20  ?<Constant {0}>_15
      24  ?<Constant {0}>_16
      20  ?<Constant {0}>_17
      20  ?<Constant {0}>_18
      20  ?<Constant {0}>_19
      24  ?<Constant {0}>_2
      20  ?<Constant {0}>_20
      20  ?<Constant {0}>_21
      20  ?<Constant {0}>_22
      20  ?<Constant {0}>_23
      24  ?<Constant {0}>_24
      20  ?<Constant {0}>_25
      20  ?<Constant {0}>_3
      24  ?<Constant {0}>_4
      20  ?<Constant {0}>_5
      24  ?<Constant {0}>_6
      20  ?<Constant {0}>_7
      24  ?<Constant {0}>_8
      20  ?<Constant {0}>_9
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
      96  HAL_SD_CheckReadOperation
     114  HAL_SD_CheckWriteOperation
       2  HAL_SD_DMA_RxCpltCallback
       2  HAL_SD_DMA_RxErrorCallback
       2  HAL_SD_DMA_TxCpltCallback
       2  HAL_SD_DMA_TxErrorCallback
      18  HAL_SD_DeInit
     282  HAL_SD_Erase
     124  HAL_SD_GetCardStatus
      26  HAL_SD_GetStatus
     742  HAL_SD_Get_CardInfo
     338  HAL_SD_HighSpeed
     158  HAL_SD_IRQHandler
     178  HAL_SD_Init
       2  HAL_SD_MspDeInit
       2  HAL_SD_MspInit
     430  HAL_SD_ReadBlocks
     272  HAL_SD_ReadBlocks_DMA
     328  HAL_SD_SendSDStatus
      56  HAL_SD_StopTransfer
     136  HAL_SD_WideBusOperation_Config
     542  HAL_SD_WriteBlocks
     280  HAL_SD_WriteBlocks_DMA
       2  HAL_SD_XferCpltCallback
       2  HAL_SD_XferErrorCallback
      56  SD_CmdError
     234  SD_CmdResp1Error
      46  SD_CmdResp2Error
      34  SD_CmdResp3Error
     112  SD_CmdResp6Error
      88  SD_CmdResp7Error
      22  SD_DMA_RxCplt
      12  SD_DMA_RxError
      22  SD_DMA_TxCplt
      12  SD_DMA_TxError
     326  SD_FindSCR
      30  SD_GetState
     258  SD_Initialize_Cards
     334  SD_IsCardProgramming
      12  SD_PowerOFF
     368  SD_PowerON
      56  SD_Select_Deselect
      84  SD_SendStatus
     136  SD_WideBus_Disable
     136  SD_WideBus_Enable

 
   632 bytes in section .rodata
 6 534 bytes in section .text
 
 6 534 bytes of CODE  memory
   632 bytes of CONST memory

Errors: none
Warnings: 2
