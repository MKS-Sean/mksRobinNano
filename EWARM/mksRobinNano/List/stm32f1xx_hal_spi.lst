###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:07
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_hal_spi.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_hal_spi.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   SPI HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     11            *           + Initialization and de-initialization functions
     12            *           + IO operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The SPI HAL driver can be used as follows:
     21          
     22                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     23                    SPI_HandleTypeDef  hspi; 
     24          
     25                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit ()API:
     26                    (##) Enable the SPIx interface clock 
     27                    (##) SPI pins configuration
     28                        (+++) Enable the clock for the SPI GPIOs 
     29                        (+++) Configure these SPI pins as alternate function push-pull
     30                    (##) NVIC configuration if you need to use interrupt process
     31                        (+++) Configure the SPIx interrupt priority
     32                        (+++) Enable the NVIC SPI IRQ handle
     33                    (##) DMA Configuration if you need to use DMA process
     34                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Channel
     35                        (+++) Enable the DMAx clock
     36                        (+++) Configure the DMA handle parameters 
     37                        (+++) Configure the DMA Tx or Rx Channel
     38                        (+++) Associate the initilalized hdma_tx(or _rx) handle to the hspi DMA Tx (or Rx) handle
     39                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Channel
     40          
     41                (#) Program the Mode, Direction , Data size, Baudrate Prescaler, NSS 
     42                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     43          
     44                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     45                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     46                        by calling the customed HAL_SPI_MspInit() API.
     47               [..]
     48                 Circular mode restriction:
     49                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     50                    (##) Master 2Lines RxOnly
     51                    (##) Master 1Line Rx
     52                (#) The CRC feature is not managed when the DMA circular mode is enabled
     53                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs 
     54                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     55          
     56            @endverbatim
     57            ******************************************************************************
     58            * @attention
     59            *
     60            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     61            *
     62            * Redistribution and use in source and binary forms, with or without modification,
     63            * are permitted provided that the following conditions are met:
     64            *   1. Redistributions of source code must retain the above copyright notice,
     65            *      this list of conditions and the following disclaimer.
     66            *   2. Redistributions in binary form must reproduce the above copyright notice,
     67            *      this list of conditions and the following disclaimer in the documentation
     68            *      and/or other materials provided with the distribution.
     69            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     70            *      may be used to endorse or promote products derived from this software
     71            *      without specific prior written permission.
     72            *
     73            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     74            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     75            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     76            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     77            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     78            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     79            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     80            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     81            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     82            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     83            *
     84            ******************************************************************************
     85            */
     86          
     87          /*
     88              Using the HAL it is not possible to reach all supported SPI frequency with the differents SPI Modes,
     89              the following table resume the max SPI frequency reached with data size 8bits/16bits, 
     90              according to frequency used on APBx Peripheral Clock (fPCLK) used by the SPI instance :
     91          
     92              For 8 bits SPI data size transfers :
     93             +--------------------------------------------------------------------------------------------------+
     94             |         |                | 2Lines Fullduplex     |     2Lines RxOnly     |        1Line          |
     95             | Process | Tranfert mode  |-----------------------|-----------------------|-----------------------|
     96             |         |                |  Master   |  Slave    |  Master   |  Slave    |  Master   |  Slave    |
     97             |==================================================================================================|
     98             |    T    |     Polling    |  fPCLK/8  | fPCLK/8   |    NA     |    NA     |    NA     |    NA     |
     99             |    X    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    100             |    /    |     Interrupt  |  fPCLK/32 | fPCLK/32  |    NA     |    NA     |    NA     |    NA     |
    101             |    R    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    102             |    X    |       DMA      |  fPCLK/2  | fPCLK/4   |    NA     |    NA     |    NA     |    NA     |
    103             |=========|================|===========|===========|===========|===========|===========|===========|
    104             |         |     Polling    |  fPCLK/4  | fPCLK/8   | fPCLK/128 | fPCLK/16  | fPCLK/128 | fPCLK/8   |
    105             |         |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    106             |    R    |     Interrupt  |  fPCLK/32 | fPCLK/16  | fPCLK/128 | fPCLK/16  | fPCLK/128 | fPCLK/16  |
    107             |    X    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    108             |         |       DMA      |  fPCLK/2  |  fPCLK/2  | fPCLK/128 | fPCLK/16  | fPCLK/128 | fPCLK/2   |
    109             |=========|================|===========|===========|===========|===========|===========|===========|
    110             |         |     Polling    |  fPCLK/4  |  fPCLK/4  |    NA     |    NA     |  fPCLK/4  | fPCLK/64  |
    111             |         |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    112             |    T    |     Interrupt  |  fPCLK/8  | fPCLK/16  |    NA     |    NA     |  fPCLK/8  | fPCLK/128 |
    113             |    X    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    114             |         |       DMA      |  fPCLK/2  |  fPCLK/4  |    NA     |    NA     |  fPCLK/2  | fPCLK/64  |
    115             +--------------------------------------------------------------------------------------------------+
    116          
    117              For 16 bits SPI data size transfers :
    118             +--------------------------------------------------------------------------------------------------+
    119             |         |                | 2Lines Fullduplex     |     2Lines RxOnly     |        1Line          |
    120             | Process | Tranfert mode  |-----------------------|-----------------------|-----------------------|
    121             |         |                |  Master   |  Slave    |  Master   |  Slave    |  Master   |  Slave    |
    122             |==================================================================================================|
    123             |    T    |     Polling    |  fPCLK/2  | fPCLK/4   |    NA     |    NA     |    NA     |    NA     |
    124             |    X    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    125             |    /    |     Interrupt  |  fPCLK/16 | fPCLK/16  |    NA     |    NA     |    NA     |    NA     |
    126             |    R    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    127             |    X    |       DMA      |  fPCLK/2  | fPCLK/4   |    NA     |    NA     |    NA     |    NA     |
    128             |=========|================|===========|===========|===========|===========|===========|===========|
    129             |         |     Polling    |  fPCLK/2  |  fPCLK/4  | fPCLK/64  | fPCLK/8   | fPCLK/64  | fPCLK/4   |
    130             |         |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    131             |    R    |     Interrupt  |  fPCLK/16 |  fPCLK/8  | fPCLK/128 | fPCLK/8   | fPCLK/128 | fPCLK/8   |
    132             |    X    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    133             |         |       DMA      |  fPCLK/2  |  fPCLK/2  | fPCLK/128 | fPCLK/8   | fPCLK/128 | fPCLK/2   |
    134             |=========|================|===========|===========|===========|===========|===========|===========|
    135             |         |     Polling    |  fPCLK/2  |  fPCLK/4  |    NA     |    NA     |  fPCLK/2  | fPCLK/64  |
    136             |         |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    137             |    T    |     Interrupt  |  fPCLK/4  |  fPCLK/8  |    NA     |    NA     |  fPCLK/4  | fPCLK/256 |
    138             |    X    |----------------|-----------|-----------|-----------|-----------|-----------|-----------|
    139             |         |       DMA      |  fPCLK/2  |  fPCLK/4  |    NA     |    NA     |  fPCLK/2  | fPCLK/32  |
    140             +--------------------------------------------------------------------------------------------------+
    141          
    142            note: 
    143              The max SPI frequency depend on SPI data size (8bits, 16bits),
    144              SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
    145          
    146            note:
    147              TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
    148              RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
    149              TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()
    150          
    151          */
    152          
    153          /* Includes ------------------------------------------------------------------*/
    154          #include "stm32f1xx_hal.h"
    155          
    156          /** @addtogroup STM32F1xx_HAL_Driver
    157            * @{
    158            */
    159          
    160          /** @defgroup SPI SPI
    161            * @brief SPI HAL module driver
    162            * @{
    163            */
    164          
    165          #ifdef HAL_SPI_MODULE_ENABLED
    166          
    167          /* Private typedef -----------------------------------------------------------*/
    168          /* Private define ------------------------------------------------------------*/
    169          /** @defgroup SPI_Private_Constants SPI Private Constants
    170            * @{
    171            */
    172          #define SPI_TIMEOUT_VALUE  10
    173          /**
    174            * @}
    175            */
    176          
    177          /* Private macro -------------------------------------------------------------*/
    178          /* Private variables ---------------------------------------------------------*/
    179          /* Private function prototypes -----------------------------------------------*/
    180          /** @defgroup SPI_Private_Functions SPI Private Functions
    181            * @{
    182            */
    183          static void SPI_TxCloseIRQHandler(SPI_HandleTypeDef *hspi);
    184          static void SPI_TxISR(SPI_HandleTypeDef *hspi);
    185          static void SPI_RxCloseIRQHandler(SPI_HandleTypeDef *hspi);
    186          static void SPI_2LinesRxISR(SPI_HandleTypeDef *hspi);
    187          static void SPI_RxISR(SPI_HandleTypeDef *hspi);
    188          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    189          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    190          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    191          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    192          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    193          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    194          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    195          static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    196          /**
    197            * @}
    198            */
    199          
    200          /* Exported functions ---------------------------------------------------------*/
    201          
    202          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    203            * @{
    204            */
    205          
    206          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions 
    207           *  @brief    Initialization and Configuration functions 
    208           *
    209          @verbatim
    210           ===============================================================================
    211                        ##### Initialization and de-initialization functions #####
    212           ===============================================================================
    213              [..]  This subsection provides a set of functions allowing to initialize and 
    214                    de-initialiaze the SPIx peripheral:
    215          
    216                (+) User must implement HAL_SPI_MspInit() function in which he configures 
    217                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    218          
    219                (+) Call the function HAL_SPI_Init() to configure the selected device with 
    220                    the selected configuration:
    221                  (++) Mode
    222                  (++) Direction 
    223                  (++) Data Size
    224                  (++) Clock Polarity and Phase
    225                  (++) NSS Management
    226                  (++) BaudRate Prescaler
    227                  (++) FirstBit
    228                  (++) TIMode
    229                  (++) CRC Calculation
    230                  (++) CRC Polynomial if CRC enabled
    231          
    232                (+) Call the function HAL_SPI_DeInit() to restore the default configuration 
    233                    of the selected SPIx periperal.       
    234          
    235          @endverbatim
    236            * @{
    237            */
    238          
    239          /**
    240            * @brief  Initializes the SPI according to the specified parameters 
    241            *         in the SPI_InitTypeDef and create the associated handle.
    242            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    243            *                the configuration information for SPI module.
    244            * @retval HAL status
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          __weak HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    247          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    248            /* Check the SPI handle allocation */
    249            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_Init_0
    250            {
    251              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    252            }
    253          
    254            /* Check the parameters */
    255            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    256            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    257            assert_param(IS_SPI_DIRECTION_MODE(hspi->Init.Direction));
    258            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    259            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    260            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    261            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    262            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    263            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    264            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    265            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    266            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    267          
    268            if(hspi->State == HAL_SPI_STATE_RESET)
   \                     ??HAL_SPI_Init_0: (+1)
   \   0000000A   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_SPI_Init_1
    269            {
    270              /* Allocate lock resource and initialize it */
    271              hspi->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0050      STRB     R0,[R4, #+80]
    272              
    273              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    274              HAL_SPI_MspInit(hspi);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_SPI_MspInit
    275            }
    276            
    277            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0051      STRB     R0,[R4, #+81]
    278          
    279            /* Disble the selected SPI peripheral */
    280            __HAL_SPI_DISABLE(hspi);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    281          
    282            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    283            /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
    284            Communication speed, First bit and CRC calculation state */
    285            WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
    286                                            hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    287                                            hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x68A1             LDR      R1,[R4, #+8]
   \   00000032   0x4308             ORRS     R0,R1,R0
   \   00000034   0x68E1             LDR      R1,[R4, #+12]
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x6921             LDR      R1,[R4, #+16]
   \   0000003A   0x4308             ORRS     R0,R1,R0
   \   0000003C   0x6961             LDR      R1,[R4, #+20]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x69A1             LDR      R1,[R4, #+24]
   \   00000042   0xF401 0x7100      AND      R1,R1,#0x200
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x69E1             LDR      R1,[R4, #+28]
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x6A21             LDR      R1,[R4, #+32]
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x6AA1             LDR      R1,[R4, #+40]
   \   00000052   0x4308             ORRS     R0,R1,R0
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6008             STR      R0,[R1, #+0]
    288          
    289            /* Configure : NSS management */
    290            WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode));
   \   00000058   0x69A0             LDR      R0,[R4, #+24]
   \   0000005A   0x0C00             LSRS     R0,R0,#+16
   \   0000005C   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000060   0x6A61             LDR      R1,[R4, #+36]
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6048             STR      R0,[R1, #+4]
    291          
    292            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    293            /* Configure : CRC Polynomial */
    294            WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
   \   00000068   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6108             STR      R0,[R1, #+16]
    295          
    296            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x6560             STR      R0,[R4, #+84]
    297            hspi->State = HAL_SPI_STATE_READY;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xF884 0x0051      STRB     R0,[R4, #+81]
    298            
    299            return HAL_OK;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return
    300          }
    301          
    302          /**
    303            * @brief  DeInitializes the SPI peripheral 
    304            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    305            *                the configuration information for SPI module.
    306            * @retval HAL status
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    309          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    310            /* Check the SPI handle allocation */
    311            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    312            {
    313              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    314            }
    315          
    316            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF884 0x0051      STRB     R0,[R4, #+81]
    317          
    318            /* Disable the SPI Peripheral Clock */
    319            __HAL_SPI_DISABLE(hspi);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000018   0x6001             STR      R1,[R0, #+0]
    320          
    321            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    322            HAL_SPI_MspDeInit(hspi);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_SPI_MspDeInit
    323          
    324            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6560             STR      R0,[R4, #+84]
    325            hspi->State = HAL_SPI_STATE_RESET;
   \   00000024   0xF884 0x0051      STRB     R0,[R4, #+81]
    326          
    327            /* Release Lock */
    328            __HAL_UNLOCK(hspi);
   \   00000028   0xF884 0x0050      STRB     R0,[R4, #+80]
    329          
    330            return HAL_OK;
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    331          }
    332          
    333          /**
    334            * @brief SPI MSP Init
    335            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    336            *               the configuration information for SPI module.
    337            * @retval None
    338            */

   \                                 In section .text, align 2, keep-with-next
    339           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    340           {
    341            /* Prevent unused argument(s) compilation warning */
    342            UNUSED(hspi);
    343             /* NOTE : This function Should not be modified, when the callback is needed,
    344                       the HAL_SPI_MspInit could be implenetd in the user file
    345             */
    346          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    347          
    348          /**
    349            * @brief SPI MSP DeInit
    350            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    351            *               the configuration information for SPI module.
    352            * @retval None
    353            */

   \                                 In section .text, align 2, keep-with-next
    354           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    355          {
    356            /* Prevent unused argument(s) compilation warning */
    357            UNUSED(hspi);
    358            /* NOTE : This function Should not be modified, when the callback is needed,
    359                      the HAL_SPI_MspDeInit could be implenetd in the user file
    360             */
    361          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    362          
    363          /**
    364            * @}
    365            */
    366          
    367          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    368           *  @brief   Data transfers functions
    369           *
    370          @verbatim
    371            ==============================================================================
    372                                ##### IO operation functions #####
    373           ===============================================================================
    374              This subsection provides a set of functions allowing to manage the SPI
    375              data transfers.
    376          
    377              [..] The SPI supports master and slave mode :
    378          
    379              (#) There are two modes of transfer:
    380                 (++) Blocking mode: The communication is performed in polling mode.
    381                      The HAL status of all data processing is returned by the same function
    382                      after finishing transfer.
    383                 (++) No-Blocking mode: The communication is performed using Interrupts
    384                      or DMA, These APIs return the HAL status.
    385                      The end of the data processing will be indicated through the 
    386                      dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when 
    387                      using DMA mode.
    388                      The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks 
    389                      will be executed respectivelly at the end of the transmit or Receive process
    390                      The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    391          
    392              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    393                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    394          
    395          @endverbatim
    396            * @{
    397            */
    398          
    399          /**
    400            * @brief  Transmit an amount of data in blocking mode
    401            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    402            *                the configuration information for SPI module.
    403            * @param  pData: pointer to data buffer
    404            * @param  Size: amount of data to be sent
    405            * @param  Timeout: Timeout duration
    406            * @retval HAL status
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    409          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x461D             MOV      R5,R3
    410          
    411            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000006   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xF040 0x80C7      BNE.W    ??HAL_SPI_Transmit_0
    412            {
    413              if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_SPI_Transmit_1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??HAL_SPI_Transmit_2
    414              {
    415                return  HAL_ERROR;
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    416              }
    417          
    418              /* Check the parameters */
    419              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    420          
    421              /* Process Locked */
    422              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   0000001C   0xF994 0x0050      LDRSB    R0,[R4, #+80]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xF000 0x80BC      BEQ.W    ??HAL_SPI_Transmit_0
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF884 0x0050      STRB     R0,[R4, #+80]
    423          
    424              /* Configure communication */
    425              hspi->State = HAL_SPI_STATE_BUSY_TX;
   \   0000002C   0x2012             MOVS     R0,#+18
   \   0000002E   0xF884 0x0051      STRB     R0,[R4, #+81]
    426              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6560             STR      R0,[R4, #+84]
    427          
    428              hspi->pTxBuffPtr  = pData;
   \   00000036   0x6321             STR      R1,[R4, #+48]
    429              hspi->TxXferSize  = Size;
   \   00000038   0x86A2             STRH     R2,[R4, #+52]
    430              hspi->TxXferCount = Size;
   \   0000003A   0x86E2             STRH     R2,[R4, #+54]
    431          
    432              /*Init field not used in handle to zero */
    433              hspi->TxISR = 0;
   \   0000003C   0x64E0             STR      R0,[R4, #+76]
    434              hspi->RxISR = 0;
   \   0000003E   0x64A0             STR      R0,[R4, #+72]
    435              hspi->pRxBuffPtr  = NULL;
   \   00000040   0x63A0             STR      R0,[R4, #+56]
    436              hspi->RxXferSize  = 0;
   \   00000042   0x87A0             STRH     R0,[R4, #+60]
    437              hspi->RxXferCount = 0;
   \   00000044   0x87E0             STRH     R0,[R4, #+62]
    438          
    439              /* Reset CRC Calculation */
    440              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000046   0x6AA0             LDR      R0,[R4, #+40]
   \   00000048   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000004C   0xD109             BNE.N    ??HAL_SPI_Transmit_3
    441              {
    442                SPI_RESET_CRC(hspi);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000056   0x6001             STR      R1,[R0, #+0]
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000060   0x6001             STR      R1,[R0, #+0]
    443              }
    444          
    445              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   00000062   0x68A0             LDR      R0,[R4, #+8]
   \   00000064   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000068   0xD104             BNE.N    ??HAL_SPI_Transmit_4
    446              {
    447                /* Configure communication direction : 1Line */
    448                SPI_1LINE_TX(hspi);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000072   0x6001             STR      R1,[R0, #+0]
    449              }
    450          
    451              /* Check if the SPI is already enabled */ 
    452              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x0649             LSLS     R1,R1,#+25
   \   0000007A   0xD403             BMI.N    ??HAL_SPI_Transmit_5
    453              {
    454                /* Enable SPI peripheral */
    455                __HAL_SPI_ENABLE(hspi);
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000082   0x6001             STR      R1,[R0, #+0]
    456              }
    457          
    458              /* Transmit data in 8 Bit mode */
    459              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   00000084   0x6860             LDR      R0,[R4, #+4]
   \   00000086   0x68E1             LDR      R1,[R4, #+12]
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xD12C             BNE.N    ??HAL_SPI_Transmit_6
    460              {
    461                if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD002             BEQ.N    ??HAL_SPI_Transmit_7
   \   00000090   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD11A             BNE.N    ??HAL_SPI_Transmit_8
    462                {
    463                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   00000096   0x6B20             LDR      R0,[R4, #+48]
   \   00000098   0x1C41             ADDS     R1,R0,#+1
   \   0000009A   0x6321             STR      R1,[R4, #+48]
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x60C8             STR      R0,[R1, #+12]
    464                  hspi->TxXferCount--;
   \   000000A2   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x86E0             STRH     R0,[R4, #+54]
   \   000000A8   0xE010             B.N      ??HAL_SPI_Transmit_8
    465                }
    466          
    467                while(hspi->TxXferCount > 0)
    468                {
    469                  /* Wait until TXE flag is set to send data */
    470                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   000000AA   0x462B             MOV      R3,R5
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0x2102             MOVS     R1,#+2
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD13A             BNE.N    ??HAL_SPI_Transmit_10
    471                  { 
    472                    return HAL_TIMEOUT;
    473                  }
    474                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \   000000BA   0x6B20             LDR      R0,[R4, #+48]
   \   000000BC   0x1C41             ADDS     R1,R0,#+1
   \   000000BE   0x6321             STR      R1,[R4, #+48]
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x60C8             STR      R0,[R1, #+12]
    475                  hspi->TxXferCount--;
   \   000000C6   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000C8   0x1E40             SUBS     R0,R0,#+1
   \   000000CA   0x86E0             STRH     R0,[R4, #+54]
    476                }
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   000000CC   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD1EB             BNE.N    ??HAL_SPI_Transmit_9
    477                /* Enable CRC Transmission */
    478                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \   000000D2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D4   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000D8   0xD135             BNE.N    ??HAL_SPI_Transmit_11
    479                {
    480                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000E2   0x6001             STR      R1,[R0, #+0]
   \   000000E4   0xE02F             B.N      ??HAL_SPI_Transmit_11
    481                }
    482              }
    483              /* Transmit data in 16 Bit mode */
    484              else
    485              {
    486                if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD002             BEQ.N    ??HAL_SPI_Transmit_12
   \   000000EA   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD114             BNE.N    ??HAL_SPI_Transmit_13
    487                {
    488                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   000000F0   0x6B20             LDR      R0,[R4, #+48]
   \   000000F2   0x8800             LDRH     R0,[R0, #+0]
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x60C8             STR      R0,[R1, #+12]
    489                  hspi->pTxBuffPtr+=2;
   \   000000F8   0x6B20             LDR      R0,[R4, #+48]
   \   000000FA   0x1C80             ADDS     R0,R0,#+2
   \   000000FC   0x6320             STR      R0,[R4, #+48]
    490                  hspi->TxXferCount--;
   \   000000FE   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000100   0x1E40             SUBS     R0,R0,#+1
   \   00000102   0x86E0             STRH     R0,[R4, #+54]
   \   00000104   0xE009             B.N      ??HAL_SPI_Transmit_13
    491                }
    492          
    493                while(hspi->TxXferCount > 0)
    494                {
    495                  /* Wait until TXE flag is set to send data */
    496                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
    497                  { 
    498                    return HAL_TIMEOUT;
    499                  }
    500                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000106   0x6B20             LDR      R0,[R4, #+48]
   \   00000108   0x8800             LDRH     R0,[R0, #+0]
   \   0000010A   0x6821             LDR      R1,[R4, #+0]
   \   0000010C   0x60C8             STR      R0,[R1, #+12]
    501                  hspi->pTxBuffPtr+=2;
   \   0000010E   0x6B20             LDR      R0,[R4, #+48]
   \   00000110   0x1C80             ADDS     R0,R0,#+2
   \   00000112   0x6320             STR      R0,[R4, #+48]
    502                  hspi->TxXferCount--;
   \   00000114   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0x86E0             STRH     R0,[R4, #+54]
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   0000011A   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD009             BEQ.N    ??HAL_SPI_Transmit_15
   \   00000120   0x462B             MOV      R3,R5
   \   00000122   0x2200             MOVS     R2,#+0
   \   00000124   0x2102             MOVS     R1,#+2
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD0EA             BEQ.N    ??HAL_SPI_Transmit_14
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   00000130   0x2003             MOVS     R0,#+3
   \   00000132   0xBD32             POP      {R1,R4,R5,PC}
    503                }
    504                /* Enable CRC Transmission */
    505                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \                     ??HAL_SPI_Transmit_15: (+1)
   \   00000134   0x6AA0             LDR      R0,[R4, #+40]
   \   00000136   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000013A   0xD104             BNE.N    ??HAL_SPI_Transmit_11
    506                {
    507                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000013C   0x6820             LDR      R0,[R4, #+0]
   \   0000013E   0x6801             LDR      R1,[R0, #+0]
   \   00000140   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000144   0x6001             STR      R1,[R0, #+0]
    508                }
    509              }
    510          
    511              /* Wait until TXE flag is set to send data */
    512              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   00000146   0x462B             MOV      R3,R5
   \   00000148   0x2200             MOVS     R2,#+0
   \   0000014A   0x2102             MOVS     R1,#+2
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD005             BEQ.N    ??HAL_SPI_Transmit_16
    513              {
    514                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000156   0x6D60             LDR      R0,[R4, #+84]
   \   00000158   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000015C   0x6560             STR      R0,[R4, #+84]
    515                return HAL_TIMEOUT;
   \   0000015E   0x2003             MOVS     R0,#+3
   \   00000160   0xBD32             POP      {R1,R4,R5,PC}
    516              }
    517          
    518              /* Wait until Busy flag is reset before disabling SPI */
    519              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Transmit_16: (+1)
   \   00000162   0x462B             MOV      R3,R5
   \   00000164   0x2201             MOVS     R2,#+1
   \   00000166   0x2180             MOVS     R1,#+128
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD005             BEQ.N    ??HAL_SPI_Transmit_17
    520              { 
    521                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000172   0x6D60             LDR      R0,[R4, #+84]
   \   00000174   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000178   0x6560             STR      R0,[R4, #+84]
    522                return HAL_TIMEOUT;
   \   0000017A   0x2003             MOVS     R0,#+3
   \   0000017C   0xBD32             POP      {R1,R4,R5,PC}
    523              }
    524           
    525              /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    526              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_17: (+1)
   \   0000017E   0x68A0             LDR      R0,[R4, #+8]
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD105             BNE.N    ??HAL_SPI_Transmit_18
    527              {
    528                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000184   0x6820             LDR      R0,[R4, #+0]
   \   00000186   0x68C1             LDR      R1,[R0, #+12]
   \   00000188   0x9100             STR      R1,[SP, #+0]
   \   0000018A   0x6880             LDR      R0,[R0, #+8]
   \   0000018C   0x9000             STR      R0,[SP, #+0]
   \   0000018E   0x9800             LDR      R0,[SP, #+0]
    529              }
    530          
    531              hspi->State = HAL_SPI_STATE_READY; 
   \                     ??HAL_SPI_Transmit_18: (+1)
   \   00000190   0x2001             MOVS     R0,#+1
   \   00000192   0xF884 0x0051      STRB     R0,[R4, #+81]
    532          
    533              /* Process Unlocked */
    534              __HAL_UNLOCK(hspi);
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xF884 0x0050      STRB     R0,[R4, #+80]
    535          
    536              return HAL_OK;
   \   0000019C   0xBD32             POP      {R1,R4,R5,PC}
    537            }
    538            else
    539            {
    540              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   0000019E   0x2002             MOVS     R0,#+2
   \   000001A0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    541            }
    542          }
    543          
    544          /**
    545            * @brief  Receive an amount of data in blocking mode 
    546            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    547            *                the configuration information for SPI module.
    548            * @param  pData: pointer to data buffer
    549            * @param  Size: amount of data to be sent
    550            * @param  Timeout: Timeout duration
    551            * @retval HAL status
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    554          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x461D             MOV      R5,R3
    555            __IO uint16_t tmpreg = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    556          
    557            if(hspi->State == HAL_SPI_STATE_READY)
   \   0000000C   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80FB      BNE.W    ??HAL_SPI_Receive_0
    558            {
    559              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD001             BEQ.N    ??HAL_SPI_Receive_1
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_SPI_Receive_2
    560              {
    561                return  HAL_ERROR;
   \                     ??HAL_SPI_Receive_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    562              }
    563          
    564              /* Process Locked */
    565              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_2: (+1)
   \   00000022   0xF994 0x0050      LDRSB    R0,[R4, #+80]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xF000 0x80F0      BEQ.W    ??HAL_SPI_Receive_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0050      STRB     R0,[R4, #+80]
    566          
    567              /* Configure communication */
    568              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000032   0x2022             MOVS     R0,#+34
   \   00000034   0xF884 0x0051      STRB     R0,[R4, #+81]
    569              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6560             STR      R0,[R4, #+84]
    570          
    571              hspi->pRxBuffPtr  = pData;
   \   0000003C   0x63A1             STR      R1,[R4, #+56]
    572              hspi->RxXferSize  = Size;
   \   0000003E   0x87A2             STRH     R2,[R4, #+60]
    573              hspi->RxXferCount = Size;
   \   00000040   0x87E2             STRH     R2,[R4, #+62]
    574          
    575              /*Init field not used in handle to zero */
    576              hspi->RxISR = 0;
   \   00000042   0x64A0             STR      R0,[R4, #+72]
    577              hspi->TxISR = 0;
   \   00000044   0x64E0             STR      R0,[R4, #+76]
    578              hspi->pTxBuffPtr  = NULL;
   \   00000046   0x6320             STR      R0,[R4, #+48]
    579              hspi->TxXferSize  = 0;
   \   00000048   0x86A0             STRH     R0,[R4, #+52]
    580              hspi->TxXferCount = 0;
   \   0000004A   0x86E0             STRH     R0,[R4, #+54]
    581          
    582              /* Configure communication direction : 1Line */
    583              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   0000004C   0x68A0             LDR      R0,[R4, #+8]
   \   0000004E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000052   0xD104             BNE.N    ??HAL_SPI_Receive_3
    584              {
    585                SPI_1LINE_RX(hspi);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6803             LDR      R3,[R0, #+0]
   \   00000058   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   0000005C   0x6003             STR      R3,[R0, #+0]
    586              }
    587          
    588              /* Reset CRC Calculation */
    589              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_3: (+1)
   \   0000005E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000060   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000064   0xD109             BNE.N    ??HAL_SPI_Receive_4
    590              {
    591                SPI_RESET_CRC(hspi);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6803             LDR      R3,[R0, #+0]
   \   0000006A   0xF423 0x5300      BIC      R3,R3,#0x2000
   \   0000006E   0x6003             STR      R3,[R0, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6803             LDR      R3,[R0, #+0]
   \   00000074   0xF443 0x5300      ORR      R3,R3,#0x2000
   \   00000078   0x6003             STR      R3,[R0, #+0]
    592              }
    593              
    594              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \                     ??HAL_SPI_Receive_4: (+1)
   \   0000007A   0x6860             LDR      R0,[R4, #+4]
   \   0000007C   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000080   0xD10C             BNE.N    ??HAL_SPI_Receive_5
   \   00000082   0x68A0             LDR      R0,[R4, #+8]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD109             BNE.N    ??HAL_SPI_Receive_5
    595              {
    596                /* Process Unlocked */
    597                __HAL_UNLOCK(hspi);
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0050      STRB     R0,[R4, #+80]
    598          
    599                /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    600                return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
   \   0000008E   0x9500             STR      R5,[SP, #+0]
   \   00000090   0x4613             MOV      R3,R2
   \   00000092   0x460A             MOV      R2,R1
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       HAL_SPI_TransmitReceive
   \   0000009A   0xBD32             POP      {R1,R4,R5,PC}
    601              }
    602          
    603              /* Check if the SPI is already enabled */ 
    604              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_5: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6801             LDR      R1,[R0, #+0]
   \   000000A0   0x0649             LSLS     R1,R1,#+25
   \   000000A2   0xD403             BMI.N    ??HAL_SPI_Receive_6
    605              {
    606                /* Enable SPI peripheral */
    607                __HAL_SPI_ENABLE(hspi);
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000AA   0x6001             STR      R1,[R0, #+0]
    608              }
    609          
    610              /* Receive data in 8 Bit mode */
    611              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_6: (+1)
   \   000000AC   0x68E0             LDR      R0,[R4, #+12]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD130             BNE.N    ??HAL_SPI_Receive_7
   \   000000B2   0xE010             B.N      ??HAL_SPI_Receive_8
    612              {
    613                while(hspi->RxXferCount > 1)
    614                {
    615                  /* Wait until RXNE flag is set */
    616                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_9: (+1)
   \   000000B4   0x462B             MOV      R3,R5
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD13B             BNE.N    ??HAL_SPI_Receive_10
    617                  { 
    618                    return HAL_TIMEOUT;
    619                  }
    620          
    621                  (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   000000C4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000C6   0x1C41             ADDS     R1,R0,#+1
   \   000000C8   0x63A1             STR      R1,[R4, #+56]
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x68C9             LDR      R1,[R1, #+12]
   \   000000CE   0x7001             STRB     R1,[R0, #+0]
    622                  hspi->RxXferCount--;
   \   000000D0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   \   000000D4   0x87E0             STRH     R0,[R4, #+62]
    623                }
   \                     ??HAL_SPI_Receive_8: (+1)
   \   000000D6   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D8   0x2802             CMP      R0,#+2
   \   000000DA   0xDAEB             BGE.N    ??HAL_SPI_Receive_9
    624                /* Enable CRC Reception */
    625                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \   000000DC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000DE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000E2   0xD123             BNE.N    ??HAL_SPI_Receive_11
    626                {
    627                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000EC   0x6001             STR      R1,[R0, #+0]
   \   000000EE   0xE01D             B.N      ??HAL_SPI_Receive_11
    628                }
    629              }
    630              /* Receive data in 16 Bit mode */
    631              else
    632              {
    633                while(hspi->RxXferCount > 1)
    634                {
    635                  /* Wait until RXNE flag is set to read data */
    636                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_12: (+1)
   \   000000F0   0x462B             MOV      R3,R5
   \   000000F2   0x2200             MOVS     R2,#+0
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD11D             BNE.N    ??HAL_SPI_Receive_10
    637                  { 
    638                    return HAL_TIMEOUT;
    639                  }
    640          
    641                  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x68C0             LDR      R0,[R0, #+12]
   \   00000104   0x6BA1             LDR      R1,[R4, #+56]
   \   00000106   0x8008             STRH     R0,[R1, #+0]
    642                  hspi->pRxBuffPtr+=2;
   \   00000108   0x6BA0             LDR      R0,[R4, #+56]
   \   0000010A   0x1C80             ADDS     R0,R0,#+2
   \   0000010C   0x63A0             STR      R0,[R4, #+56]
    643                  hspi->RxXferCount--;
   \   0000010E   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000110   0x1E40             SUBS     R0,R0,#+1
   \   00000112   0x87E0             STRH     R0,[R4, #+62]
    644                }
   \                     ??HAL_SPI_Receive_7: (+1)
   \   00000114   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000116   0x2802             CMP      R0,#+2
   \   00000118   0xDAEA             BGE.N    ??HAL_SPI_Receive_12
    645                /* Enable CRC Reception */
    646                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) 
   \   0000011A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000011C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000120   0xD104             BNE.N    ??HAL_SPI_Receive_11
    647                {
    648                  SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6801             LDR      R1,[R0, #+0]
   \   00000126   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000012A   0x6001             STR      R1,[R0, #+0]
    649                }
    650              }
    651          
    652              /* Wait until RXNE flag is set */
    653              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_Receive_11: (+1)
   \   0000012C   0x462B             MOV      R3,R5
   \   0000012E   0x2200             MOVS     R2,#+0
   \   00000130   0x2101             MOVS     R1,#+1
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD001             BEQ.N    ??HAL_SPI_Receive_13
    654              { 
    655                return HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_10: (+1)
   \   0000013C   0x2003             MOVS     R0,#+3
   \   0000013E   0xBD32             POP      {R1,R4,R5,PC}
    656              }
    657          
    658              /* Receive last data in 8 Bit mode */
    659              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_13: (+1)
   \   00000140   0x6BA0             LDR      R0,[R4, #+56]
   \   00000142   0x68E1             LDR      R1,[R4, #+12]
   \   00000144   0x2900             CMP      R1,#+0
   \   00000146   0xD105             BNE.N    ??HAL_SPI_Receive_14
    660              {
    661                (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   00000148   0x1C41             ADDS     R1,R0,#+1
   \   0000014A   0x63A1             STR      R1,[R4, #+56]
   \   0000014C   0x6821             LDR      R1,[R4, #+0]
   \   0000014E   0x68C9             LDR      R1,[R1, #+12]
   \   00000150   0x7001             STRB     R1,[R0, #+0]
   \   00000152   0xE005             B.N      ??HAL_SPI_Receive_15
    662              }
    663              /* Receive last data in 16 Bit mode */
    664              else
    665              {
    666                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_14: (+1)
   \   00000154   0x6821             LDR      R1,[R4, #+0]
   \   00000156   0x68C9             LDR      R1,[R1, #+12]
   \   00000158   0x8001             STRH     R1,[R0, #+0]
    667                hspi->pRxBuffPtr+=2;
   \   0000015A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000015C   0x1C80             ADDS     R0,R0,#+2
   \   0000015E   0x63A0             STR      R0,[R4, #+56]
    668              }
    669              hspi->RxXferCount--;
   \                     ??HAL_SPI_Receive_15: (+1)
   \   00000160   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000162   0x1E40             SUBS     R0,R0,#+1
   \   00000164   0x87E0             STRH     R0,[R4, #+62]
    670          
    671              /* If CRC computation is enabled */
    672              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000166   0x6AA0             LDR      R0,[R4, #+40]
   \   00000168   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000016C   0xD113             BNE.N    ??HAL_SPI_Receive_16
    673              {
    674                /* Wait until RXNE flag is set: CRC Received */
    675                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   0000016E   0x462B             MOV      R3,R5
   \   00000170   0x2200             MOVS     R2,#+0
   \   00000172   0x2101             MOVS     R1,#+1
   \   00000174   0x4620             MOV      R0,R4
   \   00000176   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000017A   0x2800             CMP      R0,#+0
   \   0000017C   0xD005             BEQ.N    ??HAL_SPI_Receive_17
    676                {
    677                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   0000017E   0x6D60             LDR      R0,[R4, #+84]
   \   00000180   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000184   0x6560             STR      R0,[R4, #+84]
    678                  return HAL_TIMEOUT;
   \   00000186   0x2003             MOVS     R0,#+3
   \   00000188   0xBD32             POP      {R1,R4,R5,PC}
    679                }
    680          
    681                /* Read CRC to clear RXNE flag */
    682                tmpreg = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_17: (+1)
   \   0000018A   0x6820             LDR      R0,[R4, #+0]
   \   0000018C   0x68C0             LDR      R0,[R0, #+12]
   \   0000018E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    683                UNUSED(tmpreg);
   \   00000192   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
    684              }
    685              
    686              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??HAL_SPI_Receive_16: (+1)
   \   00000196   0x6860             LDR      R0,[R4, #+4]
   \   00000198   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000019C   0xD10B             BNE.N    ??HAL_SPI_Receive_18
   \   0000019E   0x68A0             LDR      R0,[R4, #+8]
   \   000001A0   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000001A4   0xD002             BEQ.N    ??HAL_SPI_Receive_19
   \   000001A6   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000001AA   0xD104             BNE.N    ??HAL_SPI_Receive_18
    687              {
    688                /* Disable SPI peripheral */
    689                __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_Receive_19: (+1)
   \   000001AC   0x6820             LDR      R0,[R4, #+0]
   \   000001AE   0x6801             LDR      R1,[R0, #+0]
   \   000001B0   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000001B4   0x6001             STR      R1,[R0, #+0]
    690              }
    691          
    692              hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Receive_18: (+1)
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0xF884 0x0051      STRB     R0,[R4, #+81]
    693          
    694              /* Check if CRC error occurred */
    695              if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
   \   000001BC   0x6AA0             LDR      R0,[R4, #+40]
   \   000001BE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001C2   0xD11F             BNE.N    ??HAL_SPI_Receive_20
   \   000001C4   0x6820             LDR      R0,[R4, #+0]
   \   000001C6   0x6880             LDR      R0,[R0, #+8]
   \   000001C8   0x06C0             LSLS     R0,R0,#+27
   \   000001CA   0xD51B             BPL.N    ??HAL_SPI_Receive_20
    696              {  
    697                /* Check if CRC error is valid or not (workaround to be applied or not) */
    698                if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR)
   \   000001CC   0x4620             MOV      R0,R4
   \   000001CE   0x.... 0x....      BL       SPI_ISCRCErrorValid
   \   000001D2   0x2801             CMP      R0,#+1
   \   000001D4   0xD112             BNE.N    ??HAL_SPI_Receive_21
    699                {
    700                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   000001D6   0x6D60             LDR      R0,[R4, #+84]
   \   000001D8   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001DC   0x6560             STR      R0,[R4, #+84]
    701          
    702                  /* Reset CRC Calculation */
    703                  SPI_RESET_CRC(hspi);
   \   000001DE   0x6820             LDR      R0,[R4, #+0]
   \   000001E0   0x6801             LDR      R1,[R0, #+0]
   \   000001E2   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   000001E6   0x6001             STR      R1,[R0, #+0]
   \   000001E8   0x6820             LDR      R0,[R4, #+0]
   \   000001EA   0x6801             LDR      R1,[R0, #+0]
   \   000001EC   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000001F0   0x6001             STR      R1,[R0, #+0]
    704          
    705                  /* Process Unlocked */
    706                  __HAL_UNLOCK(hspi);
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0xF884 0x0050      STRB     R0,[R4, #+80]
    707          
    708                  return HAL_ERROR; 
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0xBD32             POP      {R1,R4,R5,PC}
    709                }
    710                else
    711                {
    712                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \                     ??HAL_SPI_Receive_21: (+1)
   \   000001FC   0xF06F 0x0010      MVN      R0,#+16
   \   00000200   0x6821             LDR      R1,[R4, #+0]
   \   00000202   0x6088             STR      R0,[R1, #+8]
    713                }
    714              }
    715          
    716              /* Process Unlocked */
    717              __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_20: (+1)
   \   00000204   0x2000             MOVS     R0,#+0
   \   00000206   0xF884 0x0050      STRB     R0,[R4, #+80]
    718          
    719              return HAL_OK;
   \   0000020A   0xBD32             POP      {R1,R4,R5,PC}
    720            }
    721            else
    722            {
    723              return HAL_BUSY;
   \                     ??HAL_SPI_Receive_0: (+1)
   \   0000020C   0x2002             MOVS     R0,#+2
   \   0000020E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    724            }
    725          }
    726          
    727          /**
    728            * @brief  Transmit and Receive an amount of data in blocking mode 
    729            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    730            *                the configuration information for SPI module.
    731            * @param  pTxData: pointer to transmission data buffer
    732            * @param  pRxData: pointer to reception data buffer to be
    733            * @param  Size: amount of data to be sent
    734            * @param  Timeout: Timeout duration
    735            * @retval HAL status
    736            */

   \                                 In section .text, align 2, keep-with-next
    737          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    738          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    739            __IO uint16_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    740          
    741            if((hspi->State == HAL_SPI_STATE_READY) || (hspi->State == HAL_SPI_STATE_BUSY_RX))
   \   0000000A   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_0
   \   00000012   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000016   0x2822             CMP      R0,#+34
   \   00000018   0xF040 0x8177      BNE.W    ??HAL_SPI_TransmitReceive_1
    742            {
    743              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_2
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_2
   \   00000024   0x2B00             CMP      R3,#+0
   \   00000026   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_3
    744              {
    745                return  HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
    746              }
    747          
    748              /* Check the parameters */
    749              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    750          
    751              /* Process Locked */
    752              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   0000002C   0xF994 0x0050      LDRSB    R0,[R4, #+80]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xF000 0x816A      BEQ.W    ??HAL_SPI_TransmitReceive_1
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x0050      STRB     R0,[R4, #+80]
    753           
    754              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    755              if(hspi->State == HAL_SPI_STATE_READY)
   \   0000003C   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_4
    756              {
    757                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0xF884 0x0051      STRB     R0,[R4, #+81]
    758              }
    759          
    760               /* Configure communication */   
    761              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6560             STR      R0,[R4, #+84]
    762          
    763              hspi->pRxBuffPtr  = pRxData;
   \   0000004E   0x63A2             STR      R2,[R4, #+56]
    764              hspi->RxXferSize  = Size;
   \   00000050   0x87A3             STRH     R3,[R4, #+60]
    765              hspi->RxXferCount = Size;  
   \   00000052   0x87E3             STRH     R3,[R4, #+62]
    766              
    767              hspi->pTxBuffPtr  = pTxData;
   \   00000054   0x6321             STR      R1,[R4, #+48]
    768              hspi->TxXferSize  = Size; 
   \   00000056   0x86A3             STRH     R3,[R4, #+52]
    769              hspi->TxXferCount = Size;
   \   00000058   0x86E3             STRH     R3,[R4, #+54]
    770          
    771              /*Init field not used in handle to zero */
    772              hspi->RxISR = 0;
   \   0000005A   0x64A0             STR      R0,[R4, #+72]
    773              hspi->TxISR = 0;
   \   0000005C   0x64E0             STR      R0,[R4, #+76]
    774          
    775              /* Reset CRC Calculation */
    776              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000005E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000060   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000064   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_5
    777              {
    778                SPI_RESET_CRC(hspi);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000078   0x6001             STR      R1,[R0, #+0]
    779              }
    780          
    781              /* Check if the SPI is already enabled */ 
    782              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0649             LSLS     R1,R1,#+25
   \   00000080   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_6
    783              {
    784                /* Enable SPI peripheral */
    785                __HAL_SPI_ENABLE(hspi);
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000088   0x6001             STR      R1,[R0, #+0]
    786              }
    787          
    788              /* Transmit and Receive data in 16 Bit mode */
    789              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   0000008A   0x6860             LDR      R0,[R4, #+4]
   \   0000008C   0x9D04             LDR      R5,[SP, #+16]
   \   0000008E   0x68E1             LDR      R1,[R4, #+12]
   \   00000090   0xF5B1 0x6F00      CMP      R1,#+2048
   \   00000094   0xD17D             BNE.N    ??HAL_SPI_TransmitReceive_7
    790              {
    791                if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_8
   \   0000009A   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000009E   0xD10C             BNE.N    ??HAL_SPI_TransmitReceive_9
   \   000000A0   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_9
    792                {
    793                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   000000A6   0x6B20             LDR      R0,[R4, #+48]
   \   000000A8   0x8800             LDRH     R0,[R0, #+0]
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x60C8             STR      R0,[R1, #+12]
    794                  hspi->pTxBuffPtr+=2;
   \   000000AE   0x6B20             LDR      R0,[R4, #+48]
   \   000000B0   0x1C80             ADDS     R0,R0,#+2
   \   000000B2   0x6320             STR      R0,[R4, #+48]
    795                  hspi->TxXferCount--;
   \   000000B4   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000B6   0x1E40             SUBS     R0,R0,#+1
   \   000000B8   0x86E0             STRH     R0,[R4, #+54]
    796                }
    797                if(hspi->TxXferCount == 0)
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   000000BA   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD14E             BNE.N    ??HAL_SPI_TransmitReceive_10
    798                {
    799                  /* Enable CRC Transmission */
    800                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   000000C0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C2   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000C6   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_11
    801                  {
    802                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000D0   0x6001             STR      R1,[R0, #+0]
    803                  }
    804          
    805                  /* Wait until RXNE flag is set */
    806                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   000000D2   0x462B             MOV      R3,R5
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0x2101             MOVS     R1,#+1
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xF040 0x80C0      BNE.W    ??HAL_SPI_TransmitReceive_12
    807                  { 
    808                    return HAL_TIMEOUT;
    809                  }
    810          
    811                  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x68C0             LDR      R0,[R0, #+12]
   \   000000E8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000EA   0x8008             STRH     R0,[R1, #+0]
    812                  hspi->pRxBuffPtr+=2;
   \   000000EC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EE   0x1C80             ADDS     R0,R0,#+2
   \   000000F0   0x63A0             STR      R0,[R4, #+56]
    813                  hspi->RxXferCount--;
   \   000000F2   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000F4   0x1E40             SUBS     R0,R0,#+1
   \   000000F6   0x87E0             STRH     R0,[R4, #+62]
   \   000000F8   0xE0BF             B.N      ??HAL_SPI_TransmitReceive_13
    814                }
    815                else
    816                {
    817                  while(hspi->TxXferCount > 0)
    818                  {
    819                    /* Wait until TXE flag is set to send data */
    820                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \   000000FA   0x462B             MOV      R3,R5
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0x2102             MOVS     R1,#+2
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xF040 0x80AC      BNE.W    ??HAL_SPI_TransmitReceive_12
    821                    { 
    822                      return HAL_TIMEOUT;
    823                    }
    824          
    825                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \   0000010C   0x6B20             LDR      R0,[R4, #+48]
   \   0000010E   0x8800             LDRH     R0,[R0, #+0]
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x60C8             STR      R0,[R1, #+12]
    826                    hspi->pTxBuffPtr+=2;
   \   00000114   0x6B20             LDR      R0,[R4, #+48]
   \   00000116   0x1C80             ADDS     R0,R0,#+2
   \   00000118   0x6320             STR      R0,[R4, #+48]
    827                    hspi->TxXferCount--;
   \   0000011A   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000011C   0x1E40             SUBS     R0,R0,#+1
   \   0000011E   0x86E0             STRH     R0,[R4, #+54]
    828          
    829                    /* Enable CRC Transmission */
    830                    if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000120   0xB280             UXTH     R0,R0
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_15
   \   00000126   0x6AA0             LDR      R0,[R4, #+40]
   \   00000128   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000012C   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_15
    831                    {
    832                      SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000012E   0x6820             LDR      R0,[R4, #+0]
   \   00000130   0x6801             LDR      R1,[R0, #+0]
   \   00000132   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000136   0x6001             STR      R1,[R0, #+0]
    833                    }
    834          
    835                    /* Wait until RXNE flag is set */
    836                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \   00000138   0x462B             MOV      R3,R5
   \   0000013A   0x2200             MOVS     R2,#+0
   \   0000013C   0x2101             MOVS     R1,#+1
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xF040 0x808D      BNE.W    ??HAL_SPI_TransmitReceive_12
    837                    { 
    838                      return HAL_TIMEOUT;
    839                    }
    840          
    841                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   0000014A   0x6820             LDR      R0,[R4, #+0]
   \   0000014C   0x68C0             LDR      R0,[R0, #+12]
   \   0000014E   0x6BA1             LDR      R1,[R4, #+56]
   \   00000150   0x8008             STRH     R0,[R1, #+0]
    842                    hspi->pRxBuffPtr+=2;
   \   00000152   0x6BA0             LDR      R0,[R4, #+56]
   \   00000154   0x1C80             ADDS     R0,R0,#+2
   \   00000156   0x63A0             STR      R0,[R4, #+56]
    843                    hspi->RxXferCount--;
   \   00000158   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000015A   0x1E40             SUBS     R0,R0,#+1
   \   0000015C   0x87E0             STRH     R0,[R4, #+62]
    844                  }
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   0000015E   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD1CA             BNE.N    ??HAL_SPI_TransmitReceive_14
    845                  /* Receive the last byte */
    846                  if(hspi->Init.Mode == SPI_MODE_SLAVE)
   \   00000164   0x6860             LDR      R0,[R4, #+4]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xF040 0x8087      BNE.W    ??HAL_SPI_TransmitReceive_13
    847                  {
    848                    /* Wait until RXNE flag is set */
    849                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   0000016C   0x462B             MOV      R3,R5
   \   0000016E   0x2200             MOVS     R2,#+0
   \   00000170   0x2101             MOVS     R1,#+1
   \   00000172   0x4620             MOV      R0,R4
   \   00000174   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD173             BNE.N    ??HAL_SPI_TransmitReceive_12
    850                    {
    851                      return HAL_TIMEOUT;
    852                    }
    853                    
    854                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   0000017C   0x6820             LDR      R0,[R4, #+0]
   \   0000017E   0x68C0             LDR      R0,[R0, #+12]
   \   00000180   0x6BA1             LDR      R1,[R4, #+56]
   \   00000182   0x8008             STRH     R0,[R1, #+0]
    855                    hspi->pRxBuffPtr+=2;
   \   00000184   0x6BA0             LDR      R0,[R4, #+56]
   \   00000186   0x1C80             ADDS     R0,R0,#+2
   \   00000188   0x63A0             STR      R0,[R4, #+56]
    856                    hspi->RxXferCount--;
   \   0000018A   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000018C   0x1E40             SUBS     R0,R0,#+1
   \   0000018E   0x87E0             STRH     R0,[R4, #+62]
   \   00000190   0xE073             B.N      ??HAL_SPI_TransmitReceive_13
    857                  }
    858                }
    859              }
    860              /* Transmit and Receive data in 8 Bit mode */
    861              else
    862              {
    863                if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_16
   \   00000196   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000019A   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_17
   \   0000019C   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000019E   0x2801             CMP      R0,#+1
   \   000001A0   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_17
    864                {
    865                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \   000001A2   0x6B20             LDR      R0,[R4, #+48]
   \   000001A4   0x1C41             ADDS     R1,R0,#+1
   \   000001A6   0x6321             STR      R1,[R4, #+48]
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0x6821             LDR      R1,[R4, #+0]
   \   000001AC   0x60C8             STR      R0,[R1, #+12]
    866                  hspi->TxXferCount--;
   \   000001AE   0x8EE0             LDRH     R0,[R4, #+54]
   \   000001B0   0x1E40             SUBS     R0,R0,#+1
   \   000001B2   0x86E0             STRH     R0,[R4, #+54]
    867                }
    868                if(hspi->TxXferCount == 0)
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \   000001B4   0x8EE0             LDRH     R0,[R4, #+54]
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD146             BNE.N    ??HAL_SPI_TransmitReceive_18
    869                {
    870                  /* Enable CRC Transmission */
    871                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   000001BA   0x6AA0             LDR      R0,[R4, #+40]
   \   000001BC   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000001C0   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_19
    872                  {
    873                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0x6801             LDR      R1,[R0, #+0]
   \   000001C6   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000001CA   0x6001             STR      R1,[R0, #+0]
    874                  }
    875          
    876                  /* Wait until RXNE flag is set */
    877                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \   000001CC   0x462B             MOV      R3,R5
   \   000001CE   0x2200             MOVS     R2,#+0
   \   000001D0   0x2101             MOVS     R1,#+1
   \   000001D2   0x4620             MOV      R0,R4
   \   000001D4   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000001D8   0x2800             CMP      R0,#+0
   \   000001DA   0xD143             BNE.N    ??HAL_SPI_TransmitReceive_12
    878                  {
    879                    return HAL_TIMEOUT;
    880                  }
    881          
    882                  (*hspi->pRxBuffPtr) = hspi->Instance->DR;
   \   000001DC   0x6820             LDR      R0,[R4, #+0]
   \   000001DE   0x68C0             LDR      R0,[R0, #+12]
   \   000001E0   0x6BA1             LDR      R1,[R4, #+56]
   \   000001E2   0x7008             STRB     R0,[R1, #+0]
    883                  hspi->RxXferCount--;
   \   000001E4   0x8FE0             LDRH     R0,[R4, #+62]
   \   000001E6   0x1E40             SUBS     R0,R0,#+1
   \   000001E8   0x87E0             STRH     R0,[R4, #+62]
   \   000001EA   0xE046             B.N      ??HAL_SPI_TransmitReceive_13
    884                }
    885                else
    886                {
    887                  while(hspi->TxXferCount > 0)
    888                  {
    889                    /* Wait until TXE flag is set to send data */
    890                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \   000001EC   0x462B             MOV      R3,R5
   \   000001EE   0x2200             MOVS     R2,#+0
   \   000001F0   0x2102             MOVS     R1,#+2
   \   000001F2   0x4620             MOV      R0,R4
   \   000001F4   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000001F8   0x2800             CMP      R0,#+0
   \   000001FA   0xD133             BNE.N    ??HAL_SPI_TransmitReceive_12
    891                    {
    892                      return HAL_TIMEOUT;
    893                    }
    894          
    895                    hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \   000001FC   0x6B20             LDR      R0,[R4, #+48]
   \   000001FE   0x1C41             ADDS     R1,R0,#+1
   \   00000200   0x6321             STR      R1,[R4, #+48]
   \   00000202   0x7800             LDRB     R0,[R0, #+0]
   \   00000204   0x6821             LDR      R1,[R4, #+0]
   \   00000206   0x60C8             STR      R0,[R1, #+12]
    896                    hspi->TxXferCount--;
   \   00000208   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000020A   0x1E40             SUBS     R0,R0,#+1
   \   0000020C   0x86E0             STRH     R0,[R4, #+54]
    897          
    898                    /* Enable CRC Transmission */
    899                    if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   0000020E   0xB280             UXTH     R0,R0
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_21
   \   00000214   0x6AA0             LDR      R0,[R4, #+40]
   \   00000216   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000021A   0xD104             BNE.N    ??HAL_SPI_TransmitReceive_21
    900                    {
    901                      SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   0000021C   0x6820             LDR      R0,[R4, #+0]
   \   0000021E   0x6801             LDR      R1,[R0, #+0]
   \   00000220   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000224   0x6001             STR      R1,[R0, #+0]
    902                    }
    903          
    904                    /* Wait until RXNE flag is set */
    905                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \   00000226   0x462B             MOV      R3,R5
   \   00000228   0x2200             MOVS     R2,#+0
   \   0000022A   0x2101             MOVS     R1,#+1
   \   0000022C   0x4620             MOV      R0,R4
   \   0000022E   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000232   0x2800             CMP      R0,#+0
   \   00000234   0xD116             BNE.N    ??HAL_SPI_TransmitReceive_12
    906                    {
    907                      return HAL_TIMEOUT;
    908                    }
    909          
    910                    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   00000236   0x6BA0             LDR      R0,[R4, #+56]
   \   00000238   0x1C41             ADDS     R1,R0,#+1
   \   0000023A   0x63A1             STR      R1,[R4, #+56]
   \   0000023C   0x6821             LDR      R1,[R4, #+0]
   \   0000023E   0x68C9             LDR      R1,[R1, #+12]
   \   00000240   0x7001             STRB     R1,[R0, #+0]
    911                    hspi->RxXferCount--;
   \   00000242   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000244   0x1E40             SUBS     R0,R0,#+1
   \   00000246   0x87E0             STRH     R0,[R4, #+62]
    912                  }
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \   00000248   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000024A   0x2800             CMP      R0,#+0
   \   0000024C   0xD1CE             BNE.N    ??HAL_SPI_TransmitReceive_20
    913                  if(hspi->Init.Mode == SPI_MODE_SLAVE)
   \   0000024E   0x6860             LDR      R0,[R4, #+4]
   \   00000250   0x2800             CMP      R0,#+0
   \   00000252   0xD112             BNE.N    ??HAL_SPI_TransmitReceive_13
    914                  {
    915                    /* Wait until RXNE flag is set */
    916                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000254   0x462B             MOV      R3,R5
   \   00000256   0x2200             MOVS     R2,#+0
   \   00000258   0x2101             MOVS     R1,#+1
   \   0000025A   0x4620             MOV      R0,R4
   \   0000025C   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_22
    917                    {
    918                      return HAL_TIMEOUT;
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   00000264   0x2003             MOVS     R0,#+3
   \   00000266   0xBD32             POP      {R1,R4,R5,PC}
    919                    }
    920                    
    921                    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \   00000268   0x6BA0             LDR      R0,[R4, #+56]
   \   0000026A   0x1C41             ADDS     R1,R0,#+1
   \   0000026C   0x63A1             STR      R1,[R4, #+56]
   \   0000026E   0x6821             LDR      R1,[R4, #+0]
   \   00000270   0x68C9             LDR      R1,[R1, #+12]
   \   00000272   0x7001             STRB     R1,[R0, #+0]
    922                    hspi->RxXferCount--;
   \   00000274   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000276   0x1E40             SUBS     R0,R0,#+1
   \   00000278   0x87E0             STRH     R0,[R4, #+62]
    923                  }
    924                }
    925              }
    926          
    927              /* Read CRC from DR to close CRC calculation process */
    928              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \   0000027A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000027C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000280   0xD113             BNE.N    ??HAL_SPI_TransmitReceive_23
    929              {
    930                /* Wait until RXNE flag is set */
    931                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000282   0x462B             MOV      R3,R5
   \   00000284   0x2200             MOVS     R2,#+0
   \   00000286   0x2101             MOVS     R1,#+1
   \   00000288   0x4620             MOV      R0,R4
   \   0000028A   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000028E   0x2800             CMP      R0,#+0
   \   00000290   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_24
    932                {
    933                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   00000292   0x6D60             LDR      R0,[R4, #+84]
   \   00000294   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000298   0x6560             STR      R0,[R4, #+84]
    934                  return HAL_TIMEOUT;
   \   0000029A   0x2003             MOVS     R0,#+3
   \   0000029C   0xBD32             POP      {R1,R4,R5,PC}
    935                }
    936                /* Read CRC */
    937                tmpreg = hspi->Instance->DR;
   \                     ??HAL_SPI_TransmitReceive_24: (+1)
   \   0000029E   0x6820             LDR      R0,[R4, #+0]
   \   000002A0   0x68C0             LDR      R0,[R0, #+12]
   \   000002A2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    938                UNUSED(tmpreg);
   \   000002A6   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
    939              }
    940          
    941              /* Wait until Busy flag is reset before disabling SPI */
    942              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \   000002AA   0x462B             MOV      R3,R5
   \   000002AC   0x2201             MOVS     R2,#+1
   \   000002AE   0x2180             MOVS     R1,#+128
   \   000002B0   0x4620             MOV      R0,R4
   \   000002B2   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   000002B6   0x2800             CMP      R0,#+0
   \   000002B8   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_25
    943              {
    944                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   000002BA   0x6D60             LDR      R0,[R4, #+84]
   \   000002BC   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000002C0   0x6560             STR      R0,[R4, #+84]
    945                return HAL_TIMEOUT;
   \   000002C2   0x2003             MOVS     R0,#+3
   \   000002C4   0xBD32             POP      {R1,R4,R5,PC}
    946              }
    947              
    948              hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_25: (+1)
   \   000002C6   0x2001             MOVS     R0,#+1
   \   000002C8   0xF884 0x0051      STRB     R0,[R4, #+81]
    949          
    950              /* Check if CRC error occurred */
    951              if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
   \   000002CC   0x6AA0             LDR      R0,[R4, #+40]
   \   000002CE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000002D2   0xD116             BNE.N    ??HAL_SPI_TransmitReceive_26
   \   000002D4   0x6820             LDR      R0,[R4, #+0]
   \   000002D6   0x6880             LDR      R0,[R0, #+8]
   \   000002D8   0x06C0             LSLS     R0,R0,#+27
   \   000002DA   0xD512             BPL.N    ??HAL_SPI_TransmitReceive_26
    952              {
    953                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   000002DC   0x6D60             LDR      R0,[R4, #+84]
   \   000002DE   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000002E2   0x6560             STR      R0,[R4, #+84]
    954          
    955                SPI_RESET_CRC(hspi);
   \   000002E4   0x6820             LDR      R0,[R4, #+0]
   \   000002E6   0x6801             LDR      R1,[R0, #+0]
   \   000002E8   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   000002EC   0x6001             STR      R1,[R0, #+0]
   \   000002EE   0x6820             LDR      R0,[R4, #+0]
   \   000002F0   0x6801             LDR      R1,[R0, #+0]
   \   000002F2   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000002F6   0x6001             STR      R1,[R0, #+0]
    956          
    957                /* Process Unlocked */
    958                __HAL_UNLOCK(hspi);
   \   000002F8   0x2000             MOVS     R0,#+0
   \   000002FA   0xF884 0x0050      STRB     R0,[R4, #+80]
    959                
    960                return HAL_ERROR; 
   \   000002FE   0x2001             MOVS     R0,#+1
   \   00000300   0xBD32             POP      {R1,R4,R5,PC}
    961              }
    962          
    963              /* Process Unlocked */
    964              __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_26: (+1)
   \   00000302   0x2000             MOVS     R0,#+0
   \   00000304   0xF884 0x0050      STRB     R0,[R4, #+80]
    965          
    966              return HAL_OK;
   \   00000308   0xBD32             POP      {R1,R4,R5,PC}
    967            }
    968            else
    969            {
    970              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   0000030A   0x2002             MOVS     R0,#+2
   \   0000030C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    971            }
    972          }
    973          
    974          /**
    975            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    976            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    977            *                the configuration information for SPI module.
    978            * @param  pData: pointer to data buffer
    979            * @param  Size: amount of data to be sent
    980            * @retval HAL status
    981            */

   \                                 In section .text, align 2, keep-with-next
    982          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    983          {
    984            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xF990 0x3051      LDRSB    R3,[R0, #+81]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD14C             BNE.N    ??HAL_SPI_Transmit_IT_0
    985            {
    986              if((pData == NULL) || (Size == 0))
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD001             BEQ.N    ??HAL_SPI_Transmit_IT_1
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_2
    987              {
    988                return  HAL_ERROR;
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
    989              }
    990          
    991              /* Check the parameters */
    992              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    993          
    994              /* Process Locked */
    995              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   00000014   0xF990 0x3050      LDRSB    R3,[R0, #+80]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD042             BEQ.N    ??HAL_SPI_Transmit_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3050      STRB     R3,[R0, #+80]
    996          
    997              /* Configure communication */
    998              hspi->State        = HAL_SPI_STATE_BUSY_TX;
   \   00000022   0x2312             MOVS     R3,#+18
   \   00000024   0xF880 0x3051      STRB     R3,[R0, #+81]
    999              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x6543             STR      R3,[R0, #+84]
   1000          
   1001              hspi->TxISR        = &SPI_TxISR;
   \   0000002C   0x.... 0x....      ADR.W    R3,SPI_TxISR
   \   00000030   0x64C3             STR      R3,[R0, #+76]
   1002              hspi->pTxBuffPtr   = pData;
   \   00000032   0x6301             STR      R1,[R0, #+48]
   1003              hspi->TxXferSize   = Size;
   \   00000034   0x8682             STRH     R2,[R0, #+52]
   1004              hspi->TxXferCount  = Size;
   \   00000036   0x86C2             STRH     R2,[R0, #+54]
   1005          
   1006              /*Init field not used in handle to zero */
   1007              hspi->RxISR        = 0;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6481             STR      R1,[R0, #+72]
   1008              hspi->pRxBuffPtr   = NULL;
   \   0000003C   0x6381             STR      R1,[R0, #+56]
   1009              hspi->RxXferSize   = 0;
   \   0000003E   0x8781             STRH     R1,[R0, #+60]
   1010              hspi->RxXferCount  = 0;
   \   00000040   0x87C1             STRH     R1,[R0, #+62]
   1011          
   1012              /* Configure communication direction : 1Line */
   1013              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000042   0x6881             LDR      R1,[R0, #+8]
   \   00000044   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000048   0xD104             BNE.N    ??HAL_SPI_Transmit_IT_3
   1014              {
   1015                SPI_1LINE_TX(hspi);
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x680A             LDR      R2,[R1, #+0]
   \   0000004E   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   00000052   0x600A             STR      R2,[R1, #+0]
   1016              }
   1017          
   1018              /* Reset CRC Calculation */
   1019              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \   00000054   0x6A81             LDR      R1,[R0, #+40]
   \   00000056   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005A   0xD109             BNE.N    ??HAL_SPI_Transmit_IT_4
   1020              {
   1021                SPI_RESET_CRC(hspi);
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x680A             LDR      R2,[R1, #+0]
   \   00000060   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000064   0x600A             STR      R2,[R1, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0x680A             LDR      R2,[R1, #+0]
   \   0000006A   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   0000006E   0x600A             STR      R2,[R1, #+0]
   1022              }
   1023          
   1024              if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x6882             LDR      R2,[R0, #+8]
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0x684A             LDR      R2,[R1, #+4]
   \   00000078   0xD103             BNE.N    ??HAL_SPI_Transmit_IT_5
   1025              {
   1026                __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE));
   \   0000007A   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000007E   0x604A             STR      R2,[R1, #+4]
   \   00000080   0xE002             B.N      ??HAL_SPI_Transmit_IT_6
   1027              }
   1028              else
   1029              {
   1030                /* Enable TXE and ERR interrupt */
   1031                __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??HAL_SPI_Transmit_IT_5: (+1)
   \   00000082   0xF042 0x02A0      ORR      R2,R2,#0xA0
   \   00000086   0x604A             STR      R2,[R1, #+4]
   1032              }
   1033              /* Process Unlocked */
   1034              __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_6: (+1)
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0xF880 0x1050      STRB     R1,[R0, #+80]
   1035          
   1036              /* Check if the SPI is already enabled */ 
   1037              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0x0649             LSLS     R1,R1,#+25
   \   00000094   0xD403             BMI.N    ??HAL_SPI_Transmit_IT_7
   1038              {
   1039                /* Enable SPI peripheral */
   1040                __HAL_SPI_ENABLE(hspi);
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   1041              }
   1042          
   1043              return HAL_OK;
   \                     ??HAL_SPI_Transmit_IT_7: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4770             BX       LR
   1044            }
   1045            else
   1046            {
   1047              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   000000A2   0x2002             MOVS     R0,#+2
   \   000000A4   0x4770             BX       LR               ;; return
   1048            }
   1049          }
   1050          
   1051          /**
   1052            * @brief  Receive an amount of data in no-blocking mode with Interrupt
   1053            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1054            *                the configuration information for SPI module.
   1055            * @param  pData: pointer to data buffer
   1056            * @param  Size: amount of data to be sent
   1057            * @retval HAL status
   1058            */

   \                                 In section .text, align 2, keep-with-next
   1059          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1060          {
   1061            if(hspi->State == HAL_SPI_STATE_READY)
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xF990 0x3051      LDRSB    R3,[R0, #+81]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD151             BNE.N    ??HAL_SPI_Receive_IT_0
   1062            {
   1063              if((pData == NULL) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD001             BEQ.N    ??HAL_SPI_Receive_IT_1
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_SPI_Receive_IT_2
   1064              {
   1065                return  HAL_ERROR;
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1066              }
   1067          
   1068              /* Process Locked */
   1069              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   00000014   0xF990 0x3050      LDRSB    R3,[R0, #+80]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD047             BEQ.N    ??HAL_SPI_Receive_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3050      STRB     R3,[R0, #+80]
   1070          
   1071              /* Configure communication */
   1072              hspi->State        = HAL_SPI_STATE_BUSY_RX;
   \   00000022   0x2322             MOVS     R3,#+34
   \   00000024   0xF880 0x3051      STRB     R3,[R0, #+81]
   1073              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x6543             STR      R3,[R0, #+84]
   1074          
   1075              hspi->RxISR        = &SPI_RxISR;
   \   0000002C   0x.... 0x....      ADR.W    R3,SPI_RxISR
   \   00000030   0x6483             STR      R3,[R0, #+72]
   1076              hspi->pRxBuffPtr   = pData;
   \   00000032   0x6381             STR      R1,[R0, #+56]
   1077              hspi->RxXferSize   = Size;
   \   00000034   0x8782             STRH     R2,[R0, #+60]
   1078              hspi->RxXferCount  = Size ; 
   \   00000036   0x87C2             STRH     R2,[R0, #+62]
   1079          
   1080             /*Init field not used in handle to zero */
   1081              hspi->TxISR        = 0;
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x64C3             STR      R3,[R0, #+76]
   1082              hspi->pTxBuffPtr   = NULL;
   \   0000003C   0x6303             STR      R3,[R0, #+48]
   1083              hspi->TxXferSize   = 0;
   \   0000003E   0x8683             STRH     R3,[R0, #+52]
   1084              hspi->TxXferCount  = 0;
   \   00000040   0x86C3             STRH     R3,[R0, #+54]
   1085          
   1086              /* Configure communication direction : 1Line */
   1087              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000042   0x6883             LDR      R3,[R0, #+8]
   \   00000044   0xF5B3 0x4F00      CMP      R3,#+32768
   \   00000048   0xD124             BNE.N    ??HAL_SPI_Receive_IT_3
   1088              {
   1089                SPI_1LINE_RX(hspi);
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x680A             LDR      R2,[R1, #+0]
   \   0000004E   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   00000052   0x600A             STR      R2,[R1, #+0]
   1090              }
   1091              else if((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   1092              {
   1093                /* Process Unlocked */
   1094                __HAL_UNLOCK(hspi);
   1095          
   1096                /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1097                return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   1098              }
   1099          
   1100              /* Reset CRC Calculation */
   1101              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \   00000054   0x6A81             LDR      R1,[R0, #+40]
   \   00000056   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000005A   0xD109             BNE.N    ??HAL_SPI_Receive_IT_5
   1102              {
   1103                SPI_RESET_CRC(hspi);
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x680A             LDR      R2,[R1, #+0]
   \   00000060   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000064   0x600A             STR      R2,[R1, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0x680A             LDR      R2,[R1, #+0]
   \   0000006A   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   0000006E   0x600A             STR      R2,[R1, #+0]
   1104              }
   1105          
   1106              /* Enable TXE and ERR interrupt */
   1107              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x684A             LDR      R2,[R1, #+4]
   \   00000074   0xF042 0x0260      ORR      R2,R2,#0x60
   \   00000078   0x604A             STR      R2,[R1, #+4]
   1108          
   1109              /* Process Unlocked */
   1110              __HAL_UNLOCK(hspi);
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0xF880 0x1050      STRB     R1,[R0, #+80]
   1111          
   1112              /* Note : The SPI must be enabled after unlocking current process 
   1113                        to avoid the risk of SPI interrupt handle execution before current
   1114                        process unlock */
   1115          
   1116              /* Check if the SPI is already enabled */ 
   1117              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0x0649             LSLS     R1,R1,#+25
   \   00000086   0xD403             BMI.N    ??HAL_SPI_Receive_IT_6
   1118              {
   1119                /* Enable SPI peripheral */
   1120                __HAL_SPI_ENABLE(hspi);
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000008E   0x6001             STR      R1,[R0, #+0]
   1121              }
   1122          
   1123              return HAL_OK;
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x4770             BX       LR
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   00000094   0x2B00             CMP      R3,#+0
   \   00000096   0xD1DD             BNE.N    ??HAL_SPI_Receive_IT_4
   \   00000098   0x6843             LDR      R3,[R0, #+4]
   \   0000009A   0xF5B3 0x7F82      CMP      R3,#+260
   \   0000009E   0xD1D9             BNE.N    ??HAL_SPI_Receive_IT_4
   \   000000A0   0x2300             MOVS     R3,#+0
   \   000000A2   0xF880 0x3050      STRB     R3,[R0, #+80]
   \   000000A6   0x4613             MOV      R3,R2
   \   000000A8   0x460A             MOV      R2,R1
   \   000000AA   0x....             B.N      HAL_SPI_TransmitReceive_IT
   1124            }
   1125            else
   1126            {
   1127              return HAL_BUSY; 
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   000000AC   0x2002             MOVS     R0,#+2
   \   000000AE   0x4770             BX       LR               ;; return
   1128            }
   1129          }
   1130          
   1131          /**
   1132            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt 
   1133            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1134            *                the configuration information for SPI module.
   1135            * @param  pTxData: pointer to transmission data buffer
   1136            * @param  pRxData: pointer to reception data buffer to be
   1137            * @param  Size: amount of data to be sent
   1138            * @retval HAL status
   1139            */

   \                                 In section .text, align 2, keep-with-next
   1140          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1141          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1142          
   1143            if((hspi->State == HAL_SPI_STATE_READY) || \
   1144               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000002   0xF990 0x4051      LDRSB    R4,[R0, #+81]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD00A             BEQ.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000A   0x6844             LDR      R4,[R0, #+4]
   \   0000000C   0xF5B4 0x7F82      CMP      R4,#+260
   \   00000010   0xD14A             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000012   0x6884             LDR      R4,[R0, #+8]
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD147             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000018   0xF990 0x4051      LDRSB    R4,[R0, #+81]
   \   0000001C   0x2C22             CMP      R4,#+34
   \   0000001E   0xD143             BNE.N    ??HAL_SPI_TransmitReceive_IT_1
   1145            {
   1146              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_3
   1147              {
   1148                return  HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE03C             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1149              }
   1150          
   1151              /* Check the parameters */
   1152              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1153          
   1154              /* Process locked */
   1155              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   00000030   0xF990 0x4050      LDRSB    R4,[R0, #+80]
   \   00000034   0x2C01             CMP      R4,#+1
   \   00000036   0xD037             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000038   0x2401             MOVS     R4,#+1
   \   0000003A   0xF880 0x4050      STRB     R4,[R0, #+80]
   1156          
   1157              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1158              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   0000003E   0xF990 0x4051      LDRSB    R4,[R0, #+81]
   \   00000042   0x2C22             CMP      R4,#+34
   \   00000044   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_IT_5
   1159              {
   1160                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000046   0x2432             MOVS     R4,#+50
   \   00000048   0xF880 0x4051      STRB     R4,[R0, #+81]
   1161              }
   1162          
   1163              /* Configure communication */
   1164              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   0000004C   0x2400             MOVS     R4,#+0
   \   0000004E   0x6544             STR      R4,[R0, #+84]
   1165          
   1166              hspi->TxISR = &SPI_TxISR;
   \   00000050   0x.... 0x....      ADR.W    R4,SPI_TxISR
   \   00000054   0x64C4             STR      R4,[R0, #+76]
   1167              hspi->pTxBuffPtr   = pTxData;
   \   00000056   0x6301             STR      R1,[R0, #+48]
   1168              hspi->TxXferSize   = Size;
   \   00000058   0x8683             STRH     R3,[R0, #+52]
   1169              hspi->TxXferCount  = Size;
   \   0000005A   0x86C3             STRH     R3,[R0, #+54]
   1170          
   1171              hspi->RxISR = &SPI_2LinesRxISR;
   \   0000005C   0x.... 0x....      ADR.W    R1,SPI_2LinesRxISR
   \   00000060   0x6481             STR      R1,[R0, #+72]
   1172              hspi->pRxBuffPtr   = pRxData;
   \   00000062   0x6382             STR      R2,[R0, #+56]
   1173              hspi->RxXferSize   = Size;
   \   00000064   0x8783             STRH     R3,[R0, #+60]
   1174              hspi->RxXferCount  = Size;
   \   00000066   0x87C3             STRH     R3,[R0, #+62]
   1175          
   1176              /* Reset CRC Calculation */
   1177              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000068   0x6A81             LDR      R1,[R0, #+40]
   \   0000006A   0xF5B1 0x5F00      CMP      R1,#+8192
   \   0000006E   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_IT_6
   1178              {
   1179                SPI_RESET_CRC(hspi);
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x680A             LDR      R2,[R1, #+0]
   \   00000074   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000078   0x600A             STR      R2,[R1, #+0]
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0x680A             LDR      R2,[R1, #+0]
   \   0000007E   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   00000082   0x600A             STR      R2,[R1, #+0]
   1180              }
   1181          
   1182              /* Enable TXE, RXNE and ERR interrupt */
   1183              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0x684A             LDR      R2,[R1, #+4]
   \   00000088   0xF042 0x02E0      ORR      R2,R2,#0xE0
   \   0000008C   0x604A             STR      R2,[R1, #+4]
   1184          
   1185              /* Process Unlocked */
   1186              __HAL_UNLOCK(hspi);
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0xF880 0x1050      STRB     R1,[R0, #+80]
   1187          
   1188              /* Check if the SPI is already enabled */ 
   1189              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0649             LSLS     R1,R1,#+25
   \   0000009A   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_IT_7
   1190              {
   1191                /* Enable SPI peripheral */
   1192                __HAL_SPI_ENABLE(hspi);
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000A2   0x6001             STR      R1,[R0, #+0]
   1193              }
   1194          
   1195              return HAL_OK;
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE000             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1196            }
   1197            else
   1198            {
   1199              return HAL_BUSY; 
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   000000A8   0x2002             MOVS     R0,#+2
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   000000AA   0xBC10             POP      {R4}
   \   000000AC   0x4770             BX       LR               ;; return
   1200            }
   1201          }
   1202          
   1203          /**
   1204            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1205            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1206            *                the configuration information for SPI module.
   1207            * @param  pData: pointer to data buffer
   1208            * @param  Size: amount of data to be sent
   1209            * @retval HAL status
   1210            */

   \                                 In section .text, align 2, keep-with-next
   1211          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1212          {
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1213            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000004   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD156             BNE.N    ??HAL_SPI_Transmit_DMA_0
   1214            {
   1215              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_2
   1216              {
   1217                return  HAL_ERROR;
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
   1218              }
   1219          
   1220              /* Check the parameters */
   1221              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1222          
   1223              /* Process Locked */
   1224              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   00000018   0xF994 0x0050      LDRSB    R0,[R4, #+80]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD04C             BEQ.N    ??HAL_SPI_Transmit_DMA_0
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x0050      STRB     R0,[R4, #+80]
   1225          
   1226              /* Configure communication */
   1227              hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   00000026   0x2012             MOVS     R0,#+18
   \   00000028   0xF884 0x0051      STRB     R0,[R4, #+81]
   1228              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6560             STR      R0,[R4, #+84]
   1229          
   1230              hspi->pTxBuffPtr  = pData;
   \   00000030   0x6321             STR      R1,[R4, #+48]
   1231              hspi->TxXferSize  = Size;
   \   00000032   0x86A2             STRH     R2,[R4, #+52]
   1232              hspi->TxXferCount = Size;
   \   00000034   0x86E2             STRH     R2,[R4, #+54]
   1233          
   1234              /*Init field not used in handle to zero */
   1235              hspi->TxISR       = 0;
   \   00000036   0x64E0             STR      R0,[R4, #+76]
   1236              hspi->RxISR       = 0;
   \   00000038   0x64A0             STR      R0,[R4, #+72]
   1237              hspi->pRxBuffPtr  = NULL;
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
   1238              hspi->RxXferSize  = 0;
   \   0000003C   0x87A0             STRH     R0,[R4, #+60]
   1239              hspi->RxXferCount = 0;
   \   0000003E   0x87E0             STRH     R0,[R4, #+62]
   1240          
   1241              /* Configure communication direction : 1Line */
   1242              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000046   0xD104             BNE.N    ??HAL_SPI_Transmit_DMA_3
   1243              {
   1244                SPI_1LINE_TX(hspi);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000050   0x6001             STR      R1,[R0, #+0]
   1245              }
   1246          
   1247              /* Reset CRC Calculation */
   1248              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   00000052   0x6AA0             LDR      R0,[R4, #+40]
   \   00000054   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000058   0xD109             BNE.N    ??HAL_SPI_Transmit_DMA_4
   1249              {
   1250                SPI_RESET_CRC(hspi);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000062   0x6001             STR      R1,[R0, #+0]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   1251              }
   1252          
   1253              /* Set the SPI TxDMA Half transfer complete callback */
   1254              hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \   0000006E   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitCplt
   \   00000072   0x6C21             LDR      R1,[R4, #+64]
   \   00000074   0x62C8             STR      R0,[R1, #+44]
   1255          
   1256              /* Set the SPI TxDMA transfer complete callback */
   1257              hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   00000076   0x.... 0x....      ADR.W    R0,SPI_DMATransmitCplt
   \   0000007A   0x6C21             LDR      R1,[R4, #+64]
   \   0000007C   0x6288             STR      R0,[R1, #+40]
   1258          
   1259              /* Set the DMA error callback */
   1260              hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   0000007E   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   00000082   0x6C21             LDR      R1,[R4, #+64]
   \   00000084   0x6308             STR      R0,[R1, #+48]
   1261          
   1262              /* Enable the Tx DMA Channel */
   1263              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \   00000086   0x8EE3             LDRH     R3,[R4, #+54]
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0xF100 0x020C      ADD      R2,R0,#+12
   \   0000008E   0x6B21             LDR      R1,[R4, #+48]
   \   00000090   0x6C20             LDR      R0,[R4, #+64]
   \   00000092   0x.... 0x....      BL       HAL_DMA_Start_IT
   1264          
   1265              /* Enable Tx DMA Request */
   1266              SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6841             LDR      R1,[R0, #+4]
   \   0000009A   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000009E   0x6041             STR      R1,[R0, #+4]
   1267          
   1268              /* Process Unlocked */
   1269              __HAL_UNLOCK(hspi);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF884 0x0050      STRB     R0,[R4, #+80]
   1270          
   1271              /* Check if the SPI is already enabled */ 
   1272              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6801             LDR      R1,[R0, #+0]
   \   000000AA   0x0649             LSLS     R1,R1,#+25
   \   000000AC   0xD403             BMI.N    ??HAL_SPI_Transmit_DMA_5
   1273              {
   1274                /* Enable SPI peripheral */
   1275                __HAL_SPI_ENABLE(hspi);
   \   000000AE   0x6801             LDR      R1,[R0, #+0]
   \   000000B0   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000B4   0x6001             STR      R1,[R0, #+0]
   1276              }
   1277          
   1278              return HAL_OK;
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBD10             POP      {R4,PC}
   1279            }
   1280            else
   1281            {
   1282              return HAL_BUSY;
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0xBD10             POP      {R4,PC}          ;; return
   1283            }
   1284          }
   1285          
   1286          /**
   1287            * @brief  Receive an amount of data in no-blocking mode with DMA 
   1288            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1289            *                the configuration information for SPI module.
   1290            * @param  pData: pointer to data buffer
   1291            * @note  When the CRC feature is enabled the pData Length must be Size + 1. 
   1292            * @param  Size: amount of data to be sent
   1293            * @retval HAL status
   1294            */

   \                                 In section .text, align 2, keep-with-next
   1295          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1296          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1297            if(hspi->State == HAL_SPI_STATE_READY)
   \   00000004   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD165             BNE.N    ??HAL_SPI_Receive_DMA_0
   1298            {
   1299              if((pData == NULL) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_SPI_Receive_DMA_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   1300              {
   1301                return  HAL_ERROR;
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
   1302              }
   1303          
   1304              /* Process Locked */
   1305              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   00000018   0xF994 0x0050      LDRSB    R0,[R4, #+80]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD05B             BEQ.N    ??HAL_SPI_Receive_DMA_0
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x0050      STRB     R0,[R4, #+80]
   1306          
   1307              /* Configure communication */
   1308              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000026   0x2022             MOVS     R0,#+34
   \   00000028   0xF884 0x0051      STRB     R0,[R4, #+81]
   1309              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6560             STR      R0,[R4, #+84]
   1310          
   1311              hspi->pRxBuffPtr  = pData;
   \   00000030   0x63A1             STR      R1,[R4, #+56]
   1312              hspi->RxXferSize  = Size;
   \   00000032   0x87A2             STRH     R2,[R4, #+60]
   1313              hspi->RxXferCount = Size;
   \   00000034   0x87E2             STRH     R2,[R4, #+62]
   1314          
   1315              /*Init field not used in handle to zero */
   1316              hspi->RxISR       = 0;
   \   00000036   0x64A0             STR      R0,[R4, #+72]
   1317              hspi->TxISR       = 0;
   \   00000038   0x64E0             STR      R0,[R4, #+76]
   1318              hspi->pTxBuffPtr  = NULL;
   \   0000003A   0x6320             STR      R0,[R4, #+48]
   1319              hspi->TxXferSize  = 0;
   \   0000003C   0x86A0             STRH     R0,[R4, #+52]
   1320              hspi->TxXferCount = 0;
   \   0000003E   0x86E0             STRH     R0,[R4, #+54]
   1321          
   1322              /* Configure communication direction : 1Line */
   1323              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000046   0xD138             BNE.N    ??HAL_SPI_Receive_DMA_3
   1324              {
   1325                SPI_1LINE_RX(hspi);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000050   0x6001             STR      R1,[R0, #+0]
   1326              }
   1327              else if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
   1328              {
   1329                /* Process Unlocked */
   1330                __HAL_UNLOCK(hspi);
   1331          
   1332                /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1333                return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   1334              }
   1335          
   1336              /* Reset CRC Calculation */
   1337              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   00000052   0x6AA0             LDR      R0,[R4, #+40]
   \   00000054   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000058   0xD109             BNE.N    ??HAL_SPI_Receive_DMA_5
   1338              {
   1339                SPI_RESET_CRC(hspi);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000062   0x6001             STR      R1,[R0, #+0]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   1340              }
   1341          
   1342              /* Set the SPI RxDMA Half transfer complete callback */
   1343              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \   0000006E   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \   00000072   0x6C61             LDR      R1,[R4, #+68]
   \   00000074   0x62C8             STR      R0,[R1, #+44]
   1344          
   1345              /* Set the SPI Rx DMA transfer complete callback */
   1346              hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   00000076   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   0000007A   0x6C61             LDR      R1,[R4, #+68]
   \   0000007C   0x6288             STR      R0,[R1, #+40]
   1347          
   1348              /* Set the DMA error callback */
   1349              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \   0000007E   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   00000082   0x6C61             LDR      R1,[R4, #+68]
   \   00000084   0x6308             STR      R0,[R1, #+48]
   1350          
   1351              /* Enable the Rx DMA Channel */
   1352              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   00000086   0x8FE3             LDRH     R3,[R4, #+62]
   \   00000088   0x6BA2             LDR      R2,[R4, #+56]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0xF100 0x010C      ADD      R1,R0,#+12
   \   00000090   0x6C60             LDR      R0,[R4, #+68]
   \   00000092   0x.... 0x....      BL       HAL_DMA_Start_IT
   1353          
   1354              /* Enable Rx DMA Request */  
   1355              SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6841             LDR      R1,[R0, #+4]
   \   0000009A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000009E   0x6041             STR      R1,[R0, #+4]
   1356          
   1357              /* Process Unlocked */
   1358              __HAL_UNLOCK(hspi);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF884 0x0050      STRB     R0,[R4, #+80]
   1359          
   1360              /* Check if the SPI is already enabled */ 
   1361              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6801             LDR      R1,[R0, #+0]
   \   000000AA   0x0649             LSLS     R1,R1,#+25
   \   000000AC   0xD403             BMI.N    ??HAL_SPI_Receive_DMA_6
   1362              {
   1363                /* Enable SPI peripheral */
   1364                __HAL_SPI_ENABLE(hspi);
   \   000000AE   0x6801             LDR      R1,[R0, #+0]
   \   000000B0   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000B4   0x6001             STR      R1,[R0, #+0]
   1365              }
   1366          
   1367              return HAL_OK;
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBD10             POP      {R4,PC}
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD1C9             BNE.N    ??HAL_SPI_Receive_DMA_4
   \   000000BE   0x6860             LDR      R0,[R4, #+4]
   \   000000C0   0xF5B0 0x7F82      CMP      R0,#+260
   \   000000C4   0xD1C5             BNE.N    ??HAL_SPI_Receive_DMA_4
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF884 0x0050      STRB     R0,[R4, #+80]
   \   000000CC   0x4613             MOV      R3,R2
   \   000000CE   0x460A             MOV      R2,R1
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0xE8BD 0x4010      POP      {R4,LR}
   \   000000D6   0x....             B.N      HAL_SPI_TransmitReceive_DMA
   1368            }
   1369            else
   1370            {
   1371              return HAL_BUSY;
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0xBD10             POP      {R4,PC}          ;; return
   1372            }
   1373          }
   1374          
   1375          /**
   1376            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA 
   1377            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1378            *                the configuration information for SPI module.
   1379            * @param  pTxData: pointer to transmission data buffer
   1380            * @param  pRxData: pointer to reception data buffer
   1381            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1 
   1382            * @param  Size: amount of data to be sent
   1383            * @retval HAL status
   1384            */

   \                                 In section .text, align 2, keep-with-next
   1385          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1386          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1387            if((hspi->State == HAL_SPI_STATE_READY) || \
   1388               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->State == HAL_SPI_STATE_BUSY_RX)))
   \   00000004   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD00A             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000012   0xD17B             BNE.N    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD178             BNE.N    ??HAL_SPI_TransmitReceive_DMA_1
   \   0000001A   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000001E   0x2822             CMP      R0,#+34
   \   00000020   0xD174             BNE.N    ??HAL_SPI_TransmitReceive_DMA_1
   1389            {
   1390              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_3
   1391              {
   1392                return  HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
   1393              }
   1394          
   1395              /* Check the parameters */
   1396              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1397              
   1398              /* Process locked */
   1399              __HAL_LOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   00000032   0xF994 0x0050      LDRSB    R0,[R4, #+80]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD068             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_1
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0050      STRB     R0,[R4, #+80]
   1400          
   1401              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1402              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   \   00000040   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   00000044   0x2822             CMP      R0,#+34
   \   00000046   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_4
   1403              {
   1404                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000048   0x2032             MOVS     R0,#+50
   \   0000004A   0xF884 0x0051      STRB     R0,[R4, #+81]
   1405              }
   1406          
   1407              /* Configure communication */
   1408              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6560             STR      R0,[R4, #+84]
   1409          
   1410              hspi->pTxBuffPtr  = (uint8_t*)pTxData;
   \   00000052   0x6321             STR      R1,[R4, #+48]
   1411              hspi->TxXferSize  = Size;
   \   00000054   0x86A3             STRH     R3,[R4, #+52]
   1412              hspi->TxXferCount = Size;
   \   00000056   0x86E3             STRH     R3,[R4, #+54]
   1413          
   1414              hspi->pRxBuffPtr  = (uint8_t*)pRxData;
   \   00000058   0x63A2             STR      R2,[R4, #+56]
   1415              hspi->RxXferSize  = Size;
   \   0000005A   0x87A3             STRH     R3,[R4, #+60]
   1416              hspi->RxXferCount = Size;
   \   0000005C   0x87E3             STRH     R3,[R4, #+62]
   1417          
   1418              /*Init field not used in handle to zero */
   1419              hspi->RxISR = 0;
   \   0000005E   0x64A0             STR      R0,[R4, #+72]
   1420              hspi->TxISR = 0;
   \   00000060   0x64E0             STR      R0,[R4, #+76]
   1421          
   1422              /* Reset CRC Calculation */
   1423              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000062   0x6AA0             LDR      R0,[R4, #+40]
   \   00000064   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000068   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_DMA_5
   1424              {
   1425                SPI_RESET_CRC(hspi);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   1426              }
   1427          
   1428              /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   1429              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   0000007E   0x6C60             LDR      R0,[R4, #+68]
   \   00000080   0xF994 0x1051      LDRSB    R1,[R4, #+81]
   \   00000084   0x2922             CMP      R1,#+34
   \   00000086   0xD107             BNE.N    ??HAL_SPI_TransmitReceive_DMA_6
   1430              {
   1431                /* Set the SPI Rx DMA Half transfer complete callback */
   1432                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   00000088   0x.... 0x....      ADR.W    R1,SPI_DMAHalfReceiveCplt
   \   0000008C   0x62C1             STR      R1,[R0, #+44]
   1433                
   1434                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   0000008E   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   00000092   0x6C61             LDR      R1,[R4, #+68]
   \   00000094   0x6288             STR      R0,[R1, #+40]
   \   00000096   0xE006             B.N      ??HAL_SPI_TransmitReceive_DMA_7
   1435              }
   1436              else
   1437              {
   1438                /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   1439                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   00000098   0x.... 0x....      ADR.W    R1,SPI_DMAHalfTransmitReceiveCplt
   \   0000009C   0x62C1             STR      R1,[R0, #+44]
   1440            
   1441                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   \   0000009E   0x.... 0x....      ADR.W    R0,SPI_DMATransmitReceiveCplt
   \   000000A2   0x6C61             LDR      R1,[R4, #+68]
   \   000000A4   0x6288             STR      R0,[R1, #+40]
   1442              }
   1443          
   1444              /* Set the DMA error callback */
   1445              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   000000A6   0x.... 0x....      ADR.W    R5,SPI_DMAError
   \   000000AA   0x6C60             LDR      R0,[R4, #+68]
   \   000000AC   0x6305             STR      R5,[R0, #+48]
   1446          
   1447              /* Enable the Rx DMA Channel */
   1448              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   \   000000AE   0x8FE3             LDRH     R3,[R4, #+62]
   \   000000B0   0x6BA2             LDR      R2,[R4, #+56]
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0xF100 0x010C      ADD      R1,R0,#+12
   \   000000B8   0x6C60             LDR      R0,[R4, #+68]
   \   000000BA   0x.... 0x....      BL       HAL_DMA_Start_IT
   1449          
   1450              /* Enable Rx DMA Request */  
   1451              SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6841             LDR      R1,[R0, #+4]
   \   000000C2   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000C6   0x6041             STR      R1,[R0, #+4]
   1452          
   1453              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1454              is performed in DMA reception complete callback  */
   1455              if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   000000C8   0x6C20             LDR      R0,[R4, #+64]
   \   000000CA   0xF994 0x1051      LDRSB    R1,[R4, #+81]
   \   000000CE   0x2932             CMP      R1,#+50
   \   000000D0   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_8
   1456              {
   1457                /* Set the DMA error callback */
   1458                hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   000000D2   0x6305             STR      R5,[R0, #+48]
   \   000000D4   0xE001             B.N      ??HAL_SPI_TransmitReceive_DMA_9
   1459              }
   1460              else
   1461              {
   1462                hspi->hdmatx->XferErrorCallback = NULL;
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x6301             STR      R1,[R0, #+48]
   1463              }
   1464              
   1465              /* Enable the Tx DMA Channel */
   1466              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \   000000DA   0x8EE3             LDRH     R3,[R4, #+54]
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0xF100 0x020C      ADD      R2,R0,#+12
   \   000000E2   0x6B21             LDR      R1,[R4, #+48]
   \   000000E4   0x6C20             LDR      R0,[R4, #+64]
   \   000000E6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1467          
   1468              /* Check if the SPI is already enabled */ 
   1469              if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6801             LDR      R1,[R0, #+0]
   \   000000EE   0x0649             LSLS     R1,R1,#+25
   \   000000F0   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_DMA_10
   1470              {
   1471                /* Enable SPI peripheral */
   1472                __HAL_SPI_ENABLE(hspi);
   \   000000F2   0x6801             LDR      R1,[R0, #+0]
   \   000000F4   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000F8   0x6001             STR      R1,[R0, #+0]
   1473              }
   1474          
   1475              /* Enable Tx DMA Request */  
   1476              SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6841             LDR      R1,[R0, #+4]
   \   000000FE   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000102   0x6041             STR      R1,[R0, #+4]
   1477          
   1478              /* Process Unlocked */
   1479              __HAL_UNLOCK(hspi);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x0050      STRB     R0,[R4, #+80]
   1480          
   1481              return HAL_OK;
   \   0000010A   0xBD32             POP      {R1,R4,R5,PC}
   1482            }
   1483            else
   1484            {
   1485              return HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   0000010C   0x2002             MOVS     R0,#+2
   \   0000010E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1486            }
   1487          }
   1488          
   1489          
   1490          /**
   1491            * @brief Pauses the DMA Transfer.
   1492            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1493            *                the configuration information for the specified SPI module.
   1494            * @retval HAL status
   1495            */

   \                                 In section .text, align 2, keep-with-next
   1496          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1497          {
   1498            /* Process Locked */
   1499            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0xF990 0x1050      LDRSB    R1,[R0, #+80]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1050      STRB     R1,[R0, #+80]
   1500            
   1501            /* Disable the SPI DMA Tx & Rx requests */
   1502            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   1503            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x684A             LDR      R2,[R1, #+4]
   \   00000020   0x0852             LSRS     R2,R2,#+1
   \   00000022   0x0052             LSLS     R2,R2,#+1
   \   00000024   0x604A             STR      R2,[R1, #+4]
   1504            
   1505            /* Process Unlocked */
   1506            __HAL_UNLOCK(hspi);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF880 0x1050      STRB     R1,[R0, #+80]
   1507            
   1508            return HAL_OK; 
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x4770             BX       LR               ;; return
   1509          }
   1510          
   1511          /**
   1512            * @brief Resumes the DMA Transfer.
   1513            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1514            *                the configuration information for the specified SPI module.
   1515            * @retval HAL status
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1518          {
   1519            /* Process Locked */
   1520            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0xF990 0x1050      LDRSB    R1,[R0, #+80]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1050      STRB     R1,[R0, #+80]
   1521            
   1522            /* Enable the SPI DMA Tx & Rx requests */
   1523            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   1524            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x684A             LDR      R2,[R1, #+4]
   \   00000020   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000024   0x604A             STR      R2,[R1, #+4]
   1525            
   1526            /* Process Unlocked */
   1527            __HAL_UNLOCK(hspi);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF880 0x1050      STRB     R1,[R0, #+80]
   1528            
   1529            return HAL_OK;
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x4770             BX       LR               ;; return
   1530          }
   1531          
   1532          /**
   1533            * @brief Stops the DMA Transfer.
   1534            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1535            *                the configuration information for the specified SPI module.
   1536            * @retval HAL status
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1539          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1540            /* The Lock is not implemented on this API to allow the user application
   1541               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1542               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1543               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1544               */
   1545            
   1546            /* Abort the SPI DMA tx Channel */
   1547            if(hspi->hdmatx != NULL)
   \   00000004   0x6C20             LDR      R0,[R4, #+64]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??HAL_SPI_DMAStop_0
   1548            {
   1549              HAL_DMA_Abort(hspi->hdmatx);
   \   0000000A   0x.... 0x....      BL       HAL_DMA_Abort
   1550            }
   1551            /* Abort the SPI DMA rx Channel */
   1552            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   0000000E   0x6C60             LDR      R0,[R4, #+68]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_SPI_DMAStop_1
   1553            {
   1554              HAL_DMA_Abort(hspi->hdmarx);
   \   00000014   0x.... 0x....      BL       HAL_DMA_Abort
   1555            }
   1556            
   1557            /* Disable the SPI DMA Tx & Rx requests */
   1558            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000020   0x6041             STR      R1,[R0, #+4]
   1559            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6841             LDR      R1,[R0, #+4]
   \   00000026   0x0849             LSRS     R1,R1,#+1
   \   00000028   0x0049             LSLS     R1,R1,#+1
   \   0000002A   0x6041             STR      R1,[R0, #+4]
   1560            
   1561            hspi->State = HAL_SPI_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0051      STRB     R0,[R4, #+81]
   1562            
   1563            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1564          }
   1565          
   1566          /**
   1567            * @brief  This function handles SPI interrupt request.
   1568            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1569            *                the configuration information for SPI module.
   1570            * @retval None
   1571            */

   \                                 In section .text, align 2, keep-with-next
   1572          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1573          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1574            /* SPI in mode Receiver and Overrun not occurred ---------------------------*/
   1575            if((__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) != RESET) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE) != RESET) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) == RESET))
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0x0652             LSLS     R2,R2,#+25
   \   00000008   0xD509             BPL.N    ??HAL_SPI_IRQHandler_0
   \   0000000A   0x688A             LDR      R2,[R1, #+8]
   \   0000000C   0x07D2             LSLS     R2,R2,#+31
   \   0000000E   0xD506             BPL.N    ??HAL_SPI_IRQHandler_0
   \   00000010   0x688A             LDR      R2,[R1, #+8]
   \   00000012   0x0652             LSLS     R2,R2,#+25
   \   00000014   0xD403             BMI.N    ??HAL_SPI_IRQHandler_0
   1576            {
   1577              hspi->RxISR(hspi);
   \   00000016   0x6C81             LDR      R1,[R0, #+72]
   \   00000018   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001C   0x4708             BX       R1
   1578              return;
   1579            }
   1580          
   1581            /* SPI in mode Tramitter ---------------------------------------------------*/
   1582            if((__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) != RESET) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   0000001E   0x684A             LDR      R2,[R1, #+4]
   \   00000020   0x0612             LSLS     R2,R2,#+24
   \   00000022   0xD506             BPL.N    ??HAL_SPI_IRQHandler_1
   \   00000024   0x688A             LDR      R2,[R1, #+8]
   \   00000026   0x0792             LSLS     R2,R2,#+30
   \   00000028   0xD503             BPL.N    ??HAL_SPI_IRQHandler_1
   1583            {
   1584              hspi->TxISR(hspi);
   \   0000002A   0x6CC1             LDR      R1,[R0, #+76]
   \   0000002C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000030   0x4708             BX       R1
   1585              return;
   1586            }
   1587          
   1588            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_ERR) != RESET)
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0x0692             LSLS     R2,R2,#+26
   \   00000036   0xD53A             BPL.N    ??HAL_SPI_IRQHandler_2
   1589            {
   1590              /* SPI CRC error interrupt occurred ---------------------------------------*/
   1591              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000038   0x6889             LDR      R1,[R1, #+8]
   \   0000003A   0x06C9             LSLS     R1,R1,#+27
   \   0000003C   0xD507             BPL.N    ??HAL_SPI_IRQHandler_3
   1592              {
   1593                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   0000003E   0x6D41             LDR      R1,[R0, #+84]
   \   00000040   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000044   0x6541             STR      R1,[R0, #+84]
   1594                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   00000046   0xF06F 0x0110      MVN      R1,#+16
   \   0000004A   0x6802             LDR      R2,[R0, #+0]
   \   0000004C   0x6091             STR      R1,[R2, #+8]
   1595              }
   1596              /* SPI Mode Fault error interrupt occurred --------------------------------*/
   1597              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x6889             LDR      R1,[R1, #+8]
   \   00000052   0x0689             LSLS     R1,R1,#+26
   \   00000054   0xD50C             BPL.N    ??HAL_SPI_IRQHandler_4
   1598              {
   1599                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
   \   00000056   0x6D41             LDR      R1,[R0, #+84]
   \   00000058   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000005C   0x6541             STR      R1,[R0, #+84]
   1600                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0x688A             LDR      R2,[R1, #+8]
   \   00000062   0x9200             STR      R2,[SP, #+0]
   \   00000064   0x680A             LDR      R2,[R1, #+0]
   \   00000066   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000006A   0x600A             STR      R2,[R1, #+0]
   \   0000006C   0x9200             STR      R2,[SP, #+0]
   \   0000006E   0x9900             LDR      R1,[SP, #+0]
   1601              }
   1602              
   1603              /* SPI Overrun error interrupt occurred -----------------------------------*/
   1604              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x6889             LDR      R1,[R1, #+8]
   \   00000074   0x0649             LSLS     R1,R1,#+25
   \   00000076   0xD50D             BPL.N    ??HAL_SPI_IRQHandler_5
   1605              {
   1606                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   00000078   0xF990 0x1051      LDRSB    R1,[R0, #+81]
   \   0000007C   0x2912             CMP      R1,#+18
   \   0000007E   0xD009             BEQ.N    ??HAL_SPI_IRQHandler_5
   1607                {
   1608                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
   \   00000080   0x6D41             LDR      R1,[R0, #+84]
   \   00000082   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000086   0x6541             STR      R1,[R0, #+84]
   1609                  __HAL_SPI_CLEAR_OVRFLAG(hspi);      
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0x68CA             LDR      R2,[R1, #+12]
   \   0000008C   0x9200             STR      R2,[SP, #+0]
   \   0000008E   0x6889             LDR      R1,[R1, #+8]
   \   00000090   0x9100             STR      R1,[SP, #+0]
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   1610                }
   1611              }
   1612          
   1613              /* Call the Error call Back in case of Errors */
   1614              if(hspi->ErrorCode!=HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   00000094   0x6D41             LDR      R1,[R0, #+84]
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD009             BEQ.N    ??HAL_SPI_IRQHandler_2
   1615              {
   1616                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \   0000009A   0x6801             LDR      R1,[R0, #+0]
   \   0000009C   0x684A             LDR      R2,[R1, #+4]
   \   0000009E   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   000000A2   0x604A             STR      R2,[R1, #+4]
   1617                hspi->State = HAL_SPI_STATE_READY;
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0xF880 0x1051      STRB     R1,[R0, #+81]
   1618                HAL_SPI_ErrorCallback(hspi);
   \   000000AA   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1619              }
   1620            }
   1621          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   000000AE   0xBD01             POP      {R0,PC}          ;; return
   1622          
   1623          /**
   1624            * @brief Tx Transfer completed callbacks
   1625            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1626            *                the configuration information for SPI module.
   1627            * @retval None
   1628            */

   \                                 In section .text, align 2, keep-with-next
   1629          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1630          {
   1631            /* Prevent unused argument(s) compilation warning */
   1632            UNUSED(hspi);
   1633            /* NOTE : This function Should not be modified, when the callback is needed,
   1634                      the HAL_SPI_TxCpltCallback could be implenetd in the user file
   1635             */
   1636          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1637          
   1638          /**
   1639            * @brief Rx Transfer completed callbacks
   1640            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1641            *                the configuration information for SPI module.
   1642            * @retval None
   1643            */

   \                                 In section .text, align 2, keep-with-next
   1644          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1645          {
   1646            /* Prevent unused argument(s) compilation warning */
   1647            UNUSED(hspi);
   1648            /* NOTE : This function Should not be modified, when the callback is needed,
   1649                      the HAL_SPI_RxCpltCallback() could be implenetd in the user file
   1650             */
   1651          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1652          
   1653          /**
   1654            * @brief Tx and Rx Transfer completed callbacks
   1655            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1656            *                the configuration information for SPI module.
   1657            * @retval None
   1658            */

   \                                 In section .text, align 2, keep-with-next
   1659          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1660          {
   1661            /* Prevent unused argument(s) compilation warning */
   1662            UNUSED(hspi);
   1663            /* NOTE : This function Should not be modified, when the callback is needed,
   1664                      the HAL_SPI_TxRxCpltCallback() could be implenetd in the user file
   1665             */
   1666          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1667          
   1668          /**
   1669            * @brief Tx Half Transfer completed callbacks
   1670            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1671            *                the configuration information for SPI module.
   1672            * @retval None
   1673            */

   \                                 In section .text, align 2, keep-with-next
   1674          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1675          {
   1676            /* Prevent unused argument(s) compilation warning */
   1677            UNUSED(hspi);
   1678            /* NOTE : This function Should not be modified, when the callback is needed,
   1679                      the HAL_SPI_TxHalfCpltCallback could be implenetd in the user file
   1680             */
   1681          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1682          
   1683          /**
   1684            * @brief Rx Half Transfer completed callbacks
   1685            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1686            *                the configuration information for SPI module.
   1687            * @retval None
   1688            */

   \                                 In section .text, align 2, keep-with-next
   1689          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1690          {
   1691            /* Prevent unused argument(s) compilation warning */
   1692            UNUSED(hspi);
   1693            /* NOTE : This function Should not be modified, when the callback is needed,
   1694                      the HAL_SPI_RxHalfCpltCallback() could be implenetd in the user file
   1695             */
   1696          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1697          
   1698          /**
   1699            * @brief Tx and Rx Transfer completed callbacks
   1700            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1701            *                the configuration information for SPI module.
   1702            * @retval None
   1703            */

   \                                 In section .text, align 2, keep-with-next
   1704          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1705          {
   1706            /* Prevent unused argument(s) compilation warning */
   1707            UNUSED(hspi);
   1708            /* NOTE : This function Should not be modified, when the callback is needed,
   1709                      the HAL_SPI_TxRxHalfCpltCallback() could be implenetd in the user file
   1710             */
   1711          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1712          
   1713          /**
   1714            * @brief SPI error callbacks
   1715            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1716            *                the configuration information for SPI module.
   1717            * @retval None
   1718            */

   \                                 In section .text, align 2, keep-with-next
   1719           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1720          {
   1721            /* Prevent unused argument(s) compilation warning */
   1722            UNUSED(hspi);
   1723            /* NOTE : - This function Should not be modified, when the callback is needed,
   1724                      the HAL_SPI_ErrorCallback() could be implenetd in the user file.
   1725                      - The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1726                      and user can use HAL_SPI_GetError() API to check the latest error occurred.
   1727             */
   1728          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1729          
   1730          /**
   1731            * @}
   1732            */
   1733          
   1734          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions 
   1735            *  @brief   SPI control functions 
   1736            *
   1737          @verbatim
   1738           ===============================================================================
   1739                                ##### Peripheral State and Errors functions #####
   1740           ===============================================================================  
   1741              [..]
   1742              This subsection provides a set of functions allowing to control the SPI.
   1743               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1744               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1745          @endverbatim
   1746            * @{
   1747            */
   1748          
   1749          /**
   1750            * @brief  Return the SPI state
   1751            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1752            *                the configuration information for SPI module.
   1753            * @retval SPI state
   1754            */

   \                                 In section .text, align 2, keep-with-next
   1755          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1756          {
   1757            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF990 0x0051      LDRSB    R0,[R0, #+81]
   \   00000004   0x4770             BX       LR               ;; return
   1758          }
   1759          
   1760          /**
   1761            * @brief  Return the SPI error code
   1762            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1763            *                the configuration information for SPI module.
   1764            * @retval SPI Error Code
   1765            */

   \                                 In section .text, align 2, keep-with-next
   1766          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1767          {
   1768            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6D40             LDR      R0,[R0, #+84]
   \   00000002   0x4770             BX       LR               ;; return
   1769          }
   1770          
   1771          /**
   1772            * @}
   1773            */
   1774            
   1775          /**
   1776              * @}
   1777              */
   1778          
   1779          
   1780          
   1781          /** @addtogroup SPI_Private_Functions
   1782              * @{
   1783              */
   1784          
   1785          
   1786            /**
   1787            * @brief  Interrupt Handler to close Tx transfer 
   1788            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1789            *                the configuration information for SPI module.
   1790            * @retval None
   1791            */

   \                                 In section .text, align 2, keep-with-next
   1792          static void SPI_TxCloseIRQHandler(SPI_HandleTypeDef *hspi)
   1793          {
   \                     SPI_TxCloseIRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   1794            /* Wait until TXE flag is set to send data */
   1795            if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??SPI_TxCloseIRQHandler_0
   1796            {
   1797              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000014   0x6D60             LDR      R0,[R4, #+84]
   \   00000016   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000001A   0x6560             STR      R0,[R4, #+84]
   1798            }
   1799          
   1800            /* Disable TXE interrupt */
   1801            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE));
   \                     ??SPI_TxCloseIRQHandler_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000024   0x6041             STR      R1,[R0, #+4]
   1802          
   1803            /* Disable ERR interrupt if Receive process is finished */
   1804            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) == RESET)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0x0649             LSLS     R1,R1,#+25
   \   0000002C   0xD433             BMI.N    ??SPI_TxCloseIRQHandler_1
   1805            {
   1806              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_ERR));
   \   0000002E   0x6841             LDR      R1,[R0, #+4]
   \   00000030   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000034   0x6041             STR      R1,[R0, #+4]
   1807          
   1808              /* Wait until Busy flag is reset before disabling SPI */
   1809              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000036   0x230A             MOVS     R3,#+10
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x2180             MOVS     R1,#+128
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??SPI_TxCloseIRQHandler_2
   1810              {
   1811                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000046   0x6D60             LDR      R0,[R4, #+84]
   \   00000048   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000004C   0x6560             STR      R0,[R4, #+84]
   1812              }
   1813          
   1814              /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   1815              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_TxCloseIRQHandler_2: (+1)
   \   0000004E   0x68A0             LDR      R0,[R4, #+8]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD105             BNE.N    ??SPI_TxCloseIRQHandler_3
   1816              {
   1817                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C1             LDR      R1,[R0, #+12]
   \   00000058   0x9100             STR      R1,[SP, #+0]
   \   0000005A   0x6880             LDR      R0,[R0, #+8]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   1818              }
   1819              
   1820              /* Check if Errors has been detected during transfer */
   1821              if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
   \                     ??SPI_TxCloseIRQHandler_3: (+1)
   \   00000060   0x6D60             LDR      R0,[R4, #+84]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD111             BNE.N    ??SPI_TxCloseIRQHandler_4
   1822              {
   1823                /* Check if we are in Tx or in Rx/Tx Mode */
   1824                if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   00000066   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000006A   0x2832             CMP      R0,#+50
   \   0000006C   0xD106             BNE.N    ??SPI_TxCloseIRQHandler_5
   1825                {
   1826                  /* Set state to READY before run the Callback Complete */
   1827                  hspi->State = HAL_SPI_STATE_READY;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xF884 0x0051      STRB     R0,[R4, #+81]
   1828                  HAL_SPI_TxRxCpltCallback(hspi);
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   0000007A   0xBD13             POP      {R0,R1,R4,PC}
   1829                }
   1830                else
   1831                {
   1832                  /* Set state to READY before run the Callback Complete */
   1833                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_TxCloseIRQHandler_5: (+1)
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF884 0x0051      STRB     R0,[R4, #+81]
   1834                  HAL_SPI_TxCpltCallback(hspi);
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   \   00000088   0xBD13             POP      {R0,R1,R4,PC}
   1835                }
   1836              }
   1837              else
   1838              {
   1839                /* Set state to READY before run the Callback Complete */
   1840                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_TxCloseIRQHandler_4: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF884 0x0051      STRB     R0,[R4, #+81]
   1841                /* Call Error call back in case of Error */
   1842                HAL_SPI_ErrorCallback(hspi);
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1843              }
   1844            }
   1845          }
   \                     ??SPI_TxCloseIRQHandler_1: (+1)
   \   00000096   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1846          
   1847          /**
   1848            * @brief  Interrupt Handler to transmit amount of data in no-blocking mode 
   1849            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1850            *                the configuration information for SPI module.
   1851            * @retval None
   1852            */

   \                                 In section .text, align 4, keep-with-next
   1853          static void SPI_TxISR(SPI_HandleTypeDef *hspi)
   1854          {
   1855            /* Transmit data in 8 Bit mode */
   1856            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     SPI_TxISR: (+1)
   \   00000000   0x6B01             LDR      R1,[R0, #+48]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD105             BNE.N    ??SPI_TxISR_0
   1857            {
   1858              hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6302             STR      R2,[R0, #+48]
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x60D1             STR      R1,[R2, #+12]
   \   00000012   0xE005             B.N      ??SPI_TxISR_1
   1859            }
   1860            /* Transmit data in 16 Bit mode */
   1861            else
   1862            {
   1863              hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   \                     ??SPI_TxISR_0: (+1)
   \   00000014   0x8809             LDRH     R1,[R1, #+0]
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x60D1             STR      R1,[R2, #+12]
   1864              hspi->pTxBuffPtr+=2;
   \   0000001A   0x6B01             LDR      R1,[R0, #+48]
   \   0000001C   0x1C89             ADDS     R1,R1,#+2
   \   0000001E   0x6301             STR      R1,[R0, #+48]
   1865            }
   1866            hspi->TxXferCount--;
   \                     ??SPI_TxISR_1: (+1)
   \   00000020   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000022   0x1E49             SUBS     R1,R1,#+1
   \   00000024   0x86C1             STRH     R1,[R0, #+54]
   1867          
   1868            if(hspi->TxXferCount == 0)
   \   00000026   0xB289             UXTH     R1,R1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD109             BNE.N    ??SPI_TxISR_2
   1869            {
   1870              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000002C   0x6A81             LDR      R1,[R0, #+40]
   \   0000002E   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000032   0xD104             BNE.N    ??SPI_TxISR_3
   1871              {
   1872                /* calculate and transfer CRC on Tx line */
   1873                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000003C   0x600A             STR      R2,[R1, #+0]
   1874              }
   1875              SPI_TxCloseIRQHandler(hspi);
   \                     ??SPI_TxISR_3: (+1)
   \   0000003E   0x....             B.N      SPI_TxCloseIRQHandler
   1876            }
   1877          }
   \                     ??SPI_TxISR_2: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   1878          
   1879          /**
   1880            * @brief  Interrupt Handler to close Rx transfer 
   1881            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1882            *                the configuration information for SPI module.
   1883            * @retval None
   1884            */

   \                                 In section .text, align 2, keep-with-next
   1885          static void SPI_RxCloseIRQHandler(SPI_HandleTypeDef *hspi)
   1886          {
   \                     SPI_RxCloseIRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   1887            __IO uint16_t tmpreg = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1888          
   1889            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000000C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000000E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000012   0xD13D             BNE.N    ??SPI_RxCloseIRQHandler_0
   1890            {
   1891              /* Wait until RXNE flag is set to read CRC data */
   1892              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000014   0x230A             MOVS     R3,#+10
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??SPI_RxCloseIRQHandler_1
   1893              {
   1894                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000024   0x6D60             LDR      R0,[R4, #+84]
   \   00000026   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000002A   0x6560             STR      R0,[R4, #+84]
   1895              }
   1896          
   1897              /* Read CRC to reset RXNE flag */
   1898              tmpreg = hspi->Instance->DR;
   \                     ??SPI_RxCloseIRQHandler_1: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1899              UNUSED(tmpreg);
   \   00000034   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   1900          
   1901              /* Wait until RXNE flag is reset */
   1902              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000038   0x230A             MOVS     R3,#+10
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x4611             MOV      R1,R2
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD003             BEQ.N    ??SPI_RxCloseIRQHandler_2
   1903              {
   1904                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000048   0x6D60             LDR      R0,[R4, #+84]
   \   0000004A   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000004E   0x6560             STR      R0,[R4, #+84]
   1905              }
   1906          
   1907              /* Check if CRC error occurred */
   1908              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \                     ??SPI_RxCloseIRQHandler_2: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x06C0             LSLS     R0,R0,#+27
   \   00000056   0xD51B             BPL.N    ??SPI_RxCloseIRQHandler_0
   1909              {
   1910                /* Check if CRC error is valid or not (workaround to be applied or not) */
   1911                if (   (hspi->State != HAL_SPI_STATE_BUSY_RX)
   1912                    || (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR) )
   \   00000058   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000005C   0x2822             CMP      R0,#+34
   \   0000005E   0xD104             BNE.N    ??SPI_RxCloseIRQHandler_3
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       SPI_ISCRCErrorValid
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD10E             BNE.N    ??SPI_RxCloseIRQHandler_4
   1913                {
   1914                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \                     ??SPI_RxCloseIRQHandler_3: (+1)
   \   0000006A   0x6D60             LDR      R0,[R4, #+84]
   \   0000006C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000070   0x6560             STR      R0,[R4, #+84]
   1915          
   1916                  /* Reset CRC Calculation */
   1917                  SPI_RESET_CRC(hspi);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000007A   0x6001             STR      R1,[R0, #+0]
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000084   0x6001             STR      R1,[R0, #+0]
   \   00000086   0xE003             B.N      ??SPI_RxCloseIRQHandler_0
   1918                }
   1919                else
   1920                {
   1921                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \                     ??SPI_RxCloseIRQHandler_4: (+1)
   \   00000088   0xF06F 0x0010      MVN      R0,#+16
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6088             STR      R0,[R1, #+8]
   1922                }
   1923              }
   1924            }
   1925          
   1926            /* Disable RXNE interrupt */
   1927            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE));
   \                     ??SPI_RxCloseIRQHandler_0: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6841             LDR      R1,[R0, #+4]
   \   00000094   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000098   0x6041             STR      R1,[R0, #+4]
   1928          
   1929            /* if Transmit process is finished */
   1930            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) == RESET)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0x0609             LSLS     R1,R1,#+24
   \   000000A0   0xD42E             BMI.N    ??SPI_RxCloseIRQHandler_5
   1931            {
   1932              /* Disable ERR interrupt */
   1933              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_ERR));
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0xF021 0x0120      BIC      R1,R1,#0x20
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   1934          
   1935              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0xF5B0 0x7F82      CMP      R0,#+260
   \   000000B0   0xD10B             BNE.N    ??SPI_RxCloseIRQHandler_6
   \   000000B2   0x68A0             LDR      R0,[R4, #+8]
   \   000000B4   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000B8   0xD002             BEQ.N    ??SPI_RxCloseIRQHandler_7
   \   000000BA   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000BE   0xD104             BNE.N    ??SPI_RxCloseIRQHandler_6
   1936              {
   1937                /* Disable SPI peripheral */
   1938                __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_RxCloseIRQHandler_7: (+1)
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6801             LDR      R1,[R0, #+0]
   \   000000C4   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000C8   0x6001             STR      R1,[R0, #+0]
   1939              }
   1940              
   1941              /* Check if Errors has been detected during transfer */
   1942              if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
   \                     ??SPI_RxCloseIRQHandler_6: (+1)
   \   000000CA   0x6D60             LDR      R0,[R4, #+84]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD111             BNE.N    ??SPI_RxCloseIRQHandler_8
   1943              {
   1944                /* Check if we are in Rx or in Rx/Tx Mode */
   1945                if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   \   000000D0   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   000000D4   0x2832             CMP      R0,#+50
   \   000000D6   0xD106             BNE.N    ??SPI_RxCloseIRQHandler_9
   1946                {
   1947                  /* Set state to READY before run the Callback Complete */
   1948                  hspi->State = HAL_SPI_STATE_READY;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xF884 0x0051      STRB     R0,[R4, #+81]
   1949                  HAL_SPI_TxRxCpltCallback(hspi);
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   000000E4   0xBD13             POP      {R0,R1,R4,PC}
   1950                }
   1951                else
   1952                {
   1953                  /* Set state to READY before run the Callback Complete */
   1954                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_RxCloseIRQHandler_9: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xF884 0x0051      STRB     R0,[R4, #+81]
   1955                  HAL_SPI_RxCpltCallback(hspi);
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   000000F2   0xBD13             POP      {R0,R1,R4,PC}
   1956                }
   1957              }
   1958              else
   1959              {
   1960                /* Set state to READY before run the Callback Complete */
   1961                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_RxCloseIRQHandler_8: (+1)
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF884 0x0051      STRB     R0,[R4, #+81]
   1962                /* Call Error call back in case of Error */
   1963                HAL_SPI_ErrorCallback(hspi);
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   1964              }
   1965            }
   1966          }
   \                     ??SPI_RxCloseIRQHandler_5: (+1)
   \   00000100   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1967          
   1968          /**
   1969            * @brief  Interrupt Handler to receive amount of data in 2Lines mode 
   1970            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1971            *                the configuration information for SPI module.
   1972            * @retval None
   1973            */

   \                                 In section .text, align 4, keep-with-next
   1974          static void SPI_2LinesRxISR(SPI_HandleTypeDef *hspi)
   1975          {
   1976            /* Receive data in 8 Bit mode */
   1977            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     SPI_2LinesRxISR: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD105             BNE.N    ??SPI_2LinesRxISR_0
   1978            {
   1979              (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6382             STR      R2,[R0, #+56]
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x68D2             LDR      R2,[R2, #+12]
   \   00000010   0x700A             STRB     R2,[R1, #+0]
   \   00000012   0xE005             B.N      ??SPI_2LinesRxISR_1
   1980            }
   1981            /* Receive data in 16 Bit mode */
   1982            else
   1983            {
   1984              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??SPI_2LinesRxISR_0: (+1)
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x68D2             LDR      R2,[R2, #+12]
   \   00000018   0x800A             STRH     R2,[R1, #+0]
   1985              hspi->pRxBuffPtr+=2;
   \   0000001A   0x6B81             LDR      R1,[R0, #+56]
   \   0000001C   0x1C89             ADDS     R1,R1,#+2
   \   0000001E   0x6381             STR      R1,[R0, #+56]
   1986            }
   1987            hspi->RxXferCount--;
   \                     ??SPI_2LinesRxISR_1: (+1)
   \   00000020   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000022   0x1E49             SUBS     R1,R1,#+1
   \   00000024   0x87C1             STRH     R1,[R0, #+62]
   1988          
   1989            if(hspi->RxXferCount==0)
   \   00000026   0xB289             UXTH     R1,R1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD100             BNE.N    ??SPI_2LinesRxISR_2
   1990            {
   1991              SPI_RxCloseIRQHandler(hspi);
   \   0000002C   0x....             B.N      SPI_RxCloseIRQHandler
   1992            }
   1993          }
   \                     ??SPI_2LinesRxISR_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
   1994          
   1995          /**
   1996            * @brief  Interrupt Handler to receive amount of data in no-blocking mode 
   1997            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1998            *                the configuration information for SPI module.
   1999            * @retval None
   2000            */

   \                                 In section .text, align 4, keep-with-next
   2001          static void SPI_RxISR(SPI_HandleTypeDef *hspi)
   2002          {
   2003            /* Receive data in 8 Bit mode */
   2004            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     SPI_RxISR: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD105             BNE.N    ??SPI_RxISR_0
   2005            {
   2006              (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6382             STR      R2,[R0, #+56]
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x68D2             LDR      R2,[R2, #+12]
   \   00000010   0x700A             STRB     R2,[R1, #+0]
   \   00000012   0xE005             B.N      ??SPI_RxISR_1
   2007            }
   2008            /* Receive data in 16 Bit mode */
   2009            else
   2010            {
   2011              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     ??SPI_RxISR_0: (+1)
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x68D2             LDR      R2,[R2, #+12]
   \   00000018   0x800A             STRH     R2,[R1, #+0]
   2012              hspi->pRxBuffPtr+=2;
   \   0000001A   0x6B81             LDR      R1,[R0, #+56]
   \   0000001C   0x1C89             ADDS     R1,R1,#+2
   \   0000001E   0x6381             STR      R1,[R0, #+56]
   2013            }
   2014              hspi->RxXferCount--;
   \                     ??SPI_RxISR_1: (+1)
   \   00000020   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000022   0x1E49             SUBS     R1,R1,#+1
   \   00000024   0x87C1             STRH     R1,[R0, #+62]
   2015          
   2016            /* Enable CRC Transmission */
   2017            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   \   00000026   0xB289             UXTH     R1,R1
   \   00000028   0x2901             CMP      R1,#+1
   \   0000002A   0xD108             BNE.N    ??SPI_RxISR_2
   \   0000002C   0x6A81             LDR      R1,[R0, #+40]
   \   0000002E   0xF5B1 0x5F00      CMP      R1,#+8192
   \   00000032   0xD104             BNE.N    ??SPI_RxISR_2
   2018            {
   2019              /* Set CRC Next to calculate CRC on Rx side */
   2020              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000003C   0x600A             STR      R2,[R1, #+0]
   2021            }
   2022          
   2023            if(hspi->RxXferCount == 0)
   \                     ??SPI_RxISR_2: (+1)
   \   0000003E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD100             BNE.N    ??SPI_RxISR_3
   2024            {
   2025              SPI_RxCloseIRQHandler(hspi);
   \   00000044   0x....             B.N      SPI_RxCloseIRQHandler
   2026            }
   2027          }
   \                     ??SPI_RxISR_3: (+1)
   \   00000046   0x4770             BX       LR               ;; return
   2028          
   2029          /**
   2030            * @brief DMA SPI transmit process complete callback 
   2031            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2032            *                the configuration information for the specified DMA module.
   2033            * @retval None
   2034            */

   \                                 In section .text, align 4, keep-with-next
   2035          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   2036          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   2037            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A44             LDR      R4,[R0, #+36]
   2038          
   2039            /* DMA Normal Mode */
   2040            if((hdma->Instance->CCR & DMA_CIRCULAR) == 0)
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD421             BMI.N    ??SPI_DMATransmitCplt_0
   2041            {
   2042              /* Wait until TXE flag is set to send data */
   2043              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000000E   0x230A             MOVS     R3,#+10
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??SPI_DMATransmitCplt_1
   2044              {
   2045                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000001E   0x6D60             LDR      R0,[R4, #+84]
   \   00000020   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000024   0x6560             STR      R0,[R4, #+84]
   2046              }
   2047          
   2048              /* Disable Tx DMA Request */
   2049              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000002E   0x6041             STR      R1,[R0, #+4]
   2050          
   2051              /* Wait until Busy flag is reset before disabling SPI */
   2052              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000030   0x230A             MOVS     R3,#+10
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??SPI_DMATransmitCplt_2
   2053              {
   2054                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000040   0x6D60             LDR      R0,[R4, #+84]
   \   00000042   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000046   0x6560             STR      R0,[R4, #+84]
   2055              }
   2056          
   2057              hspi->TxXferCount = 0;
   \                     ??SPI_DMATransmitCplt_2: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x86E0             STRH     R0,[R4, #+54]
   2058              hspi->State = HAL_SPI_STATE_READY;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF884 0x0051      STRB     R0,[R4, #+81]
   2059            }
   2060          
   2061            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   2062            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD105             BNE.N    ??SPI_DMATransmitCplt_3
   2063            {
   2064              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0x9100             STR      R1,[SP, #+0]
   \   0000005E   0x6880             LDR      R0,[R0, #+8]
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   2065            }
   2066          
   2067            /* Check if Errors has been detected during transfer */
   2068            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??SPI_DMATransmitCplt_3: (+1)
   \   00000064   0x6D60             LDR      R0,[R4, #+84]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0xD002             BEQ.N    ??SPI_DMATransmitCplt_4
   2069            {
   2070              HAL_SPI_ErrorCallback(hspi);
   \   0000006C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000070   0xBD13             POP      {R0,R1,R4,PC}
   2071            }
   2072            else
   2073            {
   2074              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_4: (+1)
   \   00000072   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   2075            }
   2076          }
   \   00000076   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2077          
   2078          /**
   2079            * @brief DMA SPI receive process complete callback 
   2080            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2081            *                the configuration information for the specified DMA module.
   2082            * @retval None
   2083            */

   \                                 In section .text, align 4, keep-with-next
   2084          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2085          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   2086            __IO uint16_t tmpreg = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   2087            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   0000000A   0x6A44             LDR      R4,[R0, #+36]
   2088          
   2089            /* DMA Normal mode */
   2090            if((hdma->Instance->CCR & DMA_CIRCULAR) == 0)
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD465             BMI.N    ??SPI_DMAReceiveCplt_0
   2091            {
   2092              /* Disable Rx DMA Request */
   2093              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0x0849             LSRS     R1,R1,#+1
   \   0000001A   0x0049             LSLS     R1,R1,#+1
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   2094          
   2095              /* Disable Tx DMA Request (done by default to handle the case Master RX direction 2 lines) */
   2096              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6841             LDR      R1,[R0, #+4]
   \   00000022   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000026   0x6041             STR      R1,[R0, #+4]
   2097          
   2098              /* CRC Calculation handling */
   2099              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000028   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002E   0xD138             BNE.N    ??SPI_DMAReceiveCplt_1
   2100              {
   2101                /* Wait until RXNE flag is set (CRC ready) */
   2102                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000030   0x230A             MOVS     R3,#+10
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_2
   2103                {
   2104                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000040   0x6D60             LDR      R0,[R4, #+84]
   \   00000042   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000046   0x6560             STR      R0,[R4, #+84]
   2105                }
   2106          
   2107                /* Read CRC */
   2108                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2109                UNUSED(tmpreg);
   \   00000050   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   2110          
   2111                /* Wait until RXNE flag is reset */
   2112                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000054   0x230A             MOVS     R3,#+10
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x4611             MOV      R1,R2
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_3
   2113                {
   2114                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000064   0x6D60             LDR      R0,[R4, #+84]
   \   00000066   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000006A   0x6560             STR      R0,[R4, #+84]
   2115                }
   2116          
   2117                /* Check if CRC error occurred */
   2118                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \                     ??SPI_DMAReceiveCplt_3: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6880             LDR      R0,[R0, #+8]
   \   00000070   0x06C0             LSLS     R0,R0,#+27
   \   00000072   0xD516             BPL.N    ??SPI_DMAReceiveCplt_1
   2119                {
   2120                  /* Check if CRC error is valid or not (workaround to be applied or not) */
   2121                  if (SPI_ISCRCErrorValid(hspi) == SPI_VALID_CRC_ERROR) 
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       SPI_ISCRCErrorValid
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD10D             BNE.N    ??SPI_DMAReceiveCplt_4
   2122                  {
   2123                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   0000007E   0x6D60             LDR      R0,[R4, #+84]
   \   00000080   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000084   0x6560             STR      R0,[R4, #+84]
   2124                    
   2125                    /* Reset CRC Calculation */
   2126                    SPI_RESET_CRC(hspi);
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000008E   0x6001             STR      R1,[R0, #+0]
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000098   0x6001             STR      R1,[R0, #+0]
   2127                  }
   2128                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \                     ??SPI_DMAReceiveCplt_4: (+1)
   \   0000009A   0xF06F 0x0010      MVN      R0,#+16
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x6088             STR      R0,[R1, #+8]
   2129                }
   2130              }
   2131          
   2132              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \   000000A2   0x6860             LDR      R0,[R4, #+4]
   \   000000A4   0xF5B0 0x7F82      CMP      R0,#+260
   \   000000A8   0xD10B             BNE.N    ??SPI_DMAReceiveCplt_5
   \   000000AA   0x68A0             LDR      R0,[R4, #+8]
   \   000000AC   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000B0   0xD002             BEQ.N    ??SPI_DMAReceiveCplt_6
   \   000000B2   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000B6   0xD104             BNE.N    ??SPI_DMAReceiveCplt_5
   2133              {
   2134                /* Disable SPI peripheral */
   2135                __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_DMAReceiveCplt_6: (+1)
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000C0   0x6001             STR      R1,[R0, #+0]
   2136              }
   2137          
   2138              hspi->RxXferCount = 0;
   \                     ??SPI_DMAReceiveCplt_5: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x87E0             STRH     R0,[R4, #+62]
   2139              hspi->State = HAL_SPI_STATE_READY;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF884 0x0051      STRB     R0,[R4, #+81]
   2140          
   2141              /* Check if Errors has been detected during transfer */
   2142              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   000000CC   0x6D60             LDR      R0,[R4, #+84]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0xD002             BEQ.N    ??SPI_DMAReceiveCplt_7
   2143              {
   2144                HAL_SPI_ErrorCallback(hspi);
   \   000000D4   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000D8   0xBD13             POP      {R0,R1,R4,PC}
   2145              }
   2146              else
   2147              {
   2148                HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_7: (+1)
   \   000000DA   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   000000DE   0xBD13             POP      {R0,R1,R4,PC}
   2149              }
   2150            }
   2151            else
   2152            {
   2153              HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   2154            }
   2155          }
   \   000000E6   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2156          
   2157          /**
   2158            * @brief DMA SPI transmit receive process complete callback 
   2159            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2160            *                the configuration information for the specified DMA module.
   2161            * @retval None
   2162            */

   \                                 In section .text, align 4, keep-with-next
   2163          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)   
   2164          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   2165            __IO uint16_t tmpreg = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   2166          
   2167            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   0000000A   0x6A44             LDR      R4,[R0, #+36]
   2168          
   2169            if((hdma->Instance->CCR & DMA_CIRCULAR) == 0)
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD45A             BMI.N    ??SPI_DMATransmitReceiveCplt_0
   2170            {
   2171              /* CRC Calculation handling */
   2172              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   00000014   0x6AA0             LDR      R0,[R4, #+40]
   \   00000016   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000001A   0xD124             BNE.N    ??SPI_DMATransmitReceiveCplt_1
   2173              {
   2174                /* Check if CRC is done on going (RXNE flag set) */
   2175                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) == HAL_OK)
   \   0000001C   0x230A             MOVS     R3,#+10
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD10B             BNE.N    ??SPI_DMATransmitReceiveCplt_2
   2176                {
   2177                  /* Wait until RXNE flag is set to send data */
   2178                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   0000002C   0x230A             MOVS     R3,#+10
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_2
   2179                  {
   2180                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000003C   0x6D60             LDR      R0,[R4, #+84]
   \   0000003E   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000042   0x6560             STR      R0,[R4, #+84]
   2181                  }
   2182                }
   2183                /* Read CRC */
   2184                tmpreg = hspi->Instance->DR;
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C1             LDR      R1,[R0, #+12]
   \   00000048   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   2185                UNUSED(tmpreg);
   \   0000004C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   2186          
   2187                /* Check if CRC error occurred */
   2188                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x06C0             LSLS     R0,R0,#+27
   \   00000054   0xD507             BPL.N    ??SPI_DMATransmitReceiveCplt_1
   2189                {
   2190                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   \   00000056   0x6D60             LDR      R0,[R4, #+84]
   \   00000058   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000005C   0x6560             STR      R0,[R4, #+84]
   2191                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   \   0000005E   0xF06F 0x0010      MVN      R0,#+16
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6088             STR      R0,[R1, #+8]
   2192                }
   2193              }
   2194          
   2195              /* Wait until TXE flag is set to send data */
   2196              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   00000066   0x230A             MOVS     R3,#+10
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_3
   2197              {
   2198                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000076   0x6D60             LDR      R0,[R4, #+84]
   \   00000078   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000007C   0x6560             STR      R0,[R4, #+84]
   2199              }
   2200            
   2201              /* Disable Tx DMA Request */
   2202              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_3: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6841             LDR      R1,[R0, #+4]
   \   00000082   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000086   0x6041             STR      R1,[R0, #+4]
   2203          
   2204              /* Wait until Busy flag is reset before disabling SPI */
   2205              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   \   00000088   0x230A             MOVS     R3,#+10
   \   0000008A   0x2201             MOVS     R2,#+1
   \   0000008C   0x2180             MOVS     R1,#+128
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       SPI_WaitOnFlagUntilTimeout
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_4
   2206              {
   2207                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000098   0x6D60             LDR      R0,[R4, #+84]
   \   0000009A   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000009E   0x6560             STR      R0,[R4, #+84]
   2208              }
   2209          
   2210              /* Disable Rx DMA Request */
   2211              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_4: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0x0849             LSRS     R1,R1,#+1
   \   000000A6   0x0049             LSLS     R1,R1,#+1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   2212          
   2213              hspi->TxXferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x86E0             STRH     R0,[R4, #+54]
   2214              hspi->RxXferCount = 0;
   \   000000AE   0x87E0             STRH     R0,[R4, #+62]
   2215          
   2216              hspi->State = HAL_SPI_STATE_READY;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF884 0x0051      STRB     R0,[R4, #+81]
   2217          
   2218              /* Check if Errors has been detected during transfer */
   2219              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   000000B6   0x6D60             LDR      R0,[R4, #+84]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0xD002             BEQ.N    ??SPI_DMATransmitReceiveCplt_5
   2220              {
   2221                HAL_SPI_ErrorCallback(hspi);
   \   000000BE   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   000000C2   0xBD13             POP      {R0,R1,R4,PC}
   2222              }
   2223              else
   2224              {
   2225                HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_5: (+1)
   \   000000C4   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   000000C8   0xBD13             POP      {R0,R1,R4,PC}
   2226              }
   2227            }
   2228            else
   2229            {
   2230              HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   2231            }
   2232          }
   \   000000D0   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2233          
   2234          /**
   2235            * @brief DMA SPI half transmit process complete callback 
   2236            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2237            *                the configuration information for the specified DMA module.
   2238            * @retval None
   2239            */

   \                                 In section .text, align 4, keep-with-next
   2240          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2241          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2242            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2243          
   2244            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2245          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2246          
   2247          /**
   2248            * @brief DMA SPI half receive process complete callback 
   2249            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2250            *                the configuration information for the specified DMA module.
   2251            * @retval None
   2252            */

   \                                 In section .text, align 4, keep-with-next
   2253          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2254          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2255            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2256          
   2257            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   \   00000004   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2258          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2259          
   2260          /**
   2261            * @brief DMA SPI Half transmit receive process complete callback 
   2262            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2263            *                the configuration information for the specified DMA module.
   2264            * @retval None
   2265            */

   \                                 In section .text, align 4, keep-with-next
   2266          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)   
   2267          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2268            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2269          
   2270            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2271          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2272          
   2273          /**
   2274            * @brief DMA SPI communication error callback 
   2275            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2276            *                the configuration information for the specified DMA module.
   2277            * @retval None
   2278            */

   \                                 In section .text, align 4, keep-with-next
   2279          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2280          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2281            SPI_HandleTypeDef* hspi = (SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   2282            hspi->TxXferCount = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x86C1             STRH     R1,[R0, #+54]
   2283            hspi->RxXferCount = 0;
   \   00000008   0xF200 0x0136      ADDW     R1,R0,#+54
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x810A             STRH     R2,[R1, #+8]
   2284            hspi->State= HAL_SPI_STATE_READY;
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x76CA             STRB     R2,[R1, #+27]
   2285            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \   00000014   0x6D41             LDR      R1,[R0, #+84]
   \   00000016   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000001A   0x6541             STR      R1,[R0, #+84]
   2286            HAL_SPI_ErrorCallback(hspi);
   \   0000001C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2287          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
   2288          
   2289          /**
   2290            * @brief  This function handles SPI Communication Timeout.
   2291            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2292            *                the configuration information for SPI module.
   2293            * @param  Flag: SPI flag to check
   2294            * @param  Status: Flag status to check: RESET or set
   2295            * @param  Timeout: Timeout duration
   2296            * @retval HAL status
   2297            */

   \                                 In section .text, align 2, keep-with-next
   2298          static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
   2299          {
   \                     SPI_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461E             MOV      R6,R3
   2300            uint32_t tickstart = 0;
   2301          
   2302            /* Get tick */ 
   2303            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4607             MOV      R7,R0
   2304          
   2305            /* Wait until flag is set */
   2306            if(Status == RESET)
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD127             BNE.N    ??SPI_WaitOnFlagUntilTimeout_0
   2307            {
   2308              while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
   \                     ??SPI_WaitOnFlagUntilTimeout_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x4028             ANDS     R0,R5,R0
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD051             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_2
   2309              {
   2310                if(Timeout != HAL_MAX_DELAY)
   \   00000022   0xF116 0x0F01      CMN      R6,#+1
   \   00000026   0xD0F7             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_1
   2311                {
   2312                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD004             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_3
   \   0000002C   0x.... 0x....      BL       HAL_GetTick
   \   00000030   0x1BC0             SUBS     R0,R0,R7
   \   00000032   0x4286             CMP      R6,R0
   \   00000034   0xD2F0             BCS.N    ??SPI_WaitOnFlagUntilTimeout_1
   2313                  {
   2314                    /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2315                       on both master and slave sides in order to resynchronize the master
   2316                       and slave for their respective CRC calculation */
   2317          
   2318                    /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2319                    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitOnFlagUntilTimeout_3: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6841             LDR      R1,[R0, #+4]
   \   0000003A   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000003E   0x6041             STR      R1,[R0, #+4]
   2320          
   2321                    /* Disable SPI peripheral */
   2322                    __HAL_SPI_DISABLE(hspi);
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000048   0x6001             STR      R1,[R0, #+0]
   2323          
   2324                    /* Reset CRC Calculation */
   2325                    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000004A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000050   0xD131             BNE.N    ??SPI_WaitOnFlagUntilTimeout_4
   2326                    {
   2327                      SPI_RESET_CRC(hspi);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000064   0x6001             STR      R1,[R0, #+0]
   \   00000066   0xE026             B.N      ??SPI_WaitOnFlagUntilTimeout_4
   2328                    }
   2329          
   2330                    hspi->State= HAL_SPI_STATE_READY;
   2331          
   2332                    /* Process Unlocked */
   2333                    __HAL_UNLOCK(hspi);
   2334          
   2335                    return HAL_TIMEOUT;
   2336                  }
   2337                }
   2338              }
   2339            }
   2340            else
   2341            {
   2342              while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
   \                     ??SPI_WaitOnFlagUntilTimeout_0: (+1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6880             LDR      R0,[R0, #+8]
   \   0000006C   0x4028             ANDS     R0,R5,R0
   \   0000006E   0x42A8             CMP      R0,R5
   \   00000070   0xD129             BNE.N    ??SPI_WaitOnFlagUntilTimeout_2
   2343              {
   2344                if(Timeout != HAL_MAX_DELAY)
   \   00000072   0xF116 0x0F01      CMN      R6,#+1
   \   00000076   0xD0F7             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_0
   2345                {
   2346                  if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD004             BEQ.N    ??SPI_WaitOnFlagUntilTimeout_5
   \   0000007C   0x.... 0x....      BL       HAL_GetTick
   \   00000080   0x1BC0             SUBS     R0,R0,R7
   \   00000082   0x4286             CMP      R6,R0
   \   00000084   0xD2F0             BCS.N    ??SPI_WaitOnFlagUntilTimeout_0
   2347                  {
   2348                    /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2349                       on both master and slave sides in order to resynchronize the master
   2350                       and slave for their respective CRC calculation */
   2351          
   2352                    /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2353                    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitOnFlagUntilTimeout_5: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6841             LDR      R1,[R0, #+4]
   \   0000008A   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000008E   0x6041             STR      R1,[R0, #+4]
   2354          
   2355                    /* Disable SPI peripheral */
   2356                    __HAL_SPI_DISABLE(hspi);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000098   0x6001             STR      R1,[R0, #+0]
   2357          
   2358                    /* Reset CRC Calculation */
   2359                    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \   0000009A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000009C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000A0   0xD109             BNE.N    ??SPI_WaitOnFlagUntilTimeout_4
   2360                    {
   2361                      SPI_RESET_CRC(hspi);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   000000AA   0x6001             STR      R1,[R0, #+0]
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6801             LDR      R1,[R0, #+0]
   \   000000B0   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000B4   0x6001             STR      R1,[R0, #+0]
   2362                    }
   2363          
   2364                    hspi->State= HAL_SPI_STATE_READY;
   \                     ??SPI_WaitOnFlagUntilTimeout_4: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xF884 0x0051      STRB     R0,[R4, #+81]
   2365          
   2366                    /* Process Unlocked */
   2367                    __HAL_UNLOCK(hspi);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF884 0x0050      STRB     R0,[R4, #+80]
   2368          
   2369                    return HAL_TIMEOUT;
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE000             B.N      ??SPI_WaitOnFlagUntilTimeout_6
   2370                  }
   2371                }
   2372              }
   2373            }
   2374            return HAL_OK;
   \                     ??SPI_WaitOnFlagUntilTimeout_2: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitOnFlagUntilTimeout_6: (+1)
   \   000000C8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2375          }
   2376          
   2377          /**
   2378            * @}
   2379            */
   2380          
   2381          /** @addtogroup SPI_Private_Functions
   2382            * @{
   2383            */
   2384          
   2385          /**
   2386            * @brief  Checks if encountered CRC error could be corresponding to wrongly detected errors 
   2387            *         according to SPI instance, Device type, and revision ID.
   2388            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2389            *               the configuration information for SPI module.
   2390            * @retval CRC error validity (SPI_INVALID_CRC_ERROR or SPI_VALID_CRC_ERROR).  
   2391          */

   \                                 In section .text, align 2, keep-with-next
   2392          __weak uint8_t SPI_ISCRCErrorValid(SPI_HandleTypeDef *hspi)
   2393          {
   2394            return (SPI_VALID_CRC_ERROR);
   \                     SPI_ISCRCErrorValid: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   2395          }
   2396          /**
   2397            * @}
   2398            */
   2399          
   2400          
   2401          #endif /* HAL_SPI_MODULE_ENABLED */
   2402          /**
   2403            * @}
   2404            */
   2405          
   2406          /**
   2407            * @}
   2408            */
   2409          
   2410          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
       8   HAL_SPI_IRQHandler
         0   -- Indirect call
         8   -> HAL_SPI_ErrorCallback
       8   HAL_SPI_Init
         8   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      16   HAL_SPI_Receive
        16   -> HAL_SPI_TransmitReceive
        16   -> SPI_ISCRCErrorValid
        16   -> SPI_WaitOnFlagUntilTimeout
       8   HAL_SPI_Receive_DMA
         8   -> HAL_DMA_Start_IT
         0   -> HAL_SPI_TransmitReceive_DMA
       0   HAL_SPI_Receive_IT
         0   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      16   HAL_SPI_Transmit
        16   -> SPI_WaitOnFlagUntilTimeout
      16   HAL_SPI_TransmitReceive
        16   -> SPI_WaitOnFlagUntilTimeout
      16   HAL_SPI_TransmitReceive_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_SPI_TransmitReceive_IT
       8   HAL_SPI_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       0   SPI_2LinesRxISR
         0   -> SPI_RxCloseIRQHandler
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_ISCRCErrorValid
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_DMATransmitCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
       0   SPI_ISCRCErrorValid
      16   SPI_RxCloseIRQHandler
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_ISCRCErrorValid
        16   -> SPI_WaitOnFlagUntilTimeout
       0   SPI_RxISR
         0   -> SPI_RxCloseIRQHandler
      16   SPI_TxCloseIRQHandler
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
       0   SPI_TxISR
         0   -> SPI_TxCloseIRQHandler
      24   SPI_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      48  HAL_SPI_DMAPause
      48  HAL_SPI_DMAResume
      54  HAL_SPI_DMAStop
      46  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     176  HAL_SPI_IRQHandler
     124  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     528  HAL_SPI_Receive
     220  HAL_SPI_Receive_DMA
     176  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     418  HAL_SPI_Transmit
     782  HAL_SPI_TransmitReceive
     272  HAL_SPI_TransmitReceive_DMA
     174  HAL_SPI_TransmitReceive_IT
     190  HAL_SPI_Transmit_DMA
     166  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      48  SPI_2LinesRxISR
      34  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
     232  SPI_DMAReceiveCplt
     120  SPI_DMATransmitCplt
     210  SPI_DMATransmitReceiveCplt
       4  SPI_ISCRCErrorValid
     258  SPI_RxCloseIRQHandler
      72  SPI_RxISR
     152  SPI_TxCloseIRQHandler
      66  SPI_TxISR
     204  SPI_WaitOnFlagUntilTimeout

 
 4 880 bytes in section .text
 
 4 880 bytes of CODE memory

Errors: none
Warnings: none
