###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:25
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\endstops.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\endstops.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\endstops.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\endstops.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\endstops.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * endstops.cpp - A singleton object to manage endstops
     25           */
     26          
     27          #include "Marlin.h"

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     28          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 524 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless

   \                                 In section .text, align 4
   \   __interwork __softfp bool Stepper::motor_direction(AxisEnum)
   \                     _ZN7Stepper15motor_directionE8AxisEnum: (+1)
   \   00000000   0x4905             LDR.N    R1,??motor_direction_0
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xFA02 0xF000      LSL      R0,R2,R0
   \   0000000A   0x4001             ANDS     R1,R0,R1
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0x4770             BX       LR               ;; return
   \                     ??motor_direction_0:
   \   00000018   0x........         DC32     _ZN7Stepper19last_direction_bitsE

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::kill_current_block()
   \                     _ZN7Stepper18kill_current_blockEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??kill_current_block_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6940             LDR      R0,[R0, #+20]
   \   00000006   0x4902             LDR.N    R1,??kill_current_block_0+0x4
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??kill_current_block_0:
   \   0000000C   0x........         DC32     _ZN7Stepper13current_blockE
   \   00000010   0x........         DC32     _ZN7Stepper21step_events_completedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Stepper::triggered_position_mm(AxisEnum)
   \                     _ZN7Stepper21triggered_position_mmE8AxisEnum: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4805             LDR.N    R0,??triggered_position_mm_0
   \   00000006   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2f
   \   0000000E   0x4904             LDR.N    R1,??triggered_position_mm_0+0x4
   \   00000010   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      __aeabi_fmul
   \                     ??triggered_position_mm_0:
   \   0000001C   0x........         DC32     _ZN7Stepper18endstops_trigstepsE
   \   00000020   0x........         DC32     _ZN7Planner11steps_to_mmE

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")
     29          #include "endstops.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp Endstops::Endstops()
   \                     _ZN8EndstopsC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       _ZN8Endstops15enable_globallyEb
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_globally(bool)
   \                     _ZN8Endstops15enable_globallyEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_globally_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x7048             STRB     R0,[R1, #+1]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??enable_globally_0:
   \   00000008   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::hit_on_purpose()
   \                     _ZN8Endstops14hit_on_purposeEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??hit_on_purpose_0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??hit_on_purpose_0:
   \   00000008   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE
     30          #include "temperature.h"
     31          #include "stepper.h"
     32          #include "ultralcd.h"
     33          
     34          // TEST_ENDSTOP: test the old and the current status of an endstop
     35          #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
     36          

   \                                 In section .bss, align 4
     37          Endstops endstops;
   \                     endstops:
   \   00000000                      DS8 4
     38          
     39          // public:
     40          

   \                                 In section .bss, align 1
     41          bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
   \                     _ZN8Endstops7enabledE:
   \   00000000                      DS8 1
   \                     _ZN8Endstops16enabled_globallyE:
   \   00000001                      DS8 1

   \                                 In section .bss, align 2
     42          volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
   \                     _ZN8Endstops16endstop_hit_bitsE:
   \   00000000                      DS8 1
     43          #if 0
     44          #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     45            uint16_t
     46          #else
     47            byte
     48          #endif
     49          #endif
     50          uint16_t    Endstops::current_endstop_bits = 0;
     51          uint16_t    Endstops::old_endstop_bits = 0;
     52          
     53          #if HAS_BED_PROBE
     54            volatile bool Endstops::z_probe_enabled = false;
   \                     _ZN8Endstops15z_probe_enabledE:
   \   00000001                      DS8 1
   \                     _ZN8Endstops20current_endstop_bitsE:
   \   00000002                      DS8 2
   \                     _ZN8Endstops16old_endstop_bitsE:
   \   00000004                      DS8 2
     55          #endif
     56          
     57          /**
     58           * Class and Instance Methods
     59           */
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void Endstops::init() {
     62          
     63            #if HAS_X_MIN
     64              #if ENABLED(ENDSTOPPULLUP_XMIN)
     65                SET_INPUT_PULLUP(X_MIN_PIN);
     66              #else
     67                SET_INPUT(X_MIN_PIN);
     68              #endif
     69            #endif
     70          
     71            #if HAS_X2_MIN
     72              #if ENABLED(ENDSTOPPULLUP_XMIN)
     73                SET_INPUT_PULLUP(X2_MIN_PIN);
     74              #else
     75                SET_INPUT(X2_MIN_PIN);
     76              #endif
     77            #endif
     78          
     79            #if HAS_Y_MIN
     80              #if ENABLED(ENDSTOPPULLUP_YMIN)
     81                SET_INPUT_PULLUP(Y_MIN_PIN);
     82              #else
     83                SET_INPUT(Y_MIN_PIN);
     84              #endif
     85            #endif
     86          
     87            #if HAS_Y2_MIN
     88              #if ENABLED(ENDSTOPPULLUP_YMIN)
     89                SET_INPUT_PULLUP(Y2_MIN_PIN);
     90              #else
     91                SET_INPUT(Y2_MIN_PIN);
     92              #endif
     93            #endif
     94          
     95            #if HAS_Z_MIN
     96              #if ENABLED(ENDSTOPPULLUP_ZMIN)
     97                SET_INPUT_PULLUP(Z_MIN_PIN);
     98              #else
     99                SET_INPUT(Z_MIN_PIN);
    100              #endif
    101            #endif
    102          
    103            //#if HAS_Z2_MIN
    104            if((Z_DUAL_ENDSTOPS==1)&&(Z2_USE_ENDSTOP==2))
    105            {
    106              #if ENABLED(ENDSTOPPULLUP_ZMIN)
    107                SET_INPUT_PULLUP(Z2_MIN_PIN);
    108              #else
    109                SET_INPUT(Z2_MIN_PIN);
    110              #endif
    111            }
    112            //#endif
    113          
    114            #if HAS_X_MAX
    115              #if ENABLED(ENDSTOPPULLUP_XMAX)
    116                SET_INPUT_PULLUP(X_MAX_PIN);
    117              #else
    118                SET_INPUT(X_MAX_PIN);
    119              #endif
    120            #endif
    121          
    122            #if HAS_X2_MAX
    123              #if ENABLED(ENDSTOPPULLUP_XMAX)
    124                SET_INPUT_PULLUP(X2_MAX_PIN);
    125              #else
    126                SET_INPUT(X2_MAX_PIN);
    127              #endif
    128            #endif
    129          
    130            #if HAS_Y_MAX
    131              #if ENABLED(ENDSTOPPULLUP_YMAX)
    132                SET_INPUT_PULLUP(Y_MAX_PIN);
    133              #else
    134                SET_INPUT(Y_MAX_PIN);
    135              #endif
    136            #endif
    137          
    138            #if HAS_Y2_MAX
    139              #if ENABLED(ENDSTOPPULLUP_YMAX)
    140                SET_INPUT_PULLUP(Y2_MAX_PIN);
    141              #else
    142                SET_INPUT(Y2_MAX_PIN);
    143              #endif
    144            #endif
    145          
    146            #if HAS_Z_MAX
    147            if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
    148            {  
    149              #if ENABLED(ENDSTOPPULLUP_ZMAX)
    150                SET_INPUT_PULLUP(Z_MAX_PIN);
    151              #else
    152                SET_INPUT(Z_MAX_PIN);
    153              #endif
    154            }
    155            #endif
    156          
    157            //#if HAS_Z2_MAX
    158            if((Z_DUAL_ENDSTOPS==1)&&(Z2_USE_ENDSTOP==1))
    159            {
    160              #if ENABLED(ENDSTOPPULLUP_ZMAX)
    161                SET_INPUT_PULLUP(Z2_MAX_PIN);
    162              #else
    163                SET_INPUT(Z2_MAX_PIN);
    164              #endif
    165            }
    166            //#endif
    167          
    168            //#if ENABLED(Z_MIN_PROBE_ENDSTOP)
    169             if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)  
    170           	{
    171              #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
    172                SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
    173              #else
    174                SET_INPUT(Z_MIN_PROBE_PIN);
    175              #endif
    176             	}
    177            //#endif
    178          
    179          } // Endstops::init
   \                     _ZN8Endstops4initEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    180          

   \                                 In section .text, align 2, keep-with-next
    181          void Endstops::report_state() {
   \                     _ZN8Endstops12report_stateEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    182            if (endstop_hit_bits) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000006   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD04E             BEQ.N    ??report_state_0
    183              #if ENABLED(ULTRA_LCD)
    184                char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
    185                #define _SET_STOP_CHAR(A,C) (chr## A = C)
    186              #else
    187                #define _SET_STOP_CHAR(A,C) ;
    188              #endif
    189          
    190              #define _ENDSTOP_HIT_ECHO(A,C) do{ \
    191                SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(A ##_AXIS)); \
    192                _SET_STOP_CHAR(A,C); }while(0)
    193          
    194              #define _ENDSTOP_HIT_TEST(A,C) \
    195                if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
    196                  _ENDSTOP_HIT_ECHO(A,C)
    197          
    198              #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
    199              #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
    200              #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
    201          
    202              SERIAL_ECHO_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
    203              SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "endstops hit: ">`
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    204              ENDSTOP_HIT_TEST_X();
   \   0000001E   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD403             BMI.N    ??report_state_1
   \   00000026   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000002A   0x06C0             LSLS     R0,R0,#+27
   \   0000002C   0xD506             BPL.N    ??report_state_2
   \                     ??report_state_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x....             ADR.N    R0,??DataTable20  ;; " X:"
   \   00000038   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    205              ENDSTOP_HIT_TEST_Y();
   \                     ??report_state_2: (+1)
   \   0000003C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000040   0x0780             LSLS     R0,R0,#+30
   \   00000042   0xD403             BMI.N    ??report_state_3
   \   00000044   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000048   0x0680             LSLS     R0,R0,#+26
   \   0000004A   0xD506             BPL.N    ??report_state_4
   \                     ??report_state_3: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0x....             ADR.N    R0,??DataTable20_1  ;; " Y:"
   \   00000056   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    206              ENDSTOP_HIT_TEST_Z();
   \                     ??report_state_4: (+1)
   \   0000005A   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000005E   0x0740             LSLS     R0,R0,#+29
   \   00000060   0xD403             BMI.N    ??report_state_5
   \   00000062   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000066   0x0640             LSLS     R0,R0,#+25
   \   00000068   0xD506             BPL.N    ??report_state_6
   \                     ??report_state_5: (+1)
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   00000070   0x4601             MOV      R1,R0
   \   00000072   0x....             ADR.N    R0,??DataTable20_2  ;; " Z:"
   \   00000074   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    207          
    208              //#if ENABLED(Z_MIN_PROBE_ENDSTOP)
    209          	 if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \                     ??report_state_6: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   0000007C   0xF890 0x0099      LDRB     R0,[R0, #+153]
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xD10A             BNE.N    ??report_state_7
    210          	 {	
    211                #define P_AXIS Z_AXIS
    212                if (TEST(endstop_hit_bits, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
   \   00000084   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000088   0x0700             LSLS     R0,R0,#+28
   \   0000008A   0xD506             BPL.N    ??report_state_7
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   00000092   0x4601             MOV      R1,R0
   \   00000094   0x....             ADR.N    R0,??DataTable20_3  ;; " P:"
   \   00000096   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    213          	 }
    214              //#endif
    215          	
    216              SERIAL_EOL();
   \                     ??report_state_7: (+1)
   \   0000009A   0x210A             MOVS     R1,#+10
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable27_4
   \   000000A0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    217          
    218              #if ENABLED(ULTRA_LCD)
    219                lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
    220              #endif
    221          
    222              hit_on_purpose();
   \   000000A4   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A8   0x.... 0x....      B.W      _ZN8Endstops14hit_on_purposeEv
    223          
    224              #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
    225                if (stepper.abort_on_endstop_hit) {
    226                  card.sdprinting = false;
    227                  card.closefile();
    228                  quickstop_stepper();
    229                  thermalManager.disable_all_heaters(); // switch off all heaters.
    230                }
    231              #endif
    232            }
    233          } // Endstops::report_state
   \                     ??report_state_0: (+1)
   \   000000AC   0xBD10             POP      {R4,PC}          ;; return
    234          

   \                                 In section .text, align 2, keep-with-next
    235          void Endstops::M119() {
   \                     _ZN8Endstops4M119Ev: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    236            SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "Reporting endstop sta...">`
   \   00000008   0x.... 0x....      BL       _Z14serialprintPGMPKc
    237            #define ES_REPORT(AXIS) do{ \
    238              SERIAL_PROTOCOLPGM(MSG_##AXIS); \
    239              SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
    240            }while(0)
    241            #if HAS_X_MIN
    242            if(mksCfg.use_xmin_plug){
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable27_4
   \   00000010   0x.... 0x....      ADR.W    R5,`?<Constant "open">`
   \   00000014   0x.... 0x....      ADR.W    R6,`?<Constant "TRIGGERED">`
   \   00000018   0x.... 0x....      LDR.W    R7,??DataTable27_5
   \   0000001C   0x.... 0x....      LDR.W    R8,??DataTable27_6
   \   00000020   0x.... 0x....      LDR.W    R10,??DataTable27_3
   \   00000024   0xF89A 0x0080      LDRB     R0,[R10, #+128]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD017             BEQ.N    ??M119_0
    243              ES_REPORT(X_MIN);
   \   0000002C   0x.... 0x....      ADR.W    R0,`?<Constant "x_min: ">`
   \   00000030   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000034   0xF8B8 0x1006      LDRH     R1,[R8, #+6]
   \   00000038   0x68F8             LDR      R0,[R7, #+12]
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000003E   0xF89A 0x1037      LDRB     R1,[R10, #+55]
   \   00000042   0xEA91 0x0F00      TEQ      R1,R0
   \   00000046   0xD001             BEQ.N    ??M119_1
   \   00000048   0x4631             MOV      R1,R6
   \   0000004A   0xE000             B.N      ??M119_2
   \                     ??M119_1: (+1)
   \   0000004C   0x4629             MOV      R1,R5
   \                     ??M119_2: (+1)
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000054   0x210A             MOVS     R1,#+10
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    244            	}
    245            #endif
    246            #if HAS_X2_MIN
    247              ES_REPORT(X2_MIN);
    248            #endif
    249            #if HAS_X_MAX
    250            if(mksCfg.use_xmax_plug){
   \                     ??M119_0: (+1)
   \   0000005C   0xF20A 0x0937      ADDW     R9,R10,#+55
   \   00000060   0xF10A 0x0A80      ADD      R10,R10,#+128
   \   00000064   0xF89A 0x0003      LDRB     R0,[R10, #+3]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD017             BEQ.N    ??M119_3
    251              ES_REPORT(X_MAX);
   \   0000006C   0x.... 0x....      ADR.W    R0,`?<Constant "x_max: ">`
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000074   0xF8B8 0x1006      LDRH     R1,[R8, #+6]
   \   00000078   0x68F8             LDR      R0,[R7, #+12]
   \   0000007A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000007E   0xF899 0x1003      LDRB     R1,[R9, #+3]
   \   00000082   0xEA91 0x0F00      TEQ      R1,R0
   \   00000086   0xD001             BEQ.N    ??M119_4
   \   00000088   0x4631             MOV      R1,R6
   \   0000008A   0xE000             B.N      ??M119_5
   \                     ??M119_4: (+1)
   \   0000008C   0x4629             MOV      R1,R5
   \                     ??M119_5: (+1)
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000094   0x210A             MOVS     R1,#+10
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    252            	}
    253            #endif
    254            #if HAS_X2_MAX
    255              ES_REPORT(X2_MAX);
    256            #endif
    257            #if HAS_Y_MIN
    258            if(mksCfg.use_ymin_plug){  
   \                     ??M119_3: (+1)
   \   0000009C   0xF89A 0x0001      LDRB     R0,[R10, #+1]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD017             BEQ.N    ??M119_6
    259              ES_REPORT(Y_MIN);
   \   000000A4   0x.... 0x....      ADR.W    R0,`?<Constant "y_min: ">`
   \   000000A8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000AC   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   000000B0   0x6A38             LDR      R0,[R7, #+32]
   \   000000B2   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000B6   0xF899 0x1001      LDRB     R1,[R9, #+1]
   \   000000BA   0xEA91 0x0F00      TEQ      R1,R0
   \   000000BE   0xD001             BEQ.N    ??M119_7
   \   000000C0   0x4631             MOV      R1,R6
   \   000000C2   0xE000             B.N      ??M119_8
   \                     ??M119_7: (+1)
   \   000000C4   0x4629             MOV      R1,R5
   \                     ??M119_8: (+1)
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000000CC   0x210A             MOVS     R1,#+10
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    260            	}
    261            #endif
    262            #if HAS_Y2_MIN
    263              ES_REPORT(Y2_MIN);
    264            #endif
    265            #if HAS_Y_MAX
    266          if(mksCfg.use_ymax_plug){   
   \                     ??M119_6: (+1)
   \   000000D4   0xF89A 0x0004      LDRB     R0,[R10, #+4]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD017             BEQ.N    ??M119_9
    267              ES_REPORT(Y_MAX);
   \   000000DC   0x.... 0x....      ADR.W    R0,`?<Constant "y_max: ">`
   \   000000E0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000E4   0xF8B8 0x1010      LDRH     R1,[R8, #+16]
   \   000000E8   0x6A38             LDR      R0,[R7, #+32]
   \   000000EA   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000EE   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   000000F2   0xEA91 0x0F00      TEQ      R1,R0
   \   000000F6   0xD001             BEQ.N    ??M119_10
   \   000000F8   0x4631             MOV      R1,R6
   \   000000FA   0xE000             B.N      ??M119_11
   \                     ??M119_10: (+1)
   \   000000FC   0x4629             MOV      R1,R5
   \                     ??M119_11: (+1)
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000104   0x210A             MOVS     R1,#+10
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    268          }
    269            #endif
    270            #if HAS_Y2_MAX
    271              ES_REPORT(Y2_MAX);
    272            #endif
    273            #if HAS_Z_MIN
    274          if(mksCfg.use_zmin_plug){  
   \                     ??M119_9: (+1)
   \   0000010C   0xF89A 0x0002      LDRB     R0,[R10, #+2]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD017             BEQ.N    ??M119_12
    275              ES_REPORT(Z_MIN);
   \   00000114   0x.... 0x....      ADR.W    R0,`?<Constant "z_min: ">`
   \   00000118   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000011C   0xF8B8 0x101A      LDRH     R1,[R8, #+26]
   \   00000120   0x6B78             LDR      R0,[R7, #+52]
   \   00000122   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000126   0xF899 0x1002      LDRB     R1,[R9, #+2]
   \   0000012A   0xEA91 0x0F00      TEQ      R1,R0
   \   0000012E   0xD001             BEQ.N    ??M119_13
   \   00000130   0x4631             MOV      R1,R6
   \   00000132   0xE000             B.N      ??M119_14
   \                     ??M119_13: (+1)
   \   00000134   0x4629             MOV      R1,R5
   \                     ??M119_14: (+1)
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000013C   0x210A             MOVS     R1,#+10
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    276          }
    277            #endif
    278            #if HAS_Z2_MIN
    279              ES_REPORT(Z2_MIN);
   \                     ??M119_12: (+1)
   \   00000144   0x.... 0x....      ADR.W    R0,`?<Constant "z2_min: ">`
   \   00000148   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000014C   0xF8B8 0x101A      LDRH     R1,[R8, #+26]
   \   00000150   0x6B78             LDR      R0,[R7, #+52]
   \   00000152   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000156   0xF899 0x1002      LDRB     R1,[R9, #+2]
   \   0000015A   0xEA91 0x0F00      TEQ      R1,R0
   \   0000015E   0xD001             BEQ.N    ??M119_15
   \   00000160   0x4631             MOV      R1,R6
   \   00000162   0xE000             B.N      ??M119_16
   \                     ??M119_15: (+1)
   \   00000164   0x4629             MOV      R1,R5
   \                     ??M119_16: (+1)
   \   00000166   0x4620             MOV      R0,R4
   \   00000168   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000016C   0x210A             MOVS     R1,#+10
   \   0000016E   0x4620             MOV      R0,R4
   \   00000170   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    280            #endif
    281            #if HAS_Z_MAX
    282          	if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)  
   \   00000174   0xF89A 0x0019      LDRB     R0,[R10, #+25]
   \   00000178   0x2802             CMP      R0,#+2
   \   0000017A   0xD01B             BEQ.N    ??M119_17
    283          	{
    284          		if(mksCfg.use_zmax_plug)
   \   0000017C   0xF89A 0x0005      LDRB     R0,[R10, #+5]
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD017             BEQ.N    ??M119_17
    285          		{   
    286              		ES_REPORT(Z_MAX);
   \   00000184   0x.... 0x....      ADR.W    R0,`?<Constant "z_max: ">`
   \   00000188   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000018C   0xF8B8 0x101C      LDRH     R1,[R8, #+28]
   \   00000190   0x6BB8             LDR      R0,[R7, #+56]
   \   00000192   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000196   0xF899 0x1005      LDRB     R1,[R9, #+5]
   \   0000019A   0xEA91 0x0F00      TEQ      R1,R0
   \   0000019E   0xD001             BEQ.N    ??M119_18
   \   000001A0   0x4631             MOV      R1,R6
   \   000001A2   0xE000             B.N      ??M119_19
   \                     ??M119_18: (+1)
   \   000001A4   0x4629             MOV      R1,R5
   \                     ??M119_19: (+1)
   \   000001A6   0x4620             MOV      R0,R4
   \   000001A8   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000001AC   0x210A             MOVS     R1,#+10
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    287          		}
    288          	}
    289            #endif
    290            #if HAS_Z2_MAX
    291              ES_REPORT(Z2_MAX);
   \                     ??M119_17: (+1)
   \   000001B4   0x.... 0x....      ADR.W    R0,`?<Constant "z2_max: ">`
   \   000001B8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000001BC   0xF8B8 0x101C      LDRH     R1,[R8, #+28]
   \   000001C0   0x6BB8             LDR      R0,[R7, #+56]
   \   000001C2   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000001C6   0xF899 0x1005      LDRB     R1,[R9, #+5]
   \   000001CA   0xEA91 0x0F00      TEQ      R1,R0
   \   000001CE   0xD001             BEQ.N    ??M119_20
   \   000001D0   0x4631             MOV      R1,R6
   \   000001D2   0xE000             B.N      ??M119_21
   \                     ??M119_20: (+1)
   \   000001D4   0x4629             MOV      R1,R5
   \                     ??M119_21: (+1)
   \   000001D6   0x4620             MOV      R0,R4
   \   000001D8   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000001DC   0x210A             MOVS     R1,#+10
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    292            #endif
    293            //#if ENABLED(Z_MIN_PROBE_ENDSTOP)
    294              if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \   000001E4   0xF89A 0x0019      LDRB     R0,[R10, #+25]
   \   000001E8   0x2802             CMP      R0,#+2
   \   000001EA   0xD118             BNE.N    ??M119_22
    295             	{
    296              	SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
   \   000001EC   0x.... 0x....      ADR.W    R0,`?<Constant "z_probe: ">`
   \   000001F0   0x.... 0x....      BL       _Z14serialprintPGMPKc
    297              	SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   \   000001F4   0xF8B8 0x101C      LDRH     R1,[R8, #+28]
   \   000001F8   0x6BB8             LDR      R0,[R7, #+56]
   \   000001FA   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000001FE   0xF899 0x1006      LDRB     R1,[R9, #+6]
   \   00000202   0xEA91 0x0F00      TEQ      R1,R0
   \   00000206   0xD000             BEQ.N    ??M119_23
   \   00000208   0x4635             MOV      R5,R6
   \                     ??M119_23: (+1)
   \   0000020A   0x4629             MOV      R1,R5
   \   0000020C   0x4620             MOV      R0,R4
   \   0000020E   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000212   0x210A             MOVS     R1,#+10
   \   00000214   0x4620             MOV      R0,R4
   \   00000216   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   0000021A   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    298              }
    299            //#endif
    300            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    301              SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
    302              SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
    303            #endif
    304          } // Endstops::M119
   \                     ??M119_22: (+1)
   \   0000021E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    305          
    306          #if ENABLED(X_DUAL_ENDSTOPS)
    307            void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
    308              byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
    309              if (x_test && stepper.current_block->steps[X_AXIS] > 0) {
    310                SBI(endstop_hit_bits, X_MIN);
    311                if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
    312                  stepper.kill_current_block();
    313              }
    314            }
    315          #endif
    316          #if ENABLED(Y_DUAL_ENDSTOPS)
    317            void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
    318              byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
    319              if (y_test && stepper.current_block->steps[Y_AXIS] > 0) {
    320                SBI(endstop_hit_bits, Y_MIN);
    321                if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
    322                  stepper.kill_current_block();
    323              }
    324            }
    325          #endif
    326          #if 1//ENABLED(Z_DUAL_ENDSTOPS)

   \                                 In section .text, align 2, keep-with-next
    327            void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
   \                     _ZN8Endstops20test_dual_z_endstopsE11EndstopEnumS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
    328              byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable27_1
   \   00000006   0x8853             LDRH     R3,[R2, #+2]
   \   00000008   0x8894             LDRH     R4,[R2, #+4]
   \   0000000A   0x4023             ANDS     R3,R4,R3
   \   0000000C   0xFA43 0xF400      ASR      R4,R3,R0
   \   00000010   0xFA43 0xF001      ASR      R0,R3,R1
   \   00000014   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000018   0x0861             LSRS     R1,R4,#+1
   \   0000001A   0x4140             ADCS     R0,R0,R0
   \   0000001C   0xB2C0             UXTB     R0,R0
    329              if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD013             BEQ.N    ??test_dual_z_endstops_0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x68C9             LDR      R1,[R1, #+12]
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xDB0D             BLT.N    ??test_dual_z_endstops_0
    330                SBI(endstop_hit_bits, Z_MIN);
   \   0000002E   0x7811             LDRB     R1,[R2, #+0]
   \   00000030   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000034   0x7011             STRB     R1,[R2, #+0]
    331                if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable27_8
   \   0000003A   0x7809             LDRB     R1,[R1, #+0]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD001             BEQ.N    ??test_dual_z_endstops_1
   \   00000040   0x2803             CMP      R0,#+3
   \   00000042   0xD102             BNE.N    ??test_dual_z_endstops_0
    332                  stepper.kill_current_block();
   \                     ??test_dual_z_endstops_1: (+1)
   \   00000044   0xBC11             POP      {R0,R4}
   \   00000046   0x.... 0x....      B.W      _ZN7Stepper18kill_current_blockEv
    333              }
    334            }
   \                     ??test_dual_z_endstops_0: (+1)
   \   0000004A   0xBC11             POP      {R0,R4}
   \   0000004C   0x4770             BX       LR               ;; return
    335          #endif
    336          
    337          #if 1//IS_CORE
    338            #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
    339            #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
    340          #endif
    341          

   \                                 In section .text, align 2, keep-with-next
    342          bool  X_MOVE_TEST()
    343          {
   \                     _Z11X_MOVE_TESTv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000006   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000000A   0x213C             MOVS     R1,#+60
   \   0000000C   0x4208             TST      R0,R1
   \   0000000E   0xF000 0x8091      BEQ.W    ??X_MOVE_TEST_0
    344              bool D_temp;
    345          	if(MACHINETPYE & CORE_IS_XY || MACHINETPYE & CORE_IS_XZ)
    346          	{
    347          		if(MACHINETPYE & COREXY || MACHINETPYE & COREXZ)
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD046             BEQ.N    ??X_MOVE_TEST_1
    348          		{
    349          	          if(MACHINETPYE & CORE_IS_XY)
   \   00000018   0x210C             MOVS     R1,#+12
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xD00C             BEQ.N    ??X_MOVE_TEST_2
    350          	            D_temp = (stepper.motor_direction(A_AXIS) == stepper.motor_direction(B_AXIS));
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000024   0x4604             MOV      R4,R0
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD101             BNE.N    ??X_MOVE_TEST_3
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xE01D             B.N      ??X_MOVE_TEST_4
   \                     ??X_MOVE_TEST_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xE01B             B.N      ??X_MOVE_TEST_4
    351          	          else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??X_MOVE_TEST_2: (+1)
   \   00000038   0x2130             MOVS     R1,#+48
   \   0000003A   0x4208             TST      R0,R1
   \   0000003C   0xD00C             BEQ.N    ??X_MOVE_TEST_5
    352          	            D_temp = (stepper.motor_direction(A_AXIS) == stepper.motor_direction(C_AXIS));
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000044   0x4604             MOV      R4,R0
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD101             BNE.N    ??X_MOVE_TEST_6
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0xE00D             B.N      ??X_MOVE_TEST_4
   \                     ??X_MOVE_TEST_6: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xE00B             B.N      ??X_MOVE_TEST_4
    353          	          else
    354          	            D_temp = (stepper.motor_direction(B_AXIS) == stepper.motor_direction(C_AXIS));
   \                     ??X_MOVE_TEST_5: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000005E   0x4604             MOV      R4,R0
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD101             BNE.N    ??X_MOVE_TEST_7
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xE000             B.N      ??X_MOVE_TEST_4
   \                     ??X_MOVE_TEST_7: (+1)
   \   0000006E   0x2100             MOVS     R1,#+0
    355          	          return  ( S_(1) != S_(2) || (S_(1) > 0 && D_temp) );
   \                     ??X_MOVE_TEST_4: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000074   0x7C02             LDRB     R2,[R0, #+16]
   \   00000076   0x.... 0x....      LDR.W    R3,??DataTable27_7
   \   0000007A   0x681B             LDR      R3,[R3, #+0]
   \   0000007C   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \   00000080   0x6852             LDR      R2,[R2, #+4]
   \   00000082   0x7C40             LDRB     R0,[R0, #+17]
   \   00000084   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   00000088   0x6840             LDR      R0,[R0, #+4]
   \   0000008A   0x4282             CMP      R2,R0
   \   0000008C   0xD107             BNE.N    ??X_MOVE_TEST_8
   \   0000008E   0x2A01             CMP      R2,#+1
   \   00000090   0xDB07             BLT.N    ??X_MOVE_TEST_9
   \   00000092   0x4608             MOV      R0,R1
   \   00000094   0x1E40             SUBS     R0,R0,#+1
   \   00000096   0x4180             SBCS     R0,R0,R0
   \   00000098   0x43C0             MVNS     R0,R0
   \   0000009A   0x0FC0             LSRS     R0,R0,#+31
   \   0000009C   0xBD10             POP      {R4,PC}
   \                     ??X_MOVE_TEST_8: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xBD10             POP      {R4,PC}
   \                     ??X_MOVE_TEST_9: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xBD10             POP      {R4,PC}
    356          		}
    357          		else
    358          		{
    359                        if(MACHINETPYE & CORE_IS_XY)
   \                     ??X_MOVE_TEST_1: (+1)
   \   000000A6   0x210C             MOVS     R1,#+12
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xD00C             BEQ.N    ??X_MOVE_TEST_10
    360                          D_temp = (stepper.motor_direction(A_AXIS) != stepper.motor_direction(B_AXIS));
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000B2   0x4604             MOV      R4,R0
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000BA   0x4284             CMP      R4,R0
   \   000000BC   0xD001             BEQ.N    ??X_MOVE_TEST_11
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0xE01D             B.N      ??X_MOVE_TEST_12
   \                     ??X_MOVE_TEST_11: (+1)
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xE01B             B.N      ??X_MOVE_TEST_12
    361                        else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??X_MOVE_TEST_10: (+1)
   \   000000C6   0x2130             MOVS     R1,#+48
   \   000000C8   0x4208             TST      R0,R1
   \   000000CA   0xD00C             BEQ.N    ??X_MOVE_TEST_13
    362                          D_temp = (stepper.motor_direction(A_AXIS) != stepper.motor_direction(C_AXIS));
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000D2   0x4604             MOV      R4,R0
   \   000000D4   0x2002             MOVS     R0,#+2
   \   000000D6   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000DA   0x4284             CMP      R4,R0
   \   000000DC   0xD001             BEQ.N    ??X_MOVE_TEST_14
   \   000000DE   0x2101             MOVS     R1,#+1
   \   000000E0   0xE00D             B.N      ??X_MOVE_TEST_12
   \                     ??X_MOVE_TEST_14: (+1)
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xE00B             B.N      ??X_MOVE_TEST_12
    363                        else
    364                          D_temp = (stepper.motor_direction(B_AXIS) != stepper.motor_direction(C_AXIS));
   \                     ??X_MOVE_TEST_13: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000EC   0x4604             MOV      R4,R0
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000F4   0x4284             CMP      R4,R0
   \   000000F6   0xD001             BEQ.N    ??X_MOVE_TEST_15
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0xE000             B.N      ??X_MOVE_TEST_12
   \                     ??X_MOVE_TEST_15: (+1)
   \   000000FC   0x2100             MOVS     R1,#+0
    365                        return  ( S_(1) != S_(2) || (S_(1) > 0 && D_temp) );
   \                     ??X_MOVE_TEST_12: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000102   0x7C02             LDRB     R2,[R0, #+16]
   \   00000104   0x.... 0x....      LDR.W    R3,??DataTable27_7
   \   00000108   0x681B             LDR      R3,[R3, #+0]
   \   0000010A   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \   0000010E   0x6852             LDR      R2,[R2, #+4]
   \   00000110   0x7C40             LDRB     R0,[R0, #+17]
   \   00000112   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   00000116   0x6840             LDR      R0,[R0, #+4]
   \   00000118   0x4282             CMP      R2,R0
   \   0000011A   0xD107             BNE.N    ??X_MOVE_TEST_16
   \   0000011C   0x2A01             CMP      R2,#+1
   \   0000011E   0xDB07             BLT.N    ??X_MOVE_TEST_17
   \   00000120   0x4608             MOV      R0,R1
   \   00000122   0x1E40             SUBS     R0,R0,#+1
   \   00000124   0x4180             SBCS     R0,R0,R0
   \   00000126   0x43C0             MVNS     R0,R0
   \   00000128   0x0FC0             LSRS     R0,R0,#+31
   \   0000012A   0xBD10             POP      {R4,PC}
   \                     ??X_MOVE_TEST_16: (+1)
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xBD10             POP      {R4,PC}
   \                     ??X_MOVE_TEST_17: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xBD10             POP      {R4,PC}
    366          		}
    367          	}
    368          	else
    369          	{
    370          		return (stepper.current_block->steps[X_AXIS] > 0);
   \                     ??X_MOVE_TEST_0: (+1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x6840             LDR      R0,[R0, #+4]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xDB01             BLT.N    ??X_MOVE_TEST_18
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0xBD10             POP      {R4,PC}
   \                     ??X_MOVE_TEST_18: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xBD10             POP      {R4,PC}          ;; return
    371          	}
    372          }

   \                                 In section .text, align 2, keep-with-next
    373          AxisEnum  X_AXIS_HEAD()
    374          {
    375          	if(MACHINETPYE & CORE_IS_XY || MACHINETPYE & CORE_IS_XZ)
   \                     _Z11X_AXIS_HEADv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000004   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   00000008   0x213C             MOVS     R1,#+60
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??X_AXIS_HEAD_0
    376          		return X_HEAD;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x4770             BX       LR
    377          	else
    378          		return X_AXIS;
   \                     ??X_AXIS_HEAD_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    379          }
    380          

   \                                 In section .text, align 2, keep-with-next
    381          bool Y_MOVE_TEST()
    382           {
   \                     _Z11Y_MOVE_TESTv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000006   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000000A   0x21CC             MOVS     R1,#+204
   \   0000000C   0x4208             TST      R0,R1
   \   0000000E   0xF000 0x8091      BEQ.W    ??Y_MOVE_TEST_0
    383              bool D_temp;
    384          
    385          	if(MACHINETPYE & CORE_IS_XY || MACHINETPYE & CORE_IS_YZ)
    386          	{
    387          		if(MACHINETPYE & COREYX || MACHINETPYE & COREYZ)
   \   00000012   0x2148             MOVS     R1,#+72
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD046             BEQ.N    ??Y_MOVE_TEST_1
    388          		{
    389          	          if(MACHINETPYE & CORE_IS_XY)
   \   00000018   0x210C             MOVS     R1,#+12
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xD00C             BEQ.N    ??Y_MOVE_TEST_2
    390          	            D_temp = (stepper.motor_direction(A_AXIS) == stepper.motor_direction(B_AXIS));
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000024   0x4604             MOV      R4,R0
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD101             BNE.N    ??Y_MOVE_TEST_3
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xE01D             B.N      ??Y_MOVE_TEST_4
   \                     ??Y_MOVE_TEST_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xE01B             B.N      ??Y_MOVE_TEST_4
    391          	          else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??Y_MOVE_TEST_2: (+1)
   \   00000038   0x2130             MOVS     R1,#+48
   \   0000003A   0x4208             TST      R0,R1
   \   0000003C   0xD00C             BEQ.N    ??Y_MOVE_TEST_5
    392          	            D_temp = (stepper.motor_direction(A_AXIS) == stepper.motor_direction(C_AXIS));
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000044   0x4604             MOV      R4,R0
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD101             BNE.N    ??Y_MOVE_TEST_6
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0xE00D             B.N      ??Y_MOVE_TEST_4
   \                     ??Y_MOVE_TEST_6: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xE00B             B.N      ??Y_MOVE_TEST_4
    393          	          else
    394          	            D_temp = (stepper.motor_direction(B_AXIS) == stepper.motor_direction(C_AXIS));
   \                     ??Y_MOVE_TEST_5: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000005E   0x4604             MOV      R4,R0
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD101             BNE.N    ??Y_MOVE_TEST_7
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xE000             B.N      ??Y_MOVE_TEST_4
   \                     ??Y_MOVE_TEST_7: (+1)
   \   0000006E   0x2100             MOVS     R1,#+0
    395                                    
    396          			  return( S_(1) != S_(2) || (S_(1) > 0 && D_temp) );
   \                     ??Y_MOVE_TEST_4: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000074   0x7C02             LDRB     R2,[R0, #+16]
   \   00000076   0x.... 0x....      LDR.W    R3,??DataTable27_7
   \   0000007A   0x681B             LDR      R3,[R3, #+0]
   \   0000007C   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \   00000080   0x6852             LDR      R2,[R2, #+4]
   \   00000082   0x7C40             LDRB     R0,[R0, #+17]
   \   00000084   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   00000088   0x6840             LDR      R0,[R0, #+4]
   \   0000008A   0x4282             CMP      R2,R0
   \   0000008C   0xD107             BNE.N    ??Y_MOVE_TEST_8
   \   0000008E   0x2A01             CMP      R2,#+1
   \   00000090   0xDB07             BLT.N    ??Y_MOVE_TEST_9
   \   00000092   0x4608             MOV      R0,R1
   \   00000094   0x1E40             SUBS     R0,R0,#+1
   \   00000096   0x4180             SBCS     R0,R0,R0
   \   00000098   0x43C0             MVNS     R0,R0
   \   0000009A   0x0FC0             LSRS     R0,R0,#+31
   \   0000009C   0xBD10             POP      {R4,PC}
   \                     ??Y_MOVE_TEST_8: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xBD10             POP      {R4,PC}
   \                     ??Y_MOVE_TEST_9: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xBD10             POP      {R4,PC}
    397          		}
    398          		else
    399          		{
    400                        if(MACHINETPYE & CORE_IS_XY)
   \                     ??Y_MOVE_TEST_1: (+1)
   \   000000A6   0x210C             MOVS     R1,#+12
   \   000000A8   0x4208             TST      R0,R1
   \   000000AA   0xD00C             BEQ.N    ??Y_MOVE_TEST_10
    401                          D_temp = (stepper.motor_direction(A_AXIS) != stepper.motor_direction(B_AXIS));
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000B2   0x4604             MOV      R4,R0
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000BA   0x4284             CMP      R4,R0
   \   000000BC   0xD001             BEQ.N    ??Y_MOVE_TEST_11
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0xE01D             B.N      ??Y_MOVE_TEST_12
   \                     ??Y_MOVE_TEST_11: (+1)
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xE01B             B.N      ??Y_MOVE_TEST_12
    402                        else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??Y_MOVE_TEST_10: (+1)
   \   000000C6   0x2130             MOVS     R1,#+48
   \   000000C8   0x4208             TST      R0,R1
   \   000000CA   0xD00C             BEQ.N    ??Y_MOVE_TEST_13
    403                          D_temp = (stepper.motor_direction(A_AXIS) != stepper.motor_direction(C_AXIS));
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000D2   0x4604             MOV      R4,R0
   \   000000D4   0x2002             MOVS     R0,#+2
   \   000000D6   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000DA   0x4284             CMP      R4,R0
   \   000000DC   0xD001             BEQ.N    ??Y_MOVE_TEST_14
   \   000000DE   0x2101             MOVS     R1,#+1
   \   000000E0   0xE00D             B.N      ??Y_MOVE_TEST_12
   \                     ??Y_MOVE_TEST_14: (+1)
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xE00B             B.N      ??Y_MOVE_TEST_12
    404                        else
    405                          D_temp = (stepper.motor_direction(B_AXIS) != stepper.motor_direction(C_AXIS));
   \                     ??Y_MOVE_TEST_13: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000EC   0x4604             MOV      R4,R0
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000F4   0x4284             CMP      R4,R0
   \   000000F6   0xD001             BEQ.N    ??Y_MOVE_TEST_15
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0xE000             B.N      ??Y_MOVE_TEST_12
   \                     ??Y_MOVE_TEST_15: (+1)
   \   000000FC   0x2100             MOVS     R1,#+0
    406                                    
    407          			  return( S_(1) != S_(2) || (S_(1) > 0 && D_temp) );
   \                     ??Y_MOVE_TEST_12: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000102   0x7C02             LDRB     R2,[R0, #+16]
   \   00000104   0x.... 0x....      LDR.W    R3,??DataTable27_7
   \   00000108   0x681B             LDR      R3,[R3, #+0]
   \   0000010A   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \   0000010E   0x6852             LDR      R2,[R2, #+4]
   \   00000110   0x7C40             LDRB     R0,[R0, #+17]
   \   00000112   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   00000116   0x6840             LDR      R0,[R0, #+4]
   \   00000118   0x4282             CMP      R2,R0
   \   0000011A   0xD107             BNE.N    ??Y_MOVE_TEST_16
   \   0000011C   0x2A01             CMP      R2,#+1
   \   0000011E   0xDB07             BLT.N    ??Y_MOVE_TEST_17
   \   00000120   0x4608             MOV      R0,R1
   \   00000122   0x1E40             SUBS     R0,R0,#+1
   \   00000124   0x4180             SBCS     R0,R0,R0
   \   00000126   0x43C0             MVNS     R0,R0
   \   00000128   0x0FC0             LSRS     R0,R0,#+31
   \   0000012A   0xBD10             POP      {R4,PC}
   \                     ??Y_MOVE_TEST_16: (+1)
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xBD10             POP      {R4,PC}
   \                     ??Y_MOVE_TEST_17: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xBD10             POP      {R4,PC}
    408          		}
    409          		
    410          	}
    411          	else
    412          	{
    413          		return(stepper.current_block->steps[Y_AXIS] > 0);
   \                     ??Y_MOVE_TEST_0: (+1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x6880             LDR      R0,[R0, #+8]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xDB01             BLT.N    ??Y_MOVE_TEST_18
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0xBD10             POP      {R4,PC}
   \                     ??Y_MOVE_TEST_18: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xBD10             POP      {R4,PC}          ;; return
    414          	}
    415            }
    416            

   \                                 In section .text, align 2, keep-with-next
    417            AxisEnum  Y_AXIS_HEAD()
    418            {
    419          	  if(MACHINETPYE & CORE_IS_XY || MACHINETPYE & CORE_IS_YZ)
   \                     _Z11Y_AXIS_HEADv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000004   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   00000008   0x21CC             MOVS     R1,#+204
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??Y_AXIS_HEAD_0
    420          		  return Y_HEAD;
   \   0000000E   0x2005             MOVS     R0,#+5
   \   00000010   0x4770             BX       LR
    421          	  else
    422          		  return Y_AXIS;
   \                     ??Y_AXIS_HEAD_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR               ;; return
    423            }
    424           /*----------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    425            bool	Z_MOVE_TEST()
    426            {
   \                     _Z11Z_MOVE_TESTv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000006   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000000A   0x21F0             MOVS     R1,#+240
   \   0000000C   0x4208             TST      R0,R1
   \   0000000E   0xF000 0x8091      BEQ.W    ??Z_MOVE_TEST_0
    427              bool D_temp;
    428          
    429          	if(MACHINETPYE & CORE_IS_XZ || MACHINETPYE & CORE_IS_YZ)
    430          	{
    431          		if(MACHINETPYE & COREZX || MACHINETPYE & COREZY)
   \   00000012   0xF000 0x010C      AND      R1,R0,#0xC
   \   00000016   0x22A0             MOVS     R2,#+160
   \   00000018   0x4210             TST      R0,R2
   \   0000001A   0xD045             BEQ.N    ??Z_MOVE_TEST_1
    432          		{
    433          		      if(MACHINETPYE & CORE_IS_XY)
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD00C             BEQ.N    ??Z_MOVE_TEST_2
    434          		        D_temp = (stepper.motor_direction(A_AXIS) == stepper.motor_direction(B_AXIS));
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000026   0x4604             MOV      R4,R0
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD101             BNE.N    ??Z_MOVE_TEST_3
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xE01D             B.N      ??Z_MOVE_TEST_4
   \                     ??Z_MOVE_TEST_3: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xE01B             B.N      ??Z_MOVE_TEST_4
    435          		      else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??Z_MOVE_TEST_2: (+1)
   \   0000003A   0x2130             MOVS     R1,#+48
   \   0000003C   0x4208             TST      R0,R1
   \   0000003E   0xD00C             BEQ.N    ??Z_MOVE_TEST_5
    436          		        D_temp = (stepper.motor_direction(A_AXIS) == stepper.motor_direction(C_AXIS));
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000046   0x4604             MOV      R4,R0
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD101             BNE.N    ??Z_MOVE_TEST_6
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0xE00D             B.N      ??Z_MOVE_TEST_4
   \                     ??Z_MOVE_TEST_6: (+1)
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xE00B             B.N      ??Z_MOVE_TEST_4
    437          		      else
    438          		        D_temp = (stepper.motor_direction(B_AXIS) == stepper.motor_direction(C_AXIS));
   \                     ??Z_MOVE_TEST_5: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000060   0x4604             MOV      R4,R0
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD101             BNE.N    ??Z_MOVE_TEST_7
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0xE000             B.N      ??Z_MOVE_TEST_4
   \                     ??Z_MOVE_TEST_7: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
    439                                    
    440          			  return( S_(1) != S_(2) || (S_(1) > 0 && D_temp) );
   \                     ??Z_MOVE_TEST_4: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000076   0x7C02             LDRB     R2,[R0, #+16]
   \   00000078   0x.... 0x....      LDR.W    R3,??DataTable27_7
   \   0000007C   0x681B             LDR      R3,[R3, #+0]
   \   0000007E   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \   00000082   0x6852             LDR      R2,[R2, #+4]
   \   00000084   0x7C40             LDRB     R0,[R0, #+17]
   \   00000086   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0x4282             CMP      R2,R0
   \   0000008E   0xD107             BNE.N    ??Z_MOVE_TEST_8
   \   00000090   0x2A01             CMP      R2,#+1
   \   00000092   0xDB07             BLT.N    ??Z_MOVE_TEST_9
   \   00000094   0x4608             MOV      R0,R1
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x4180             SBCS     R0,R0,R0
   \   0000009A   0x43C0             MVNS     R0,R0
   \   0000009C   0x0FC0             LSRS     R0,R0,#+31
   \   0000009E   0xBD10             POP      {R4,PC}
   \                     ??Z_MOVE_TEST_8: (+1)
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xBD10             POP      {R4,PC}
   \                     ??Z_MOVE_TEST_9: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBD10             POP      {R4,PC}
    441          		}
    442          		else
    443          		{
    444          	          if(MACHINETPYE & CORE_IS_XY)
   \                     ??Z_MOVE_TEST_1: (+1)
   \   000000A8   0x2900             CMP      R1,#+0
   \   000000AA   0xD00C             BEQ.N    ??Z_MOVE_TEST_10
    445          	            D_temp = (stepper.motor_direction(A_AXIS) != stepper.motor_direction(B_AXIS));
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000B2   0x4604             MOV      R4,R0
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000BA   0x4284             CMP      R4,R0
   \   000000BC   0xD001             BEQ.N    ??Z_MOVE_TEST_11
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0xE01D             B.N      ??Z_MOVE_TEST_12
   \                     ??Z_MOVE_TEST_11: (+1)
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xE01B             B.N      ??Z_MOVE_TEST_12
    446          	          else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??Z_MOVE_TEST_10: (+1)
   \   000000C6   0x2130             MOVS     R1,#+48
   \   000000C8   0x4208             TST      R0,R1
   \   000000CA   0xD00C             BEQ.N    ??Z_MOVE_TEST_13
    447          	            D_temp = (stepper.motor_direction(A_AXIS) != stepper.motor_direction(C_AXIS));
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000D2   0x4604             MOV      R4,R0
   \   000000D4   0x2002             MOVS     R0,#+2
   \   000000D6   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000DA   0x4284             CMP      R4,R0
   \   000000DC   0xD001             BEQ.N    ??Z_MOVE_TEST_14
   \   000000DE   0x2101             MOVS     R1,#+1
   \   000000E0   0xE00D             B.N      ??Z_MOVE_TEST_12
   \                     ??Z_MOVE_TEST_14: (+1)
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xE00B             B.N      ??Z_MOVE_TEST_12
    448          	          else
    449          	            D_temp = (stepper.motor_direction(B_AXIS) != stepper.motor_direction(C_AXIS));
   \                     ??Z_MOVE_TEST_13: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000EC   0x4604             MOV      R4,R0
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000F4   0x4284             CMP      R4,R0
   \   000000F6   0xD001             BEQ.N    ??Z_MOVE_TEST_15
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0xE000             B.N      ??Z_MOVE_TEST_12
   \                     ??Z_MOVE_TEST_15: (+1)
   \   000000FC   0x2100             MOVS     R1,#+0
    450                                    
    451          			  return( S_(1) != S_(2) || (S_(1) > 0 && D_temp) );
   \                     ??Z_MOVE_TEST_12: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable27_9
   \   00000102   0x7C02             LDRB     R2,[R0, #+16]
   \   00000104   0x.... 0x....      LDR.W    R3,??DataTable27_7
   \   00000108   0x681B             LDR      R3,[R3, #+0]
   \   0000010A   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \   0000010E   0x6852             LDR      R2,[R2, #+4]
   \   00000110   0x7C40             LDRB     R0,[R0, #+17]
   \   00000112   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \   00000116   0x6840             LDR      R0,[R0, #+4]
   \   00000118   0x4282             CMP      R2,R0
   \   0000011A   0xD107             BNE.N    ??Z_MOVE_TEST_16
   \   0000011C   0x2A01             CMP      R2,#+1
   \   0000011E   0xDB07             BLT.N    ??Z_MOVE_TEST_17
   \   00000120   0x4608             MOV      R0,R1
   \   00000122   0x1E40             SUBS     R0,R0,#+1
   \   00000124   0x4180             SBCS     R0,R0,R0
   \   00000126   0x43C0             MVNS     R0,R0
   \   00000128   0x0FC0             LSRS     R0,R0,#+31
   \   0000012A   0xBD10             POP      {R4,PC}
   \                     ??Z_MOVE_TEST_16: (+1)
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xBD10             POP      {R4,PC}
   \                     ??Z_MOVE_TEST_17: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xBD10             POP      {R4,PC}
    452          		}
    453          		
    454          	}
    455          	else
    456          	{
    457          		return(stepper.current_block->steps[Z_AXIS] > 0);
   \                     ??Z_MOVE_TEST_0: (+1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x68C0             LDR      R0,[R0, #+12]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xDB01             BLT.N    ??Z_MOVE_TEST_18
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0xBD10             POP      {R4,PC}
   \                     ??Z_MOVE_TEST_18: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xBD10             POP      {R4,PC}          ;; return
    458          	}
    459            }
    460            

   \                                 In section .text, align 2, keep-with-next
    461            AxisEnum  Z_AXIS_HEAD()
    462            {
    463              if(MACHINETPYE & CORE_IS_XZ || MACHINETPYE & CORE_IS_YZ)
   \                     _Z11Z_AXIS_HEADv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000004   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   00000008   0x21F0             MOVS     R1,#+240
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??Z_AXIS_HEAD_0
    464          		  return Z_HEAD;
   \   0000000E   0x2006             MOVS     R0,#+6
   \   00000010   0x4770             BX       LR
    465          	  else
    466          		  return Z_AXIS;
   \                     ??Z_AXIS_HEAD_0: (+1)
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x4770             BX       LR               ;; return
    467            }
    468          
    469            /*----------------------------------------*/  
    470          
    471          // Check endstops - Called from ISR!

   \                                 In section .text, align 2, keep-with-next
    472          void Endstops::update() {
   \                     _ZN8Endstops6updateEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    473          
    474            #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
    475            #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
    476            #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
    477            #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
    478          
    479            // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
    480            //#define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
    481               #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) __SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
    482          
    483               #define UPDATE_ENDSTOP_BIT_Z2_MIN (current_endstop_bits)^= ((-(READ(Z2_MIN_PIN)!=Z2_MIN_ENDSTOP_INVERTING))^(current_endstop_bits)) & (_BV(Z2_MAX))
    484               #define UPDATE_ENDSTOP_BIT_Z2_MAX (current_endstop_bits)^= ((-(READ(Z2_MAX_PIN)!=Z2_MAX_ENDSTOP_INVERTING))^(current_endstop_bits)) & (_BV(Z2_MIN))
    485          
    486          
    487            // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
    488            //#define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
    489          	#define COPY_BIT(bits, COPY_BIT, BIT) __SET_BIT(bits, BIT, TEST(bits, COPY_BIT))
    490          
    491            #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
    492                UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
    493                if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
    494                  _ENDSTOP_HIT(AXIS, MINMAX); \
    495                  stepper.endstop_triggered(_AXIS(AXIS)); \
    496                } \
    497              }while(0)
    498          
    499            //#if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
    500          	#if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE)	//mks_delta
    501          	
    502              // If G38 command is active check Z_MIN_PROBE for ALL movement
    503              if (G38_move) {
    504                UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
    505                if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
    506                  if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
    507                  else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
    508                  else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
    509                  G38_endstop_hit = true;
    510                }
    511              }
    512            #endif
    513          
    514            /**
    515             * Define conditions for checking endstops
    516             */
    517          #if 0
    518            #if IS_CORE
    519              #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
    520              #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
    521            #endif
    522          
    523            #if CORE_IS_XY || CORE_IS_XZ
    524              /**
    525               * Head direction in -X axis for CoreXY and CoreXZ bots.
    526               *
    527               * If steps differ, both axes are moving.
    528               * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
    529               * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
    530               */
    531              #if ENABLED(COREXY) || ENABLED(COREXZ)
    532                #define X_CMP ==
    533              #else
    534                #define X_CMP !=
    535              #endif
    536              #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
    537              #define X_AXIS_HEAD X_HEAD
    538            #else
    539              #define X_MOVE_TEST stepper.current_block->steps[X_AXIS] > 0
    540              #define X_AXIS_HEAD X_AXIS
    541            #endif
    542          
    543            #if CORE_IS_XY || CORE_IS_YZ
    544              /**
    545               * Head direction in -Y axis for CoreXY / CoreYZ bots.
    546               *
    547               * If steps differ, both axes are moving
    548               * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
    549               * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
    550               */
    551              #if ENABLED(COREYX) || ENABLED(COREYZ)
    552                #define Y_CMP ==
    553              #else
    554                #define Y_CMP !=
    555              #endif
    556              #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
    557              #define Y_AXIS_HEAD Y_HEAD
    558            #else
    559              #define Y_MOVE_TEST stepper.current_block->steps[Y_AXIS] > 0
    560              #define Y_AXIS_HEAD Y_AXIS
    561            #endif
    562          
    563            #if CORE_IS_XZ || CORE_IS_YZ
    564              /**
    565               * Head direction in -Z axis for CoreXZ or CoreYZ bots.
    566               *
    567               * If steps differ, both axes are moving
    568               * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
    569               * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
    570               */
    571              #if ENABLED(COREZX) || ENABLED(COREZY)
    572                #define Z_CMP ==
    573              #else
    574                #define Z_CMP !=
    575              #endif
    576              #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
    577              #define Z_AXIS_HEAD Z_HEAD
    578            #else
    579              #define Z_MOVE_TEST stepper.current_block->steps[Z_AXIS] > 0
    580              #define Z_AXIS_HEAD Z_AXIS
    581            #endif
    582          #endif
    583          
    584            // With Dual X, endstops are only checked in the homing direction for the active extruder
    585            #if ENABLED(DUAL_X_CARRIAGE)
    586              #define E0_ACTIVE stepper.current_block->active_extruder == 0
    587              #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
    588              #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
    589            #else
    590              #define X_MIN_TEST true
    591              #define X_MAX_TEST true
    592            #endif
    593          
    594            /**
    595             * Check and update endstops according to conditions
    596             */
    597            if (X_MOVE_TEST()) {
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable27_3
   \   0000000C   0x.... 0x....      BL       _Z11X_MOVE_TESTv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD05E             BEQ.N    ??update_0
    598              if (stepper.motor_direction(X_AXIS_HEAD())) { // -direction
   \   00000014   0x.... 0x....      BL       _Z11X_AXIS_HEADv
   \   00000018   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD02B             BEQ.N    ??update_1
    599                #if HAS_X_MIN
    600                  #if ENABLED(X_DUAL_ENDSTOPS)
    601                    UPDATE_ENDSTOP_BIT(X, MIN);
    602                    #if HAS_X2_MIN
    603                      UPDATE_ENDSTOP_BIT(X2, MIN);
    604                    #else
    605                      COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
    606                    #endif
    607                    test_dual_x_endstops(X_MIN, X2_MIN);
    608                  #else
    609          		if(mksCfg.use_xmin_plug)
   \   00000020   0xF895 0x0080      LDRB     R0,[R5, #+128]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD054             BEQ.N    ??update_0
    610                    if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable27_6
   \   0000002C   0x88C1             LDRH     R1,[R0, #+6]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000038   0xF895 0x1037      LDRB     R1,[R5, #+55]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD001             BEQ.N    ??update_2
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??update_3
   \                     ??update_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??update_3: (+1)
   \   00000046   0x8861             LDRH     R1,[R4, #+2]
   \   00000048   0x4240             RSBS     R0,R0,#+0
   \   0000004A   0x4048             EORS     R0,R1,R0
   \   0000004C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000050   0x4048             EORS     R0,R0,R1
   \   00000052   0x8060             STRH     R0,[R4, #+2]
   \   00000054   0x88A1             LDRH     R1,[R4, #+4]
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x07C0             LSLS     R0,R0,#+31
   \   0000005A   0xD53A             BPL.N    ??update_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x6840             LDR      R0,[R0, #+4]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xDB34             BLT.N    ??update_0
   \   00000068   0x7820             LDRB     R0,[R4, #+0]
   \   0000006A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000006E   0x7020             STRB     R0,[R4, #+0]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
   \   00000076   0xE02C             B.N      ??update_0
    611                  #endif
    612                #endif
    613              }
    614              else { // +direction
    615                #if HAS_X_MAX
    616                  #if ENABLED(X_DUAL_ENDSTOPS)
    617                    UPDATE_ENDSTOP_BIT(X, MAX);
    618                    #if HAS_X2_MAX
    619                      UPDATE_ENDSTOP_BIT(X2, MAX);
    620                    #else
    621                      COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
    622                    #endif
    623                    test_dual_x_endstops(X_MAX, X2_MAX);
    624                  #else
    625          		if(mksCfg.use_xmax_plug)
   \                     ??update_1: (+1)
   \   00000078   0xF105 0x0080      ADD      R0,R5,#+128
   \   0000007C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD027             BEQ.N    ??update_0
    626                    if (X_MIN_TEST) UPDATE_ENDSTOP(X, MAX);
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable27_6
   \   00000086   0x88C1             LDRH     R1,[R0, #+6]
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable27_5
   \   0000008C   0x68C0             LDR      R0,[R0, #+12]
   \   0000008E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000092   0xF105 0x0137      ADD      R1,R5,#+55
   \   00000096   0x78C9             LDRB     R1,[R1, #+3]
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD001             BEQ.N    ??update_4
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE000             B.N      ??update_5
   \                     ??update_4: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??update_5: (+1)
   \   000000A2   0x8861             LDRH     R1,[R4, #+2]
   \   000000A4   0x4240             RSBS     R0,R0,#+0
   \   000000A6   0x4048             EORS     R0,R1,R0
   \   000000A8   0xF000 0x0010      AND      R0,R0,#0x10
   \   000000AC   0x4048             EORS     R0,R0,R1
   \   000000AE   0x8060             STRH     R0,[R4, #+2]
   \   000000B0   0x88A1             LDRH     R1,[R4, #+4]
   \   000000B2   0x4008             ANDS     R0,R1,R0
   \   000000B4   0x06C0             LSLS     R0,R0,#+27
   \   000000B6   0xD50C             BPL.N    ??update_0
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x6840             LDR      R0,[R0, #+4]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xDB06             BLT.N    ??update_0
   \   000000C4   0x7820             LDRB     R0,[R4, #+0]
   \   000000C6   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000CA   0x7020             STRB     R0,[R4, #+0]
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
    627                  #endif
    628          
    629                #endif
    630              }
    631            }
    632          
    633            if (Y_MOVE_TEST()) {
   \                     ??update_0: (+1)
   \   000000D2   0x.... 0x....      BL       _Z11Y_MOVE_TESTv
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD058             BEQ.N    ??update_6
    634              if (stepper.motor_direction(Y_AXIS_HEAD())) { // -direction
   \   000000DA   0x.... 0x....      BL       _Z11Y_AXIS_HEADv
   \   000000DE   0xF105 0x0680      ADD      R6,R5,#+128
   \   000000E2   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD028             BEQ.N    ??update_7
    635                #if HAS_Y_MIN
    636                  #if ENABLED(Y_DUAL_ENDSTOPS)
    637                    UPDATE_ENDSTOP_BIT(Y, MIN);
    638                    #if HAS_Y2_MIN
    639                      UPDATE_ENDSTOP_BIT(Y2, MIN);
    640                    #else
    641                      COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
    642                    #endif
    643                    test_dual_y_endstops(Y_MIN, Y2_MIN);
    644                  #else
    645          		if(mksCfg.use_ymin_plug)
   \   000000EA   0x7870             LDRB     R0,[R6, #+1]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD04D             BEQ.N    ??update_6
    646                    UPDATE_ENDSTOP(Y, MIN);
   \   000000F0   0x....             LDR.N    R0,??DataTable27_6
   \   000000F2   0x8A01             LDRH     R1,[R0, #+16]
   \   000000F4   0x....             LDR.N    R0,??DataTable27_5
   \   000000F6   0x6A00             LDR      R0,[R0, #+32]
   \   000000F8   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000FC   0xF105 0x0137      ADD      R1,R5,#+55
   \   00000100   0x7849             LDRB     R1,[R1, #+1]
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xD001             BEQ.N    ??update_8
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xE000             B.N      ??update_9
   \                     ??update_8: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \                     ??update_9: (+1)
   \   0000010C   0x8861             LDRH     R1,[R4, #+2]
   \   0000010E   0x4240             RSBS     R0,R0,#+0
   \   00000110   0x4048             EORS     R0,R1,R0
   \   00000112   0xF000 0x0002      AND      R0,R0,#0x2
   \   00000116   0x4048             EORS     R0,R0,R1
   \   00000118   0x8060             STRH     R0,[R4, #+2]
   \   0000011A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000011C   0x4008             ANDS     R0,R1,R0
   \   0000011E   0x0780             LSLS     R0,R0,#+30
   \   00000120   0xD534             BPL.N    ??update_6
   \   00000122   0x....             LDR.N    R0,??DataTable27_7
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x6880             LDR      R0,[R0, #+8]
   \   00000128   0x2801             CMP      R0,#+1
   \   0000012A   0xDB2F             BLT.N    ??update_6
   \   0000012C   0x7820             LDRB     R0,[R4, #+0]
   \   0000012E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000132   0x7020             STRB     R0,[R4, #+0]
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
   \   0000013A   0xE027             B.N      ??update_6
    647                  #endif
    648                #endif
    649              }
    650              else { // +direction
    651                #if HAS_Y_MAX
    652                  #if ENABLED(Y_DUAL_ENDSTOPS)
    653                    UPDATE_ENDSTOP_BIT(Y, MAX);
    654                    #if HAS_Y2_MAX
    655                      UPDATE_ENDSTOP_BIT(Y2, MAX);
    656                    #else
    657                      COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
    658                    #endif
    659                    test_dual_y_endstops(Y_MAX, Y2_MAX);
    660                  #else
    661          		if(mksCfg.use_ymax_plug)
   \                     ??update_7: (+1)
   \   0000013C   0x7930             LDRB     R0,[R6, #+4]
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD024             BEQ.N    ??update_6
    662                    UPDATE_ENDSTOP(Y, MAX);
   \   00000142   0x....             LDR.N    R0,??DataTable27_6
   \   00000144   0x8A01             LDRH     R1,[R0, #+16]
   \   00000146   0x....             LDR.N    R0,??DataTable27_5
   \   00000148   0x6A00             LDR      R0,[R0, #+32]
   \   0000014A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000014E   0xF105 0x0137      ADD      R1,R5,#+55
   \   00000152   0x7909             LDRB     R1,[R1, #+4]
   \   00000154   0x4288             CMP      R0,R1
   \   00000156   0xD001             BEQ.N    ??update_10
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0xE000             B.N      ??update_11
   \                     ??update_10: (+1)
   \   0000015C   0x2000             MOVS     R0,#+0
   \                     ??update_11: (+1)
   \   0000015E   0x8861             LDRH     R1,[R4, #+2]
   \   00000160   0x4240             RSBS     R0,R0,#+0
   \   00000162   0x4048             EORS     R0,R1,R0
   \   00000164   0xF000 0x0020      AND      R0,R0,#0x20
   \   00000168   0x4048             EORS     R0,R0,R1
   \   0000016A   0x8060             STRH     R0,[R4, #+2]
   \   0000016C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000016E   0x4008             ANDS     R0,R1,R0
   \   00000170   0x0680             LSLS     R0,R0,#+26
   \   00000172   0xD50B             BPL.N    ??update_6
   \   00000174   0x....             LDR.N    R0,??DataTable27_7
   \   00000176   0x6800             LDR      R0,[R0, #+0]
   \   00000178   0x6880             LDR      R0,[R0, #+8]
   \   0000017A   0x2801             CMP      R0,#+1
   \   0000017C   0xDB06             BLT.N    ??update_6
   \   0000017E   0x7820             LDRB     R0,[R4, #+0]
   \   00000180   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000184   0x7020             STRB     R0,[R4, #+0]
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
    663                  #endif
    664                #endif
    665              }
    666            }
    667          
    668            if (Z_MOVE_TEST()) {
   \                     ??update_6: (+1)
   \   0000018C   0x.... 0x....      BL       _Z11Z_MOVE_TESTv
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xF000 0x8148      BEQ.W    ??update_12
    669              if (stepper.motor_direction(Z_AXIS_HEAD())) { // Z -direction. Gantry down, bed up.
   \   00000196   0x.... 0x....      BL       _Z11Z_AXIS_HEADv
   \   0000019A   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xF000 0x80CF      BEQ.W    ??update_13
    670                #if HAS_Z_MIN
    671                  //#if ENABLED(Z_DUAL_ENDSTOPS)
    672                  if(Z_DUAL_ENDSTOPS==1)
   \   000001A4   0xF895 0x0102      LDRB     R0,[R5, #+258]
   \   000001A8   0x2801             CMP      R0,#+1
   \   000001AA   0xD13E             BNE.N    ??update_14
    673                  {
    674                    UPDATE_ENDSTOP_BIT(Z, MIN);
   \   000001AC   0x....             LDR.N    R7,??DataTable27_5
   \   000001AE   0x.... 0x....      LDR.W    R8,??DataTable27_6
   \   000001B2   0xF8B8 0x101A      LDRH     R1,[R8, #+26]
   \   000001B6   0x6B78             LDR      R0,[R7, #+52]
   \   000001B8   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000001BC   0xF205 0x0637      ADDW     R6,R5,#+55
   \   000001C0   0x78B1             LDRB     R1,[R6, #+2]
   \   000001C2   0x4288             CMP      R0,R1
   \   000001C4   0xD001             BEQ.N    ??update_15
   \   000001C6   0x2001             MOVS     R0,#+1
   \   000001C8   0xE000             B.N      ??update_16
   \                     ??update_15: (+1)
   \   000001CA   0x2000             MOVS     R0,#+0
   \                     ??update_16: (+1)
   \   000001CC   0x8861             LDRH     R1,[R4, #+2]
   \   000001CE   0x4240             RSBS     R0,R0,#+0
   \   000001D0   0x4048             EORS     R0,R1,R0
   \   000001D2   0xF000 0x0004      AND      R0,R0,#0x4
   \   000001D6   0x4048             EORS     R0,R0,R1
   \   000001D8   0x8060             STRH     R0,[R4, #+2]
    675                    //#if HAS_Z2_MIN
    676                    if(mksCfg.z2_endstop==1)
   \   000001DA   0xF505 0x7181      ADD      R1,R5,#+258
   \   000001DE   0x7849             LDRB     R1,[R1, #+1]
   \   000001E0   0x2901             CMP      R1,#+1
   \   000001E2   0xD112             BNE.N    ??update_17
    677                    {
    678                      //UPDATE_ENDSTOP_BIT(Z2, MIN);
    679                      UPDATE_ENDSTOP_BIT_Z2_MAX;
   \   000001E4   0xF8B8 0x101C      LDRH     R1,[R8, #+28]
   \   000001E8   0x6BB8             LDR      R0,[R7, #+56]
   \   000001EA   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000001EE   0x7971             LDRB     R1,[R6, #+5]
   \   000001F0   0x4288             CMP      R0,R1
   \   000001F2   0xD001             BEQ.N    ??update_18
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0xE000             B.N      ??update_19
   \                     ??update_18: (+1)
   \   000001F8   0x2000             MOVS     R0,#+0
   \                     ??update_19: (+1)
   \   000001FA   0x8861             LDRH     R1,[R4, #+2]
   \   000001FC   0x4240             RSBS     R0,R0,#+0
   \   000001FE   0x4048             EORS     R0,R1,R0
   \   00000200   0xF400 0x6000      AND      R0,R0,#0x800
   \   00000204   0x4048             EORS     R0,R0,R1
   \   00000206   0x8060             STRH     R0,[R4, #+2]
   \   00000208   0xE00A             B.N      ??update_20
    680                    }
    681                    //#else
    682                    else
    683                    {
    684                      COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
   \                     ??update_17: (+1)
   \   0000020A   0x4601             MOV      R1,R0
   \   0000020C   0xB2C9             UXTB     R1,R1
   \   0000020E   0x0889             LSRS     R1,R1,#+2
   \   00000210   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000214   0x4249             RSBS     R1,R1,#+0
   \   00000216   0x4041             EORS     R1,R0,R1
   \   00000218   0xF401 0x6100      AND      R1,R1,#0x800
   \   0000021C   0x4048             EORS     R0,R1,R0
   \   0000021E   0x8060             STRH     R0,[R4, #+2]
    685                    }
    686                    //#endif
    687                    test_dual_z_endstops(Z_MIN, Z2_MIN);
   \                     ??update_20: (+1)
   \   00000220   0x210B             MOVS     R1,#+11
   \   00000222   0x2002             MOVS     R0,#+2
   \   00000224   0x.... 0x....      BL       _ZN8Endstops20test_dual_z_endstopsE11EndstopEnumS0_
   \   00000228   0xE052             B.N      ??update_21
    688                  }
    689                  //#else
    690                  else
    691                  {
    692                   // #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
    693                   if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   \                     ??update_14: (+1)
   \   0000022A   0xF105 0x0080      ADD      R0,R5,#+128
   \   0000022E   0x7E40             LDRB     R0,[R0, #+25]
   \   00000230   0x2801             CMP      R0,#+1
   \   00000232   0xD128             BNE.N    ??update_22
    694                   {
    695                      if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
   \   00000234   0x7860             LDRB     R0,[R4, #+1]
   \   00000236   0x2800             CMP      R0,#+0
   \   00000238   0xD04A             BEQ.N    ??update_21
   \   0000023A   0x....             LDR.N    R0,??DataTable27_6
   \   0000023C   0x8B41             LDRH     R1,[R0, #+26]
   \   0000023E   0x....             LDR.N    R0,??DataTable27_5
   \   00000240   0x6B40             LDR      R0,[R0, #+52]
   \   00000242   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000246   0xF105 0x0137      ADD      R1,R5,#+55
   \   0000024A   0x7889             LDRB     R1,[R1, #+2]
   \   0000024C   0x4288             CMP      R0,R1
   \   0000024E   0xD001             BEQ.N    ??update_23
   \   00000250   0x2001             MOVS     R0,#+1
   \   00000252   0xE000             B.N      ??update_24
   \                     ??update_23: (+1)
   \   00000254   0x2000             MOVS     R0,#+0
   \                     ??update_24: (+1)
   \   00000256   0x8861             LDRH     R1,[R4, #+2]
   \   00000258   0x4240             RSBS     R0,R0,#+0
   \   0000025A   0x4048             EORS     R0,R1,R0
   \   0000025C   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000260   0x4048             EORS     R0,R0,R1
   \   00000262   0x8060             STRH     R0,[R4, #+2]
   \   00000264   0x88A1             LDRH     R1,[R4, #+4]
   \   00000266   0x4008             ANDS     R0,R1,R0
   \   00000268   0x0740             LSLS     R0,R0,#+29
   \   0000026A   0xD531             BPL.N    ??update_21
   \   0000026C   0x....             LDR.N    R0,??DataTable27_7
   \   0000026E   0x6800             LDR      R0,[R0, #+0]
   \   00000270   0x68C0             LDR      R0,[R0, #+12]
   \   00000272   0x2801             CMP      R0,#+1
   \   00000274   0xDB2C             BLT.N    ??update_21
   \   00000276   0x7820             LDRB     R0,[R4, #+0]
   \   00000278   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000027C   0x7020             STRB     R0,[R4, #+0]
   \   0000027E   0x2002             MOVS     R0,#+2
   \   00000280   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
   \   00000284   0xE024             B.N      ??update_21
    696                   }
    697                    //#else
    698                    else
    699                    {
    700                      UPDATE_ENDSTOP(Z, MIN);
   \                     ??update_22: (+1)
   \   00000286   0x....             LDR.N    R0,??DataTable27_6
   \   00000288   0x8B41             LDRH     R1,[R0, #+26]
   \   0000028A   0x....             LDR.N    R0,??DataTable27_5
   \   0000028C   0x6B40             LDR      R0,[R0, #+52]
   \   0000028E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000292   0xF105 0x0137      ADD      R1,R5,#+55
   \   00000296   0x7889             LDRB     R1,[R1, #+2]
   \   00000298   0x4288             CMP      R0,R1
   \   0000029A   0xD001             BEQ.N    ??update_25
   \   0000029C   0x2001             MOVS     R0,#+1
   \   0000029E   0xE000             B.N      ??update_26
   \                     ??update_25: (+1)
   \   000002A0   0x2000             MOVS     R0,#+0
   \                     ??update_26: (+1)
   \   000002A2   0x8861             LDRH     R1,[R4, #+2]
   \   000002A4   0x4240             RSBS     R0,R0,#+0
   \   000002A6   0x4048             EORS     R0,R1,R0
   \   000002A8   0xF000 0x0004      AND      R0,R0,#0x4
   \   000002AC   0x4048             EORS     R0,R0,R1
   \   000002AE   0x8060             STRH     R0,[R4, #+2]
   \   000002B0   0x88A1             LDRH     R1,[R4, #+4]
   \   000002B2   0x4008             ANDS     R0,R1,R0
   \   000002B4   0x0740             LSLS     R0,R0,#+29
   \   000002B6   0xD50B             BPL.N    ??update_21
   \   000002B8   0x....             LDR.N    R0,??DataTable27_7
   \   000002BA   0x6800             LDR      R0,[R0, #+0]
   \   000002BC   0x68C0             LDR      R0,[R0, #+12]
   \   000002BE   0x2801             CMP      R0,#+1
   \   000002C0   0xDB06             BLT.N    ??update_21
   \   000002C2   0x7820             LDRB     R0,[R4, #+0]
   \   000002C4   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000002C8   0x7020             STRB     R0,[R4, #+0]
   \   000002CA   0x2002             MOVS     R0,#+2
   \   000002CC   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
    701                    }
    702                    //#endif
    703                  }
    704                  //#endif
    705                #endif
    706          
    707                // When closing the gap check the enabled probe
    708                //#if ENABLED(Z_MIN_PROBE_ENDSTOP)
    709                if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \                     ??update_21: (+1)
   \   000002D0   0xF105 0x0080      ADD      R0,R5,#+128
   \   000002D4   0x7E40             LDRB     R0,[R0, #+25]
   \   000002D6   0x2802             CMP      R0,#+2
   \   000002D8   0xF040 0x80A5      BNE.W    ??update_12
    710                {
    711                  if (z_probe_enabled) {
   \   000002DC   0x7860             LDRB     R0,[R4, #+1]
   \   000002DE   0x2800             CMP      R0,#+0
   \   000002E0   0xF000 0x80A1      BEQ.W    ??update_12
    712                    UPDATE_ENDSTOP(Z, MIN_PROBE);
   \   000002E4   0x....             LDR.N    R0,??DataTable27_6
   \   000002E6   0x8B81             LDRH     R1,[R0, #+28]
   \   000002E8   0x....             LDR.N    R0,??DataTable27_5
   \   000002EA   0x6B80             LDR      R0,[R0, #+56]
   \   000002EC   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000002F0   0xF105 0x0137      ADD      R1,R5,#+55
   \   000002F4   0x7989             LDRB     R1,[R1, #+6]
   \   000002F6   0x4288             CMP      R0,R1
   \   000002F8   0xD001             BEQ.N    ??update_27
   \   000002FA   0x2001             MOVS     R0,#+1
   \   000002FC   0xE000             B.N      ??update_28
   \                     ??update_27: (+1)
   \   000002FE   0x2000             MOVS     R0,#+0
   \                     ??update_28: (+1)
   \   00000300   0x8861             LDRH     R1,[R4, #+2]
   \   00000302   0x4240             RSBS     R0,R0,#+0
   \   00000304   0x4048             EORS     R0,R1,R0
   \   00000306   0xF000 0x0008      AND      R0,R0,#0x8
   \   0000030A   0x4048             EORS     R0,R0,R1
   \   0000030C   0x8060             STRH     R0,[R4, #+2]
   \   0000030E   0x88A1             LDRH     R1,[R4, #+4]
   \   00000310   0x4008             ANDS     R0,R1,R0
   \   00000312   0x0700             LSLS     R0,R0,#+28
   \   00000314   0xD50B             BPL.N    ??update_29
   \   00000316   0x....             LDR.N    R0,??DataTable27_7
   \   00000318   0x6800             LDR      R0,[R0, #+0]
   \   0000031A   0x68C0             LDR      R0,[R0, #+12]
   \   0000031C   0x2801             CMP      R0,#+1
   \   0000031E   0xDB06             BLT.N    ??update_29
   \   00000320   0x7820             LDRB     R0,[R4, #+0]
   \   00000322   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000326   0x7020             STRB     R0,[R4, #+0]
   \   00000328   0x2002             MOVS     R0,#+2
   \   0000032A   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
    713                    if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
   \                     ??update_29: (+1)
   \   0000032E   0x8860             LDRH     R0,[R4, #+2]
   \   00000330   0x88A1             LDRH     R1,[R4, #+4]
   \   00000332   0x4008             ANDS     R0,R1,R0
   \   00000334   0x0700             LSLS     R0,R0,#+28
   \   00000336   0xD576             BPL.N    ??update_12
   \   00000338   0x7820             LDRB     R0,[R4, #+0]
   \   0000033A   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000033E   0x7020             STRB     R0,[R4, #+0]
   \   00000340   0xE071             B.N      ??update_12
    714                  }
    715                }
    716                //#endif
    717              }
    718              else { // Z +direction. Gantry up, bed down.
    719                #if HAS_Z_MAX
    720          	  	 if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)  
   \                     ??update_13: (+1)
   \   00000342   0xF105 0x0680      ADD      R6,R5,#+128
   \   00000346   0x7E70             LDRB     R0,[R6, #+25]
   \   00000348   0x2802             CMP      R0,#+2
   \   0000034A   0xD06C             BEQ.N    ??update_12
    721          	  	{
    722          		  	if(mksCfg.use_zmax_plug)
   \   0000034C   0x7971             LDRB     R1,[R6, #+5]
   \   0000034E   0x2900             CMP      R1,#+0
   \   00000350   0xD069             BEQ.N    ??update_12
    723          	      	{
    724          		        // Check both Z dual endstops
    725          		        //#if ENABLED(Z_DUAL_ENDSTOPS)
    726          		        if(Z_DUAL_ENDSTOPS==1)
   \   00000352   0xF895 0x1102      LDRB     R1,[R5, #+258]
   \   00000356   0x2901             CMP      R1,#+1
   \   00000358   0xD13E             BNE.N    ??update_30
    727                          {      
    728          		          UPDATE_ENDSTOP_BIT(Z, MAX);
   \   0000035A   0x....             LDR.N    R7,??DataTable27_5
   \   0000035C   0x.... 0x....      LDR.W    R8,??DataTable27_6
   \   00000360   0xF8B8 0x101C      LDRH     R1,[R8, #+28]
   \   00000364   0x6BB8             LDR      R0,[R7, #+56]
   \   00000366   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000036A   0xF205 0x0637      ADDW     R6,R5,#+55
   \   0000036E   0x7971             LDRB     R1,[R6, #+5]
   \   00000370   0x4288             CMP      R0,R1
   \   00000372   0xD001             BEQ.N    ??update_31
   \   00000374   0x2001             MOVS     R0,#+1
   \   00000376   0xE000             B.N      ??update_32
   \                     ??update_31: (+1)
   \   00000378   0x2000             MOVS     R0,#+0
   \                     ??update_32: (+1)
   \   0000037A   0x8861             LDRH     R1,[R4, #+2]
   \   0000037C   0x4240             RSBS     R0,R0,#+0
   \   0000037E   0x4048             EORS     R0,R1,R0
   \   00000380   0xF000 0x0040      AND      R0,R0,#0x40
   \   00000384   0x4048             EORS     R0,R0,R1
   \   00000386   0x8060             STRH     R0,[R4, #+2]
    729          		          //#if HAS_Z2_MAX
    730                            if(mksCfg.z2_endstop!=0)
   \   00000388   0xF505 0x7181      ADD      R1,R5,#+258
   \   0000038C   0x7849             LDRB     R1,[R1, #+1]
   \   0000038E   0x2900             CMP      R1,#+0
   \   00000390   0xD012             BEQ.N    ??update_33
    731          			UPDATE_ENDSTOP_BIT(Z2, MAX);
   \   00000392   0xF8B8 0x101C      LDRH     R1,[R8, #+28]
   \   00000396   0x6BB8             LDR      R0,[R7, #+56]
   \   00000398   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000039C   0x7971             LDRB     R1,[R6, #+5]
   \   0000039E   0x4288             CMP      R0,R1
   \   000003A0   0xD001             BEQ.N    ??update_34
   \   000003A2   0x2001             MOVS     R0,#+1
   \   000003A4   0xE000             B.N      ??update_35
   \                     ??update_34: (+1)
   \   000003A6   0x2000             MOVS     R0,#+0
   \                     ??update_35: (+1)
   \   000003A8   0x8861             LDRH     R1,[R4, #+2]
   \   000003AA   0x4240             RSBS     R0,R0,#+0
   \   000003AC   0x4048             EORS     R0,R1,R0
   \   000003AE   0xF400 0x5080      AND      R0,R0,#0x1000
   \   000003B2   0x4048             EORS     R0,R0,R1
   \   000003B4   0x8060             STRH     R0,[R4, #+2]
   \   000003B6   0xE00A             B.N      ??update_36
    732                              //UPDATE_ENDSTOP_BIT_Z2_MIN;
    733                             else
    734          		          //#else
    735          		            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
   \                     ??update_33: (+1)
   \   000003B8   0x4601             MOV      R1,R0
   \   000003BA   0xB2C9             UXTB     R1,R1
   \   000003BC   0x0989             LSRS     R1,R1,#+6
   \   000003BE   0xF001 0x0101      AND      R1,R1,#0x1
   \   000003C2   0x4249             RSBS     R1,R1,#+0
   \   000003C4   0x4041             EORS     R1,R0,R1
   \   000003C6   0xF401 0x5180      AND      R1,R1,#0x1000
   \   000003CA   0x4048             EORS     R0,R1,R0
   \   000003CC   0x8060             STRH     R0,[R4, #+2]
    736          		          //#endif
    737          		          test_dual_z_endstops(Z_MAX, Z2_MAX);
   \                     ??update_36: (+1)
   \   000003CE   0x210C             MOVS     R1,#+12
   \   000003D0   0x2006             MOVS     R0,#+6
   \   000003D2   0x.... 0x....      BL       _ZN8Endstops20test_dual_z_endstopsE11EndstopEnumS0_
   \   000003D6   0xE026             B.N      ??update_12
    738          		        // If this pin is not hijacked for the bed probe
    739          		        // then it belongs to the Z endstop
    740          		        //#elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
    741                          }
    742          		        //#else
    743          		        else
    744                          {      
    745          				  if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)		//mks
   \                     ??update_30: (+1)
   \   000003D8   0x2802             CMP      R0,#+2
   \   000003DA   0xD024             BEQ.N    ??update_12
    746          		          	UPDATE_ENDSTOP(Z, MAX);
   \   000003DC   0x....             LDR.N    R0,??DataTable27_6
   \   000003DE   0x8B81             LDRH     R1,[R0, #+28]
   \   000003E0   0x....             LDR.N    R0,??DataTable27_5
   \   000003E2   0x6B80             LDR      R0,[R0, #+56]
   \   000003E4   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000003E8   0xF105 0x0137      ADD      R1,R5,#+55
   \   000003EC   0x7949             LDRB     R1,[R1, #+5]
   \   000003EE   0x4288             CMP      R0,R1
   \   000003F0   0xD001             BEQ.N    ??update_37
   \   000003F2   0x2001             MOVS     R0,#+1
   \   000003F4   0xE000             B.N      ??update_38
   \                     ??update_37: (+1)
   \   000003F6   0x2000             MOVS     R0,#+0
   \                     ??update_38: (+1)
   \   000003F8   0x8861             LDRH     R1,[R4, #+2]
   \   000003FA   0x4240             RSBS     R0,R0,#+0
   \   000003FC   0x4048             EORS     R0,R1,R0
   \   000003FE   0xF000 0x0040      AND      R0,R0,#0x40
   \   00000402   0x4048             EORS     R0,R0,R1
   \   00000404   0x8060             STRH     R0,[R4, #+2]
   \   00000406   0x88A1             LDRH     R1,[R4, #+4]
   \   00000408   0x4008             ANDS     R0,R1,R0
   \   0000040A   0x0640             LSLS     R0,R0,#+25
   \   0000040C   0xD50B             BPL.N    ??update_12
   \   0000040E   0x....             LDR.N    R0,??DataTable27_7
   \   00000410   0x6800             LDR      R0,[R0, #+0]
   \   00000412   0x68C0             LDR      R0,[R0, #+12]
   \   00000414   0x2801             CMP      R0,#+1
   \   00000416   0xDB06             BLT.N    ??update_12
   \   00000418   0x7820             LDRB     R0,[R4, #+0]
   \   0000041A   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000041E   0x7020             STRB     R0,[R4, #+0]
   \   00000420   0x2002             MOVS     R0,#+2
   \   00000422   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
    747                          }
    748          		        //#endif
    749          	  		}
    750          	  	 }
    751                #endif
    752              }
    753            }
    754          
    755            old_endstop_bits = current_endstop_bits;
   \                     ??update_12: (+1)
   \   00000426   0x8860             LDRH     R0,[R4, #+2]
   \   00000428   0x80A0             STRH     R0,[R4, #+4]
    756          
    757          } // Endstops::update()
   \   0000042A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " X:">`:
   \   00000000   0x20 0x58          DC8 " X:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y:">`:
   \   00000000   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " P:">`:
   \   00000000   0x20 0x50          DC8 " P:"
   \              0x3A 0x00    

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000004   0x.... 0x....      B.W      _ZN8EndstopsC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x20 0x58          DC8      " X:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x20 0x50          DC8      " P:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     endstops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x........         DC32     _ZN7Stepper13current_blockE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \   00000000   0x........         DC32     _ZN7Stepper17performing_homingE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "endstops hit: ">`:
   \   00000000   0x65 0x6E          DC8 "endstops hit: "
   \              0x64 0x73    
   \              0x74 0x6F    
   \              0x70 0x73    
   \              0x20 0x68    
   \              0x69 0x74    
   \              0x3A 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Reporting endstop sta...">`:
   \   00000000   0x52 0x65          DC8 "Reporting endstop status\012"
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x65 0x6E    
   \              0x64 0x73    
   \              0x74 0x6F    
   \              0x70 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "x_min: ">`:
   \   00000000   0x78 0x5F          DC8 "x_min: "
   \              0x6D 0x69    
   \              0x6E 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TRIGGERED">`:
   \   00000000   0x54 0x52          DC8 "TRIGGERED"
   \              0x49 0x47    
   \              0x47 0x45    
   \              0x52 0x45    
   \              0x44 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "open">`:
   \   00000000   0x6F 0x70          DC8 "open"
   \              0x65 0x6E    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "x_max: ">`:
   \   00000000   0x78 0x5F          DC8 "x_max: "
   \              0x6D 0x61    
   \              0x78 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "y_min: ">`:
   \   00000000   0x79 0x5F          DC8 "y_min: "
   \              0x6D 0x69    
   \              0x6E 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "y_max: ">`:
   \   00000000   0x79 0x5F          DC8 "y_max: "
   \              0x6D 0x61    
   \              0x78 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z_min: ">`:
   \   00000000   0x7A 0x5F          DC8 "z_min: "
   \              0x6D 0x69    
   \              0x6E 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z2_min: ">`:
   \   00000000   0x7A 0x32          DC8 "z2_min: "
   \              0x5F 0x6D    
   \              0x69 0x6E    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z_max: ">`:
   \   00000000   0x7A 0x5F          DC8 "z_max: "
   \              0x6D 0x61    
   \              0x78 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z2_max: ">`:
   \   00000000   0x7A 0x32          DC8 "z2_max: "
   \              0x5F 0x6D    
   \              0x61 0x78    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z_probe: ">`:
   \   00000000   0x7A 0x5F          DC8 "z_probe: "
   \              0x70 0x72    
   \              0x6F 0x62    
   \              0x65 0x3A    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Endstops::Endstops()
         8   -> Endstops::enable_globally(bool)
      32   Endstops::M119()
        32   -> HAL_GPIO_ReadPin
        32   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
        32   -> USARTClass::write(uint8_t)
        32   -> serialprintPGM(char const *)
       0   Endstops::enable_globally(bool)
       0   Endstops::hit_on_purpose()
       0   Endstops::init()
       8   Endstops::report_state()
         0   -> Endstops::hit_on_purpose()
         8   -> Stepper::triggered_position_mm(AxisEnum)
         8   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
       8   Endstops::test_dual_z_endstops(EndstopEnum, EndstopEnum)
         0   -> Stepper::kill_current_block()
      24   Endstops::update()
        24   -> Endstops::test_dual_z_endstops(EndstopEnum, EndstopEnum)
        24   -> HAL_GPIO_ReadPin
        24   -> Stepper::endstop_triggered(AxisEnum)
        24   -> Stepper::motor_direction(AxisEnum)
        24   -> X_AXIS_HEAD()
        24   -> X_MOVE_TEST()
        24   -> Y_AXIS_HEAD()
        24   -> Y_MOVE_TEST()
        24   -> Z_AXIS_HEAD()
        24   -> Z_MOVE_TEST()
       0   Stepper::kill_current_block()
       0   Stepper::motor_direction(AxisEnum)
       8   Stepper::triggered_position_mm(AxisEnum)
         0   -> __aeabi_fmul
         8   -> __aeabi_i2f
       0   X_AXIS_HEAD()
       8   X_MOVE_TEST()
         8   -> Stepper::motor_direction(AxisEnum)
       0   Y_AXIS_HEAD()
       8   Y_MOVE_TEST()
         8   -> Stepper::motor_direction(AxisEnum)
       0   Z_AXIS_HEAD()
       8   Z_MOVE_TEST()
         8   -> Stepper::motor_direction(AxisEnum)
       0   __sti__routine()
         0   -> Endstops::Endstops()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant " P:">
       4  ?<Constant " X:">
       4  ?<Constant " Y:">
       4  ?<Constant " Z:">
      28  ?<Constant "Reporting endstop sta...">
      12  ?<Constant "TRIGGERED">
      16  ?<Constant "endstops hit: ">
       8  ?<Constant "open">
       8  ?<Constant "x_max: ">
       8  ?<Constant "x_min: ">
       8  ?<Constant "y_max: ">
       8  ?<Constant "y_min: ">
      12  ?<Constant "z2_max: ">
      12  ?<Constant "z2_min: ">
       8  ?<Constant "z_max: ">
       8  ?<Constant "z_min: ">
      12  ?<Constant "z_probe: ">
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
      14  Endstops::Endstops()
     546  Endstops::M119()
      12  Endstops::enable_globally(bool)
       2  Endstops::enabled
          Endstops::enabled_globally
       6  Endstops::endstop_hit_bits
          Endstops::z_probe_enabled
          Endstops::current_endstop_bits
          Endstops::old_endstop_bits
      12  Endstops::hit_on_purpose()
       2  Endstops::init()
     174  Endstops::report_state()
      78  Endstops::test_dual_z_endstops(EndstopEnum, EndstopEnum)
    1070  Endstops::update()
      20  Stepper::kill_current_block()
      28  Stepper::motor_direction(AxisEnum)
      36  Stepper::triggered_position_mm(AxisEnum)
      22  X_AXIS_HEAD()
     328  X_MOVE_TEST()
      22  Y_AXIS_HEAD()
     328  Y_MOVE_TEST()
      22  Z_AXIS_HEAD()
     328  Z_MOVE_TEST()
       8  __sti__routine()
       4  endstops
      28  serialprintPGM(char const *)
       5  -- Other

 
    12 bytes in section .bss
     4 bytes in section .init_array
    17 bytes in section .rodata
 3 282 bytes in section .text
 
 3 136 bytes of CODE  memory (+ 150 bytes shared)
    16 bytes of CONST memory (+   1 byte  shared)
    12 bytes of DATA  memory

Errors: none
Warnings: 17
