###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:06:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_i2c.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_hal_i2c.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\stm32f1xx_hal_i2c.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   I2C HAL module driver.
      8            *          This file provides firmware functions to manage the following
      9            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              The I2C HAL driver can be used as follows:
     21          
     22              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     23                  I2C_HandleTypeDef  hi2c;
     24          
     25              (#)Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API:
     26                  (##) Enable the I2Cx interface clock
     27                  (##) I2C pins configuration
     28                      (+++) Enable the clock for the I2C GPIOs
     29                      (+++) Configure I2C pins as alternate function open-drain
     30                  (##) NVIC configuration if you need to use interrupt process
     31                      (+++) Configure the I2Cx interrupt priority
     32                      (+++) Enable the NVIC I2C IRQ Channel
     33                  (##) DMA Configuration if you need to use DMA process
     34                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     35                      (+++) Enable the DMAx interface clock using
     36                      (+++) Configure the DMA handle parameters
     37                      (+++) Configure the DMA Tx or Rx channel
     38                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     39                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on 
     40                            the DMA Tx or Rx channel
     41          
     42              (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
     43                  Dual Addressing mode, Own Address2, General call and Nostretch mode in the hi2c Init structure.
     44          
     45              (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware 
     46                  (GPIO, CLOCK, NVIC...etc) by calling the customized HAL_I2C_MspInit(&hi2c) API.
     47          
     48              (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()
     49          
     50              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     51          
     52              *** Polling mode IO operation ***
     53              =================================
     54              [..]
     55                (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
     56                (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
     57                (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
     58                (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()
     59          
     60              *** Polling mode IO MEM operation ***
     61              =====================================
     62              [..]
     63                (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
     64                (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()
     65          
     66          
     67              *** Interrupt mode IO operation ***
     68              ===================================
     69              [..]
     70                (+) The I2C interrupts should have the highest priority in the application in order 
     71                    to make them uninterruptible.
     72                (+) Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT()
     73                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can
     74                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
     75                (+) Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT()
     76                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can
     77                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
     78                (+) Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT()
     79                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can
     80                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
     81                (+) Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT()
     82                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can
     83                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
     84                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     85                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
     86          
     87              *** Interrupt mode IO MEM operation ***
     88              =======================================
     89              [..]
     90                (+) The I2C interrupts should have the highest priority in the application in order 
     91                    to make them uninterruptible.
     92                (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
     93                    HAL_I2C_Mem_Write_IT()
     94                (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and user can
     95                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback()
     96                (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
     97                    HAL_I2C_Mem_Read_IT()
     98                (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and user can
     99                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback()
    100                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    101                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
    102          
    103              *** DMA mode IO operation ***
    104              ==============================
    105              [..]
    106                (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
    107                    HAL_I2C_Master_Transmit_DMA()
    108                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can
    109                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
    110                (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
    111                    HAL_I2C_Master_Receive_DMA()
    112                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can
    113                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
    114                (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
    115                    HAL_I2C_Slave_Transmit_DMA()
    116                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can
    117                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
    118                (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
    119                    HAL_I2C_Slave_Receive_DMA()
    120                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can
    121                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
    122                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    123                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
    124          
    125              *** DMA mode IO MEM operation ***
    126              =================================
    127              [..]
    128                (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
    129                    HAL_I2C_Mem_Write_DMA()
    130                (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and user can
    131                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback()
    132                (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
    133                    HAL_I2C_Mem_Read_DMA()
    134                (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and user can
    135                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback()
    136                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    137                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
    138          
    139          
    140               *** I2C HAL driver macros list ***
    141               ==================================
    142               [..]
    143                 Below the list of most used macros in I2C HAL driver.
    144          
    145                (+) __HAL_I2C_ENABLE: Enable the I2C peripheral
    146                (+) __HAL_I2C_DISABLE: Disable the I2C peripheral
    147                (+) __HAL_I2C_GET_FLAG:    Check whether the specified I2C flag is set or not
    148                (+) __HAL_I2C_CLEAR_FLAG : Clear the specified I2C pending flag
    149                (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    150                (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    151                 (@) You can refer to the I2C HAL driver header file for more useful macros
    152          
    153          
    154               *** I2C Workarounds linked to Silicon Limitation ***
    155               ====================================================
    156               [..]
    157                 Below the list of all silicon limitations implemented for HAL on STM32F1xx product.
    158                 (@) See ErrataSheet to know full silicon limitation list of your product.
    159          
    160                 (#) Workarounds Implemented inside I2C HAL Driver
    161                    (##) Wrong data read into data register (Polling and Interrupt mode)
    162                    (##) Start cannot be generated after a misplaced Stop
    163                    (##) Some software events must be managed before the current byte is being transferred: 
    164                         Workaround: Use DMA in general, except when the Master is receiving a single byte.
    165                         For Interupt mode, I2C should have the highest priority in the application.
    166                    (##) Mismatch on the "Setup time for a repeated Start condition" timing parameter:
    167                         Workaround: Reduce the frequency down to 88 kHz or use the I2C Fast-mode if 
    168                         supported by the slave.
    169                    (##) Data valid time (tVD;DAT) violated without the OVR flag being set:
    170                         Workaround: If the slave device allows it, use the clock stretching mechanism 
    171                         by programming NoStretchMode = I2C_NOSTRETCH_DISABLE in HAL_I2C_Init.
    172          
    173            @endverbatim
    174            ******************************************************************************
    175            * @attention
    176            *
    177            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    178            *
    179            * Redistribution and use in source and binary forms, with or without modification,
    180            * are permitted provided that the following conditions are met:
    181            *   1. Redistributions of source code must retain the above copyright notice,
    182            *      this list of conditions and the following disclaimer.
    183            *   2. Redistributions in binary form must reproduce the above copyright notice,
    184            *      this list of conditions and the following disclaimer in the documentation
    185            *      and/or other materials provided with the distribution.
    186            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    187            *      may be used to endorse or promote products derived from this software
    188            *      without specific prior written permission.
    189            *
    190            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    191            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    192            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    193            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    194            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    195            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    196            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    197            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    198            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    199            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    200            *
    201            ******************************************************************************
    202            */
    203          
    204          /* Includes ------------------------------------------------------------------*/
    205          #include "stm32f1xx_hal.h"
    206          
    207          /** @addtogroup STM32F1xx_HAL_Driver
    208            * @{
    209            */
    210          
    211          /** @defgroup I2C I2C
    212            * @brief I2C HAL module driver
    213            * @{
    214            */
    215          
    216          #ifdef HAL_I2C_MODULE_ENABLED
    217          
    218          /* Private typedef -----------------------------------------------------------*/
    219          /* Private constants ---------------------------------------------------------*/
    220          /** @addtogroup I2C_Private_Constants I2C Private Constants
    221            * @{
    222            */
    223          #define I2C_TIMEOUT_FLAG          ((uint32_t)35)     /*!< Timeout 35 ms */
    224          #define I2C_TIMEOUT_ADDR_SLAVE    ((uint32_t)10000)  /*!< Timeout 10 s  */
    225          #define I2C_TIMEOUT_BUSY_FLAG     ((uint32_t)10000)  /*!< Timeout 10 s  */
    226          /**
    227            * @}
    228            */ 
    229          
    230          /* Private macro -------------------------------------------------------------*/
    231          /* Private variables ---------------------------------------------------------*/
    232          /* Private function prototypes -----------------------------------------------*/
    233          /** @addtogroup I2C_Private_Functions I2C Private Functions
    234            * @{
    235            */
    236          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    237          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    238          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    239          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    240          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma);
    241          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma);
    242          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    243          
    244          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout);
    245          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout);
    246          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    247          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    248          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    249          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout);
    250          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    251          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    252          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    253          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    254          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c);
    255          
    256          static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c);
    257          static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c);
    258          static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c);
    259          static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c);
    260          
    261          static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c);
    262          static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c);
    263          static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c);
    264          static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c);
    265          static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c);
    266          static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c);
    267          static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c);
    268          
    269          static uint32_t I2C_Configure_Speed(I2C_HandleTypeDef *hi2c, uint32_t I2CClkSrcFreq);
    270          /**
    271            * @}
    272            */ 
    273            
    274          /* Exported functions ---------------------------------------------------------*/
    275          
    276          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    277            * @{
    278            */
    279          
    280          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    281           *  @brief    Initialization and Configuration functions
    282           *
    283          @verbatim
    284           ===============================================================================
    285                        ##### Initialization and de-initialization functions #####
    286           ===============================================================================
    287              [..]  This subsection provides a set of functions allowing to initialize and
    288                    de-initialiaze the I2Cx peripheral:
    289          
    290                (+) User must Implement HAL_I2C_MspInit() function in which he configures
    291                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC).
    292          
    293                (+) Call the function HAL_I2C_Init() to configure the selected device with
    294                    the selected configuration:
    295                  (++) Communication Speed
    296                  (++) Duty cycle
    297                  (++) Addressing mode
    298                  (++) Own Address 1
    299                  (++) Dual Addressing mode
    300                  (++) Own Address 2
    301                  (++) General call mode
    302                  (++) Nostretch mode
    303          
    304                (+) Call the function HAL_I2C_DeInit() to restore the default configuration
    305                    of the selected I2Cx periperal.
    306          
    307          @endverbatim
    308            * @{
    309            */
    310          
    311          /**
    312            * @brief  Initializes the I2C according to the specified parameters
    313            *         in the I2C_InitTypeDef and initialize the associated handle.
    314            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    315            *                the configuration information for the specified I2C.
    316            * @retval HAL status
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    319          {
   \                     HAL_I2C_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    320            uint32_t freqrange = 0;
    321            uint32_t pclk1 = 0;
    322          
    323            /* Check the I2C handle allocation */
    324            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_Init_0
    325            {
    326              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    327            }
    328          
    329            /* Check the parameters */
    330            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    331            assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
    332            assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
    333            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    334            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    335            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    336            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    337            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    338            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    339          
    340            if(hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_I2C_Init_1
    341            {
    342              /* Allocate lock resource and initialize it */
    343              hi2c->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0034      STRB     R0,[R4, #+52]
    344              
    345              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    346              HAL_I2C_MspInit(hi2c);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_I2C_MspInit
    347            }
    348          
    349            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \   0000001E   0x2024             MOVS     R0,#+36
   \   00000020   0xF884 0x0035      STRB     R0,[R4, #+53]
    350          
    351            /* Disable the selected I2C peripheral */
    352            __HAL_I2C_DISABLE(hi2c);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x0849             LSRS     R1,R1,#+1
   \   0000002A   0x0049             LSLS     R1,R1,#+1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    353          
    354            /* Get PCLK1 frequency */
    355            pclk1 = HAL_RCC_GetPCLK1Freq();
   \   0000002E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
    356          
    357            /* Calculate frequency range */
    358            freqrange = I2C_FREQ_RANGE(pclk1);
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0xf4240
   \   00000036   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    359          
    360            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    361            /* Configure I2Cx: Frequency range */
    362            hi2c->Instance->CR2 = freqrange;
   \   0000003A   0x6822             LDR      R2,[R4, #+0]
   \   0000003C   0x6051             STR      R1,[R2, #+4]
    363          
    364            /*---------------------------- I2Cx TRISE Configuration --------------------*/
    365            /* Configure I2Cx: Rise Time */
    366            hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
   \   0000003E   0x6862             LDR      R2,[R4, #+4]
   \   00000040   0x.... 0x....      LDR.W    R3,??DataTable13  ;; 0x186a1
   \   00000044   0x429A             CMP      R2,R3
   \   00000046   0xD201             BCS.N    ??HAL_I2C_Init_2
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0xE007             B.N      ??HAL_I2C_Init_3
   \                     ??HAL_I2C_Init_2: (+1)
   \   0000004C   0xF44F 0x7296      MOV      R2,#+300
   \   00000050   0x4351             MULS     R1,R2,R1
   \   00000052   0xF44F 0x727A      MOV      R2,#+1000
   \   00000056   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \                     ??HAL_I2C_Init_3: (+1)
   \   0000005C   0x6822             LDR      R2,[R4, #+0]
   \   0000005E   0x6211             STR      R1,[R2, #+32]
    367          
    368            /*---------------------------- I2Cx CCR Configuration ----------------------*/
    369            /* Configure I2Cx: Speed */
    370            hi2c->Instance->CCR = I2C_Configure_Speed(hi2c, pclk1);
   \   00000060   0x4601             MOV      R1,R0
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       I2C_Configure_Speed
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x61C8             STR      R0,[R1, #+28]
    371          
    372            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    373            /* Configure I2Cx: Generalcall and NoStretch mode */
    374            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \   0000006C   0x69E0             LDR      R0,[R4, #+28]
   \   0000006E   0x6A21             LDR      R1,[R4, #+32]
   \   00000070   0x4308             ORRS     R0,R1,R0
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6008             STR      R0,[R1, #+0]
    375          
    376            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    377            /* Configure I2Cx: Own Address1 and addressing mode */
    378            hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
   \   00000076   0x6920             LDR      R0,[R4, #+16]
   \   00000078   0x68E1             LDR      R1,[R4, #+12]
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6088             STR      R0,[R1, #+8]
    379          
    380            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    381            /* Configure I2Cx: Dual mode and Own Address2 */
    382            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
   \   00000080   0x6960             LDR      R0,[R4, #+20]
   \   00000082   0x69A1             LDR      R1,[R4, #+24]
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x60C8             STR      R0,[R1, #+12]
    383          
    384            /* Enable the selected I2C peripheral */
    385            __HAL_I2C_ENABLE(hi2c);
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000092   0x6001             STR      R1,[R0, #+0]
    386          
    387            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x63A0             STR      R0,[R4, #+56]
    388            hi2c->State = HAL_I2C_STATE_READY;
   \   00000098   0x2020             MOVS     R0,#+32
   \   0000009A   0xF884 0x0035      STRB     R0,[R4, #+53]
    389            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x0036      STRB     R0,[R4, #+54]
    390          
    391            return HAL_OK;
   \   000000A4   0xBD10             POP      {R4,PC}          ;; return
    392          }
    393          
    394          /**
    395            * @brief  DeInitialize the I2C peripheral. 
    396            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    397            *                the configuration information for the specified I2C.
    398            * @retval HAL status
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    401          {
   \                     HAL_I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    402            /* Check the I2C handle allocation */
    403            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    404            {
    405              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    406            }
    407          
    408            /* Check the parameters */
    409            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    410          
    411            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \   0000000A   0x2024             MOVS     R0,#+36
   \   0000000C   0xF884 0x0035      STRB     R0,[R4, #+53]
    412          
    413            /* Disable the I2C Peripheral Clock */
    414            __HAL_I2C_DISABLE(hi2c);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    415          
    416            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    417            HAL_I2C_MspDeInit(hi2c);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_I2C_MspDeInit
    418          
    419            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63A0             STR      R0,[R4, #+56]
    420            hi2c->State = HAL_I2C_STATE_RESET;
   \   00000024   0xF884 0x0035      STRB     R0,[R4, #+53]
    421            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000028   0xF884 0x0036      STRB     R0,[R4, #+54]
    422          
    423            /* Release Lock */
    424            __HAL_UNLOCK(hi2c);
   \   0000002C   0xF884 0x0034      STRB     R0,[R4, #+52]
    425          
    426            return HAL_OK;
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    427          }
    428          
    429          /**
    430            * @brief Initialize the I2C MSP.
    431            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    432            *                the configuration information for the specified I2C.
    433            * @retval None
    434            */

   \                                 In section .text, align 2, keep-with-next
    435           __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    436          {
    437            /* Prevent unused argument(s) compilation warning */
    438            UNUSED(hi2c);
    439            /* NOTE : This function should not be modified, when the callback is needed,
    440                      the HAL_I2C_MspInit could be implemented in the user file
    441             */
    442          }
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    443          
    444          /**
    445            * @brief DeInitialize the I2C MSP.
    446            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    447            *                the configuration information for the specified I2C.
    448            * @retval None
    449            */

   \                                 In section .text, align 2, keep-with-next
    450           __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    451          {
    452            /* Prevent unused argument(s) compilation warning */
    453            UNUSED(hi2c);
    454            /* NOTE : This function should not be modified, when the callback is needed,
    455                      the HAL_I2C_MspDeInit could be implemented in the user file
    456             */
    457          }
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    458          
    459          /**
    460            * @}
    461            */
    462          
    463          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    464           *  @brief   Data transfers functions
    465           *
    466          @verbatim
    467           ===============================================================================
    468                                ##### IO operation functions #####
    469           ===============================================================================
    470              [..]
    471              This subsection provides a set of functions allowing to manage the I2C data
    472              transfers.
    473          
    474              (#) There are two modes of transfer:
    475                 (++) Blocking mode : The communication is performed in the polling mode.
    476                      The status of all data processing is returned by the same function
    477                      after finishing transfer.
    478                 (++) No-Blocking mode : The communication is performed using Interrupts 
    479                      or DMA. These functions return the status of the transfer startup.
    480                      The end of the data processing will be indicated through the
    481                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
    482                      using DMA mode.
    483          
    484              (#) Blocking mode functions are :
    485                  (++) HAL_I2C_Master_Transmit()
    486                  (++) HAL_I2C_Master_Receive()
    487                  (++) HAL_I2C_Slave_Transmit()
    488                  (++) HAL_I2C_Slave_Receive()
    489                  (++) HAL_I2C_Mem_Write()
    490                  (++) HAL_I2C_Mem_Read()
    491                  (++) HAL_I2C_IsDeviceReady()
    492          
    493              (#) No-Blocking mode functions with Interrupt are :
    494                  (++) HAL_I2C_Master_Transmit_IT()
    495                  (++) HAL_I2C_Master_Receive_IT()
    496                  (++) HAL_I2C_Slave_Transmit_IT()
    497                  (++) HAL_I2C_Slave_Receive_IT()
    498                  (++) HAL_I2C_Mem_Write_IT()
    499                  (++) HAL_I2C_Mem_Read_IT()
    500          
    501              (#) No-Blocking mode functions with DMA are :
    502                  (++) HAL_I2C_Master_Transmit_DMA()
    503                  (++) HAL_I2C_Master_Receive_DMA()
    504                  (++) HAL_I2C_Slave_Transmit_DMA()
    505                  (++) HAL_I2C_Slave_Receive_DMA()
    506                  (++) HAL_I2C_Mem_Write_DMA()
    507                  (++) HAL_I2C_Mem_Read_DMA()
    508          
    509              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    510                  (++) HAL_I2C_MemTxCpltCallback()
    511                  (++) HAL_I2C_MemRxCpltCallback()
    512                  (++) HAL_I2C_MasterTxCpltCallback()
    513                  (++) HAL_I2C_MasterRxCpltCallback()
    514                  (++) HAL_I2C_SlaveTxCpltCallback()
    515                  (++) HAL_I2C_SlaveRxCpltCallback()
    516                  (++) HAL_I2C_ErrorCallback()
    517          
    518          @endverbatim
    519            * @{
    520            */
    521          
    522          /**
    523            * @brief  Transmits in master mode an amount of data in blocking mode.
    524            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    525            *                the configuration information for the specified I2C.
    526            * @param  DevAddress Target device address
    527            * @param  pData Pointer to data buffer
    528            * @param  Size Amount of data to be sent
    529            * @param  Timeout Timeout duration
    530            * @retval HAL status
    531            */

   \                                 In section .text, align 2, keep-with-next
    532          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    533          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    534            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xF040 0x8081      BNE.W    ??HAL_I2C_Master_Transmit_0
    535            {
    536              if((pData == NULL) || (Size == 0))
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_1
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_2
    537              {
    538                return  HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE07B             B.N      ??HAL_I2C_Master_Transmit_3
    539              }
    540          
    541              /* Wait until BUSY flag is reset */
    542              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \   00000024   0xF242 0x7310      MOVW     R3,#+10000
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD170             BNE.N    ??HAL_I2C_Master_Transmit_0
    543              {
    544                return HAL_BUSY;
    545              }
    546          
    547              /* Process Locked */
    548              __HAL_LOCK(hi2c);
   \   00000038   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD06C             BEQ.N    ??HAL_I2C_Master_Transmit_0
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
    549          
    550              /* Disable Pos */
    551              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    552          
    553              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000050   0x2021             MOVS     R0,#+33
   \   00000052   0xF884 0x0035      STRB     R0,[R4, #+53]
    554              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000056   0x2010             MOVS     R0,#+16
   \   00000058   0xF884 0x0036      STRB     R0,[R4, #+54]
    555              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x63A0             STR      R0,[R4, #+56]
   \   00000060   0x9F08             LDR      R7,[SP, #+32]
    556          
    557              /* Send Slave Address */
    558              if(I2C_MasterRequestWrite(hi2c, DevAddress, Timeout) != HAL_OK)
   \   00000062   0x463A             MOV      R2,R7
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_4
    559              {
    560                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000070   0x6BA0             LDR      R0,[R4, #+56]
   \   00000072   0x2804             CMP      R0,#+4
   \   00000074   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_5
    561                {
    562                  /* Process Unlocked */
    563                  __HAL_UNLOCK(hi2c);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x0034      STRB     R0,[R4, #+52]
    564                  return HAL_ERROR;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE04D             B.N      ??HAL_I2C_Master_Transmit_3
    565                }
    566                else
    567                {
    568                  /* Process Unlocked */
    569                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
    570                  return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE048             B.N      ??HAL_I2C_Master_Transmit_3
    571                }
    572              }
    573          
    574              /* Clear ADDR flag */
    575              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6941             LDR      R1,[R0, #+20]
   \   0000008E   0x9100             STR      R1,[SP, #+0]
   \   00000090   0x6980             LDR      R0,[R0, #+24]
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0xE00F             B.N      ??HAL_I2C_Master_Transmit_6
    576          
    577              while(Size > 0)
    578              {
    579                /* Wait until TXE flag is set */
    580                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    581                {
    582                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    583                  {
    584                    /* Generate Stop */
    585                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
    586                    return HAL_ERROR;
    587                  }
    588                  else
    589                  {
    590                    return HAL_TIMEOUT;
    591                  }
    592                }
    593          
    594                /* Write data to DR */
    595                hi2c->Instance->DR = (*pData++);
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \   00000098   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6108             STR      R0,[R1, #+16]
    596                Size--;
   \   000000A0   0x1E76             SUBS     R6,R6,#+1
    597          
    598                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6941             LDR      R1,[R0, #+20]
   \   000000A6   0x0749             LSLS     R1,R1,#+29
   \   000000A8   0xD506             BPL.N    ??HAL_I2C_Master_Transmit_6
   \   000000AA   0xB2B6             UXTH     R6,R6
   \   000000AC   0x2E00             CMP      R6,#+0
   \   000000AE   0xD003             BEQ.N    ??HAL_I2C_Master_Transmit_6
    599                {
    600                  /* Write data to DR */
    601                  hi2c->Instance->DR = (*pData++);
   \   000000B0   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   000000B4   0x6101             STR      R1,[R0, #+16]
    602                  Size--;
   \   000000B6   0x1E76             SUBS     R6,R6,#+1
    603                }
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \   000000B8   0xB2B6             UXTH     R6,R6
   \   000000BA   0x2E00             CMP      R6,#+0
   \   000000BC   0x4639             MOV      R1,R7
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0xD00F             BEQ.N    ??HAL_I2C_Master_Transmit_8
   \   000000C2   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD0E6             BEQ.N    ??HAL_I2C_Master_Transmit_7
   \   000000CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CC   0x2804             CMP      R0,#+4
   \   000000CE   0xD106             BNE.N    ??HAL_I2C_Master_Transmit_9
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000D8   0x6001             STR      R1,[R0, #+0]
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0xE01E             B.N      ??HAL_I2C_Master_Transmit_3
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0xE01C             B.N      ??HAL_I2C_Master_Transmit_3
    604              }
    605          
    606              /* Wait until BTF flag is set */
    607              if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \   000000E2   0x.... 0x....      BL       I2C_WaitOnBTFFlagUntilTimeout
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD00B             BEQ.N    ??HAL_I2C_Master_Transmit_10
    608              {
    609                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000EA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EC   0x2804             CMP      R0,#+4
   \   000000EE   0xD106             BNE.N    ??HAL_I2C_Master_Transmit_11
    610                {
    611                  /* Generate Stop */
    612                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x6801             LDR      R1,[R0, #+0]
   \   000000F4   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000F8   0x6001             STR      R1,[R0, #+0]
    613                  return HAL_ERROR;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0xE00E             B.N      ??HAL_I2C_Master_Transmit_3
    614                }
    615                else
    616                {
    617                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Transmit_11: (+1)
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0xE00C             B.N      ??HAL_I2C_Master_Transmit_3
    618                }
    619              }
    620          
    621              /* Generate Stop */
    622              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000010A   0x6001             STR      R1,[R0, #+0]
    623          
    624              hi2c->State = HAL_I2C_STATE_READY;
   \   0000010C   0x2020             MOVS     R0,#+32
   \   0000010E   0xF884 0x0035      STRB     R0,[R4, #+53]
    625          
    626              /* Process Unlocked */
    627              __HAL_UNLOCK(hi2c);
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF884 0x0034      STRB     R0,[R4, #+52]
    628          
    629              return HAL_OK;
   \   00000118   0xE000             B.N      ??HAL_I2C_Master_Transmit_3
    630            }
    631            else
    632            {
    633              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \   0000011A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \   0000011C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    634            }
    635          }
    636          
    637          /**
    638            * @brief  Receives in master mode an amount of data in blocking mode. 
    639            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    640            *                the configuration information for the specified I2C.
    641            * @param  DevAddress Target device address
    642            * @param  pData Pointer to data buffer
    643            * @param  Size Amount of data to be sent
    644            * @param  Timeout Timeout duration
    645            * @retval HAL status
    646            */

   \                                 In section .text, align 2, keep-with-next
    647          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    648          {
   \                     HAL_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    649            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xF040 0x80F7      BNE.W    ??HAL_I2C_Master_Receive_0
    650            {
    651              if((pData == NULL) || (Size == 0))
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_1
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD101             BNE.N    ??HAL_I2C_Master_Receive_2
    652              {
    653                return  HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE0F1             B.N      ??HAL_I2C_Master_Receive_3
    654              }
    655          
    656              /* Wait until BUSY flag is reset */
    657              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \   00000024   0xF242 0x7310      MOVW     R3,#+10000
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xF040 0x80E6      BNE.W    ??HAL_I2C_Master_Receive_0
    658              {
    659                return HAL_BUSY;
    660              }
    661          
    662              /* Process Locked */
    663              __HAL_LOCK(hi2c);
   \   0000003A   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xF000 0x80E1      BEQ.W    ??HAL_I2C_Master_Receive_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
    664          
    665              /* Disable Pos */
    666              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6001             STR      R1,[R0, #+0]
    667          
    668              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000054   0x2022             MOVS     R0,#+34
   \   00000056   0xF884 0x0035      STRB     R0,[R4, #+53]
    669              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   0000005A   0x2010             MOVS     R0,#+16
   \   0000005C   0xF884 0x0036      STRB     R0,[R4, #+54]
    670              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x63A0             STR      R0,[R4, #+56]
   \   00000064   0x9F08             LDR      R7,[SP, #+32]
    671          
    672              /* Send Slave Address */
    673              if(I2C_MasterRequestRead(hi2c, DevAddress, Timeout) != HAL_OK)
   \   00000066   0x463A             MOV      R2,R7
   \   00000068   0x4641             MOV      R1,R8
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       I2C_MasterRequestRead
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_4
    674              {
    675                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000074   0x6BA0             LDR      R0,[R4, #+56]
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD104             BNE.N    ??HAL_I2C_Master_Receive_5
    676                {
    677                  /* Process Unlocked */
    678                  __HAL_UNLOCK(hi2c);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF884 0x0034      STRB     R0,[R4, #+52]
    679                  return HAL_ERROR;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xE0C1             B.N      ??HAL_I2C_Master_Receive_3
    680                }
    681                else
    682                {
    683                  /* Process Unlocked */
    684                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF884 0x0034      STRB     R0,[R4, #+52]
    685                  return HAL_TIMEOUT;
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0xE0BC             B.N      ??HAL_I2C_Master_Receive_3
    686                }
    687              }
    688          
    689              if(Size == 1)
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x4631             MOV      R1,R6
   \   00000092   0x2901             CMP      R1,#+1
   \   00000094   0xD110             BNE.N    ??HAL_I2C_Master_Receive_6
    690              {
    691                /* Disable Acknowledge */
    692                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    693          
    694                /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
    695                   software sequence must complete before the current byte end of transfer */
    696                __disable_irq();
   \   0000009E   0xB672             CPSID    I
    697          
    698                /* Clear ADDR flag */
    699                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6941             LDR      R1,[R0, #+20]
   \   000000A4   0x9100             STR      R1,[SP, #+0]
   \   000000A6   0x6981             LDR      R1,[R0, #+24]
   \   000000A8   0x9100             STR      R1,[SP, #+0]
   \   000000AA   0x9900             LDR      R1,[SP, #+0]
    700          
    701                /* Generate Stop */
    702                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000B2   0x6001             STR      R1,[R0, #+0]
    703          	  
    704                /* Re-enable IRQs */
    705                __enable_irq(); 
   \   000000B4   0xB662             CPSIE    I
   \   000000B6   0xE021             B.N      ??HAL_I2C_Master_Receive_7
    706              }
    707              else if(Size == 2)
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \   000000B8   0x2902             CMP      R1,#+2
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0xD10F             BNE.N    ??HAL_I2C_Master_Receive_8
    708              {
    709                /* Enable Pos */
    710                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000BE   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000C2   0x6001             STR      R1,[R0, #+0]
    711          
    712                /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
    713                   software sequence must complete before the current byte end of transfer */
    714                __disable_irq();
   \   000000C4   0xB672             CPSID    I
    715          
    716                /* Clear ADDR flag */
    717                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6941             LDR      R1,[R0, #+20]
   \   000000CA   0x9100             STR      R1,[SP, #+0]
   \   000000CC   0x6981             LDR      R1,[R0, #+24]
   \   000000CE   0x9100             STR      R1,[SP, #+0]
   \   000000D0   0x9900             LDR      R1,[SP, #+0]
    718          
    719                /* Disable Acknowledge */
    720                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000D8   0x6001             STR      R1,[R0, #+0]
    721          
    722                 /* Re-enable IRQs */
    723                 __enable_irq(); 
   \   000000DA   0xB662             CPSIE    I
   \   000000DC   0xE00E             B.N      ??HAL_I2C_Master_Receive_7
    724              }
    725              else
    726              {
    727                /* Enable Acknowledge */
    728                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \   000000DE   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000E2   0x6001             STR      R1,[R0, #+0]
    729          
    730                /* Clear ADDR flag */
    731                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6941             LDR      R1,[R0, #+20]
   \   000000E8   0x9100             STR      R1,[SP, #+0]
   \   000000EA   0x6980             LDR      R0,[R0, #+24]
   \   000000EC   0x9000             STR      R0,[SP, #+0]
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0xE004             B.N      ??HAL_I2C_Master_Receive_7
    732              }
    733          
    734              while(Size > 0)
    735              {
    736                if(Size <= 3)
    737                {
    738                  /* One byte */
    739                  if(Size == 1)
    740                  {
    741                    /* Wait until RXNE flag is set */
    742                    if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
    743                    {
    744                      if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
    745                      {
    746                        return HAL_TIMEOUT;
    747                      }
    748                      else
    749                      {
    750                        return HAL_ERROR;
    751                      }
    752                    }
    753          
    754                    /* Read data from DR */
    755                    (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6900             LDR      R0,[R0, #+16]
   \   000000F6   0xF805 0x0B01      STRB     R0,[R5], #+1
    756                    Size--;
   \   000000FA   0x1E76             SUBS     R6,R6,#+1
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \   000000FC   0xB2B6             UXTH     R6,R6
   \   000000FE   0x2E00             CMP      R6,#+0
   \   00000100   0xD078             BEQ.N    ??HAL_I2C_Master_Receive_10
   \   00000102   0x4630             MOV      R0,R6
   \   00000104   0x2804             CMP      R0,#+4
   \   00000106   0xDA5A             BGE.N    ??HAL_I2C_Master_Receive_11
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xD10C             BNE.N    ??HAL_I2C_Master_Receive_12
   \   0000010C   0x4639             MOV      R1,R7
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD0EC             BEQ.N    ??HAL_I2C_Master_Receive_9
   \   00000118   0x6BA0             LDR      R0,[R4, #+56]
   \   0000011A   0x2820             CMP      R0,#+32
   \   0000011C   0xD101             BNE.N    ??HAL_I2C_Master_Receive_13
   \   0000011E   0x2003             MOVS     R0,#+3
   \   00000120   0xE072             B.N      ??HAL_I2C_Master_Receive_3
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xE070             B.N      ??HAL_I2C_Master_Receive_3
    757                  }
    758                  /* Two bytes */
    759                  else if(Size == 2)
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \   00000126   0x.... 0x....      LDR.W    R8,??DataTable15  ;; 0x10004
   \   0000012A   0x2802             CMP      R0,#+2
   \   0000012C   0x463B             MOV      R3,R7
   \   0000012E   0xD119             BNE.N    ??HAL_I2C_Master_Receive_14
    760                  {
    761                    /* Wait until BTF flag is set */
    762                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   00000130   0x2200             MOVS     R2,#+0
   \   00000132   0x4641             MOV      R1,R8
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_15
    763                    {
    764                      return HAL_TIMEOUT;
   \   0000013E   0x2003             MOVS     R0,#+3
   \   00000140   0xE062             B.N      ??HAL_I2C_Master_Receive_3
    765                    }
    766          
    767                    /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
    768                       software sequence must complete before the current byte end of transfer */
    769                     __disable_irq();
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \   00000142   0xB672             CPSID    I
    770          
    771                    /* Generate Stop */
    772                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   00000144   0x6820             LDR      R0,[R4, #+0]
   \   00000146   0x6801             LDR      R1,[R0, #+0]
   \   00000148   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000014C   0x6001             STR      R1,[R0, #+0]
    773          
    774                    /* Read data from DR */
    775                    (*pData++) = hi2c->Instance->DR;
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0x6900             LDR      R0,[R0, #+16]
   \   00000152   0xF805 0x0B01      STRB     R0,[R5], #+1
    776                    Size--;
    777          
    778                    /* Re-enable IRQs */
    779                    __enable_irq();
   \   00000156   0xB662             CPSIE    I
    780          
    781                    /* Read data from DR */
    782                    (*pData++) = hi2c->Instance->DR;
   \   00000158   0x6820             LDR      R0,[R4, #+0]
   \   0000015A   0x6900             LDR      R0,[R0, #+16]
   \   0000015C   0xF805 0x0B01      STRB     R0,[R5], #+1
    783                    Size--;
   \   00000160   0x1EB6             SUBS     R6,R6,#+2
   \   00000162   0xE7CB             B.N      ??HAL_I2C_Master_Receive_7
    784                  }
    785                  /* 3 Last bytes */
    786                  else
    787                  {
    788                    /* Wait until BTF flag is set */
    789                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \   00000164   0x2200             MOVS     R2,#+0
   \   00000166   0x4641             MOV      R1,R8
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_16
    790                    {
    791                      return HAL_TIMEOUT;
   \   00000172   0x2003             MOVS     R0,#+3
   \   00000174   0xE048             B.N      ??HAL_I2C_Master_Receive_3
    792                    }
    793          
    794                    /* Disable Acknowledge */
    795                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \   00000176   0x6820             LDR      R0,[R4, #+0]
   \   00000178   0x6801             LDR      R1,[R0, #+0]
   \   0000017A   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000017E   0x6001             STR      R1,[R0, #+0]
    796          
    797                    /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
    798                       software sequence must complete before the current byte end of transfer */
    799                    __disable_irq();
   \   00000180   0xB672             CPSID    I
    800          
    801                    /* Read data from DR */
    802                    (*pData++) = hi2c->Instance->DR;
   \   00000182   0x6820             LDR      R0,[R4, #+0]
   \   00000184   0x6900             LDR      R0,[R0, #+16]
   \   00000186   0xF805 0x0B01      STRB     R0,[R5], #+1
    803                    Size--;
    804          
    805                    /* Wait until BTF flag is set */
    806                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   0000018A   0x463B             MOV      R3,R7
   \   0000018C   0x2200             MOVS     R2,#+0
   \   0000018E   0x4641             MOV      R1,R8
   \   00000190   0x4620             MOV      R0,R4
   \   00000192   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_17
    807                    {
    808                      return HAL_TIMEOUT;
   \   0000019A   0x2003             MOVS     R0,#+3
   \   0000019C   0xE034             B.N      ??HAL_I2C_Master_Receive_3
    809                    }
    810          
    811                    /* Generate Stop */
    812                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \   0000019E   0x6820             LDR      R0,[R4, #+0]
   \   000001A0   0x6801             LDR      R1,[R0, #+0]
   \   000001A2   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000001A6   0x6001             STR      R1,[R0, #+0]
    813          
    814                    /* Read data from DR */
    815                    (*pData++) = hi2c->Instance->DR;
   \   000001A8   0x6820             LDR      R0,[R4, #+0]
   \   000001AA   0x6900             LDR      R0,[R0, #+16]
   \   000001AC   0xF805 0x0B01      STRB     R0,[R5], #+1
    816                    Size--;
    817          	  
    818                    /* Re-enable IRQs */
    819                    __enable_irq(); 
   \   000001B0   0xB662             CPSIE    I
    820          
    821                    /* Read data from DR */
    822                    (*pData++) = hi2c->Instance->DR;
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6900             LDR      R0,[R0, #+16]
   \   000001B6   0xF805 0x0B01      STRB     R0,[R5], #+1
    823                    Size--;
   \   000001BA   0x1EF6             SUBS     R6,R6,#+3
   \   000001BC   0xE79E             B.N      ??HAL_I2C_Master_Receive_7
    824                  }
    825                }
    826                else
    827                {
    828                  /* Wait until RXNE flag is set */
    829                  if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \   000001BE   0x4639             MOV      R1,R7
   \   000001C0   0x4620             MOV      R0,R4
   \   000001C2   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   000001C6   0x2800             CMP      R0,#+0
   \   000001C8   0xD006             BEQ.N    ??HAL_I2C_Master_Receive_18
    830                  {
    831                    if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   000001CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001CC   0x2820             CMP      R0,#+32
   \   000001CE   0xD101             BNE.N    ??HAL_I2C_Master_Receive_19
    832                    {
    833                      return HAL_TIMEOUT;
   \   000001D0   0x2003             MOVS     R0,#+3
   \   000001D2   0xE019             B.N      ??HAL_I2C_Master_Receive_3
    834                    }
    835                    else
    836                    {
    837                      return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_19: (+1)
   \   000001D4   0x2001             MOVS     R0,#+1
   \   000001D6   0xE017             B.N      ??HAL_I2C_Master_Receive_3
    838                    }
    839                  }
    840          
    841                  /* Read data from DR */
    842                  (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_18: (+1)
   \   000001D8   0x6820             LDR      R0,[R4, #+0]
   \   000001DA   0x6900             LDR      R0,[R0, #+16]
   \   000001DC   0xF805 0x0B01      STRB     R0,[R5], #+1
    843                  Size--;
   \   000001E0   0x1E76             SUBS     R6,R6,#+1
    844          
    845                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   000001E2   0x6820             LDR      R0,[R4, #+0]
   \   000001E4   0x6941             LDR      R1,[R0, #+20]
   \   000001E6   0x0749             LSLS     R1,R1,#+29
   \   000001E8   0xD588             BPL.N    ??HAL_I2C_Master_Receive_7
    846                  {
    847                    /* Read data from DR */
    848                    (*pData++) = hi2c->Instance->DR;
   \   000001EA   0x6900             LDR      R0,[R0, #+16]
   \   000001EC   0xF805 0x0B01      STRB     R0,[R5], #+1
    849                    Size--;
   \   000001F0   0x1E76             SUBS     R6,R6,#+1
   \   000001F2   0xE783             B.N      ??HAL_I2C_Master_Receive_7
    850                  }
    851                }
    852              }
    853          
    854              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \   000001F4   0x2020             MOVS     R0,#+32
   \   000001F6   0xF884 0x0035      STRB     R0,[R4, #+53]
    855              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0xF884 0x0036      STRB     R0,[R4, #+54]
    856          
    857              /* Process Unlocked */
    858              __HAL_UNLOCK(hi2c);
   \   00000200   0xF884 0x0034      STRB     R0,[R4, #+52]
    859          
    860              return HAL_OK;
   \   00000204   0xE000             B.N      ??HAL_I2C_Master_Receive_3
    861            }
    862            else
    863            {
    864              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \   00000206   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \   00000208   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    865            }
    866          }
    867          
    868          /**
    869            * @brief  Transmits in slave mode an amount of data in blocking mode. 
    870            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    871            *                the configuration information for the specified I2C.
    872            * @param  pData Pointer to data buffer
    873            * @param  Size Amount of data to be sent
    874            * @param  Timeout Timeout duration
    875            * @retval HAL status
    876            */

   \                                 In section .text, align 2, keep-with-next
    877          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    878          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    879            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xF040 0x8098      BNE.W    ??HAL_I2C_Slave_Transmit_0
    880            {
    881              if((pData == NULL) || (Size == 0))
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_1
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_2
    882              {
    883                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE092             B.N      ??HAL_I2C_Slave_Transmit_3
    884              }
    885          
    886              /* Wait until BUSY flag is reset */
    887              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \   00000024   0xF242 0x7310      MOVW     R3,#+10000
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xF040 0x8087      BNE.W    ??HAL_I2C_Slave_Transmit_0
    888              {
    889                return HAL_BUSY;
    890              }
    891          
    892              /* Process Locked */
    893              __HAL_LOCK(hi2c);
   \   0000003A   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xF000 0x8082      BEQ.W    ??HAL_I2C_Slave_Transmit_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
    894          
    895              /* Disable Pos */
    896              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6001             STR      R1,[R0, #+0]
    897          
    898              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000054   0x2021             MOVS     R0,#+33
   \   00000056   0xF884 0x0035      STRB     R0,[R4, #+53]
    899              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   0000005A   0x2020             MOVS     R0,#+32
   \   0000005C   0xF884 0x0036      STRB     R0,[R4, #+54]
    900              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x63A0             STR      R0,[R4, #+56]
    901          
    902              /* Enable Address Acknowledge */
    903              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000006C   0x6001             STR      R1,[R0, #+0]
    904          
    905              /* Wait until ADDR flag is set */
    906              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
   \   0000006E   0x.... 0x....      LDR.W    R8,??DataTable16  ;; 0x10002
   \   00000072   0x463B             MOV      R3,R7
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x4641             MOV      R1,R8
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_4
    907              {
    908                return HAL_TIMEOUT;
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xE061             B.N      ??HAL_I2C_Slave_Transmit_3
    909              }
    910          
    911              /* Clear ADDR flag */
    912              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6941             LDR      R1,[R0, #+20]
   \   0000008A   0x9100             STR      R1,[SP, #+0]
   \   0000008C   0x6980             LDR      R0,[R0, #+24]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
    913          
    914              /* If 10bit addressing mode is selected */
    915              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   00000092   0x6920             LDR      R0,[R4, #+16]
   \   00000094   0xF5B0 0x4F40      CMP      R0,#+49152
   \   00000098   0xD120             BNE.N    ??HAL_I2C_Slave_Transmit_5
    916              {
    917                /* Wait until ADDR flag is set */
    918                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
   \   0000009A   0x463B             MOV      R3,R7
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0x4641             MOV      R1,R8
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_6
    919                {
    920                  return HAL_TIMEOUT;
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0xE04D             B.N      ??HAL_I2C_Slave_Transmit_3
    921                }
    922          
    923                /* Clear ADDR flag */
    924                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6941             LDR      R1,[R0, #+20]
   \   000000B2   0x9100             STR      R1,[SP, #+0]
   \   000000B4   0x6980             LDR      R0,[R0, #+24]
   \   000000B6   0x9000             STR      R0,[SP, #+0]
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0xE00F             B.N      ??HAL_I2C_Slave_Transmit_5
    925              }
    926          
    927              while(Size > 0)
    928              {
    929                /* Wait until TXE flag is set */
    930                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    931                {
    932                  /* Disable Address Acknowledge */
    933                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
    934                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    935                  {
    936                    return HAL_ERROR;
    937                  }
    938                  else
    939                  {
    940                    return HAL_TIMEOUT;
    941                  }
    942                }
    943          
    944                /* Write data to DR */
    945                hi2c->Instance->DR = (*pData++);
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \   000000BC   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   000000C0   0xF8C8 0x0010      STR      R0,[R8, #+16]
    946                Size--;
   \   000000C4   0x1E76             SUBS     R6,R6,#+1
    947          
    948                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6941             LDR      R1,[R0, #+20]
   \   000000CA   0x0749             LSLS     R1,R1,#+29
   \   000000CC   0xD506             BPL.N    ??HAL_I2C_Slave_Transmit_5
   \   000000CE   0xB2B6             UXTH     R6,R6
   \   000000D0   0x2E00             CMP      R6,#+0
   \   000000D2   0xD003             BEQ.N    ??HAL_I2C_Slave_Transmit_5
    949                {
    950                  /* Write data to DR */
    951                  hi2c->Instance->DR = (*pData++);
   \   000000D4   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   000000D8   0x6101             STR      R1,[R0, #+16]
    952                  Size--;
   \   000000DA   0x1E76             SUBS     R6,R6,#+1
    953                }
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \   000000DC   0xB2B6             UXTH     R6,R6
   \   000000DE   0x2E00             CMP      R6,#+0
   \   000000E0   0xD014             BEQ.N    ??HAL_I2C_Slave_Transmit_8
   \   000000E2   0xF8D4 0x8000      LDR      R8,[R4, #+0]
   \   000000E6   0x4639             MOV      R1,R7
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD0E4             BEQ.N    ??HAL_I2C_Slave_Transmit_7
   \   000000F2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000F6   0xF420 0x6080      BIC      R0,R0,#0x400
   \   000000FA   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000000FE   0x6BA0             LDR      R0,[R4, #+56]
   \   00000100   0x2804             CMP      R0,#+4
   \   00000102   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_9
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xE020             B.N      ??HAL_I2C_Slave_Transmit_3
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \   00000108   0x2003             MOVS     R0,#+3
   \   0000010A   0xE01E             B.N      ??HAL_I2C_Slave_Transmit_3
    954              }
    955          
    956              /* Wait until AF flag is set */
    957              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \   0000010C   0x463B             MOV      R3,R7
   \   0000010E   0x2200             MOVS     R2,#+0
   \   00000110   0xF44F 0x3182      MOV      R1,#+66560
   \   00000114   0x4620             MOV      R0,R4
   \   00000116   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_10
    958              {
    959                return HAL_TIMEOUT;
   \   0000011E   0x2003             MOVS     R0,#+3
   \   00000120   0xE013             B.N      ??HAL_I2C_Slave_Transmit_3
    960              }
    961          
    962              /* Clear AF flag */
    963              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6941             LDR      R1,[R0, #+20]
   \   00000126   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000012A   0x6141             STR      R1,[R0, #+20]
    964          
    965              /* Disable Address Acknowledge */
    966              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0x6801             LDR      R1,[R0, #+0]
   \   00000130   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000134   0x6001             STR      R1,[R0, #+0]
    967          
    968              hi2c->State = HAL_I2C_STATE_READY;
   \   00000136   0x2020             MOVS     R0,#+32
   \   00000138   0xF884 0x0035      STRB     R0,[R4, #+53]
    969              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0xF884 0x0036      STRB     R0,[R4, #+54]
    970          
    971              /* Process Unlocked */
    972              __HAL_UNLOCK(hi2c);
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
    973          
    974              return HAL_OK;
   \   00000146   0xE000             B.N      ??HAL_I2C_Slave_Transmit_3
    975            }
    976            else
    977            {
    978              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \   00000148   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \   0000014A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    979            }
    980          }
    981          
    982          /**
    983            * @brief  Receive in slave mode an amount of data in blocking mode 
    984            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    985            *                the configuration information for the specified I2C.
    986            * @param  pData Pointer to data buffer
    987            * @param  Size Amount of data to be sent
    988            * @param  Timeout Timeout duration
    989            * @retval HAL status
    990            */

   \                                 In section .text, align 2, keep-with-next
    991          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    992          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    993            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xF040 0x808B      BNE.W    ??HAL_I2C_Slave_Receive_0
    994            {
    995              if((pData == NULL) || (Size == 0))
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_1
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_2
    996              {
    997                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE085             B.N      ??HAL_I2C_Slave_Receive_3
    998              }
    999          
   1000              /* Wait until BUSY flag is reset */
   1001              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \   00000024   0xF242 0x7310      MOVW     R3,#+10000
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD17A             BNE.N    ??HAL_I2C_Slave_Receive_0
   1002              {
   1003                return HAL_BUSY;
   1004              }
   1005          
   1006              /* Process Locked */
   1007              __HAL_LOCK(hi2c);
   \   00000038   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD076             BEQ.N    ??HAL_I2C_Slave_Receive_0
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
   1008          
   1009              /* Disable Pos */
   1010              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1011          
   1012              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000050   0x2022             MOVS     R0,#+34
   \   00000052   0xF884 0x0035      STRB     R0,[R4, #+53]
   1013              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0xF884 0x0036      STRB     R0,[R4, #+54]
   1014              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x63A0             STR      R0,[R4, #+56]
   1015          
   1016              /* Enable Address Acknowledge */
   1017              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1018          
   1019              /* Wait until ADDR flag is set */
   1020              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)
   \   0000006A   0x463B             MOV      R3,R7
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x10002
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_4
   1021              {
   1022                return HAL_TIMEOUT;
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0xE057             B.N      ??HAL_I2C_Slave_Receive_3
   1023              }
   1024          
   1025              /* Clear ADDR flag */
   1026              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6941             LDR      R1,[R0, #+20]
   \   00000084   0x9100             STR      R1,[SP, #+0]
   \   00000086   0x6980             LDR      R0,[R0, #+24]
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0xE00F             B.N      ??HAL_I2C_Slave_Receive_5
   1027          
   1028              while(Size > 0)
   1029              {
   1030                /* Wait until RXNE flag is set */
   1031                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   1032                {
   1033                  /* Disable Address Acknowledge */
   1034                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   1035                  if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   1036                  {
   1037                    return HAL_TIMEOUT;
   1038                  }
   1039                  else
   1040                  {
   1041                    return HAL_ERROR;
   1042                  }
   1043                }
   1044          
   1045                /* Read data from DR */
   1046                (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \   0000008E   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000092   0xF805 0x0B01      STRB     R0,[R5], #+1
   1047                Size--;
   \   00000096   0x1E76             SUBS     R6,R6,#+1
   1048          
   1049                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6941             LDR      R1,[R0, #+20]
   \   0000009C   0x0749             LSLS     R1,R1,#+29
   \   0000009E   0xD506             BPL.N    ??HAL_I2C_Slave_Receive_5
   \   000000A0   0xB2B6             UXTH     R6,R6
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xD003             BEQ.N    ??HAL_I2C_Slave_Receive_5
   1050                {
   1051                  /* Read data from DR */
   1052                  (*pData++) = hi2c->Instance->DR;
   \   000000A6   0x6900             LDR      R0,[R0, #+16]
   \   000000A8   0xF805 0x0B01      STRB     R0,[R5], #+1
   1053                  Size--;
   \   000000AC   0x1E76             SUBS     R6,R6,#+1
   1054                }
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \   000000AE   0xB2B6             UXTH     R6,R6
   \   000000B0   0x2E00             CMP      R6,#+0
   \   000000B2   0xD014             BEQ.N    ??HAL_I2C_Slave_Receive_7
   \   000000B4   0xF8D4 0x8000      LDR      R8,[R4, #+0]
   \   000000B8   0x4639             MOV      R1,R7
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD0E4             BEQ.N    ??HAL_I2C_Slave_Receive_6
   \   000000C4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C8   0xF420 0x6080      BIC      R0,R0,#0x400
   \   000000CC   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000000D0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D2   0x2820             CMP      R0,#+32
   \   000000D4   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_8
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0xE02A             B.N      ??HAL_I2C_Slave_Receive_3
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0xE028             B.N      ??HAL_I2C_Slave_Receive_3
   1055              }
   1056          
   1057              /* Wait until STOP flag is set */
   1058              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \   000000DE   0x6825             LDR      R5,[R4, #+0]
   \   000000E0   0x2123             MOVS     R1,#+35
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD00A             BEQ.N    ??HAL_I2C_Slave_Receive_9
   1059              {
   1060                /* Disable Address Acknowledge */
   1061                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0xF420 0x6080      BIC      R0,R0,#0x400
   \   000000F2   0x6028             STR      R0,[R5, #+0]
   1062          
   1063                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F6   0x2804             CMP      R0,#+4
   \   000000F8   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_10
   1064                {
   1065                  return HAL_ERROR;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0xE018             B.N      ??HAL_I2C_Slave_Receive_3
   1066                }
   1067                else
   1068                {
   1069                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0xE016             B.N      ??HAL_I2C_Slave_Receive_3
   1070                }
   1071              }
   1072          
   1073              /* Clear STOP flag */
   1074              __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \   00000102   0x6968             LDR      R0,[R5, #+20]
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \   00000106   0x6828             LDR      R0,[R5, #+0]
   \   00000108   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000010C   0x6028             STR      R0,[R5, #+0]
   \   0000010E   0x9000             STR      R0,[SP, #+0]
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   1075          
   1076              /* Disable Address Acknowledge */
   1077              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6801             LDR      R1,[R0, #+0]
   \   00000116   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000011A   0x6001             STR      R1,[R0, #+0]
   1078          
   1079              hi2c->State = HAL_I2C_STATE_READY;
   \   0000011C   0x2020             MOVS     R0,#+32
   \   0000011E   0xF884 0x0035      STRB     R0,[R4, #+53]
   1080              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x0036      STRB     R0,[R4, #+54]
   1081          
   1082              /* Process Unlocked */
   1083              __HAL_UNLOCK(hi2c);
   \   00000128   0xF884 0x0034      STRB     R0,[R4, #+52]
   1084          
   1085              return HAL_OK;
   \   0000012C   0xE000             B.N      ??HAL_I2C_Slave_Receive_3
   1086            }
   1087            else
   1088            {
   1089              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \   0000012E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \   00000130   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1090            }
   1091          }
   1092          
   1093          /**
   1094            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1095            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1096            *                the configuration information for the specified I2C.
   1097            * @param  DevAddress Target device address
   1098            * @param  pData Pointer to data buffer
   1099            * @param  Size Amount of data to be sent
   1100            * @retval HAL status
   1101            */

   \                                 In section .text, align 2, keep-with-next
   1102          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1103          {
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1104            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD14A             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1105            {
   1106              if((pData == NULL) || (Size == 0))
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_IT_1
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_IT_2
   1107              {
   1108                return  HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
   1109              }
   1110          
   1111              /* Wait until BUSY flag is reset */
   1112              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \   0000001E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD13A             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1113              {
   1114                return HAL_BUSY;
   1115              }
   1116          
   1117              /* Process Locked */
   1118              __HAL_LOCK(hi2c);
   \   00000032   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD036             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0034      STRB     R0,[R4, #+52]
   1119          
   1120              /* Disable Pos */
   1121              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1122          
   1123              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   0000004A   0x2021             MOVS     R0,#+33
   \   0000004C   0xF884 0x0035      STRB     R0,[R4, #+53]
   1124              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0xF884 0x0036      STRB     R0,[R4, #+54]
   1125              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   1126          
   1127              hi2c->pBuffPtr = pData;
   \   0000005A   0x6266             STR      R6,[R4, #+36]
   1128              hi2c->XferSize = Size;
   \   0000005C   0x8527             STRH     R7,[R4, #+40]
   1129              hi2c->XferCount = Size;
   \   0000005E   0x8567             STRH     R7,[R4, #+42]
   1130          
   1131              /* Send Slave Address */
   1132              if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000060   0x2223             MOVS     R2,#+35
   \   00000062   0x4629             MOV      R1,R5
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_IT_3
   1133              {
   1134                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_IT_4
   1135                {
   1136                  /* Process Unlocked */
   1137                  __HAL_UNLOCK(hi2c);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF884 0x0034      STRB     R0,[R4, #+52]
   1138                  return HAL_ERROR;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xBDF2             POP      {R1,R4-R7,PC}
   1139                }
   1140                else
   1141                {
   1142                  /* Process Unlocked */
   1143                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_IT_4: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF884 0x0034      STRB     R0,[R4, #+52]
   1144                  return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}
   1145                }
   1146              }
   1147          
   1148              /* Clear ADDR flag */
   1149              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6941             LDR      R1,[R0, #+20]
   \   0000008C   0x9100             STR      R1,[SP, #+0]
   \   0000008E   0x6980             LDR      R0,[R0, #+24]
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   1150          
   1151              /* Process Unlocked */
   1152              __HAL_UNLOCK(hi2c);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF884 0x0034      STRB     R0,[R4, #+52]
   1153          
   1154              /* Note : The I2C interrupts must be enabled after unlocking current process
   1155                        to avoid the risk of I2C interrupt handle execution before current
   1156                        process unlock */
   1157          
   1158              /* Enable EVT, BUF and ERR interrupt */
   1159              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000A2   0x6041             STR      R1,[R0, #+4]
   1160          
   1161              return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}
   1162            }
   1163            else
   1164            {
   1165              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1166            }
   1167          }
   1168          
   1169          /**
   1170            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1171            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1172            *                the configuration information for the specified I2C.
   1173            * @param  DevAddress Target device address
   1174            * @param  pData Pointer to data buffer
   1175            * @param  Size Amount of data to be sent
   1176            * @retval HAL status
   1177            */

   \                                 In section .text, align 2, keep-with-next
   1178          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1179          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1180            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD172             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1181            {
   1182              if((pData == NULL) || (Size == 0))
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_IT_1
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD101             BNE.N    ??HAL_I2C_Master_Receive_IT_2
   1183              {
   1184                return  HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
   1185              }
   1186          
   1187              /* Wait until BUSY flag is reset */
   1188              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \   0000001E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD162             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1189              {
   1190                return HAL_BUSY;
   1191              }
   1192          
   1193              /* Process Locked */
   1194              __HAL_LOCK(hi2c);
   \   00000032   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD05E             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0034      STRB     R0,[R4, #+52]
   1195          
   1196              /* Disable Pos */
   1197              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1198          
   1199              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   0000004A   0x2022             MOVS     R0,#+34
   \   0000004C   0xF884 0x0035      STRB     R0,[R4, #+53]
   1200              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0xF884 0x0036      STRB     R0,[R4, #+54]
   1201              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   1202          
   1203              hi2c->pBuffPtr = pData;
   \   0000005A   0x6266             STR      R6,[R4, #+36]
   1204              hi2c->XferSize = Size;
   \   0000005C   0x8527             STRH     R7,[R4, #+40]
   1205              hi2c->XferCount = Size;
   \   0000005E   0x8567             STRH     R7,[R4, #+42]
   1206          
   1207              /* Send Slave Address */
   1208              if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000060   0x2223             MOVS     R2,#+35
   \   00000062   0x4629             MOV      R1,R5
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       I2C_MasterRequestRead
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_IT_3
   1209              {
   1210                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD104             BNE.N    ??HAL_I2C_Master_Receive_IT_4
   1211                {
   1212                  /* Process Unlocked */
   1213                  __HAL_UNLOCK(hi2c);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF884 0x0034      STRB     R0,[R4, #+52]
   1214                  return HAL_ERROR;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xBDF2             POP      {R1,R4-R7,PC}
   1215                }
   1216                else
   1217                {
   1218                  /* Process Unlocked */
   1219                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_IT_4: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF884 0x0034      STRB     R0,[R4, #+52]
   1220                  return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}
   1221                }
   1222              }
   1223          
   1224              if(hi2c->XferCount == 1)
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x8D61             LDRH     R1,[R4, #+42]
   \   0000008C   0x2901             CMP      R1,#+1
   \   0000008E   0xD10E             BNE.N    ??HAL_I2C_Master_Receive_IT_5
   1225              {
   1226                /* Disable Acknowledge */
   1227                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000096   0x6001             STR      R1,[R0, #+0]
   1228          
   1229                /* Clear ADDR flag */
   1230                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6941             LDR      R1,[R0, #+20]
   \   0000009C   0x9100             STR      R1,[SP, #+0]
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x9100             STR      R1,[SP, #+0]
   \   000000A2   0x9900             LDR      R1,[SP, #+0]
   1231          
   1232                /* Generate Stop */
   1233                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000AA   0x6001             STR      R1,[R0, #+0]
   \   000000AC   0xE01A             B.N      ??HAL_I2C_Master_Receive_IT_6
   1234              }
   1235              else if(hi2c->XferCount == 2)
   \                     ??HAL_I2C_Master_Receive_IT_5: (+1)
   \   000000AE   0x8D61             LDRH     R1,[R4, #+42]
   \   000000B0   0x2902             CMP      R1,#+2
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0xD10D             BNE.N    ??HAL_I2C_Master_Receive_IT_7
   1236              {
   1237                /* Enable Pos */
   1238                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000B6   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000BA   0x6001             STR      R1,[R0, #+0]
   1239          
   1240                /* Clear ADDR flag */
   1241                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6941             LDR      R1,[R0, #+20]
   \   000000C0   0x9100             STR      R1,[SP, #+0]
   \   000000C2   0x6981             LDR      R1,[R0, #+24]
   \   000000C4   0x9100             STR      R1,[SP, #+0]
   \   000000C6   0x9900             LDR      R1,[SP, #+0]
   1242          
   1243                /* Disable Acknowledge */
   1244                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000C8   0x6801             LDR      R1,[R0, #+0]
   \   000000CA   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000CE   0x6001             STR      R1,[R0, #+0]
   \   000000D0   0xE008             B.N      ??HAL_I2C_Master_Receive_IT_6
   1245              }
   1246              else
   1247              {
   1248                /* Enable Acknowledge */
   1249                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_IT_7: (+1)
   \   000000D2   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000D6   0x6001             STR      R1,[R0, #+0]
   1250          
   1251                /* Clear ADDR flag */
   1252                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6941             LDR      R1,[R0, #+20]
   \   000000DC   0x9100             STR      R1,[SP, #+0]
   \   000000DE   0x6980             LDR      R0,[R0, #+24]
   \   000000E0   0x9000             STR      R0,[SP, #+0]
   \   000000E2   0x9800             LDR      R0,[SP, #+0]
   1253              }
   1254          
   1255              /* Process Unlocked */
   1256              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_IT_6: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xF884 0x0034      STRB     R0,[R4, #+52]
   1257          
   1258              /* Note : The I2C interrupts must be enabled after unlocking current process
   1259                        to avoid the risk of I2C interrupt handle execution before current
   1260                        process unlock */
   1261          
   1262              /* Enable EVT, BUF and ERR interrupt */
   1263              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6841             LDR      R1,[R0, #+4]
   \   000000EE   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000F2   0x6041             STR      R1,[R0, #+4]
   1264          
   1265              return HAL_OK;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xBDF2             POP      {R1,R4-R7,PC}
   1266            }
   1267            else
   1268            {
   1269              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \   000000F8   0x2002             MOVS     R0,#+2
   \   000000FA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1270            }
   1271          }
   1272          
   1273          /**
   1274            * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt 
   1275            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1276            *                the configuration information for the specified I2C.
   1277            * @param  pData Pointer to data buffer
   1278            * @param  Size Amount of data to be sent
   1279            * @retval HAL status
   1280            */

   \                                 In section .text, align 2, keep-with-next
   1281          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1282          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1283            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xD139             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1284            {
   1285              if((pData == NULL) || (Size == 0))
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_1
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_2
   1286              {
   1287                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD70             POP      {R4-R6,PC}
   1288              }
   1289          
   1290              /* Wait until BUSY flag is reset */
   1291              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_IT_2: (+1)
   \   0000001C   0xF242 0x7310      MOVW     R3,#+10000
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_3
   1292              {
   1293                return HAL_BUSY;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xBD70             POP      {R4-R6,PC}
   1294              }
   1295          
   1296              /* Process Locked */
   1297              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_IT_3: (+1)
   \   00000034   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_4
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_I2C_Slave_Transmit_IT_4: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
   1298          
   1299              /* Disable Pos */
   1300              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1301          
   1302              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000050   0x2021             MOVS     R0,#+33
   \   00000052   0xF884 0x0035      STRB     R0,[R4, #+53]
   1303              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0xF884 0x0036      STRB     R0,[R4, #+54]
   1304              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x63A0             STR      R0,[R4, #+56]
   1305          
   1306              hi2c->pBuffPtr = pData;
   \   00000060   0x6265             STR      R5,[R4, #+36]
   1307              hi2c->XferSize = Size;
   \   00000062   0x8526             STRH     R6,[R4, #+40]
   1308              hi2c->XferCount = Size;
   \   00000064   0x8566             STRH     R6,[R4, #+42]
   1309          
   1310              /* Enable Address Acknowledge */
   1311              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   1312          
   1313              /* Process Unlocked */
   1314              __HAL_UNLOCK(hi2c);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x0034      STRB     R0,[R4, #+52]
   1315          
   1316              /* Note : The I2C interrupts must be enabled after unlocking current process
   1317                        to avoid the risk of I2C interrupt handle execution before current
   1318                        process unlock */
   1319          
   1320              /* Enable EVT, BUF and ERR interrupt */
   1321              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6841             LDR      R1,[R0, #+4]
   \   0000007A   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   0000007E   0x6041             STR      R1,[R0, #+4]
   1322          
   1323              return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD70             POP      {R4-R6,PC}
   1324            }
   1325            else
   1326            {
   1327              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
   1328            }
   1329          }
   1330          
   1331          /**
   1332            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt 
   1333            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1334            *                the configuration information for the specified I2C.
   1335            * @param  pData Pointer to data buffer
   1336            * @param  Size Amount of data to be sent
   1337            * @retval HAL status
   1338            */

   \                                 In section .text, align 2, keep-with-next
   1339          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1340          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1341            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xD139             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1342            {
   1343              if((pData == NULL) || (Size == 0))
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_IT_1
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_2
   1344              {
   1345                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD70             POP      {R4-R6,PC}
   1346              }
   1347          
   1348              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_IT_2: (+1)
   \   0000001C   0xF242 0x7310      MOVW     R3,#+10000
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_IT_3
   1349              {
   1350                return HAL_BUSY;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xBD70             POP      {R4-R6,PC}
   1351              }
   1352          
   1353              /* Process Locked */
   1354              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_IT_3: (+1)
   \   00000034   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_4
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_I2C_Slave_Receive_IT_4: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
   1355          
   1356              /* Disable Pos */
   1357              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1358          
   1359              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000050   0x2022             MOVS     R0,#+34
   \   00000052   0xF884 0x0035      STRB     R0,[R4, #+53]
   1360              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0xF884 0x0036      STRB     R0,[R4, #+54]
   1361              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x63A0             STR      R0,[R4, #+56]
   1362          
   1363              hi2c->pBuffPtr = pData;
   \   00000060   0x6265             STR      R5,[R4, #+36]
   1364              hi2c->XferSize = Size;
   \   00000062   0x8526             STRH     R6,[R4, #+40]
   1365              hi2c->XferCount = Size;
   \   00000064   0x8566             STRH     R6,[R4, #+42]
   1366          
   1367              /* Enable Address Acknowledge */
   1368              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   1369          
   1370              /* Process Unlocked */
   1371              __HAL_UNLOCK(hi2c);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x0034      STRB     R0,[R4, #+52]
   1372          
   1373              /* Note : The I2C interrupts must be enabled after unlocking current process
   1374                        to avoid the risk of I2C interrupt handle execution before current
   1375                        process unlock */
   1376          
   1377              /* Enable EVT, BUF and ERR interrupt */
   1378              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6841             LDR      R1,[R0, #+4]
   \   0000007A   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   0000007E   0x6041             STR      R1,[R0, #+4]
   1379          
   1380              return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD70             POP      {R4-R6,PC}
   1381            }
   1382            else
   1383            {
   1384              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
   1385            }
   1386          }
   1387          
   1388           
   1389          /**
   1390            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1391            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1392            *                the configuration information for the specified I2C.
   1393            * @param  DevAddress Target device address
   1394            * @param  pData Pointer to data buffer
   1395            * @param  Size Amount of data to be sent
   1396            * @retval HAL status
   1397            */

   \                                 In section .text, align 2, keep-with-next
   1398          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1399          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1400            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD159             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1401            {
   1402              if((pData == NULL) || (Size == 0))
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_1
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_DMA_2
   1403              {
   1404                return  HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
   1405              }
   1406          
   1407              /* Wait until BUSY flag is reset */
   1408              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \   0000001E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x100002
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD149             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1409              {
   1410                return HAL_BUSY;
   1411              }
   1412          
   1413              /* Process Locked */
   1414              __HAL_LOCK(hi2c);
   \   00000032   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD045             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0034      STRB     R0,[R4, #+52]
   1415          
   1416              /* Disable Pos */
   1417              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1418          
   1419              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   0000004A   0x2021             MOVS     R0,#+33
   \   0000004C   0xF884 0x0035      STRB     R0,[R4, #+53]
   1420              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0xF884 0x0036      STRB     R0,[R4, #+54]
   1421              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x63A0             STR      R0,[R4, #+56]
   1422          
   1423              hi2c->pBuffPtr = pData;
   \   0000005A   0x6266             STR      R6,[R4, #+36]
   1424              hi2c->XferSize = Size;
   \   0000005C   0x8527             STRH     R7,[R4, #+40]
   1425              hi2c->XferCount = Size;
   \   0000005E   0x8567             STRH     R7,[R4, #+42]
   1426          
   1427              /* Set the I2C DMA transfert complete callback */
   1428              hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000064   0x6AE1             LDR      R1,[R4, #+44]
   \   00000066   0x6288             STR      R0,[R1, #+40]
   1429          
   1430              /* Set the DMA error callback */
   1431              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000006C   0x6AE1             LDR      R1,[R4, #+44]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   1432          
   1433              /* Enable the DMA channel */
   1434              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
   \   00000070   0x463B             MOV      R3,R7
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xF100 0x0210      ADD      R2,R0,#+16
   \   00000078   0x4631             MOV      R1,R6
   \   0000007A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1435          
   1436              /* Send Slave Address */
   1437              if(I2C_MasterRequestWrite(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000080   0x2223             MOVS     R2,#+35
   \   00000082   0x4629             MOV      R1,R5
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_3
   1438              {
   1439                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0x2804             CMP      R0,#+4
   \   00000092   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_DMA_4
   1440                {
   1441                  /* Process Unlocked */
   1442                  __HAL_UNLOCK(hi2c);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF884 0x0034      STRB     R0,[R4, #+52]
   1443                  return HAL_ERROR;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}
   1444                }
   1445                else
   1446                {
   1447                  /* Process Unlocked */
   1448                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1449                  return HAL_TIMEOUT;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}
   1450                }
   1451              }
   1452          
   1453              /* Enable DMA Request */
   1454              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6841             LDR      R1,[R0, #+4]
   \   000000AC   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B0   0x6041             STR      R1,[R0, #+4]
   1455          
   1456              /* Clear ADDR flag */
   1457              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6941             LDR      R1,[R0, #+20]
   \   000000B6   0x9100             STR      R1,[SP, #+0]
   \   000000B8   0x6980             LDR      R0,[R0, #+24]
   \   000000BA   0x9000             STR      R0,[SP, #+0]
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   1458          
   1459              /* Process Unlocked */
   1460              __HAL_UNLOCK(hi2c);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1461          
   1462              return HAL_OK;
   \   000000C4   0xBDF2             POP      {R1,R4-R7,PC}
   1463            }
   1464            else
   1465            {
   1466              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \   000000C6   0x2002             MOVS     R0,#+2
   \   000000C8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1467            }
   1468          }
   1469          
   1470          /**
   1471            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
   1472            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1473            *                the configuration information for the specified I2C.
   1474            * @param  DevAddress Target device address
   1475            * @param  pData Pointer to data buffer
   1476            * @param  Size Amount of data to be sent
   1477            * @retval HAL status
   1478            */

   \                                 In section .text, align 2, keep-with-next
   1479          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1480          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461D             MOV      R5,R3
   1481            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD164             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   1482            {
   1483              if((pData == NULL) || (Size == 0))
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_DMA_1
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD101             BNE.N    ??HAL_I2C_Master_Receive_DMA_2
   1484              {
   1485                return  HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
   1486              }
   1487          
   1488              /* Wait until BUSY flag is reset */
   1489              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \   0000001E   0xF242 0x7310      MOVW     R3,#+10000
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable13_1  ;; 0x100002
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD155             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   1490              {
   1491                return HAL_BUSY;
   1492              }
   1493          
   1494              /* Process Locked */
   1495              __HAL_LOCK(hi2c);
   \   00000030   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD051             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1496          
   1497              /* Disable Pos */
   1498              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1499          
   1500              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000048   0x2022             MOVS     R0,#+34
   \   0000004A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1501              hi2c->Mode = HAL_I2C_MODE_MASTER;
   \   0000004E   0x2010             MOVS     R0,#+16
   \   00000050   0xF884 0x0036      STRB     R0,[R4, #+54]
   1502              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63A0             STR      R0,[R4, #+56]
   1503          
   1504              hi2c->pBuffPtr = pData;
   \   00000058   0x6267             STR      R7,[R4, #+36]
   1505              hi2c->XferSize = Size;
   \   0000005A   0x8525             STRH     R5,[R4, #+40]
   1506              hi2c->XferCount = Size;
   \   0000005C   0x8565             STRH     R5,[R4, #+42]
   1507          
   1508              /* Set the I2C DMA transfert complete callback */
   1509              hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000062   0x6B21             LDR      R1,[R4, #+48]
   \   00000064   0x6288             STR      R0,[R1, #+40]
   1510          
   1511              /* Set the DMA error callback */
   1512              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000006A   0x6B21             LDR      R1,[R4, #+48]
   \   0000006C   0x6308             STR      R0,[R1, #+48]
   1513          
   1514              /* Enable the DMA channel */
   1515              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
   \   0000006E   0x462B             MOV      R3,R5
   \   00000070   0x463A             MOV      R2,R7
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xF100 0x0110      ADD      R1,R0,#+16
   \   00000078   0x6B20             LDR      R0,[R4, #+48]
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1516          
   1517              /* Send Slave Address */
   1518              if(I2C_MasterRequestRead(hi2c, DevAddress, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000007E   0x2223             MOVS     R2,#+35
   \   00000080   0x4631             MOV      R1,R6
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       I2C_MasterRequestRead
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_DMA_3
   1519              {
   1520                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000008C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008E   0x2804             CMP      R0,#+4
   \   00000090   0xD104             BNE.N    ??HAL_I2C_Master_Receive_DMA_4
   1521                {
   1522                  /* Process Unlocked */
   1523                  __HAL_UNLOCK(hi2c);
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF884 0x0034      STRB     R0,[R4, #+52]
   1524                  return HAL_ERROR;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}
   1525                }
   1526                else
   1527                {
   1528                  /* Process Unlocked */
   1529                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1530                  return HAL_TIMEOUT;
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0xBDF2             POP      {R1,R4-R7,PC}
   1531                }
   1532              }
   1533          
   1534              if(Size == 1)
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x2D01             CMP      R5,#+1
   \   000000AA   0xD104             BNE.N    ??HAL_I2C_Master_Receive_DMA_5
   1535              {
   1536                /* Disable Acknowledge */
   1537                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000B2   0x6001             STR      R1,[R0, #+0]
   \   000000B4   0xE003             B.N      ??HAL_I2C_Master_Receive_DMA_6
   1538              }
   1539              else
   1540              {
   1541                /* Enable Last DMA bit */
   1542                SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \   000000B6   0x6841             LDR      R1,[R0, #+4]
   \   000000B8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000BC   0x6041             STR      R1,[R0, #+4]
   1543              }
   1544          
   1545              /* Enable DMA Request */
   1546              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Master_Receive_DMA_6: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6841             LDR      R1,[R0, #+4]
   \   000000C2   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000C6   0x6041             STR      R1,[R0, #+4]
   1547          
   1548              /* Clear ADDR flag */
   1549              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6941             LDR      R1,[R0, #+20]
   \   000000CC   0x9100             STR      R1,[SP, #+0]
   \   000000CE   0x6980             LDR      R0,[R0, #+24]
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   1550          
   1551              /* Process Unlocked */
   1552              __HAL_UNLOCK(hi2c);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF884 0x0034      STRB     R0,[R4, #+52]
   1553          
   1554              return HAL_OK;
   \   000000DA   0xBDF2             POP      {R1,R4-R7,PC}
   1555            }
   1556            else
   1557            {
   1558              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \   000000DC   0x2002             MOVS     R0,#+2
   \   000000DE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1559            }
   1560          }
   1561          
   1562          /**
   1563            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
   1564            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1565            *                the configuration information for the specified I2C.
   1566            * @param  pData Pointer to data buffer
   1567            * @param  Size Amount of data to be sent
   1568            * @retval HAL status
   1569            */

   \                                 In section .text, align 2, keep-with-next
   1570          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1571          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   1572            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xD168             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   1573            {
   1574              if((pData == NULL) || (Size == 0))
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_2
   1575              {
   1576                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
   1577              }
   1578          
   1579              /* Wait until BUSY flag is reset */
   1580              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \   0000001C   0xF242 0x7510      MOVW     R5,#+10000
   \   00000020   0x462B             MOV      R3,R5
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable13_1  ;; 0x100002
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD158             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   1581              {
   1582                return HAL_BUSY;
   1583              }
   1584          
   1585              /* Process Locked */
   1586              __HAL_LOCK(hi2c);
   \   00000030   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD054             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1587          
   1588              /* Disable Pos */
   1589              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1590          
   1591              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000048   0x2021             MOVS     R0,#+33
   \   0000004A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1592              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0xF884 0x0036      STRB     R0,[R4, #+54]
   1593              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63A0             STR      R0,[R4, #+56]
   1594          
   1595              hi2c->pBuffPtr = pData;
   \   00000058   0x6266             STR      R6,[R4, #+36]
   1596              hi2c->XferSize = Size;
   \   0000005A   0x8527             STRH     R7,[R4, #+40]
   1597              hi2c->XferCount = Size;
   \   0000005C   0x8567             STRH     R7,[R4, #+42]
   1598          
   1599              /* Set the I2C DMA transfert complete callback */
   1600              hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000062   0x6AE1             LDR      R1,[R4, #+44]
   \   00000064   0x6288             STR      R0,[R1, #+40]
   1601          
   1602              /* Set the DMA error callback */
   1603              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000006A   0x6AE1             LDR      R1,[R4, #+44]
   \   0000006C   0x6308             STR      R0,[R1, #+48]
   1604          
   1605              /* Enable the DMA channel */
   1606              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
   \   0000006E   0x463B             MOV      R3,R7
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0xF100 0x0210      ADD      R2,R0,#+16
   \   00000076   0x4631             MOV      R1,R6
   \   00000078   0x6AE0             LDR      R0,[R4, #+44]
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1607          
   1608              /* Enable DMA Request */
   1609              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6841             LDR      R1,[R0, #+4]
   \   00000082   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000086   0x6041             STR      R1,[R0, #+4]
   1610          
   1611              /* Enable Address Acknowledge */
   1612              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000090   0x6001             STR      R1,[R0, #+0]
   1613          
   1614              /* Wait until ADDR flag is set */
   1615              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
   \   00000092   0x.... 0x....      LDR.W    R6,??DataTable16  ;; 0x10002
   \   00000096   0x462B             MOV      R3,R5
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x4631             MOV      R1,R6
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD111             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_3
   1616              {
   1617                return HAL_TIMEOUT;
   1618              }
   1619          
   1620              /* If 7bit addressing mode is selected */
   1621              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6921             LDR      R1,[R4, #+16]
   \   000000AA   0xF5B1 0x4F80      CMP      R1,#+16384
   \   000000AE   0x6941             LDR      R1,[R0, #+20]
   \   000000B0   0x9100             STR      R1,[SP, #+0]
   \   000000B2   0x6980             LDR      R0,[R0, #+24]
   \   000000B4   0x9000             STR      R0,[SP, #+0]
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0xD00F             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_4
   1622              {
   1623                /* Clear ADDR flag */
   1624                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   1625              }
   1626              else
   1627              {
   1628                /* Clear ADDR flag */
   1629                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   1630          
   1631                /* Wait until ADDR flag is set */
   1632                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
   \   000000BA   0x462B             MOV      R3,R5
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x4631             MOV      R1,R6
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_5
   1633                {
   1634                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0xBDF2             POP      {R1,R4-R7,PC}
   1635                }
   1636          
   1637                /* Clear ADDR flag */
   1638                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6941             LDR      R1,[R0, #+20]
   \   000000D2   0x9100             STR      R1,[SP, #+0]
   \   000000D4   0x6980             LDR      R0,[R0, #+24]
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   1639              }
   1640          
   1641              /* Process Unlocked */
   1642              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF884 0x0034      STRB     R0,[R4, #+52]
   1643          
   1644              return HAL_OK;
   \   000000E0   0xBDF2             POP      {R1,R4-R7,PC}
   1645            }
   1646            else
   1647            {
   1648              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \   000000E4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1649            }
   1650          }
   1651          
   1652          /**
   1653            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
   1654            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1655            *                the configuration information for the specified I2C.
   1656            * @param  pData Pointer to data buffer
   1657            * @param  Size Amount of data to be sent
   1658            * @retval HAL status
   1659            */

   \                                 In section .text, align 2, keep-with-next
   1660          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1661          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   1662            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xD155             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   1663            {
   1664              if((pData == NULL) || (Size == 0))
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_DMA_2
   1665              {
   1666                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
   1667              }
   1668          
   1669              /* Wait until BUSY flag is reset */
   1670              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \   0000001C   0xF242 0x7510      MOVW     R5,#+10000
   \   00000020   0x462B             MOV      R3,R5
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable13_1  ;; 0x100002
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD145             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   1671              {
   1672                return HAL_BUSY;
   1673              }
   1674          
   1675              /* Process Locked */
   1676              __HAL_LOCK(hi2c);
   \   00000030   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD041             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1677          
   1678              /* Disable Pos */
   1679              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1680          
   1681              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000048   0x2022             MOVS     R0,#+34
   \   0000004A   0xF884 0x0035      STRB     R0,[R4, #+53]
   1682              hi2c->Mode = HAL_I2C_MODE_SLAVE;
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0xF884 0x0036      STRB     R0,[R4, #+54]
   1683              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63A0             STR      R0,[R4, #+56]
   1684          
   1685              hi2c->pBuffPtr = pData;
   \   00000058   0x6266             STR      R6,[R4, #+36]
   1686              hi2c->XferSize = Size;
   \   0000005A   0x8527             STRH     R7,[R4, #+40]
   1687              hi2c->XferCount = Size;
   \   0000005C   0x8567             STRH     R7,[R4, #+42]
   1688          
   1689              /* Set the I2C DMA transfer complete callback */
   1690              hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable19_4
   \   00000062   0x6B21             LDR      R1,[R4, #+48]
   \   00000064   0x6288             STR      R0,[R1, #+40]
   1691          
   1692              /* Set the DMA error callback */
   1693              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000006A   0x6B21             LDR      R1,[R4, #+48]
   \   0000006C   0x6308             STR      R0,[R1, #+48]
   1694          
   1695              /* Enable the DMA channel */
   1696              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
   \   0000006E   0x463B             MOV      R3,R7
   \   00000070   0x4632             MOV      R2,R6
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xF100 0x0110      ADD      R1,R0,#+16
   \   00000078   0x6B20             LDR      R0,[R4, #+48]
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1697          
   1698              /* Enable DMA Request */
   1699              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6841             LDR      R1,[R0, #+4]
   \   00000082   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000086   0x6041             STR      R1,[R0, #+4]
   1700          
   1701              /* Enable Address Acknowledge */
   1702              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000090   0x6001             STR      R1,[R0, #+0]
   1703          
   1704              /* Wait until ADDR flag is set */
   1705              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR_SLAVE) != HAL_OK)
   \   00000092   0x462B             MOV      R3,R5
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x10002
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_3
   1706              {
   1707                return HAL_TIMEOUT;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}
   1708              }
   1709          
   1710              /* Clear ADDR flag */
   1711              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6941             LDR      R1,[R0, #+20]
   \   000000AC   0x9100             STR      R1,[SP, #+0]
   \   000000AE   0x6980             LDR      R0,[R0, #+24]
   \   000000B0   0x9000             STR      R0,[SP, #+0]
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   1712          
   1713              /* Process Unlocked */
   1714              __HAL_UNLOCK(hi2c);
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF884 0x0034      STRB     R0,[R4, #+52]
   1715          
   1716              return HAL_OK;
   \   000000BA   0xBDF2             POP      {R1,R4-R7,PC}
   1717            }
   1718            else
   1719            {
   1720              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1721            }
   1722          }
   1723          
   1724          /**
   1725            * @brief  Write an amount of data in blocking mode to a specific memory address
   1726            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1727            *                the configuration information for the specified I2C.
   1728            * @param  DevAddress Target device address
   1729            * @param  MemAddress Internal memory address
   1730            * @param  MemAddSize Size of internal memory address
   1731            * @param  pData Pointer to data buffer
   1732            * @param  Size Amount of data to be sent
   1733            * @param  Timeout Timeout duration
   1734            * @retval HAL status
   1735            */

   \                                 In section .text, align 2, keep-with-next
   1736          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1737          {
   \                     HAL_I2C_Mem_Write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   1738            /* Check the parameters */
   1739            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1740          
   1741            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xF040 0x8081      BNE.W    ??HAL_I2C_Mem_Write_0
   \   00000018   0x9E0A             LDR      R6,[SP, #+40]
   1742            {
   1743              if((pData == NULL) || (Size == 0))
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_1
   \   0000001E   0x9C0B             LDR      R4,[SP, #+44]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??HAL_I2C_Mem_Write_2
   1744              {
   1745                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE079             B.N      ??HAL_I2C_Mem_Write_3
   1746              }
   1747          
   1748              /* Wait until BUSY flag is reset */
   1749              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \   00000028   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable13_1  ;; 0x100002
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD16F             BNE.N    ??HAL_I2C_Mem_Write_0
   1750              {
   1751                return HAL_BUSY;
   1752              }
   1753          
   1754              /* Process Locked */
   1755              __HAL_LOCK(hi2c);
   \   0000003A   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD06B             BEQ.N    ??HAL_I2C_Mem_Write_0
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF885 0x0034      STRB     R0,[R5, #+52]
   1756          
   1757              /* Disable Pos */
   1758              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000048   0x6828             LDR      R0,[R5, #+0]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000050   0x6001             STR      R1,[R0, #+0]
   1759          
   1760              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000052   0x2021             MOVS     R0,#+33
   \   00000054   0xF885 0x0035      STRB     R0,[R5, #+53]
   1761              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   00000058   0x2040             MOVS     R0,#+64
   \   0000005A   0xF885 0x0036      STRB     R0,[R5, #+54]
   1762              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x63A8             STR      R0,[R5, #+56]
   \   00000062   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   1763          
   1764              /* Send Slave Address and Memory Address */
   1765              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   00000066   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   0000006A   0x464B             MOV      R3,R9
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x4639             MOV      R1,R7
   \   00000070   0x4628             MOV      R0,R5
   \   00000072   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD01C             BEQ.N    ??HAL_I2C_Mem_Write_4
   1766              {
   1767                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007A   0x6BA8             LDR      R0,[R5, #+56]
   \   0000007C   0x2804             CMP      R0,#+4
   \   0000007E   0xD104             BNE.N    ??HAL_I2C_Mem_Write_5
   1768                {
   1769                  /* Process Unlocked */
   1770                  __HAL_UNLOCK(hi2c);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF885 0x0034      STRB     R0,[R5, #+52]
   1771                  return HAL_ERROR;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xE048             B.N      ??HAL_I2C_Mem_Write_3
   1772                }
   1773                else
   1774                {
   1775                  /* Process Unlocked */
   1776                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF885 0x0034      STRB     R0,[R5, #+52]
   1777                  return HAL_TIMEOUT;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE043             B.N      ??HAL_I2C_Mem_Write_3
   1778                }
   1779              }
   1780          
   1781              while(Size > 0)
   1782              {
   1783                /* Wait until TXE flag is set */
   1784                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   1785                {
   1786                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1787                  {
   1788                    /* Generate Stop */
   1789                    SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   1790                    return HAL_ERROR;
   1791                  }
   1792                  else
   1793                  {
   1794                    return HAL_TIMEOUT;
   1795                  }
   1796                }
   1797          
   1798                /* Write data to DR */
   1799                hi2c->Instance->DR = (*pData++);
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \   00000094   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   00000098   0x6829             LDR      R1,[R5, #+0]
   \   0000009A   0x6108             STR      R0,[R1, #+16]
   1800                Size--;
   \   0000009C   0x1E64             SUBS     R4,R4,#+1
   1801          
   1802                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x6941             LDR      R1,[R0, #+20]
   \   000000A2   0x0749             LSLS     R1,R1,#+29
   \   000000A4   0xD506             BPL.N    ??HAL_I2C_Mem_Write_4
   \   000000A6   0xB2A4             UXTH     R4,R4
   \   000000A8   0x2C00             CMP      R4,#+0
   \   000000AA   0xD003             BEQ.N    ??HAL_I2C_Mem_Write_4
   1803                {
   1804                  /* Write data to DR */
   1805                  hi2c->Instance->DR = (*pData++);
   \   000000AC   0xF816 0x1B01      LDRB     R1,[R6], #+1
   \   000000B0   0x6101             STR      R1,[R0, #+16]
   1806                  Size--;
   \   000000B2   0x1E64             SUBS     R4,R4,#+1
   1807                }
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \   000000B4   0xB2A4             UXTH     R4,R4
   \   000000B6   0x2C00             CMP      R4,#+0
   \   000000B8   0x4651             MOV      R1,R10
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0xD00F             BEQ.N    ??HAL_I2C_Mem_Write_7
   \   000000BE   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD0E6             BEQ.N    ??HAL_I2C_Mem_Write_6
   \   000000C6   0x6BA8             LDR      R0,[R5, #+56]
   \   000000C8   0x2804             CMP      R0,#+4
   \   000000CA   0xD106             BNE.N    ??HAL_I2C_Mem_Write_8
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000D4   0x6001             STR      R1,[R0, #+0]
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xE020             B.N      ??HAL_I2C_Mem_Write_3
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \   000000DA   0x2003             MOVS     R0,#+3
   \   000000DC   0xE01E             B.N      ??HAL_I2C_Mem_Write_3
   1808              }
   1809          
   1810              /* Wait until TXE flag is set */
   1811              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \   000000DE   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD00B             BEQ.N    ??HAL_I2C_Mem_Write_9
   1812              {
   1813                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000E6   0x6BA8             LDR      R0,[R5, #+56]
   \   000000E8   0x2804             CMP      R0,#+4
   \   000000EA   0xD106             BNE.N    ??HAL_I2C_Mem_Write_10
   1814                {
   1815                  /* Generate Stop */
   1816                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000F4   0x6001             STR      R1,[R0, #+0]
   1817                  return HAL_ERROR;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xE010             B.N      ??HAL_I2C_Mem_Write_3
   1818                }
   1819                else
   1820                {
   1821                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_10: (+1)
   \   000000FA   0x2003             MOVS     R0,#+3
   \   000000FC   0xE00E             B.N      ??HAL_I2C_Mem_Write_3
   1822                }
   1823              }
   1824          
   1825              /* Generate Stop */
   1826              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \   000000FE   0x6828             LDR      R0,[R5, #+0]
   \   00000100   0x6801             LDR      R1,[R0, #+0]
   \   00000102   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000106   0x6001             STR      R1,[R0, #+0]
   1827          
   1828              hi2c->State = HAL_I2C_STATE_READY;
   \   00000108   0x2020             MOVS     R0,#+32
   \   0000010A   0xF885 0x0035      STRB     R0,[R5, #+53]
   1829              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF885 0x0036      STRB     R0,[R5, #+54]
   1830          
   1831              /* Process Unlocked */
   1832              __HAL_UNLOCK(hi2c);
   \   00000114   0xF885 0x0034      STRB     R0,[R5, #+52]
   1833          
   1834              return HAL_OK;
   \   00000118   0xE000             B.N      ??HAL_I2C_Mem_Write_3
   1835            }
   1836            else
   1837            {
   1838              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \   0000011A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \   0000011C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1839            }
   1840          }
   1841          
   1842          /**
   1843            * @brief  Read an amount of data in blocking mode from a specific memory address
   1844            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1845            *                the configuration information for the specified I2C.
   1846            * @param  DevAddress Target device address
   1847            * @param  MemAddress Internal memory address
   1848            * @param  MemAddSize Size of internal memory address
   1849            * @param  pData Pointer to data buffer
   1850            * @param  Size Amount of data to be sent
   1851            * @param  Timeout Timeout duration
   1852            * @retval HAL status
   1853            */

   \                                 In section .text, align 2, keep-with-next
   1854          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1855          {
   \                     HAL_I2C_Mem_Read: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4691             MOV      R9,R2
   \   0000000C   0x469A             MOV      R10,R3
   1856            /* Check the parameters */
   1857            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1858          
   1859            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xF040 0x80FB      BNE.W    ??HAL_I2C_Mem_Read_0
   \   00000018   0x9E0A             LDR      R6,[SP, #+40]
   1860            {
   1861              if((pData == NULL) || (Size == 0))
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_1
   \   0000001E   0x9C0B             LDR      R4,[SP, #+44]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??HAL_I2C_Mem_Read_2
   1862              {
   1863                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE0F3             B.N      ??HAL_I2C_Mem_Read_3
   1864              }
   1865          
   1866              /* Wait until BUSY flag is reset */
   1867              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \   00000028   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x100002
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xF040 0x80E8      BNE.W    ??HAL_I2C_Mem_Read_0
   1868              {
   1869                return HAL_BUSY;
   1870              }
   1871          
   1872              /* Process Locked */
   1873              __HAL_LOCK(hi2c);
   \   0000003E   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xF000 0x80E3      BEQ.W    ??HAL_I2C_Mem_Read_0
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF885 0x0034      STRB     R0,[R5, #+52]
   1874          
   1875              /* Disable Pos */
   1876              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000056   0x6001             STR      R1,[R0, #+0]
   1877          
   1878              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000058   0x2022             MOVS     R0,#+34
   \   0000005A   0xF885 0x0035      STRB     R0,[R5, #+53]
   1879              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000005E   0x2040             MOVS     R0,#+64
   \   00000060   0xF885 0x0036      STRB     R0,[R5, #+54]
   1880              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x63A8             STR      R0,[R5, #+56]
   \   00000068   0x9F0C             LDR      R7,[SP, #+48]
   1881          
   1882              /* Send Slave Address and Memory Address */
   1883              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   0000006A   0x9700             STR      R7,[SP, #+0]
   \   0000006C   0x4653             MOV      R3,R10
   \   0000006E   0x464A             MOV      R2,R9
   \   00000070   0x4641             MOV      R1,R8
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_4
   1884              {
   1885                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007C   0x6BA8             LDR      R0,[R5, #+56]
   \   0000007E   0x2804             CMP      R0,#+4
   \   00000080   0xD104             BNE.N    ??HAL_I2C_Mem_Read_5
   1886                {
   1887                  /* Process Unlocked */
   1888                  __HAL_UNLOCK(hi2c);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF885 0x0034      STRB     R0,[R5, #+52]
   1889                  return HAL_ERROR;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xE0C1             B.N      ??HAL_I2C_Mem_Read_3
   1890                }
   1891                else
   1892                {
   1893                  /* Process Unlocked */
   1894                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF885 0x0034      STRB     R0,[R5, #+52]
   1895                  return HAL_TIMEOUT;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0xE0BC             B.N      ??HAL_I2C_Mem_Read_3
   1896                }
   1897              }
   1898          
   1899              if(Size == 1)
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \   00000096   0x6828             LDR      R0,[R5, #+0]
   \   00000098   0x4621             MOV      R1,R4
   \   0000009A   0x2901             CMP      R1,#+1
   \   0000009C   0xD110             BNE.N    ??HAL_I2C_Mem_Read_6
   1900              {
   1901                /* Disable Acknowledge */
   1902                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000009E   0x6801             LDR      R1,[R0, #+0]
   \   000000A0   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000A4   0x6001             STR      R1,[R0, #+0]
   1903          
   1904                /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
   1905                   software sequence must complete before the current byte end of transfer */
   1906                __disable_irq();
   \   000000A6   0xB672             CPSID    I
   1907          
   1908                /* Clear ADDR flag */
   1909                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000A8   0x6828             LDR      R0,[R5, #+0]
   \   000000AA   0x6941             LDR      R1,[R0, #+20]
   \   000000AC   0x9100             STR      R1,[SP, #+0]
   \   000000AE   0x6981             LDR      R1,[R0, #+24]
   \   000000B0   0x9100             STR      R1,[SP, #+0]
   \   000000B2   0x9900             LDR      R1,[SP, #+0]
   1910          
   1911                /* Generate Stop */
   1912                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000BA   0x6001             STR      R1,[R0, #+0]
   1913          
   1914                /* Re-enable IRQs */
   1915                __enable_irq(); 
   \   000000BC   0xB662             CPSIE    I
   \   000000BE   0xE021             B.N      ??HAL_I2C_Mem_Read_7
   1916              }
   1917              else if(Size == 2)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \   000000C0   0x2902             CMP      R1,#+2
   \   000000C2   0x6801             LDR      R1,[R0, #+0]
   \   000000C4   0xD10F             BNE.N    ??HAL_I2C_Mem_Read_8
   1918              {
   1919                /* Enable Pos */
   1920                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000C6   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000CA   0x6001             STR      R1,[R0, #+0]
   1921          
   1922                /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
   1923                   software sequence must complete before the current byte end of transfer */
   1924                __disable_irq();
   \   000000CC   0xB672             CPSID    I
   1925          
   1926                /* Clear ADDR flag */
   1927                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x6941             LDR      R1,[R0, #+20]
   \   000000D2   0x9100             STR      R1,[SP, #+0]
   \   000000D4   0x6981             LDR      R1,[R0, #+24]
   \   000000D6   0x9100             STR      R1,[SP, #+0]
   \   000000D8   0x9900             LDR      R1,[SP, #+0]
   1928          
   1929                /* Disable Acknowledge */
   1930                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000E0   0x6001             STR      R1,[R0, #+0]
   1931          
   1932                 /* Re-enable IRQs */
   1933                 __enable_irq(); 
   \   000000E2   0xB662             CPSIE    I
   \   000000E4   0xE00E             B.N      ??HAL_I2C_Mem_Read_7
   1934              }
   1935              else
   1936              {
   1937                /* Enable Acknowledge */
   1938                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \   000000E6   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000EA   0x6001             STR      R1,[R0, #+0]
   1939          
   1940                /* Clear ADDR flag */
   1941                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0x6941             LDR      R1,[R0, #+20]
   \   000000F0   0x9100             STR      R1,[SP, #+0]
   \   000000F2   0x6980             LDR      R0,[R0, #+24]
   \   000000F4   0x9000             STR      R0,[SP, #+0]
   \   000000F6   0x9800             LDR      R0,[SP, #+0]
   \   000000F8   0xE004             B.N      ??HAL_I2C_Mem_Read_7
   1942              }
   1943          
   1944              while(Size > 0)
   1945              {
   1946                if(Size <= 3)
   1947                {
   1948                  /* One byte */
   1949                  if(Size== 1)
   1950                  {
   1951                    /* Wait until RXNE flag is set */
   1952                    if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   1953                    {
   1954                      if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   1955                      {
   1956                        return HAL_TIMEOUT;
   1957                      }
   1958                      else
   1959                      {
   1960                        return HAL_ERROR;
   1961                      }
   1962                    }
   1963          
   1964                    /* Read data from DR */
   1965                    (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \   000000FA   0x6828             LDR      R0,[R5, #+0]
   \   000000FC   0x6900             LDR      R0,[R0, #+16]
   \   000000FE   0xF806 0x0B01      STRB     R0,[R6], #+1
   1966                    Size--;
   \   00000102   0x1E64             SUBS     R4,R4,#+1
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \   00000104   0xB2A4             UXTH     R4,R4
   \   00000106   0x2C00             CMP      R4,#+0
   \   00000108   0xD078             BEQ.N    ??HAL_I2C_Mem_Read_10
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x2804             CMP      R0,#+4
   \   0000010E   0xDA5A             BGE.N    ??HAL_I2C_Mem_Read_11
   \   00000110   0x2801             CMP      R0,#+1
   \   00000112   0xD10C             BNE.N    ??HAL_I2C_Mem_Read_12
   \   00000114   0x4639             MOV      R1,R7
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD0EC             BEQ.N    ??HAL_I2C_Mem_Read_9
   \   00000120   0x6BA8             LDR      R0,[R5, #+56]
   \   00000122   0x2820             CMP      R0,#+32
   \   00000124   0xD101             BNE.N    ??HAL_I2C_Mem_Read_13
   \   00000126   0x2003             MOVS     R0,#+3
   \   00000128   0xE072             B.N      ??HAL_I2C_Mem_Read_3
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0xE070             B.N      ??HAL_I2C_Mem_Read_3
   1967                  }
   1968                  /* Two bytes */
   1969                  else if(Size == 2)
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \   0000012E   0x.... 0x....      LDR.W    R8,??DataTable15  ;; 0x10004
   \   00000132   0x2802             CMP      R0,#+2
   \   00000134   0x463B             MOV      R3,R7
   \   00000136   0xD119             BNE.N    ??HAL_I2C_Mem_Read_14
   1970                  {
   1971                    /* Wait until BTF flag is set */
   1972                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   00000138   0x2200             MOVS     R2,#+0
   \   0000013A   0x4641             MOV      R1,R8
   \   0000013C   0x4628             MOV      R0,R5
   \   0000013E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_15
   1973                    {
   1974                      return HAL_TIMEOUT;
   \   00000146   0x2003             MOVS     R0,#+3
   \   00000148   0xE062             B.N      ??HAL_I2C_Mem_Read_3
   1975                    }
   1976          
   1977                    /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
   1978                       software sequence must complete before the current byte end of transfer */
   1979                     __disable_irq();
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \   0000014A   0xB672             CPSID    I
   1980          
   1981                    /* Generate Stop */
   1982                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   0000014C   0x6828             LDR      R0,[R5, #+0]
   \   0000014E   0x6801             LDR      R1,[R0, #+0]
   \   00000150   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000154   0x6001             STR      R1,[R0, #+0]
   1983          
   1984                    /* Read data from DR */
   1985                    (*pData++) = hi2c->Instance->DR;
   \   00000156   0x6828             LDR      R0,[R5, #+0]
   \   00000158   0x6900             LDR      R0,[R0, #+16]
   \   0000015A   0xF806 0x0B01      STRB     R0,[R6], #+1
   1986                    Size--;
   1987          
   1988                    /* Re-enable IRQs */
   1989                    __enable_irq();
   \   0000015E   0xB662             CPSIE    I
   1990          
   1991                    /* Read data from DR */
   1992                    (*pData++) = hi2c->Instance->DR;
   \   00000160   0x6828             LDR      R0,[R5, #+0]
   \   00000162   0x6900             LDR      R0,[R0, #+16]
   \   00000164   0xF806 0x0B01      STRB     R0,[R6], #+1
   1993                    Size--;
   \   00000168   0x1EA4             SUBS     R4,R4,#+2
   \   0000016A   0xE7CB             B.N      ??HAL_I2C_Mem_Read_7
   1994                  }
   1995                  /* 3 Last bytes */
   1996                  else
   1997                  {
   1998                    /* Wait until BTF flag is set */
   1999                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \   0000016C   0x2200             MOVS     R2,#+0
   \   0000016E   0x4641             MOV      R1,R8
   \   00000170   0x4628             MOV      R0,R5
   \   00000172   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_16
   2000                    {
   2001                      return HAL_TIMEOUT;
   \   0000017A   0x2003             MOVS     R0,#+3
   \   0000017C   0xE048             B.N      ??HAL_I2C_Mem_Read_3
   2002                    }
   2003          
   2004                    /* Disable Acknowledge */
   2005                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \   0000017E   0x6828             LDR      R0,[R5, #+0]
   \   00000180   0x6801             LDR      R1,[R0, #+0]
   \   00000182   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000186   0x6001             STR      R1,[R0, #+0]
   2006          
   2007                    /* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
   2008                       software sequence must complete before the current byte end of transfer */
   2009                    __disable_irq();
   \   00000188   0xB672             CPSID    I
   2010          
   2011                    /* Read data from DR */
   2012                    (*pData++) = hi2c->Instance->DR;
   \   0000018A   0x6828             LDR      R0,[R5, #+0]
   \   0000018C   0x6900             LDR      R0,[R0, #+16]
   \   0000018E   0xF806 0x0B01      STRB     R0,[R6], #+1
   2013                    Size--;
   2014          
   2015                    /* Wait until BTF flag is set */
   2016                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout) != HAL_OK)
   \   00000192   0x463B             MOV      R3,R7
   \   00000194   0x2200             MOVS     R2,#+0
   \   00000196   0x4641             MOV      R1,R8
   \   00000198   0x4628             MOV      R0,R5
   \   0000019A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_17
   2017                    {
   2018                      return HAL_TIMEOUT;
   \   000001A2   0x2003             MOVS     R0,#+3
   \   000001A4   0xE034             B.N      ??HAL_I2C_Mem_Read_3
   2019                    }
   2020          
   2021                    /* Generate Stop */
   2022                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \   000001A6   0x6828             LDR      R0,[R5, #+0]
   \   000001A8   0x6801             LDR      R1,[R0, #+0]
   \   000001AA   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000001AE   0x6001             STR      R1,[R0, #+0]
   2023          
   2024                    /* Read data from DR */
   2025                    (*pData++) = hi2c->Instance->DR;
   \   000001B0   0x6828             LDR      R0,[R5, #+0]
   \   000001B2   0x6900             LDR      R0,[R0, #+16]
   \   000001B4   0xF806 0x0B01      STRB     R0,[R6], #+1
   2026                    Size--;
   2027          
   2028                    /* Re-enable IRQs */
   2029                    __enable_irq(); 
   \   000001B8   0xB662             CPSIE    I
   2030          
   2031                    /* Read data from DR */
   2032                    (*pData++) = hi2c->Instance->DR;
   \   000001BA   0x6828             LDR      R0,[R5, #+0]
   \   000001BC   0x6900             LDR      R0,[R0, #+16]
   \   000001BE   0xF806 0x0B01      STRB     R0,[R6], #+1
   2033                    Size--;
   \   000001C2   0x1EE4             SUBS     R4,R4,#+3
   \   000001C4   0xE79E             B.N      ??HAL_I2C_Mem_Read_7
   2034                  }
   2035                }
   2036                else
   2037                {
   2038                  /* Wait until RXNE flag is set */
   2039                  if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \   000001C6   0x4639             MOV      R1,R7
   \   000001C8   0x4628             MOV      R0,R5
   \   000001CA   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD006             BEQ.N    ??HAL_I2C_Mem_Read_18
   2040                  {
   2041                    if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   000001D2   0x6BA8             LDR      R0,[R5, #+56]
   \   000001D4   0x2820             CMP      R0,#+32
   \   000001D6   0xD101             BNE.N    ??HAL_I2C_Mem_Read_19
   2042                    {
   2043                      return HAL_TIMEOUT;
   \   000001D8   0x2003             MOVS     R0,#+3
   \   000001DA   0xE019             B.N      ??HAL_I2C_Mem_Read_3
   2044                    }
   2045                    else
   2046                    {
   2047                      return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_19: (+1)
   \   000001DC   0x2001             MOVS     R0,#+1
   \   000001DE   0xE017             B.N      ??HAL_I2C_Mem_Read_3
   2048                    }
   2049                  }
   2050          
   2051                  /* Read data from DR */
   2052                  (*pData++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \   000001E0   0x6828             LDR      R0,[R5, #+0]
   \   000001E2   0x6900             LDR      R0,[R0, #+16]
   \   000001E4   0xF806 0x0B01      STRB     R0,[R6], #+1
   2053                  Size--;
   \   000001E8   0x1E64             SUBS     R4,R4,#+1
   2054          
   2055                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   000001EA   0x6828             LDR      R0,[R5, #+0]
   \   000001EC   0x6941             LDR      R1,[R0, #+20]
   \   000001EE   0x0749             LSLS     R1,R1,#+29
   \   000001F0   0xD588             BPL.N    ??HAL_I2C_Mem_Read_7
   2056                  {
   2057                    /* Read data from DR */
   2058                    (*pData++) = hi2c->Instance->DR;
   \   000001F2   0x6900             LDR      R0,[R0, #+16]
   \   000001F4   0xF806 0x0B01      STRB     R0,[R6], #+1
   2059                    Size--;
   \   000001F8   0x1E64             SUBS     R4,R4,#+1
   \   000001FA   0xE783             B.N      ??HAL_I2C_Mem_Read_7
   2060                  }
   2061                }
   2062              }
   2063          
   2064              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \   000001FC   0x2020             MOVS     R0,#+32
   \   000001FE   0xF885 0x0035      STRB     R0,[R5, #+53]
   2065              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0xF885 0x0036      STRB     R0,[R5, #+54]
   2066          
   2067              /* Process Unlocked */
   2068              __HAL_UNLOCK(hi2c);
   \   00000208   0xF885 0x0034      STRB     R0,[R5, #+52]
   2069          
   2070              return HAL_OK;
   \   0000020C   0xE000             B.N      ??HAL_I2C_Mem_Read_3
   2071            }
   2072            else
   2073            {
   2074              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \   0000020E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \   00000210   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2075            }
   2076          }
   2077          
   2078          /**
   2079            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2080            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2081            *                the configuration information for the specified I2C.
   2082            * @param  DevAddress Target device address
   2083            * @param  MemAddress Internal memory address
   2084            * @param  MemAddSize Size of internal memory address
   2085            * @param  pData Pointer to data buffer
   2086            * @param  Size Amount of data to be sent
   2087            * @retval HAL status
   2088            */

   \                                 In section .text, align 2, keep-with-next
   2089          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2090          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   2091            /* Check the parameters */
   2092            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2093          
   2094            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD14C             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   \   00000014   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   2095            {
   2096              if((pData == NULL) || (Size == 0))
   \   00000018   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_IT_1
   \   0000001E   0x9C09             LDR      R4,[SP, #+36]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??HAL_I2C_Mem_Write_IT_2
   2097              {
   2098                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE043             B.N      ??HAL_I2C_Mem_Write_IT_3
   2099              }
   2100          
   2101              /* Wait until BUSY flag is reset */
   2102              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \   00000028   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x100002
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD138             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   2103              {
   2104                return HAL_BUSY;
   2105              }
   2106          
   2107              /* Process Locked */
   2108              __HAL_LOCK(hi2c);
   \   0000003C   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD034             BEQ.N    ??HAL_I2C_Mem_Write_IT_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF885 0x0034      STRB     R0,[R5, #+52]
   2109          
   2110              /* Disable Pos */
   2111              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6001             STR      R1,[R0, #+0]
   2112          
   2113              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000054   0x2021             MOVS     R0,#+33
   \   00000056   0xF885 0x0035      STRB     R0,[R5, #+53]
   2114              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000005A   0x2040             MOVS     R0,#+64
   \   0000005C   0xF885 0x0036      STRB     R0,[R5, #+54]
   2115              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x63A8             STR      R0,[R5, #+56]
   2116          
   2117              hi2c->pBuffPtr = pData;
   \   00000064   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2118              hi2c->XferSize = Size;
   \   00000068   0x852C             STRH     R4,[R5, #+40]
   2119              hi2c->XferCount = Size;
   \   0000006A   0x856C             STRH     R4,[R5, #+42]
   2120          
   2121              /* Send Slave Address and Memory Address */
   2122              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000006C   0x2023             MOVS     R0,#+35
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x4643             MOV      R3,R8
   \   00000072   0x463A             MOV      R2,R7
   \   00000074   0x4631             MOV      R1,R6
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_IT_4
   2123              {
   2124                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000080   0x6BA8             LDR      R0,[R5, #+56]
   \   00000082   0x2804             CMP      R0,#+4
   \   00000084   0xD104             BNE.N    ??HAL_I2C_Mem_Write_IT_5
   2125                {
   2126                  /* Process Unlocked */
   2127                  __HAL_UNLOCK(hi2c);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF885 0x0034      STRB     R0,[R5, #+52]
   2128                  return HAL_ERROR;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xE00F             B.N      ??HAL_I2C_Mem_Write_IT_3
   2129                }
   2130                else
   2131                {
   2132                  /* Process Unlocked */
   2133                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_IT_5: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF885 0x0034      STRB     R0,[R5, #+52]
   2134                  return HAL_TIMEOUT;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE00A             B.N      ??HAL_I2C_Mem_Write_IT_3
   2135                }
   2136              }
   2137          
   2138              /* Process Unlocked */
   2139              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF885 0x0034      STRB     R0,[R5, #+52]
   2140          
   2141              /* Note : The I2C interrupts must be enabled after unlocking current process
   2142                        to avoid the risk of I2C interrupt handle execution before current
   2143                        process unlock */
   2144          
   2145              /* Enable EVT, BUF and ERR interrupt */
   2146              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000A0   0x6828             LDR      R0,[R5, #+0]
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   2147          
   2148              return HAL_OK;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_3
   2149            }
   2150            else
   2151            {
   2152              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \   000000AE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \   000000B0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2153            }
   2154          }
   2155          
   2156          /**
   2157            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2158            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2159            *                the configuration information for the specified I2C.
   2160            * @param  DevAddress Target device address
   2161            * @param  MemAddress Internal memory address
   2162            * @param  MemAddSize Size of internal memory address
   2163            * @param  pData Pointer to data buffer
   2164            * @param  Size Amount of data to be sent
   2165            * @retval HAL status
   2166            */

   \                                 In section .text, align 2, keep-with-next
   2167          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2168          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   2169            /* Check the parameters */
   2170            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2171          
   2172            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD17A             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   \   00000014   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   2173            {
   2174              if((pData == NULL) || (Size == 0))
   \   00000018   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_IT_1
   \   0000001E   0x9C09             LDR      R4,[SP, #+36]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??HAL_I2C_Mem_Read_IT_2
   2175              {
   2176                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE071             B.N      ??HAL_I2C_Mem_Read_IT_3
   2177              }
   2178          
   2179              /* Wait until BUSY flag is reset */
   2180              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \   00000028   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x100002
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD166             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   2181              {
   2182                return HAL_BUSY;
   2183              }
   2184          
   2185              /* Process Locked */
   2186              __HAL_LOCK(hi2c);
   \   0000003C   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD062             BEQ.N    ??HAL_I2C_Mem_Read_IT_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF885 0x0034      STRB     R0,[R5, #+52]
   2187          
   2188              /* Disable Pos */
   2189              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6001             STR      R1,[R0, #+0]
   2190          
   2191              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000054   0x2022             MOVS     R0,#+34
   \   00000056   0xF885 0x0035      STRB     R0,[R5, #+53]
   2192              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000005A   0x2040             MOVS     R0,#+64
   \   0000005C   0xF885 0x0036      STRB     R0,[R5, #+54]
   2193              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x63A8             STR      R0,[R5, #+56]
   2194          
   2195              hi2c->pBuffPtr = pData;
   \   00000064   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2196              hi2c->XferSize = Size;
   \   00000068   0x852C             STRH     R4,[R5, #+40]
   2197              hi2c->XferCount = Size;
   \   0000006A   0x856C             STRH     R4,[R5, #+42]
   2198          
   2199              /* Send Slave Address and Memory Address */
   2200              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000006C   0x2023             MOVS     R0,#+35
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x4643             MOV      R3,R8
   \   00000072   0x463A             MOV      R2,R7
   \   00000074   0x4631             MOV      R1,R6
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_IT_4
   2201              {
   2202                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000080   0x6BA8             LDR      R0,[R5, #+56]
   \   00000082   0x2804             CMP      R0,#+4
   \   00000084   0xD104             BNE.N    ??HAL_I2C_Mem_Read_IT_5
   2203                {
   2204                  /* Process Unlocked */
   2205                  __HAL_UNLOCK(hi2c);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF885 0x0034      STRB     R0,[R5, #+52]
   2206                  return HAL_ERROR;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xE03D             B.N      ??HAL_I2C_Mem_Read_IT_3
   2207                }
   2208                else
   2209                {
   2210                  /* Process Unlocked */
   2211                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF885 0x0034      STRB     R0,[R5, #+52]
   2212                  return HAL_TIMEOUT;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE038             B.N      ??HAL_I2C_Mem_Read_IT_3
   2213                }
   2214              }
   2215          
   2216              if(hi2c->XferCount == 1)
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0x8D69             LDRH     R1,[R5, #+42]
   \   0000009E   0x2901             CMP      R1,#+1
   \   000000A0   0xD10E             BNE.N    ??HAL_I2C_Mem_Read_IT_6
   2217              {
   2218                /* Disable Acknowledge */
   2219                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000A2   0x6801             LDR      R1,[R0, #+0]
   \   000000A4   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000A8   0x6001             STR      R1,[R0, #+0]
   2220          
   2221                /* Clear ADDR flag */
   2222                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000AA   0x6828             LDR      R0,[R5, #+0]
   \   000000AC   0x6941             LDR      R1,[R0, #+20]
   \   000000AE   0x9100             STR      R1,[SP, #+0]
   \   000000B0   0x6981             LDR      R1,[R0, #+24]
   \   000000B2   0x9100             STR      R1,[SP, #+0]
   \   000000B4   0x9900             LDR      R1,[SP, #+0]
   2223          
   2224                /* Generate Stop */
   2225                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000BC   0x6001             STR      R1,[R0, #+0]
   \   000000BE   0xE01A             B.N      ??HAL_I2C_Mem_Read_IT_7
   2226              }
   2227              else if(hi2c->XferCount == 2)
   \                     ??HAL_I2C_Mem_Read_IT_6: (+1)
   \   000000C0   0x8D69             LDRH     R1,[R5, #+42]
   \   000000C2   0x2902             CMP      R1,#+2
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   \   000000C6   0xD10D             BNE.N    ??HAL_I2C_Mem_Read_IT_8
   2228              {
   2229                /* Enable Pos */
   2230                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000C8   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000CC   0x6001             STR      R1,[R0, #+0]
   2231          
   2232                /* Clear ADDR flag */
   2233                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x6941             LDR      R1,[R0, #+20]
   \   000000D2   0x9100             STR      R1,[SP, #+0]
   \   000000D4   0x6981             LDR      R1,[R0, #+24]
   \   000000D6   0x9100             STR      R1,[SP, #+0]
   \   000000D8   0x9900             LDR      R1,[SP, #+0]
   2234          
   2235                /* Disable Acknowledge */
   2236                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000E0   0x6001             STR      R1,[R0, #+0]
   \   000000E2   0xE008             B.N      ??HAL_I2C_Mem_Read_IT_7
   2237              }
   2238              else
   2239              {
   2240                /* Enable Acknowledge */
   2241                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_IT_8: (+1)
   \   000000E4   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000E8   0x6001             STR      R1,[R0, #+0]
   2242          
   2243                /* Clear ADDR flag */
   2244                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000EA   0x6828             LDR      R0,[R5, #+0]
   \   000000EC   0x6941             LDR      R1,[R0, #+20]
   \   000000EE   0x9100             STR      R1,[SP, #+0]
   \   000000F0   0x6980             LDR      R0,[R0, #+24]
   \   000000F2   0x9000             STR      R0,[SP, #+0]
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   2245              }
   2246          
   2247              /* Process Unlocked */
   2248              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_IT_7: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF885 0x0034      STRB     R0,[R5, #+52]
   2249          
   2250              /* Note : The I2C interrupts must be enabled after unlocking current process
   2251                        to avoid the risk of I2C interrupt handle execution before current
   2252                        process unlock */
   2253          
   2254              /* Enable EVT, BUF and ERR interrupt */
   2255              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000FC   0x6828             LDR      R0,[R5, #+0]
   \   000000FE   0x6841             LDR      R1,[R0, #+4]
   \   00000100   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   00000104   0x6041             STR      R1,[R0, #+4]
   2256          
   2257              return HAL_OK;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_3
   2258            }
   2259            else
   2260            {
   2261              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \   0000010A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \   0000010C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2262            }
   2263          }
   2264          
   2265          
   2266          /**
   2267            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2268            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2269            *                the configuration information for the specified I2C.
   2270            * @param  DevAddress Target device address
   2271            * @param  MemAddress Internal memory address
   2272            * @param  MemAddSize Size of internal memory address
   2273            * @param  pData Pointer to data buffer
   2274            * @param  Size Amount of data to be sent
   2275            * @retval HAL status
   2276            */

   \                                 In section .text, align 2, keep-with-next
   2277          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2278          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   2279            /* Check the parameters */
   2280            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2281          
   2282            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD15B             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   \   00000014   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   2283            {
   2284              if((pData == NULL) || (Size == 0))
   \   00000018   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_DMA_1
   \   0000001E   0x9C09             LDR      R4,[SP, #+36]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??HAL_I2C_Mem_Write_DMA_2
   2285              {
   2286                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE052             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2287              }
   2288          
   2289              /* Wait until BUSY flag is reset */
   2290              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \   00000028   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x100002
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD147             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   2291              {
   2292                return HAL_BUSY;
   2293              }
   2294          
   2295              /* Process Locked */
   2296              __HAL_LOCK(hi2c);
   \   0000003C   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD043             BEQ.N    ??HAL_I2C_Mem_Write_DMA_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF885 0x0034      STRB     R0,[R5, #+52]
   2297          
   2298              /* Disable Pos */
   2299              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6001             STR      R1,[R0, #+0]
   2300          
   2301              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000054   0x2021             MOVS     R0,#+33
   \   00000056   0xF885 0x0035      STRB     R0,[R5, #+53]
   2302              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000005A   0x2040             MOVS     R0,#+64
   \   0000005C   0xF885 0x0036      STRB     R0,[R5, #+54]
   2303              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x63A8             STR      R0,[R5, #+56]
   2304          
   2305              hi2c->pBuffPtr = pData;
   \   00000064   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2306              hi2c->XferSize = Size;
   \   00000068   0x852C             STRH     R4,[R5, #+40]
   2307              hi2c->XferCount = Size;
   \   0000006A   0x856C             STRH     R4,[R5, #+42]
   2308          
   2309              /* Set the I2C DMA transfert complete callback */
   2310              hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
   \   0000006C   0x.... 0x....      ADR.W    R0,I2C_DMAMemTransmitCplt
   \   00000070   0x6AE9             LDR      R1,[R5, #+44]
   \   00000072   0x6288             STR      R0,[R1, #+40]
   2311          
   2312              /* Set the DMA error callback */
   2313              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000074   0x.... 0x....      ADR.W    R0,I2C_DMAError
   \   00000078   0x6AE9             LDR      R1,[R5, #+44]
   \   0000007A   0x6308             STR      R0,[R1, #+48]
   2314          
   2315              /* Enable the DMA channel */
   2316              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->DR, Size);
   \   0000007C   0x4623             MOV      R3,R4
   \   0000007E   0x6828             LDR      R0,[R5, #+0]
   \   00000080   0xF100 0x0210      ADD      R2,R0,#+16
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0x6AE8             LDR      R0,[R5, #+44]
   \   00000088   0x.... 0x....      BL       HAL_DMA_Start_IT
   2317          
   2318              /* Send Slave Address and Memory Address */
   2319              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000008C   0x2023             MOVS     R0,#+35
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x4643             MOV      R3,R8
   \   00000092   0x463A             MOV      R2,R7
   \   00000094   0x4631             MOV      R1,R6
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_DMA_4
   2320              {
   2321                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000A0   0x6BA8             LDR      R0,[R5, #+56]
   \   000000A2   0x2804             CMP      R0,#+4
   \   000000A4   0xD104             BNE.N    ??HAL_I2C_Mem_Write_DMA_5
   2322                {
   2323                  /* Process Unlocked */
   2324                  __HAL_UNLOCK(hi2c);
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF885 0x0034      STRB     R0,[R5, #+52]
   2325                  return HAL_ERROR;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE00E             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2326                }
   2327                else
   2328                {
   2329                  /* Process Unlocked */
   2330                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF885 0x0034      STRB     R0,[R5, #+52]
   2331                  return HAL_TIMEOUT;
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0xE009             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2332                }
   2333              }
   2334          
   2335              /* Enable DMA Request */
   2336              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \   000000BA   0x6828             LDR      R0,[R5, #+0]
   \   000000BC   0x6841             LDR      R1,[R0, #+4]
   \   000000BE   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000C2   0x6041             STR      R1,[R0, #+4]
   2337          
   2338              /* Process Unlocked */
   2339              __HAL_UNLOCK(hi2c);
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xF885 0x0034      STRB     R0,[R5, #+52]
   2340          
   2341              return HAL_OK;
   \   000000CA   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2342            }
   2343            else
   2344            {
   2345              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \   000000CC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \   000000CE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2346            }
   2347          }
   2348          
   2349          /**
   2350            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   2351            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2352            *                the configuration information for the specified I2C.
   2353            * @param  DevAddress Target device address
   2354            * @param  MemAddress Internal memory address
   2355            * @param  MemAddSize Size of internal memory address
   2356            * @param  pData Pointer to data buffer
   2357            * @param  Size Amount of data to be read
   2358            * @retval HAL status
   2359            */

   \                                 In section .text, align 2, keep-with-next
   2360          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2361          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   2362            /* Check the parameters */
   2363            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2364          
   2365            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD16D             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   \   00000014   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   2366            {
   2367              if((pData == NULL) || (Size == 0))
   \   00000018   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001C   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_DMA_1
   \   0000001E   0x9C09             LDR      R4,[SP, #+36]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??HAL_I2C_Mem_Read_DMA_2
   2368              {
   2369                return  HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE064             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2370              }
   2371          
   2372              /* Wait until BUSY flag is reset */
   2373              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \   00000028   0xF242 0x7310      MOVW     R3,#+10000
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x100002
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD159             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   2374              {
   2375                return HAL_BUSY;
   2376              }
   2377          
   2378              /* Process Locked */
   2379              __HAL_LOCK(hi2c);
   \   0000003C   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD055             BEQ.N    ??HAL_I2C_Mem_Read_DMA_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF885 0x0034      STRB     R0,[R5, #+52]
   2380          
   2381              /* Disable Pos */
   2382              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6001             STR      R1,[R0, #+0]
   2383          
   2384              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000054   0x2022             MOVS     R0,#+34
   \   00000056   0xF885 0x0035      STRB     R0,[R5, #+53]
   2385              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000005A   0x2040             MOVS     R0,#+64
   \   0000005C   0xF885 0x0036      STRB     R0,[R5, #+54]
   2386              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x63A8             STR      R0,[R5, #+56]
   2387          
   2388              hi2c->pBuffPtr = pData;
   \   00000064   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2389              hi2c->XferSize = Size;
   \   00000068   0x852C             STRH     R4,[R5, #+40]
   2390              hi2c->XferCount = Size;
   \   0000006A   0x856C             STRH     R4,[R5, #+42]
   2391          
   2392              /* Set the I2C DMA transfert complete callback */
   2393              hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
   \   0000006C   0x.... 0x....      ADR.W    R0,I2C_DMAMemReceiveCplt
   \   00000070   0x6B29             LDR      R1,[R5, #+48]
   \   00000072   0x6288             STR      R0,[R1, #+40]
   2394          
   2395              /* Set the DMA error callback */
   2396              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   00000074   0x.... 0x....      ADR.W    R0,I2C_DMAError
   \   00000078   0x6B29             LDR      R1,[R5, #+48]
   \   0000007A   0x6308             STR      R0,[R1, #+48]
   2397          
   2398              /* Enable the DMA channel */
   2399              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)pData, Size);
   \   0000007C   0x4623             MOV      R3,R4
   \   0000007E   0x464A             MOV      R2,R9
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0xF100 0x0110      ADD      R1,R0,#+16
   \   00000086   0x6B28             LDR      R0,[R5, #+48]
   \   00000088   0x.... 0x....      BL       HAL_DMA_Start_IT
   2400          
   2401              /* Send Slave Address and Memory Address */
   2402              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000008C   0x2023             MOVS     R0,#+35
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x4643             MOV      R3,R8
   \   00000092   0x463A             MOV      R2,R7
   \   00000094   0x4631             MOV      R1,R6
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_DMA_4
   2403              {
   2404                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000A0   0x6BA8             LDR      R0,[R5, #+56]
   \   000000A2   0x2804             CMP      R0,#+4
   \   000000A4   0xD104             BNE.N    ??HAL_I2C_Mem_Read_DMA_5
   2405                {
   2406                  /* Process Unlocked */
   2407                  __HAL_UNLOCK(hi2c);
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF885 0x0034      STRB     R0,[R5, #+52]
   2408                  return HAL_ERROR;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE020             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2409                }
   2410                else
   2411                {
   2412                  /* Process Unlocked */
   2413                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF885 0x0034      STRB     R0,[R5, #+52]
   2414                  return HAL_TIMEOUT;
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0xE01B             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2415                }
   2416              }
   2417          
   2418              if(Size == 1)
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \   000000BA   0x6828             LDR      R0,[R5, #+0]
   \   000000BC   0x2C01             CMP      R4,#+1
   \   000000BE   0xD104             BNE.N    ??HAL_I2C_Mem_Read_DMA_6
   2419              {
   2420                /* Disable Acknowledge */
   2421                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000C6   0x6001             STR      R1,[R0, #+0]
   \   000000C8   0xE003             B.N      ??HAL_I2C_Mem_Read_DMA_7
   2422              }
   2423              else
   2424              {
   2425                /* Enable Last DMA bit */
   2426                SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \   000000CA   0x6841             LDR      R1,[R0, #+4]
   \   000000CC   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000D0   0x6041             STR      R1,[R0, #+4]
   2427              }
   2428          
   2429              /* Enable DMA Request */
   2430              SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0x6841             LDR      R1,[R0, #+4]
   \   000000D6   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000DA   0x6041             STR      R1,[R0, #+4]
   2431          
   2432              /* Clear ADDR flag */
   2433              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0x6941             LDR      R1,[R0, #+20]
   \   000000E0   0x9100             STR      R1,[SP, #+0]
   \   000000E2   0x6980             LDR      R0,[R0, #+24]
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0x9800             LDR      R0,[SP, #+0]
   2434          
   2435              /* Process Unlocked */
   2436              __HAL_UNLOCK(hi2c);
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF885 0x0034      STRB     R0,[R5, #+52]
   2437          
   2438              return HAL_OK;
   \   000000EE   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_3
   2439            }
   2440            else
   2441            {
   2442              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \   000000F0   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \   000000F2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2443            }
   2444          }
   2445          
   2446          
   2447          /**
   2448            * @brief  Checks if target device is ready for communication.
   2449            * @note   This function is used with Memory devices
   2450            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2451            *                the configuration information for the specified I2C.
   2452            * @param  DevAddress Target device address
   2453            * @param  Trials Number of trials
   2454            * @param  Timeout Timeout duration
   2455            * @retval HAL status
   2456            */

   \                                 In section .text, align 2, keep-with-next
   2457          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   2458          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
   2459            uint32_t tickstart = 0, tmp1 = 0, tmp2 = 0, tmp3 = 0, I2C_Trials = 1;
   \   0000000C   0xF04F 0x0A01      MOV      R10,#+1
   2460          
   2461            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000010   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000014   0x2820             CMP      R0,#+32
   \   00000016   0xF040 0x8099      BNE.W    ??HAL_I2C_IsDeviceReady_0
   2462            {
   2463              /* Wait until BUSY flag is reset */
   2464              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable21  ;; 0x100002
   \   0000001E   0xF242 0x7610      MOVW     R6,#+10000
   \   00000022   0x4633             MOV      R3,R6
   \   00000024   0x4652             MOV      R2,R10
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x808C      BNE.W    ??HAL_I2C_IsDeviceReady_0
   2465              {
   2466                return HAL_BUSY;
   2467              }
   2468          
   2469              /* Process Locked */
   2470              __HAL_LOCK(hi2c);
   \   00000034   0xF994 0x0034      LDRSB    R0,[R4, #+52]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xF000 0x8087      BEQ.W    ??HAL_I2C_IsDeviceReady_0
   \   0000003E   0x4650             MOV      R0,R10
   \   00000040   0xF884 0x0034      STRB     R0,[R4, #+52]
   2471          
   2472              /* Disable Pos */
   2473              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   2474          
   2475              hi2c->State = HAL_I2C_STATE_BUSY;
   \   0000004E   0x2024             MOVS     R0,#+36
   \   00000050   0xF884 0x0035      STRB     R0,[R4, #+53]
   2476              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63A0             STR      R0,[R4, #+56]
   2477          
   2478              do
   2479              {
   2480                /* Generate Start */
   2481                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000060   0x6001             STR      R1,[R0, #+0]
   2482          
   2483                /* Wait until SB flag is set */
   2484                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   00000062   0x464B             MOV      R3,R9
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0xF04F 0x1101      MOV      R1,#+65537
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_2
   2485                {
   2486                  return HAL_TIMEOUT;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xE06A             B.N      ??HAL_I2C_IsDeviceReady_3
   2487                }
   2488          
   2489                /* Send slave address */
   2490                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \   00000078   0xF007 0x00FE      AND      R0,R7,#0xFE
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6108             STR      R0,[R1, #+16]
   2491                 
   2492                /* Wait until ADDR or AF flag are set */
   2493                /* Get tick */
   2494                tickstart = HAL_GetTick();
   \   00000080   0x.... 0x....      BL       HAL_GetTick
   \   00000084   0x4683             MOV      R11,R0
   2495          
   2496                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x6948             LDR      R0,[R1, #+20]
   \   0000008A   0x0840             LSRS     R0,R0,#+1
   \   0000008C   0xF000 0x0001      AND      R0,R0,#0x1
   2497                tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \   00000090   0x6949             LDR      R1,[R1, #+20]
   \   00000092   0x0A89             LSRS     R1,R1,#+10
   \   00000094   0xF001 0x0101      AND      R1,R1,#0x1
   2498                tmp3 = hi2c->State;
   \   00000098   0xF894 0x2035      LDRB     R2,[R4, #+53]
   \   0000009C   0xE016             B.N      ??HAL_I2C_IsDeviceReady_4
   2499                while((tmp1 == RESET) && (tmp2 == RESET) && (tmp3 != HAL_I2C_STATE_TIMEOUT))
   2500                {
   2501                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \   0000009E   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000A2   0xD005             BEQ.N    ??HAL_I2C_IsDeviceReady_6
   \   000000A4   0x.... 0x....      BL       HAL_GetTick
   \   000000A8   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000AC   0x4581             CMP      R9,R0
   \   000000AE   0xD202             BCS.N    ??HAL_I2C_IsDeviceReady_7
   2502                  {
   2503                    hi2c->State = HAL_I2C_STATE_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \   000000B0   0x20A0             MOVS     R0,#+160
   \   000000B2   0xF884 0x0035      STRB     R0,[R4, #+53]
   2504                  }
   2505                  tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \   000000B6   0x6821             LDR      R1,[R4, #+0]
   \   000000B8   0x6948             LDR      R0,[R1, #+20]
   \   000000BA   0x0840             LSRS     R0,R0,#+1
   \   000000BC   0xF000 0x0001      AND      R0,R0,#0x1
   2506                  tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \   000000C0   0x6949             LDR      R1,[R1, #+20]
   \   000000C2   0x0A89             LSRS     R1,R1,#+10
   \   000000C4   0xF001 0x0101      AND      R1,R1,#0x1
   2507                  tmp3 = hi2c->State;
   \   000000C8   0xF894 0x2035      LDRB     R2,[R4, #+53]
   2508                }
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \   000000CC   0x4308             ORRS     R0,R1,R0
   \   000000CE   0xD101             BNE.N    ??HAL_I2C_IsDeviceReady_8
   \   000000D0   0x2AA0             CMP      R2,#+160
   \   000000D2   0xD1E4             BNE.N    ??HAL_I2C_IsDeviceReady_5
   2509          
   2510                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \   000000D4   0x2020             MOVS     R0,#+32
   \   000000D6   0xF884 0x0035      STRB     R0,[R4, #+53]
   2511          
   2512                /* Check if the ADDR flag has been set */
   2513                if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6941             LDR      R1,[R0, #+20]
   \   000000DE   0x0789             LSLS     R1,R1,#+30
   \   000000E0   0x6801             LDR      R1,[R0, #+0]
   \   000000E2   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000E6   0x6001             STR      R1,[R0, #+0]
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6941             LDR      R1,[R0, #+20]
   \   000000EC   0xD514             BPL.N    ??HAL_I2C_IsDeviceReady_9
   2514                {
   2515                  /* Generate Stop */
   2516                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   2517          
   2518                  /* Clear ADDR Flag */
   2519                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000EE   0x9100             STR      R1,[SP, #+0]
   \   000000F0   0x6980             LDR      R0,[R0, #+24]
   \   000000F2   0x9000             STR      R0,[SP, #+0]
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   2520          
   2521                  /* Wait until BUSY flag is reset */
   2522                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   000000F6   0x4633             MOV      R3,R6
   \   000000F8   0x2201             MOVS     R2,#+1
   \   000000FA   0x4629             MOV      R1,R5
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_10
   2523                  {
   2524                    return HAL_TIMEOUT;
   \   00000106   0x2003             MOVS     R0,#+3
   \   00000108   0xE021             B.N      ??HAL_I2C_IsDeviceReady_3
   2525                  }
   2526          
   2527                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \   0000010A   0x2020             MOVS     R0,#+32
   \   0000010C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2528          
   2529                  /* Process Unlocked */
   2530                  __HAL_UNLOCK(hi2c);
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF884 0x0034      STRB     R0,[R4, #+52]
   2531          
   2532                  return HAL_OK;
   \   00000116   0xE01A             B.N      ??HAL_I2C_IsDeviceReady_3
   2533                }
   2534                else
   2535                {
   2536                  /* Generate Stop */
   2537                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   2538          
   2539                  /* Clear AF Flag */
   2540                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \   00000118   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000011C   0x6141             STR      R1,[R0, #+20]
   2541          
   2542                  /* Wait until BUSY flag is reset */
   2543                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG) != HAL_OK)
   \   0000011E   0x4633             MOV      R3,R6
   \   00000120   0x2201             MOVS     R2,#+1
   \   00000122   0x4629             MOV      R1,R5
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_11
   2544                  {
   2545                    return HAL_TIMEOUT;
   \   0000012E   0x2003             MOVS     R0,#+3
   \   00000130   0xE00D             B.N      ??HAL_I2C_IsDeviceReady_3
   2546                  }
   2547                }
   2548              }while(I2C_Trials++ < Trials);
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \   00000132   0x4650             MOV      R0,R10
   \   00000134   0xF100 0x0A01      ADD      R10,R0,#+1
   \   00000138   0x4540             CMP      R0,R8
   \   0000013A   0xD38D             BCC.N    ??HAL_I2C_IsDeviceReady_1
   2549          
   2550              hi2c->State = HAL_I2C_STATE_READY;
   \   0000013C   0x2020             MOVS     R0,#+32
   \   0000013E   0xF884 0x0035      STRB     R0,[R4, #+53]
   2551          
   2552              /* Process Unlocked */
   2553              __HAL_UNLOCK(hi2c);
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF884 0x0034      STRB     R0,[R4, #+52]
   2554          
   2555              return HAL_ERROR;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xE000             B.N      ??HAL_I2C_IsDeviceReady_3
   2556            }
   2557            else
   2558            {
   2559              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \   0000014C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \   0000014E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2560            }
   2561          }
   2562          /**
   2563            * @}
   2564            */
   2565          
   2566          /** @defgroup I2C_Exported_Functions_Group4 IRQ Handler and Callbacks
   2567           * @{
   2568           */   
   2569          
   2570          /**
   2571            * @brief  This function handles I2C event interrupt request.
   2572            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2573            *                the configuration information for the specified I2C.
   2574            * @retval None
   2575            */

   \                                 In section .text, align 2, keep-with-next
   2576          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   2577          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \   00000000   0xB43C             PUSH     {R2-R5}
   2578            uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0, tmp4 = 0;
   2579            /* Master or Memory mode selected */
   2580            if((hi2c->Mode == HAL_I2C_MODE_MASTER) || \
   2581               (hi2c->Mode == HAL_I2C_MODE_MEM))
   \   00000002   0xF990 0x1036      LDRSB    R1,[R0, #+54]
   \   00000006   0x2910             CMP      R1,#+16
   \   00000008   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000000A   0xF990 0x1036      LDRSB    R1,[R0, #+54]
   \   0000000E   0x2940             CMP      R1,#+64
   \   00000010   0xD13E             BNE.N    ??HAL_I2C_EV_IRQHandler_1
   2582            {
   2583              /* I2C in mode Transmitter -----------------------------------------------*/
   2584              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == SET)
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x698A             LDR      R2,[R1, #+24]
   \   00000016   0x0752             LSLS     R2,R2,#+29
   \   00000018   0x694A             LDR      R2,[R1, #+20]
   \   0000001A   0xD51C             BPL.N    ??HAL_I2C_EV_IRQHandler_2
   2585              {
   2586                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE);
   \   0000001C   0x09D2             LSRS     R2,R2,#+7
   \   0000001E   0xF002 0x0201      AND      R2,R2,#0x1
   2587                tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0x0A9B             LSRS     R3,R3,#+10
   \   00000026   0xF003 0x0301      AND      R3,R3,#0x1
   2588                tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
   \   0000002A   0x694C             LDR      R4,[R1, #+20]
   \   0000002C   0x08A4             LSRS     R4,R4,#+2
   \   0000002E   0xF004 0x0401      AND      R4,R4,#0x1
   2589                tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
   \   00000032   0x6849             LDR      R1,[R1, #+4]
   \   00000034   0x0A49             LSRS     R1,R1,#+9
   \   00000036   0xF001 0x0501      AND      R5,R1,#0x1
   2590                /* TXE set and BTF reset -----------------------------------------------*/
   2591                if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
   \   0000003A   0x2A01             CMP      R2,#+1
   \   0000003C   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_3
   \   0000003E   0x2B01             CMP      R3,#+1
   \   00000040   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_3
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_3
   2592                {
   2593                  I2C_MasterTransmit_TXE(hi2c);
   \   00000046   0xBC36             POP      {R1,R2,R4,R5}
   \   00000048   0x....             B.N      I2C_MasterTransmit_TXE
   2594                }
   2595                /* BTF set -------------------------------------------------------------*/
   2596                else if((tmp3 == SET) && (tmp4 == SET))
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \   0000004A   0x2C01             CMP      R4,#+1
   \   0000004C   0xD17A             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000004E   0x2D01             CMP      R5,#+1
   \   00000050   0xD178             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   2597                {
   2598                  I2C_MasterTransmit_BTF(hi2c);
   \   00000052   0xBC36             POP      {R1,R2,R4,R5}
   \   00000054   0x....             B.N      I2C_MasterTransmit_BTF
   2599                }
   2600              }
   2601              /* I2C in mode Receiver --------------------------------------------------*/
   2602              else
   2603              {
   2604                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE);
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \   00000056   0x0992             LSRS     R2,R2,#+6
   \   00000058   0xF002 0x0201      AND      R2,R2,#0x1
   2605                tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
   \   0000005C   0x684B             LDR      R3,[R1, #+4]
   \   0000005E   0x0A9B             LSRS     R3,R3,#+10
   \   00000060   0xF003 0x0301      AND      R3,R3,#0x1
   2606                tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
   \   00000064   0x694C             LDR      R4,[R1, #+20]
   \   00000066   0x08A4             LSRS     R4,R4,#+2
   \   00000068   0xF004 0x0401      AND      R4,R4,#0x1
   2607                tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
   \   0000006C   0x6849             LDR      R1,[R1, #+4]
   \   0000006E   0x0A49             LSRS     R1,R1,#+9
   \   00000070   0xF001 0x0501      AND      R5,R1,#0x1
   2608                /* RXNE set and BTF reset -----------------------------------------------*/
   2609                if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
   \   00000074   0x2A01             CMP      R2,#+1
   \   00000076   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_5
   \   00000078   0x2B01             CMP      R3,#+1
   \   0000007A   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_5
   \   0000007C   0x2C00             CMP      R4,#+0
   \   0000007E   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_5
   2610                {
   2611                  I2C_MasterReceive_RXNE(hi2c);
   \   00000080   0xBC36             POP      {R1,R2,R4,R5}
   \   00000082   0x....             B.N      I2C_MasterReceive_RXNE
   2612                }
   2613                /* BTF set -------------------------------------------------------------*/
   2614                else if((tmp3 == SET) && (tmp4 == SET))
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \   00000084   0x2C01             CMP      R4,#+1
   \   00000086   0xD15D             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000088   0x2D01             CMP      R5,#+1
   \   0000008A   0xD15B             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   2615                {
   2616                  I2C_MasterReceive_BTF(hi2c);
   \   0000008C   0xBC36             POP      {R1,R2,R4,R5}
   \   0000008E   0x....             B.N      I2C_MasterReceive_BTF
   2617                }
   2618              }
   2619            }
   2620            /* Slave mode selected */
   2621            else
   2622            {
   2623              tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0x694A             LDR      R2,[R1, #+20]
   \   00000094   0x0852             LSRS     R2,R2,#+1
   \   00000096   0xF002 0x0201      AND      R2,R2,#0x1
   2624              tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_EVT));
   \   0000009A   0x684B             LDR      R3,[R1, #+4]
   \   0000009C   0x0A5B             LSRS     R3,R3,#+9
   \   0000009E   0xF003 0x0301      AND      R3,R3,#0x1
   2625              tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
   \   000000A2   0x694C             LDR      R4,[R1, #+20]
   \   000000A4   0x0924             LSRS     R4,R4,#+4
   \   000000A6   0xF004 0x0401      AND      R4,R4,#0x1
   2626              tmp4 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA);
   \   000000AA   0x698D             LDR      R5,[R1, #+24]
   \   000000AC   0x08AD             LSRS     R5,R5,#+2
   \   000000AE   0xF005 0x0501      AND      R5,R5,#0x1
   2627              /* ADDR set --------------------------------------------------------------*/
   2628              if((tmp1 == SET) && (tmp2 == SET))
   \   000000B2   0x2A01             CMP      R2,#+1
   \   000000B4   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000B6   0x2B01             CMP      R3,#+1
   \   000000B8   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_6
   2629              {
   2630                I2C_Slave_ADDR(hi2c);
   \   000000BA   0xBC36             POP      {R1,R2,R4,R5}
   \   000000BC   0x....             B.N      I2C_Slave_ADDR
   2631              }
   2632              /* STOPF set --------------------------------------------------------------*/
   2633              else if((tmp3 == SET) && (tmp2 == SET))
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \   000000BE   0x2C01             CMP      R4,#+1
   \   000000C0   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   \   000000C2   0x2B01             CMP      R3,#+1
   \   000000C4   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2634              {
   2635                I2C_Slave_STOPF(hi2c);
   \   000000C6   0xBC36             POP      {R1,R2,R4,R5}
   \   000000C8   0x....             B.N      I2C_Slave_STOPF
   2636              }
   2637              /* I2C in mode Transmitter -----------------------------------------------*/
   2638              else if(tmp4 == SET)
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \   000000CA   0x2D01             CMP      R5,#+1
   \   000000CC   0x694A             LDR      R2,[R1, #+20]
   \   000000CE   0xD11C             BNE.N    ??HAL_I2C_EV_IRQHandler_8
   2639              {
   2640                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE);
   \   000000D0   0x09D2             LSRS     R2,R2,#+7
   \   000000D2   0xF002 0x0201      AND      R2,R2,#0x1
   2641                tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
   \   000000D6   0x684B             LDR      R3,[R1, #+4]
   \   000000D8   0x0A9B             LSRS     R3,R3,#+10
   \   000000DA   0xF003 0x0301      AND      R3,R3,#0x1
   2642                tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
   \   000000DE   0x694C             LDR      R4,[R1, #+20]
   \   000000E0   0x08A4             LSRS     R4,R4,#+2
   \   000000E2   0xF004 0x0401      AND      R4,R4,#0x1
   2643                tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
   \   000000E6   0x6849             LDR      R1,[R1, #+4]
   \   000000E8   0x0A49             LSRS     R1,R1,#+9
   \   000000EA   0xF001 0x0501      AND      R5,R1,#0x1
   2644                /* TXE set and BTF reset -----------------------------------------------*/
   2645                if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
   \   000000EE   0x2A01             CMP      R2,#+1
   \   000000F0   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_9
   \   000000F2   0x2B01             CMP      R3,#+1
   \   000000F4   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_9
   \   000000F6   0x2C00             CMP      R4,#+0
   \   000000F8   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_9
   2646                {
   2647                  I2C_SlaveTransmit_TXE(hi2c);
   \   000000FA   0xBC36             POP      {R1,R2,R4,R5}
   \   000000FC   0x....             B.N      I2C_SlaveTransmit_TXE
   2648                }
   2649                /* BTF set -------------------------------------------------------------*/
   2650                else if((tmp3 == SET) && (tmp4 == SET))
   \                     ??HAL_I2C_EV_IRQHandler_9: (+1)
   \   000000FE   0x2C01             CMP      R4,#+1
   \   00000100   0xD120             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000102   0x2D01             CMP      R5,#+1
   \   00000104   0xD11E             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   2651                {
   2652                  I2C_SlaveTransmit_BTF(hi2c);
   \   00000106   0xBC36             POP      {R1,R2,R4,R5}
   \   00000108   0x....             B.N      I2C_SlaveTransmit_BTF
   2653                }
   2654              }
   2655              /* I2C in mode Receiver --------------------------------------------------*/
   2656              else
   2657              {
   2658                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE);
   \                     ??HAL_I2C_EV_IRQHandler_8: (+1)
   \   0000010A   0x0992             LSRS     R2,R2,#+6
   \   0000010C   0xF002 0x0201      AND      R2,R2,#0x1
   2659                tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_BUF);
   \   00000110   0x684B             LDR      R3,[R1, #+4]
   \   00000112   0x0A9B             LSRS     R3,R3,#+10
   \   00000114   0xF003 0x0301      AND      R3,R3,#0x1
   2660                tmp3 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF);
   \   00000118   0x694C             LDR      R4,[R1, #+20]
   \   0000011A   0x08A4             LSRS     R4,R4,#+2
   \   0000011C   0xF004 0x0401      AND      R4,R4,#0x1
   2661                tmp4 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_EVT);
   \   00000120   0x6849             LDR      R1,[R1, #+4]
   \   00000122   0x0A49             LSRS     R1,R1,#+9
   \   00000124   0xF001 0x0501      AND      R5,R1,#0x1
   2662                /* RXNE set and BTF reset ----------------------------------------------*/
   2663                if((tmp1 == SET) && (tmp2 == SET) && (tmp3 == RESET))
   \   00000128   0x2A01             CMP      R2,#+1
   \   0000012A   0xD105             BNE.N    ??HAL_I2C_EV_IRQHandler_10
   \   0000012C   0x2B01             CMP      R3,#+1
   \   0000012E   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_10
   \   00000130   0x2C00             CMP      R4,#+0
   \   00000132   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_10
   2664                {
   2665                  I2C_SlaveReceive_RXNE(hi2c);
   \   00000134   0xBC36             POP      {R1,R2,R4,R5}
   \   00000136   0x....             B.N      I2C_SlaveReceive_RXNE
   2666                }
   2667                /* BTF set -------------------------------------------------------------*/
   2668                else if((tmp3 == SET) && (tmp4 == SET))
   \                     ??HAL_I2C_EV_IRQHandler_10: (+1)
   \   00000138   0x2C01             CMP      R4,#+1
   \   0000013A   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000013C   0x2D01             CMP      R5,#+1
   \   0000013E   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   2669                {
   2670                  I2C_SlaveReceive_BTF(hi2c);
   \   00000140   0xBC36             POP      {R1,R2,R4,R5}
   \   00000142   0x....             B.N      I2C_SlaveReceive_BTF
   2671                }
   2672              }
   2673            }
   2674          }
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \   00000144   0xBC33             POP      {R0,R1,R4,R5}
   \   00000146   0x4770             BX       LR               ;; return
   2675          
   2676          /**
   2677            * @brief  This function handles I2C error interrupt request.
   2678            * @param  hi2c: pointer to a I2C_HandleTypeDef structure that contains
   2679            *         the configuration information for I2C module
   2680            * @retval HAL status
   2681            */

   \                                 In section .text, align 2, keep-with-next
   2682          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   2683          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2684            uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
   2685          
   2686            tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6941             LDR      R1,[R0, #+20]
   \   00000008   0x0A09             LSRS     R1,R1,#+8
   \   0000000A   0xF001 0x0101      AND      R1,R1,#0x1
   2687            tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x0A00             LSRS     R0,R0,#+8
   \   00000012   0xF000 0x0001      AND      R0,R0,#0x1
   2688            /* I2C Bus error interrupt occurred ----------------------------------------*/
   2689            if((tmp1 == SET) && (tmp2 == SET))
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD10F             BNE.N    ??HAL_I2C_ER_IRQHandler_0
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD10D             BNE.N    ??HAL_I2C_ER_IRQHandler_0
   2690            {
   2691              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \   0000001E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000020   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000024   0x63A0             STR      R0,[R4, #+56]
   2692          
   2693              /* Clear BERR flag */
   2694              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6941             LDR      R1,[R0, #+20]
   \   0000002A   0xF421 0x7180      BIC      R1,R1,#0x100
   \   0000002E   0x6141             STR      R1,[R0, #+20]
   2695              
   2696              /* Workaround: Start cannot be generated after a misplaced Stop */
   2697              SET_BIT(hi2c->Instance->CR1, I2C_CR1_SWRST);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000038   0x6001             STR      R1,[R0, #+0]
   2698            }
   2699          
   2700            tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO);
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6941             LDR      R1,[R0, #+20]
   \   0000003E   0x0A49             LSRS     R1,R1,#+9
   \   00000040   0xF001 0x0101      AND      R1,R1,#0x1
   2701            tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
   \   00000044   0x6840             LDR      R0,[R0, #+4]
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0xF000 0x0001      AND      R0,R0,#0x1
   2702            /* I2C Arbitration Loss error interrupt occurred ---------------------------*/
   2703            if((tmp1 == SET) && (tmp2 == SET))
   \   0000004C   0x2901             CMP      R1,#+1
   \   0000004E   0xD10A             BNE.N    ??HAL_I2C_ER_IRQHandler_1
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD108             BNE.N    ??HAL_I2C_ER_IRQHandler_1
   2704            {
   2705              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \   00000054   0x6BA0             LDR      R0,[R4, #+56]
   \   00000056   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000005A   0x63A0             STR      R0,[R4, #+56]
   2706          
   2707              /* Clear ARLO flag */
   2708              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6941             LDR      R1,[R0, #+20]
   \   00000060   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000064   0x6141             STR      R1,[R0, #+20]
   2709            }
   2710          
   2711            tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6941             LDR      R1,[R0, #+20]
   \   0000006A   0x0A89             LSRS     R1,R1,#+10
   \   0000006C   0xF001 0x0101      AND      R1,R1,#0x1
   2712            tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
   \   00000070   0x6840             LDR      R0,[R0, #+4]
   \   00000072   0x0A00             LSRS     R0,R0,#+8
   \   00000074   0xF000 0x0001      AND      R0,R0,#0x1
   2713            /* I2C Acknowledge failure error interrupt occurred ------------------------*/
   2714            if((tmp1 == SET) && (tmp2 == SET))
   \   00000078   0x2901             CMP      R1,#+1
   \   0000007A   0xD11E             BNE.N    ??HAL_I2C_ER_IRQHandler_2
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD11C             BNE.N    ??HAL_I2C_ER_IRQHandler_2
   2715            {
   2716              tmp1 = hi2c->Mode;
   \   00000080   0xF994 0x1036      LDRSB    R1,[R4, #+54]
   2717              tmp2 = hi2c->XferCount;
   \   00000084   0x8D60             LDRH     R0,[R4, #+42]
   2718              tmp3 = hi2c->State;
   \   00000086   0xF894 0x2035      LDRB     R2,[R4, #+53]
   2719              if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0) && \
   2720                 (tmp3 == HAL_I2C_STATE_BUSY_TX))
   \   0000008A   0x2920             CMP      R1,#+32
   \   0000008C   0xD107             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD105             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   00000092   0x2A21             CMP      R2,#+33
   \   00000094   0xD103             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   2721              {
   2722                I2C_Slave_AF(hi2c);
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       I2C_Slave_AF
   \   0000009C   0xE00D             B.N      ??HAL_I2C_ER_IRQHandler_2
   2723              }
   2724              else
   2725              {
   2726                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \   0000009E   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A0   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000A4   0x63A0             STR      R0,[R4, #+56]
   2727            
   2728                /* Generate Stop */
   2729                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6801             LDR      R1,[R0, #+0]
   \   000000AA   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000AE   0x6001             STR      R1,[R0, #+0]
   2730            
   2731                /* Clear AF flag */
   2732                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6941             LDR      R1,[R0, #+20]
   \   000000B4   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000B8   0x6141             STR      R1,[R0, #+20]
   2733              }
   2734            }
   2735          
   2736            tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR);
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6941             LDR      R1,[R0, #+20]
   \   000000BE   0x0AC9             LSRS     R1,R1,#+11
   \   000000C0   0xF001 0x0101      AND      R1,R1,#0x1
   2737            tmp2 = __HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERR);
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0x0A00             LSRS     R0,R0,#+8
   \   000000C8   0xF000 0x0001      AND      R0,R0,#0x1
   2738            /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
   2739            if((tmp1 == SET) && (tmp2 == SET))
   \   000000CC   0x2901             CMP      R1,#+1
   \   000000CE   0xD10A             BNE.N    ??HAL_I2C_ER_IRQHandler_4
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD108             BNE.N    ??HAL_I2C_ER_IRQHandler_4
   2740            {
   2741              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \   000000D4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D6   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000000DA   0x63A0             STR      R0,[R4, #+56]
   2742              /* Clear OVR flag */
   2743              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6941             LDR      R1,[R0, #+20]
   \   000000E0   0xF421 0x6100      BIC      R1,R1,#0x800
   \   000000E4   0x6141             STR      R1,[R0, #+20]
   2744            }
   2745          
   2746            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_4: (+1)
   \   000000E6   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD00A             BEQ.N    ??HAL_I2C_ER_IRQHandler_5
   2747            {
   2748              hi2c->State = HAL_I2C_STATE_READY;
   \   000000EC   0x2020             MOVS     R0,#+32
   \   000000EE   0xF884 0x0035      STRB     R0,[R4, #+53]
   2749              
   2750              /* Disable Pos bit in I2C CR1 when error occured in Master/Mem Receive IT Process */
   2751              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6801             LDR      R1,[R0, #+0]
   \   000000F6   0xF421 0x6100      BIC      R1,R1,#0x800
   \   000000FA   0x6001             STR      R1,[R0, #+0]
   2752              
   2753              HAL_I2C_ErrorCallback(hi2c);
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2754            }
   2755          }
   \                     ??HAL_I2C_ER_IRQHandler_5: (+1)
   \   00000102   0xBD10             POP      {R4,PC}          ;; return
   2756          
   2757          /**
   2758            * @brief  Master Tx Transfer completed callback.
   2759            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2760            *                the configuration information for the specified I2C.
   2761            * @retval None
   2762            */

   \                                 In section .text, align 2, keep-with-next
   2763           __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2764          {
   2765            /* Prevent unused argument(s) compilation warning */
   2766            UNUSED(hi2c);
   2767            /* NOTE : This function should not be modified, when the callback is needed,
   2768                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2769             */
   2770          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2771          
   2772          /**
   2773            * @brief  Master Rx Transfer completed callback.
   2774            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2775            *                the configuration information for the specified I2C.
   2776            * @retval None
   2777            */

   \                                 In section .text, align 2, keep-with-next
   2778          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2779          {
   2780            /* Prevent unused argument(s) compilation warning */
   2781            UNUSED(hi2c);
   2782            /* NOTE : This function should not be modified, when the callback is needed,
   2783                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2784             */
   2785          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2786          
   2787          /** @brief  Slave Tx Transfer completed callback.
   2788            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2789            *                the configuration information for the specified I2C.
   2790            * @retval None
   2791            */

   \                                 In section .text, align 2, keep-with-next
   2792           __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2793          {
   2794            /* Prevent unused argument(s) compilation warning */
   2795            UNUSED(hi2c);
   2796            /* NOTE : This function should not be modified, when the callback is needed,
   2797                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2798             */
   2799          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2800          
   2801          /**
   2802            * @brief  Slave Rx Transfer completed callback.
   2803            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2804            *                the configuration information for the specified I2C.
   2805            * @retval None
   2806            */

   \                                 In section .text, align 2, keep-with-next
   2807          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2808          {
   2809            /* Prevent unused argument(s) compilation warning */
   2810            UNUSED(hi2c);
   2811            /* NOTE : This function should not be modified, when the callback is needed,
   2812                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2813             */
   2814          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2815          
   2816          /**
   2817            * @brief  Memory Tx Transfer completed callback.
   2818            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2819            *                the configuration information for the specified I2C.
   2820            * @retval None
   2821            */

   \                                 In section .text, align 2, keep-with-next
   2822           __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2823          {
   2824            /* Prevent unused argument(s) compilation warning */
   2825            UNUSED(hi2c);
   2826            /* NOTE : This function should not be modified, when the callback is needed,
   2827                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2828             */
   2829          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2830          
   2831          /**
   2832            * @brief  Memory Rx Transfer completed callback.
   2833            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2834            *                the configuration information for the specified I2C.
   2835            * @retval None
   2836            */

   \                                 In section .text, align 2, keep-with-next
   2837          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2838          {
   2839            /* Prevent unused argument(s) compilation warning */
   2840            UNUSED(hi2c);
   2841            /* NOTE : This function should not be modified, when the callback is needed,
   2842                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2843             */
   2844          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2845          
   2846          /**
   2847            * @brief  I2C error callback.
   2848            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2849            *                the configuration information for the specified I2C.
   2850            * @retval None
   2851            */

   \                                 In section .text, align 2, keep-with-next
   2852           __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   2853          {
   2854            /* Prevent unused argument(s) compilation warning */
   2855            UNUSED(hi2c);
   2856            /* NOTE : This function should not be modified, when the callback is needed,
   2857                      the HAL_I2C_ErrorCallback could be implemented in the user file
   2858             */
   2859          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2860          
   2861          /**
   2862            * @}
   2863            */
   2864          
   2865          
   2866          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State and Errors functions
   2867           *  @brief   Peripheral State and Errors functions
   2868           *
   2869          @verbatim
   2870           ===============================================================================
   2871                      ##### Peripheral State and Errors functions #####
   2872           ===============================================================================
   2873              [..]
   2874              This subsection permits to get in run-time the status of the peripheral
   2875              and the data flow.
   2876          
   2877          @endverbatim
   2878            * @{
   2879            */
   2880          
   2881          /**
   2882            * @brief  Return the I2C handle state.
   2883            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2884            *                the configuration information for the specified I2C.
   2885            * @retval HAL state
   2886            */

   \                                 In section .text, align 2, keep-with-next
   2887          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   2888          {
   2889            /* Return I2C handle state */
   2890            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   2891          }
   2892          
   2893          /**
   2894            * @brief  Return the I2C error code.
   2895            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2896            *                the configuration information for the specified I2C.
   2897          * @retval I2C Error Code
   2898          */

   \                                 In section .text, align 2, keep-with-next
   2899          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   2900          {
   2901            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2902          }
   2903          
   2904          /**
   2905            * @}
   2906            */
   2907          
   2908          /**
   2909            * @}
   2910            */
   2911          
   2912          /** @addtogroup I2C_Private_Functions
   2913            * @{
   2914            */
   2915          
   2916          /**
   2917            * @brief  Handle TXE flag for Master Transmit Mode
   2918            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2919            *                the configuration information for the specified I2C.
   2920            * @retval HAL status
   2921            */

   \                                 In section .text, align 2, keep-with-next
   2922          static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
   2923          {
   2924            if(hi2c->XferCount == 0)
   \                     I2C_MasterTransmit_TXE: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD105             BNE.N    ??I2C_MasterTransmit_TXE_0
   2925            {
   2926              /* Disable BUF interrupt */
   2927              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0xE008             B.N      ??I2C_MasterTransmit_TXE_1
   2928            }
   2929            else
   2930            {
   2931              /* Write data to DR */
   2932              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \                     ??I2C_MasterTransmit_TXE_0: (+1)
   \   00000012   0x6A41             LDR      R1,[R0, #+36]
   \   00000014   0x1C4A             ADDS     R2,R1,#+1
   \   00000016   0x6242             STR      R2,[R0, #+36]
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6111             STR      R1,[R2, #+16]
   2933              hi2c->XferCount--;
   \   0000001E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000020   0x1E49             SUBS     R1,R1,#+1
   \   00000022   0x8541             STRH     R1,[R0, #+42]
   2934            }
   2935            
   2936            return HAL_OK;
   \                     ??I2C_MasterTransmit_TXE_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
   2937          }
   2938          
   2939          /**
   2940            * @brief  Handle BTF flag for Master Transmit Mode
   2941            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2942            *                the configuration information for the specified I2C.
   2943            * @retval HAL status
   2944            */

   \                                 In section .text, align 2, keep-with-next
   2945          static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
   2946          {
   \                     I2C_MasterTransmit_BTF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2947            if(hi2c->XferCount != 0)
   \   00000002   0x8D41             LDRH     R1,[R0, #+42]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD009             BEQ.N    ??I2C_MasterTransmit_BTF_0
   2948            {
   2949              /* Write data to DR */
   2950              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000008   0x6A41             LDR      R1,[R0, #+36]
   \   0000000A   0x1C4A             ADDS     R2,R1,#+1
   \   0000000C   0x6242             STR      R2,[R0, #+36]
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x6111             STR      R1,[R2, #+16]
   2951              hi2c->XferCount--;
   \   00000014   0x8D41             LDRH     R1,[R0, #+42]
   \   00000016   0x1E49             SUBS     R1,R1,#+1
   \   00000018   0x8541             STRH     R1,[R0, #+42]
   \   0000001A   0xE018             B.N      ??I2C_MasterTransmit_BTF_1
   2952            }
   2953            else
   2954            {
   2955              /* Disable EVT, BUF and ERR interrupt */
   2956              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterTransmit_BTF_0: (+1)
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x684A             LDR      R2,[R1, #+4]
   \   00000020   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   00000024   0x604A             STR      R2,[R1, #+4]
   2957          
   2958              /* Generate Stop */
   2959              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xF442 0x7200      ORR      R2,R2,#0x200
   \   0000002E   0x600A             STR      R2,[R1, #+0]
   2960          
   2961              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000030   0xF990 0x1036      LDRSB    R1,[R0, #+54]
   \   00000034   0x2940             CMP      R1,#+64
   \   00000036   0xD105             BNE.N    ??I2C_MasterTransmit_BTF_2
   2962              {
   2963                hi2c->State = HAL_I2C_STATE_READY;
   \   00000038   0x2120             MOVS     R1,#+32
   \   0000003A   0xF880 0x1035      STRB     R1,[R0, #+53]
   2964          
   2965                HAL_I2C_MemTxCpltCallback(hi2c);
   \   0000003E   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   00000042   0xE004             B.N      ??I2C_MasterTransmit_BTF_1
   2966              }
   2967              else
   2968              {
   2969                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterTransmit_BTF_2: (+1)
   \   00000044   0x2120             MOVS     R1,#+32
   \   00000046   0xF880 0x1035      STRB     R1,[R0, #+53]
   2970          
   2971                HAL_I2C_MasterTxCpltCallback(hi2c);
   \   0000004A   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   2972              }
   2973            }
   2974            return HAL_OK;
   \                     ??I2C_MasterTransmit_BTF_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD02             POP      {R1,PC}          ;; return
   2975          }
   2976          
   2977          /**
   2978            * @brief  Handle RXNE flag for Master Receive Mode
   2979            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2980            *                the configuration information for the specified I2C.
   2981            * @retval HAL status
   2982            */

   \                                 In section .text, align 2, keep-with-next
   2983          static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
   2984          {
   \                     I2C_MasterReceive_RXNE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2985            uint32_t tmp = 0;
   2986          
   2987            tmp = hi2c->XferCount;
   \   00000002   0x8D41             LDRH     R1,[R0, #+42]
   2988            if(tmp > 3)
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xD309             BCC.N    ??I2C_MasterReceive_RXNE_0
   2989            {
   2990              /* Read data from DR */
   2991              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000008   0x6A41             LDR      R1,[R0, #+36]
   \   0000000A   0x1C4A             ADDS     R2,R1,#+1
   \   0000000C   0x6242             STR      R2,[R0, #+36]
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x6912             LDR      R2,[R2, #+16]
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   2992              hi2c->XferCount--;
   \   00000014   0x8D41             LDRH     R1,[R0, #+42]
   \   00000016   0x1E49             SUBS     R1,R1,#+1
   \   00000018   0x8541             STRH     R1,[R0, #+42]
   \   0000001A   0xE026             B.N      ??I2C_MasterReceive_RXNE_1
   2993            }
   2994            else if((tmp == 2) || (tmp == 3))
   \                     ??I2C_MasterReceive_RXNE_0: (+1)
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD001             BEQ.N    ??I2C_MasterReceive_RXNE_2
   \   00000020   0x2903             CMP      R1,#+3
   \   00000022   0xD105             BNE.N    ??I2C_MasterReceive_RXNE_3
   2995            {
   2996              /* Disable BUF interrupt */
   2997              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \                     ??I2C_MasterReceive_RXNE_2: (+1)
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x6848             LDR      R0,[R1, #+4]
   \   00000028   0xF420 0x6080      BIC      R0,R0,#0x400
   \   0000002C   0x6048             STR      R0,[R1, #+4]
   \   0000002E   0xE01C             B.N      ??I2C_MasterReceive_RXNE_1
   2998            }
   2999            else
   3000            {
   3001              /* Disable EVT, BUF and ERR interrupt */
   3002              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterReceive_RXNE_3: (+1)
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   00000038   0x604A             STR      R2,[R1, #+4]
   3003          
   3004              /* Read data from DR */
   3005              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000003A   0x6A41             LDR      R1,[R0, #+36]
   \   0000003C   0x1C4A             ADDS     R2,R1,#+1
   \   0000003E   0x6242             STR      R2,[R0, #+36]
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x6912             LDR      R2,[R2, #+16]
   \   00000044   0x700A             STRB     R2,[R1, #+0]
   3006              hi2c->XferCount--;
   \   00000046   0x8D41             LDRH     R1,[R0, #+42]
   \   00000048   0x1E49             SUBS     R1,R1,#+1
   \   0000004A   0x8541             STRH     R1,[R0, #+42]
   3007          
   3008              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   0000004C   0xF990 0x1036      LDRSB    R1,[R0, #+54]
   \   00000050   0x2940             CMP      R1,#+64
   \   00000052   0xD105             BNE.N    ??I2C_MasterReceive_RXNE_4
   3009              {
   3010                hi2c->State = HAL_I2C_STATE_READY;
   \   00000054   0x2120             MOVS     R1,#+32
   \   00000056   0xF880 0x1035      STRB     R1,[R0, #+53]
   3011          
   3012                HAL_I2C_MemRxCpltCallback(hi2c);
   \   0000005A   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   0000005E   0xE004             B.N      ??I2C_MasterReceive_RXNE_1
   3013              }
   3014              else
   3015              {
   3016                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterReceive_RXNE_4: (+1)
   \   00000060   0x2120             MOVS     R1,#+32
   \   00000062   0xF880 0x1035      STRB     R1,[R0, #+53]
   3017          
   3018                HAL_I2C_MasterRxCpltCallback(hi2c);
   \   00000066   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   3019              }
   3020            }
   3021            return HAL_OK;
   \                     ??I2C_MasterReceive_RXNE_1: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD02             POP      {R1,PC}          ;; return
   3022          }
   3023          
   3024          /**
   3025            * @brief  Handle BTF flag for Master Receive Mode
   3026            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3027            *                the configuration information for the specified I2C.
   3028            * @retval HAL status
   3029            */

   \                                 In section .text, align 2, keep-with-next
   3030          static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
   3031          {
   \                     I2C_MasterReceive_BTF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3032            if(hi2c->XferCount == 3)
   \   00000002   0x8D41             LDRH     R1,[R0, #+42]
   \   00000004   0x2903             CMP      R1,#+3
   \   00000006   0xD10E             BNE.N    ??I2C_MasterReceive_BTF_0
   3033            {
   3034              /* Disable Acknowledge */
   3035              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000010   0x600A             STR      R2,[R1, #+0]
   3036          
   3037              /* Read data from DR */
   3038              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000012   0x6A41             LDR      R1,[R0, #+36]
   \   00000014   0x1C4A             ADDS     R2,R1,#+1
   \   00000016   0x6242             STR      R2,[R0, #+36]
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6912             LDR      R2,[R2, #+16]
   \   0000001C   0x700A             STRB     R2,[R1, #+0]
   3039              hi2c->XferCount--;
   \   0000001E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000020   0x1E49             SUBS     R1,R1,#+1
   \   00000022   0x8541             STRH     R1,[R0, #+42]
   \   00000024   0xE037             B.N      ??I2C_MasterReceive_BTF_1
   3040            }
   3041            else if(hi2c->XferCount == 2)
   \                     ??I2C_MasterReceive_BTF_0: (+1)
   \   00000026   0x8D41             LDRH     R1,[R0, #+42]
   \   00000028   0x2902             CMP      R1,#+2
   \   0000002A   0xD12B             BNE.N    ??I2C_MasterReceive_BTF_2
   3042            {
   3043              /* Disable EVT and ERR interrupt */
   3044              /* Workaround - Wong data read into data register */
   3045              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   \   00000030   0xF422 0x7240      BIC      R2,R2,#0x300
   \   00000034   0x604A             STR      R2,[R1, #+4]
   3046          
   3047              /* Generate Stop */
   3048              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x680A             LDR      R2,[R1, #+0]
   \   0000003A   0xF442 0x7200      ORR      R2,R2,#0x200
   \   0000003E   0x600A             STR      R2,[R1, #+0]
   3049          
   3050              /* Read data from DR */
   3051              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000040   0x6A41             LDR      R1,[R0, #+36]
   \   00000042   0x1C4A             ADDS     R2,R1,#+1
   \   00000044   0x6242             STR      R2,[R0, #+36]
   \   00000046   0x6802             LDR      R2,[R0, #+0]
   \   00000048   0x6912             LDR      R2,[R2, #+16]
   \   0000004A   0x700A             STRB     R2,[R1, #+0]
   3052              hi2c->XferCount--;
   \   0000004C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000004E   0x1E49             SUBS     R1,R1,#+1
   \   00000050   0x8541             STRH     R1,[R0, #+42]
   3053          
   3054              /* Read data from DR */
   3055              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000052   0x6A41             LDR      R1,[R0, #+36]
   \   00000054   0x1C4A             ADDS     R2,R1,#+1
   \   00000056   0x6242             STR      R2,[R0, #+36]
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0x6912             LDR      R2,[R2, #+16]
   \   0000005C   0x700A             STRB     R2,[R1, #+0]
   3056              hi2c->XferCount--;
   \   0000005E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000060   0x1E49             SUBS     R1,R1,#+1
   \   00000062   0x8541             STRH     R1,[R0, #+42]
   3057          
   3058              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000064   0xF990 0x1036      LDRSB    R1,[R0, #+54]
   \   00000068   0x2940             CMP      R1,#+64
   \   0000006A   0xD105             BNE.N    ??I2C_MasterReceive_BTF_3
   3059              {
   3060                hi2c->State = HAL_I2C_STATE_READY;
   \   0000006C   0x2120             MOVS     R1,#+32
   \   0000006E   0xF880 0x1035      STRB     R1,[R0, #+53]
   3061          
   3062                HAL_I2C_MemRxCpltCallback(hi2c);
   \   00000072   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000076   0xE00E             B.N      ??I2C_MasterReceive_BTF_1
   3063              }
   3064              else
   3065              {
   3066                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterReceive_BTF_3: (+1)
   \   00000078   0x2120             MOVS     R1,#+32
   \   0000007A   0xF880 0x1035      STRB     R1,[R0, #+53]
   3067          
   3068                HAL_I2C_MasterRxCpltCallback(hi2c);
   \   0000007E   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   00000082   0xE008             B.N      ??I2C_MasterReceive_BTF_1
   3069              }
   3070            }
   3071            else
   3072            {
   3073              /* Read data from DR */
   3074              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_2: (+1)
   \   00000084   0x6A41             LDR      R1,[R0, #+36]
   \   00000086   0x1C4A             ADDS     R2,R1,#+1
   \   00000088   0x6242             STR      R2,[R0, #+36]
   \   0000008A   0x6802             LDR      R2,[R0, #+0]
   \   0000008C   0x6912             LDR      R2,[R2, #+16]
   \   0000008E   0x700A             STRB     R2,[R1, #+0]
   3075              hi2c->XferCount--;
   \   00000090   0x8D41             LDRH     R1,[R0, #+42]
   \   00000092   0x1E49             SUBS     R1,R1,#+1
   \   00000094   0x8541             STRH     R1,[R0, #+42]
   3076            }
   3077            return HAL_OK;
   \                     ??I2C_MasterReceive_BTF_1: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xBD02             POP      {R1,PC}          ;; return
   3078          }
   3079          
   3080          /**
   3081            * @brief  Handle TXE flag for Slave Transmit Mode
   3082            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3083            *                the configuration information for the specified I2C.
   3084            * @retval HAL status
   3085            */

   \                                 In section .text, align 2, keep-with-next
   3086          static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
   3087          {
   3088            if(hi2c->XferCount != 0)
   \                     I2C_SlaveTransmit_TXE: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??I2C_SlaveTransmit_TXE_0
   3089            {
   3090              /* Write data to DR */
   3091              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6242             STR      R2,[R0, #+36]
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x6111             STR      R1,[R2, #+16]
   3092              hi2c->XferCount--;
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8541             STRH     R1,[R0, #+42]
   3093            }
   3094            return HAL_OK;
   \                     ??I2C_SlaveTransmit_TXE_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   3095          }
   3096          
   3097          /**
   3098            * @brief  Handle BTF flag for Slave Transmit Mode
   3099            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3100            *                the configuration information for the specified I2C.
   3101            * @retval HAL status
   3102            */

   \                                 In section .text, align 2, keep-with-next
   3103          static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
   3104          {
   3105            if(hi2c->XferCount != 0)
   \                     I2C_SlaveTransmit_BTF: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??I2C_SlaveTransmit_BTF_0
   3106            {
   3107              /* Write data to DR */
   3108              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6242             STR      R2,[R0, #+36]
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x6111             STR      R1,[R2, #+16]
   3109              hi2c->XferCount--;
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8541             STRH     R1,[R0, #+42]
   3110            }
   3111            return HAL_OK;
   \                     ??I2C_SlaveTransmit_BTF_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   3112          }
   3113          
   3114          /**
   3115            * @brief  Handle RXNE flag for Slave Receive Mode
   3116            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3117            *                the configuration information for the specified I2C.
   3118            * @retval HAL status
   3119            */

   \                                 In section .text, align 2, keep-with-next
   3120          static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
   3121          {
   3122            if(hi2c->XferCount != 0)
   \                     I2C_SlaveReceive_RXNE: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??I2C_SlaveReceive_RXNE_0
   3123            {
   3124              /* Read data from DR */
   3125              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6242             STR      R2,[R0, #+36]
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x6912             LDR      R2,[R2, #+16]
   \   00000010   0x700A             STRB     R2,[R1, #+0]
   3126              hi2c->XferCount--;
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8541             STRH     R1,[R0, #+42]
   3127            }
   3128            return HAL_OK;
   \                     ??I2C_SlaveReceive_RXNE_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   3129          }
   3130          
   3131          /**
   3132            * @brief  Handle BTF flag for Slave Receive Mode
   3133            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3134            *                the configuration information for the specified I2C.
   3135            * @retval HAL status
   3136            */

   \                                 In section .text, align 2, keep-with-next
   3137          static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
   3138          {
   3139            if(hi2c->XferCount != 0)
   \                     I2C_SlaveReceive_BTF: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??I2C_SlaveReceive_BTF_0
   3140            {
   3141              /* Read data from DR */
   3142              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6242             STR      R2,[R0, #+36]
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x6912             LDR      R2,[R2, #+16]
   \   00000010   0x700A             STRB     R2,[R1, #+0]
   3143              hi2c->XferCount--;
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8541             STRH     R1,[R0, #+42]
   3144            }
   3145            return HAL_OK;
   \                     ??I2C_SlaveReceive_BTF_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   3146          }
   3147          
   3148          /**
   3149            * @brief  Handle ADD flag for Slave
   3150            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3151            *                the configuration information for the specified I2C.
   3152            * @retval HAL status
   3153            */

   \                                 In section .text, align 2, keep-with-next
   3154          static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)
   3155          {
   \                     I2C_Slave_ADDR: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   3156            /* Clear ADDR flag */
   3157            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6941             LDR      R1,[R0, #+20]
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0x6980             LDR      R0,[R0, #+24]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   3158          
   3159            return HAL_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
   3160          }
   3161          
   3162          /**
   3163            * @brief  Handle STOPF flag for Slave Mode
   3164            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3165            *                the configuration information for the specified I2C.
   3166            * @retval HAL status
   3167            */

   \                                 In section .text, align 2, keep-with-next
   3168          static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
   3169          {
   \                     I2C_Slave_STOPF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3170            /* Disable EVT, BUF and ERR interrupt */
   3171            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   3172          
   3173            /* Clear STOPF flag */
   3174            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x694A             LDR      R2,[R1, #+20]
   \   00000010   0x9200             STR      R2,[SP, #+0]
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0x600A             STR      R2,[R1, #+0]
   \   0000001A   0x9200             STR      R2,[SP, #+0]
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   3175          
   3176            /* Disable Acknowledge */
   3177            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000026   0x600A             STR      R2,[R1, #+0]
   3178          
   3179            hi2c->State = HAL_I2C_STATE_READY;
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0xF880 0x1035      STRB     R1,[R0, #+53]
   3180          
   3181            HAL_I2C_SlaveRxCpltCallback(hi2c);
   \   0000002E   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   3182          
   3183            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
   3184          }
   3185          
   3186          /**
   3187            * @brief  Handle Acknowledge Failed for Slave Mode
   3188            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3189            *                the configuration information for the specified I2C.
   3190            * @retval HAL status
   3191            */

   \                                 In section .text, align 2, keep-with-next
   3192          static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
   3193          {
   \                     I2C_Slave_AF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3194            /* Disable EVT, BUF and ERR interrupt */
   3195            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   3196          
   3197            /* Clear AF flag */
   3198            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x694A             LDR      R2,[R1, #+20]
   \   00000010   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000014   0x614A             STR      R2,[R1, #+20]
   3199          
   3200            /* Disable Acknowledge */
   3201            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000001E   0x600A             STR      R2,[R1, #+0]
   3202          
   3203            hi2c->State = HAL_I2C_STATE_READY;
   \   00000020   0x2120             MOVS     R1,#+32
   \   00000022   0xF880 0x1035      STRB     R1,[R0, #+53]
   3204          
   3205            HAL_I2C_SlaveTxCpltCallback(hi2c);
   \   00000026   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   3206          
   3207            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
   3208          }
   3209          
   3210          /**
   3211            * @brief  Master sends target device address followed by internal memory address for write request.
   3212            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3213            *                the configuration information for the specified I2C.
   3214            * @param  DevAddress Target device address
   3215            * @param  Timeout Timeout duration
   3216            * @retval HAL status
   3217            */

   \                                 In section .text, align 2, keep-with-next
   3218          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout)
   3219          {
   \                     I2C_MasterRequestWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   3220            /* Generate Start */
   3221            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000010   0x6001             STR      R1,[R0, #+0]
   3222          
   3223            /* Wait until SB flag is set */
   3224            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   00000012   0x462B             MOV      R3,R5
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xF04F 0x1101      MOV      R1,#+65537
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??I2C_MasterRequestWrite_0
   3225            {
   3226              return HAL_TIMEOUT;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xBD70             POP      {R4-R6,PC}
   3227            }
   3228          
   3229            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestWrite_0: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6921             LDR      R1,[R4, #+16]
   \   0000002C   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000030   0xD103             BNE.N    ??I2C_MasterRequestWrite_1
   3230            {
   3231              /* Send slave address */
   3232              hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \   00000032   0xF006 0x01FE      AND      R1,R6,#0xFE
   \   00000036   0x6101             STR      R1,[R0, #+16]
   \   00000038   0xE017             B.N      ??I2C_MasterRequestWrite_2
   3233            }
   3234            else
   3235            {
   3236              /* Send header of slave address */
   3237              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestWrite_1: (+1)
   \   0000003A   0x09F1             LSRS     R1,R6,#+7
   \   0000003C   0xF001 0x0106      AND      R1,R1,#0x6
   \   00000040   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   00000044   0x6101             STR      R1,[R0, #+16]
   3238          
   3239              /* Wait until ADD10 flag is set */
   3240              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout) != HAL_OK)
   \   00000046   0x462A             MOV      R2,R5
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable26  ;; 0x10008
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD006             BEQ.N    ??I2C_MasterRequestWrite_3
   3241              {
   3242                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000056   0x6BA0             LDR      R0,[R4, #+56]
   \   00000058   0x2804             CMP      R0,#+4
   \   0000005A   0xD101             BNE.N    ??I2C_MasterRequestWrite_4
   3243                {
   3244                  return HAL_ERROR;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD70             POP      {R4-R6,PC}
   3245                }
   3246                else
   3247                {
   3248                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_4: (+1)
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0xBD70             POP      {R4-R6,PC}
   3249                }
   3250              }
   3251          
   3252              /* Send slave address */
   3253              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestWrite_3: (+1)
   \   00000064   0xB2F6             UXTB     R6,R6
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6106             STR      R6,[R0, #+16]
   3254            }
   3255          
   3256            /* Wait until ADDR flag is set */
   3257            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \                     ??I2C_MasterRequestWrite_2: (+1)
   \   0000006A   0x462A             MOV      R2,R5
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x10002
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD006             BEQ.N    ??I2C_MasterRequestWrite_5
   3258            {
   3259              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000007C   0x2804             CMP      R0,#+4
   \   0000007E   0xD101             BNE.N    ??I2C_MasterRequestWrite_6
   3260              {
   3261                return HAL_ERROR;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xBD70             POP      {R4-R6,PC}
   3262              }
   3263              else
   3264              {
   3265                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_6: (+1)
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xBD70             POP      {R4-R6,PC}
   3266              }
   3267            }
   3268          
   3269            return HAL_OK;
   \                     ??I2C_MasterRequestWrite_5: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   3270          }
   3271          
   3272          /**
   3273            * @brief  Master sends target device address followed by internal memory address for read request.
   3274            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3275            *                the configuration information for the specified I2C.
   3276            * @param  DevAddress Target device address
   3277            * @param  Timeout Timeout duration
   3278            * @retval HAL status
   3279            */

   \                                 In section .text, align 2, keep-with-next
   3280          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout)
   3281          {
   \                     I2C_MasterRequestRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   3282            /* Enable Acknowledge */
   3283            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000010   0x6001             STR      R1,[R0, #+0]
   3284          
   3285            /* Generate Start */
   3286            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000001A   0x6001             STR      R1,[R0, #+0]
   3287          
   3288            /* Wait until SB flag is set */
   3289            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   0000001C   0x462B             MOV      R3,R5
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0xF04F 0x1101      MOV      R1,#+65537
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ.N    ??I2C_MasterRequestRead_0
   3290            {
   3291              return HAL_TIMEOUT;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
   3292            }
   3293          
   3294            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestRead_0: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6921             LDR      R1,[R4, #+16]
   \   00000036   0xF5B1 0x4F80      CMP      R1,#+16384
   \   0000003A   0xD104             BNE.N    ??I2C_MasterRequestRead_1
   3295            {
   3296              /* Send slave address */
   3297              hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \   0000003C   0xF046 0x0101      ORR      R1,R6,#0x1
   \   00000040   0xB2C9             UXTB     R1,R1
   \   00000042   0x6101             STR      R1,[R0, #+16]
   \   00000044   0xE03F             B.N      ??I2C_MasterRequestRead_2
   3298            }
   3299            else
   3300            {
   3301              /* Send header of slave address */
   3302              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestRead_1: (+1)
   \   00000046   0x09F1             LSRS     R1,R6,#+7
   \   00000048   0xF001 0x0706      AND      R7,R1,#0x6
   \   0000004C   0xF047 0x01F0      ORR      R1,R7,#0xF0
   \   00000050   0x6101             STR      R1,[R0, #+16]
   3303          
   3304              /* Wait until ADD10 flag is set */
   3305              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout) != HAL_OK)
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable26  ;; 0x10008
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD006             BEQ.N    ??I2C_MasterRequestRead_3
   3306              {
   3307                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000062   0x6BA0             LDR      R0,[R4, #+56]
   \   00000064   0x2804             CMP      R0,#+4
   \   00000066   0xD101             BNE.N    ??I2C_MasterRequestRead_4
   3308                {
   3309                  return HAL_ERROR;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}
   3310                }
   3311                else
   3312                {
   3313                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_4: (+1)
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}
   3314                }
   3315              }
   3316          
   3317              /* Send slave address */
   3318              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestRead_3: (+1)
   \   00000070   0xB2F6             UXTB     R6,R6
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6106             STR      R6,[R0, #+16]
   3319          
   3320              /* Wait until ADDR flag is set */
   3321              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000076   0x462A             MOV      R2,R5
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x10002
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD006             BEQ.N    ??I2C_MasterRequestRead_5
   3322              {
   3323                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0xD101             BNE.N    ??I2C_MasterRequestRead_6
   3324                {
   3325                  return HAL_ERROR;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}
   3326                }
   3327                else
   3328                {
   3329                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_6: (+1)
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}
   3330                }
   3331              }
   3332          
   3333              /* Clear ADDR flag */
   3334              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_MasterRequestRead_5: (+1)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6941             LDR      R1,[R0, #+20]
   \   00000098   0x9100             STR      R1,[SP, #+0]
   \   0000009A   0x6981             LDR      R1,[R0, #+24]
   \   0000009C   0x9100             STR      R1,[SP, #+0]
   \   0000009E   0x9900             LDR      R1,[SP, #+0]
   3335          
   3336              /* Generate Restart */
   3337              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0xF441 0x7180      ORR      R1,R1,#0x100
   \   000000A6   0x6001             STR      R1,[R0, #+0]
   3338          
   3339              /* Wait until SB flag is set */
   3340              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   000000A8   0x462B             MOV      R3,R5
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0xF04F 0x1101      MOV      R1,#+65537
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD001             BEQ.N    ??I2C_MasterRequestRead_7
   3341              {
   3342                return HAL_TIMEOUT;
   \   000000BA   0x2003             MOVS     R0,#+3
   \   000000BC   0xBDF2             POP      {R1,R4-R7,PC}
   3343              }
   3344          
   3345              /* Send header of slave address */
   3346              hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
   \                     ??I2C_MasterRequestRead_7: (+1)
   \   000000BE   0xF047 0x00F1      ORR      R0,R7,#0xF1
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x6108             STR      R0,[R1, #+16]
   3347            }
   3348          
   3349            /* Wait until ADDR flag is set */
   3350            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \                     ??I2C_MasterRequestRead_2: (+1)
   \   000000C6   0x462A             MOV      R2,R5
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x10002
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD006             BEQ.N    ??I2C_MasterRequestRead_8
   3351            {
   3352              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000D6   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D8   0x2804             CMP      R0,#+4
   \   000000DA   0xD101             BNE.N    ??I2C_MasterRequestRead_9
   3353              {
   3354                return HAL_ERROR;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xBDF2             POP      {R1,R4-R7,PC}
   3355              }
   3356              else
   3357              {
   3358                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_9: (+1)
   \   000000E0   0x2003             MOVS     R0,#+3
   \   000000E2   0xBDF2             POP      {R1,R4-R7,PC}
   3359              }
   3360            }
   3361          
   3362            return HAL_OK;
   \                     ??I2C_MasterRequestRead_8: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3363          }
   3364          
   3365          /**
   3366            * @brief  Master sends target device address followed by internal memory address for write request.
   3367            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3368            *                the configuration information for the specified I2C.
   3369            * @param  DevAddress Target device address
   3370            * @param  MemAddress Internal memory address
   3371            * @param  MemAddSize Size of internal memory address
   3372            * @param  Timeout Timeout duration
   3373            * @retval HAL status
   3374            */

   \                                 In section .text, align 2, keep-with-next
   3375          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3376          {
   \                     I2C_RequestMemoryWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
   3377            /* Generate Start */
   3378            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0x9F08             LDR      R7,[SP, #+32]
   3379          
   3380            /* Wait until SB flag is set */
   3381            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   0000001A   0x463B             MOV      R3,R7
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xF04F 0x1101      MOV      R1,#+65537
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??I2C_RequestMemoryWrite_0
   3382            {
   3383              return HAL_TIMEOUT;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xE045             B.N      ??I2C_RequestMemoryWrite_1
   3384            }
   3385          
   3386            /* Send slave address */
   3387            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \   00000030   0xF008 0x00FE      AND      R0,R8,#0xFE
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6108             STR      R0,[R1, #+16]
   3388          
   3389            /* Wait until ADDR flag is set */
   3390            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000038   0x463A             MOV      R2,R7
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0x10002
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD006             BEQ.N    ??I2C_RequestMemoryWrite_2
   3391            {
   3392              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000048   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004A   0x2804             CMP      R0,#+4
   \   0000004C   0xD101             BNE.N    ??I2C_RequestMemoryWrite_3
   3393              {
   3394                return HAL_ERROR;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE034             B.N      ??I2C_RequestMemoryWrite_1
   3395              }
   3396              else
   3397              {
   3398                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_3: (+1)
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0xE032             B.N      ??I2C_RequestMemoryWrite_1
   3399              }
   3400            }
   3401          
   3402            /* Clear ADDR flag */
   3403            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6941             LDR      R1,[R0, #+20]
   \   0000005A   0x9100             STR      R1,[SP, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   3404          
   3405            /* Wait until TXE flag is set */
   3406            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   00000062   0x4639             MOV      R1,R7
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00B             BEQ.N    ??I2C_RequestMemoryWrite_4
   3407            {
   3408              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD106             BNE.N    ??I2C_RequestMemoryWrite_5
   3409              {
   3410                /* Generate Stop */
   3411                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   3412                return HAL_ERROR;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE01C             B.N      ??I2C_RequestMemoryWrite_1
   3413              }
   3414              else
   3415              {
   3416                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_5: (+1)
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xE01A             B.N      ??I2C_RequestMemoryWrite_1
   3417              }
   3418            }
   3419          
   3420            /* If Memory address size is 8Bit */
   3421            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryWrite_4: (+1)
   \   00000086   0x2E01             CMP      R6,#+1
   \   00000088   0xD014             BEQ.N    ??I2C_RequestMemoryWrite_6
   3422            {
   3423              /* Send Memory Address */
   3424              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   3425            }
   3426            /* If Memory address size is 16Bit */
   3427            else
   3428            {
   3429              /* Send MSB of Memory Address */
   3430              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \   0000008A   0x0A28             LSRS     R0,R5,#+8
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6108             STR      R0,[R1, #+16]
   3431          
   3432              /* Wait until TXE flag is set */
   3433              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   00000090   0x4639             MOV      R1,R7
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD00B             BEQ.N    ??I2C_RequestMemoryWrite_6
   3434              {
   3435                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000009C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000009E   0x2804             CMP      R0,#+4
   \   000000A0   0xD106             BNE.N    ??I2C_RequestMemoryWrite_7
   3436                {
   3437                  /* Generate Stop */
   3438                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000AA   0x6001             STR      R1,[R0, #+0]
   3439                  return HAL_ERROR;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE005             B.N      ??I2C_RequestMemoryWrite_1
   3440                }
   3441                else
   3442                {
   3443                  return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_7: (+1)
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0xE003             B.N      ??I2C_RequestMemoryWrite_1
   3444                }
   3445              }
   3446          
   3447              /* Send LSB of Memory Address */
   3448              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_6: (+1)
   \   000000B4   0xB2ED             UXTB     R5,R5
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6105             STR      R5,[R0, #+16]
   3449            }
   3450          
   3451            return HAL_OK;
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \   000000BC   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3452          }
   3453          
   3454          /**
   3455            * @brief  Master sends target device address followed by internal memory address for read request.
   3456            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3457            *                the configuration information for the specified I2C.
   3458            * @param  DevAddress Target device address
   3459            * @param  MemAddress Internal memory address
   3460            * @param  MemAddSize Size of internal memory address
   3461            * @param  Timeout Timeout duration
   3462            * @retval HAL status
   3463            */

   \                                 In section .text, align 2, keep-with-next
   3464          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3465          {
   \                     I2C_RequestMemoryRead: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   3466            /* Enable Acknowledge */
   3467            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000014   0x6001             STR      R1,[R0, #+0]
   3468          
   3469            /* Generate Start */
   3470            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   \   00000020   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   3471          
   3472            /* Wait until SB flag is set */
   3473            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   00000024   0x4643             MOV      R3,R8
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0xF04F 0x1101      MOV      R1,#+65537
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD001             BEQ.N    ??I2C_RequestMemoryRead_0
   3474            {
   3475              return HAL_TIMEOUT;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xE07B             B.N      ??I2C_RequestMemoryRead_1
   3476            }
   3477          
   3478            /* Send slave address */
   3479            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \   0000003A   0xF005 0x00FE      AND      R0,R5,#0xFE
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x6108             STR      R0,[R1, #+16]
   3480          
   3481            /* Wait until ADDR flag is set */
   3482            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000042   0x.... 0x....      LDR.W    R9,??DataTable26_1  ;; 0x10002
   \   00000046   0x4642             MOV      R2,R8
   \   00000048   0x4649             MOV      R1,R9
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD006             BEQ.N    ??I2C_RequestMemoryRead_2
   3483            {
   3484              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000054   0x6BA0             LDR      R0,[R4, #+56]
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD101             BNE.N    ??I2C_RequestMemoryRead_3
   3485              {
   3486                return HAL_ERROR;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE069             B.N      ??I2C_RequestMemoryRead_1
   3487              }
   3488              else
   3489              {
   3490                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_3: (+1)
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xE067             B.N      ??I2C_RequestMemoryRead_1
   3491              }
   3492            }
   3493          
   3494            /* Clear ADDR flag */
   3495            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6941             LDR      R1,[R0, #+20]
   \   00000066   0x9100             STR      R1,[SP, #+0]
   \   00000068   0x6980             LDR      R0,[R0, #+24]
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   3496          
   3497            /* Wait until TXE flag is set */
   3498            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   0000006E   0x4641             MOV      R1,R8
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD00B             BEQ.N    ??I2C_RequestMemoryRead_4
   3499            {
   3500              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000007C   0x2804             CMP      R0,#+4
   \   0000007E   0xD106             BNE.N    ??I2C_RequestMemoryRead_5
   3501              {
   3502                /* Generate Stop */
   3503                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000088   0x6001             STR      R1,[R0, #+0]
   3504                return HAL_ERROR;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE051             B.N      ??I2C_RequestMemoryRead_1
   3505              }
   3506              else
   3507              {
   3508                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_5: (+1)
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0xE04F             B.N      ??I2C_RequestMemoryRead_1
   3509              }
   3510            }
   3511          
   3512            /* If Memory address size is 8Bit */
   3513            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryRead_4: (+1)
   \   00000092   0x2F01             CMP      R7,#+1
   \   00000094   0xD014             BEQ.N    ??I2C_RequestMemoryRead_6
   3514            {
   3515              /* Send Memory Address */
   3516              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   3517            }
   3518            /* If Memory address size is 16Bit */
   3519            else
   3520            {
   3521              /* Send MSB of Memory Address */
   3522              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \   00000096   0x0A30             LSRS     R0,R6,#+8
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x6108             STR      R0,[R1, #+16]
   3523          
   3524              /* Wait until TXE flag is set */
   3525              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   0000009C   0x4641             MOV      R1,R8
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD00B             BEQ.N    ??I2C_RequestMemoryRead_6
   3526              {
   3527                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000A8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000AA   0x2804             CMP      R0,#+4
   \   000000AC   0xD106             BNE.N    ??I2C_RequestMemoryRead_7
   3528                {
   3529                  /* Generate Stop */
   3530                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000B6   0x6001             STR      R1,[R0, #+0]
   3531                  return HAL_ERROR;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE03A             B.N      ??I2C_RequestMemoryRead_1
   3532                }
   3533                else
   3534                {
   3535                  return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_7: (+1)
   \   000000BC   0x2003             MOVS     R0,#+3
   \   000000BE   0xE038             B.N      ??I2C_RequestMemoryRead_1
   3536                }
   3537              }
   3538          
   3539              /* Send LSB of Memory Address */
   3540              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_6: (+1)
   \   000000C0   0xB2F6             UXTB     R6,R6
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6106             STR      R6,[R0, #+16]
   3541            }
   3542          
   3543            /* Wait until TXE flag is set */
   3544            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   000000C6   0x4641             MOV      R1,R8
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD00B             BEQ.N    ??I2C_RequestMemoryRead_8
   3545            {
   3546              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000D2   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D4   0x2804             CMP      R0,#+4
   \   000000D6   0xD106             BNE.N    ??I2C_RequestMemoryRead_9
   3547              {
   3548                /* Generate Stop */
   3549                SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000E0   0x6001             STR      R1,[R0, #+0]
   3550                return HAL_ERROR;
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE025             B.N      ??I2C_RequestMemoryRead_1
   3551              }
   3552              else
   3553              {
   3554                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_9: (+1)
   \   000000E6   0x2003             MOVS     R0,#+3
   \   000000E8   0xE023             B.N      ??I2C_RequestMemoryRead_1
   3555              }
   3556            }
   3557          
   3558            /* Generate Restart */
   3559            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??I2C_RequestMemoryRead_8: (+1)
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6801             LDR      R1,[R0, #+0]
   \   000000EE   0xF441 0x7180      ORR      R1,R1,#0x100
   \   000000F2   0x6001             STR      R1,[R0, #+0]
   3560          
   3561            /* Wait until SB flag is set */
   3562            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout) != HAL_OK)
   \   000000F4   0x4643             MOV      R3,R8
   \   000000F6   0x2200             MOVS     R2,#+0
   \   000000F8   0xF04F 0x1101      MOV      R1,#+65537
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD001             BEQ.N    ??I2C_RequestMemoryRead_10
   3563            {
   3564              return HAL_TIMEOUT;
   \   00000106   0x2003             MOVS     R0,#+3
   \   00000108   0xE013             B.N      ??I2C_RequestMemoryRead_1
   3565            }
   3566          
   3567            /* Send slave address */
   3568            hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \                     ??I2C_RequestMemoryRead_10: (+1)
   \   0000010A   0xF045 0x0001      ORR      R0,R5,#0x1
   \   0000010E   0xB2C0             UXTB     R0,R0
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6108             STR      R0,[R1, #+16]
   3569          
   3570            /* Wait until ADDR flag is set */
   3571            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout) != HAL_OK)
   \   00000114   0x4642             MOV      R2,R8
   \   00000116   0x4649             MOV      R1,R9
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD006             BEQ.N    ??I2C_RequestMemoryRead_11
   3572            {
   3573              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000122   0x6BA0             LDR      R0,[R4, #+56]
   \   00000124   0x2804             CMP      R0,#+4
   \   00000126   0xD101             BNE.N    ??I2C_RequestMemoryRead_12
   3574              {
   3575                return HAL_ERROR;
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0xE002             B.N      ??I2C_RequestMemoryRead_1
   3576              }
   3577              else
   3578              {
   3579                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_12: (+1)
   \   0000012C   0x2003             MOVS     R0,#+3
   \   0000012E   0xE000             B.N      ??I2C_RequestMemoryRead_1
   3580              }
   3581            }
   3582          
   3583            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_11: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \   00000132   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   3584          }
   3585          
   3586          /**
   3587            * @brief  DMA I2C master transmit process complete callback.
   3588            * @param  hdma: DMA handle
   3589            * @retval None
   3590            */

   \                                 In section .text, align 2, keep-with-next
   3591          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
   3592          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3593            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   3594          
   3595            /* Wait until BTF flag is reset */
   3596            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000004   0x2323             MOVS     R3,#+35
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable26_2  ;; 0x10004
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??I2C_DMAMasterTransmitCplt_0
   3597            {
   3598              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000014   0x6BA0             LDR      R0,[R4, #+56]
   \   00000016   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000001A   0x63A0             STR      R0,[R4, #+56]
   3599            }
   3600          
   3601            /* Generate Stop */
   3602            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000024   0x6001             STR      R1,[R0, #+0]
   3603          
   3604            /* Disable DMA Request */
   3605            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000002E   0x6041             STR      R1,[R0, #+4]
   3606          
   3607            hi2c->XferCount = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x8560             STRH     R0,[R4, #+42]
   3608          
   3609            hi2c->State = HAL_I2C_STATE_READY;
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0xF884 0x0035      STRB     R0,[R4, #+53]
   3610            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0036      STRB     R0,[R4, #+54]
   3611          
   3612            /* Check if Errors has been detected during transfer */
   3613            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000040   0x6BA0             LDR      R0,[R4, #+56]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xD002             BEQ.N    ??I2C_DMAMasterTransmitCplt_1
   3614            {
   3615              HAL_I2C_ErrorCallback(hi2c);
   \   00000048   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000004C   0xBD10             POP      {R4,PC}
   3616            }
   3617            else
   3618            {
   3619              HAL_I2C_MasterTxCpltCallback(hi2c);
   \                     ??I2C_DMAMasterTransmitCplt_1: (+1)
   \   0000004E   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   3620            }
   3621          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   3622          
   3623          /**
   3624            * @brief  DMA I2C slave transmit process complete callback.
   3625            * @param  hdma: DMA handle
   3626            * @retval None
   3627            */

   \                                 In section .text, align 2, keep-with-next
   3628          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
   3629          {
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3630            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   3631          
   3632            /* Wait until AF flag is reset */
   3633            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000004   0x2323             MOVS     R3,#+35
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xF44F 0x3182      MOV      R1,#+66560
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??I2C_DMASlaveTransmitCplt_0
   3634            {
   3635              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000016   0x6BA0             LDR      R0,[R4, #+56]
   \   00000018   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000001C   0x63A0             STR      R0,[R4, #+56]
   3636            }
   3637          
   3638            /* Clear AF flag */
   3639            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6941             LDR      R1,[R0, #+20]
   \   00000022   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000026   0x6141             STR      R1,[R0, #+20]
   3640          
   3641            /* Disable Address Acknowledge */
   3642            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000030   0x6001             STR      R1,[R0, #+0]
   3643          
   3644            /* Disable DMA Request */
   3645            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6841             LDR      R1,[R0, #+4]
   \   00000036   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000003A   0x6041             STR      R1,[R0, #+4]
   3646          
   3647            hi2c->XferCount = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x8560             STRH     R0,[R4, #+42]
   3648          
   3649            hi2c->State = HAL_I2C_STATE_READY;
   \   00000040   0x2020             MOVS     R0,#+32
   \   00000042   0xF884 0x0035      STRB     R0,[R4, #+53]
   3650            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF884 0x0036      STRB     R0,[R4, #+54]
   3651          
   3652            /* Check if Errors has been detected during transfer */
   3653            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xD002             BEQ.N    ??I2C_DMASlaveTransmitCplt_1
   3654            {
   3655              HAL_I2C_ErrorCallback(hi2c);
   \   00000054   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000058   0xBD10             POP      {R4,PC}
   3656            }
   3657            else
   3658            {
   3659              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \                     ??I2C_DMASlaveTransmitCplt_1: (+1)
   \   0000005A   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   3660            }
   3661          }
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
   3662          
   3663          /**
   3664            * @brief  DMA I2C master receive process complete callback
   3665            * @param  hdma: DMA handle
   3666            * @retval None
   3667            */

   \                                 In section .text, align 2, keep-with-next
   3668          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
   3669          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3670            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   3671          
   3672            /* Disable Acknowledge */
   3673            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   3674          
   3675            /* Generate Stop */
   3676            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000016   0x600A             STR      R2,[R1, #+0]
   3677          
   3678            /* Disable Last DMA */
   3679            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x684A             LDR      R2,[R1, #+4]
   \   0000001C   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000020   0x604A             STR      R2,[R1, #+4]
   3680          
   3681            /* Disable DMA Request */
   3682            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x684A             LDR      R2,[R1, #+4]
   \   00000026   0xF422 0x6200      BIC      R2,R2,#0x800
   \   0000002A   0x604A             STR      R2,[R1, #+4]
   3683          
   3684            hi2c->XferCount = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x8541             STRH     R1,[R0, #+42]
   3685          
   3686            hi2c->State = HAL_I2C_STATE_READY;
   \   00000030   0x2120             MOVS     R1,#+32
   \   00000032   0xF880 0x1035      STRB     R1,[R0, #+53]
   3687            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF880 0x1036      STRB     R1,[R0, #+54]
   3688          
   3689            /* Check if Errors has been detected during transfer */
   3690            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000003C   0x6B81             LDR      R1,[R0, #+56]
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD002             BEQ.N    ??I2C_DMAMasterReceiveCplt_0
   3691            {
   3692              HAL_I2C_ErrorCallback(hi2c);
   \   00000042   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000046   0xBD01             POP      {R0,PC}
   3693            }
   3694            else
   3695            {
   3696              HAL_I2C_MasterRxCpltCallback(hi2c);
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \   00000048   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   3697            }
   3698          }
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return
   3699          
   3700          /**
   3701            * @brief  DMA I2C slave receive process complete callback.
   3702            * @param  hdma: DMA handle
   3703            * @retval None
   3704            */

   \                                 In section .text, align 2, keep-with-next
   3705          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
   3706          {
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   3707            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A44             LDR      R4,[R0, #+36]
   3708          
   3709            /* Wait until STOPF flag is reset */
   3710            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000006   0x2123             MOVS     R1,#+35
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00A             BEQ.N    ??I2C_DMASlaveReceiveCplt_0
   3711            {
   3712              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000012   0x6BA0             LDR      R0,[R4, #+56]
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0x6BA0             LDR      R0,[R4, #+56]
   \   00000018   0xD103             BNE.N    ??I2C_DMASlaveReceiveCplt_1
   3713              {
   3714                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   0000001A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000001E   0x63A0             STR      R0,[R4, #+56]
   \   00000020   0xE002             B.N      ??I2C_DMASlaveReceiveCplt_0
   3715              }
   3716              else
   3717              {
   3718                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_DMASlaveReceiveCplt_1: (+1)
   \   00000022   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000026   0x63A0             STR      R0,[R4, #+56]
   3719              }
   3720            }
   3721          
   3722            /* Clear STOPF flag */
   3723            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6941             LDR      R1,[R0, #+20]
   \   0000002C   0x9100             STR      R1,[SP, #+0]
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000034   0x6001             STR      R1,[R0, #+0]
   \   00000036   0x9100             STR      R1,[SP, #+0]
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   3724          
   3725            /* Disable Address Acknowledge */
   3726            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000042   0x6001             STR      R1,[R0, #+0]
   3727          
   3728            /* Disable DMA Request */
   3729            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6841             LDR      R1,[R0, #+4]
   \   00000048   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004C   0x6041             STR      R1,[R0, #+4]
   3730          
   3731            hi2c->XferCount = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x8560             STRH     R0,[R4, #+42]
   3732          
   3733            hi2c->State = HAL_I2C_STATE_READY;
   \   00000052   0x2020             MOVS     R0,#+32
   \   00000054   0xF884 0x0035      STRB     R0,[R4, #+53]
   3734            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x0036      STRB     R0,[R4, #+54]
   3735          
   3736            /* Check if Errors has been detected during transfer */
   3737            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000005E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0xD002             BEQ.N    ??I2C_DMASlaveReceiveCplt_2
   3738            {
   3739              HAL_I2C_ErrorCallback(hi2c);
   \   00000066   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000006A   0xBD13             POP      {R0,R1,R4,PC}
   3740            }
   3741            else
   3742            {
   3743              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \                     ??I2C_DMASlaveReceiveCplt_2: (+1)
   \   0000006C   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   3744            }
   3745          }
   \   00000070   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   3746          
   3747          /**
   3748            * @brief  DMA I2C Memory Write process complete callback
   3749            * @param  hdma: DMA handle
   3750            * @retval None
   3751            */

   \                                 In section .text, align 4, keep-with-next
   3752          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)
   3753          {
   \                     I2C_DMAMemTransmitCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3754            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   3755          
   3756            /* Wait until BTF flag is reset */
   3757            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000004   0x2323             MOVS     R3,#+35
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable26_2  ;; 0x10004
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??I2C_DMAMemTransmitCplt_0
   3758            {
   3759              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000014   0x6BA0             LDR      R0,[R4, #+56]
   \   00000016   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000001A   0x63A0             STR      R0,[R4, #+56]
   3760            }
   3761          
   3762            /* Generate Stop */
   3763            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??I2C_DMAMemTransmitCplt_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000024   0x6001             STR      R1,[R0, #+0]
   3764          
   3765            /* Disable DMA Request */
   3766            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000002E   0x6041             STR      R1,[R0, #+4]
   3767          
   3768            hi2c->XferCount = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x8560             STRH     R0,[R4, #+42]
   3769          
   3770            hi2c->State = HAL_I2C_STATE_READY;
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0xF884 0x0035      STRB     R0,[R4, #+53]
   3771            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0036      STRB     R0,[R4, #+54]
   3772          
   3773            /* Check if Errors has been detected during transfer */
   3774            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000040   0x6BA0             LDR      R0,[R4, #+56]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xD002             BEQ.N    ??I2C_DMAMemTransmitCplt_1
   3775            {
   3776              HAL_I2C_ErrorCallback(hi2c);
   \   00000048   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000004C   0xBD10             POP      {R4,PC}
   3777            }
   3778            else
   3779            {
   3780              HAL_I2C_MemTxCpltCallback(hi2c);
   \                     ??I2C_DMAMemTransmitCplt_1: (+1)
   \   0000004E   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   3781            }
   3782          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   3783          
   3784          /**
   3785            * @brief  DMA I2C Memory Read process complete callback
   3786            * @param  hdma: DMA handle
   3787            * @retval None
   3788            */

   \                                 In section .text, align 4, keep-with-next
   3789          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)
   3790          {
   \                     I2C_DMAMemReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3791            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   3792          
   3793            /* Disable Acknowledge */
   3794            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   3795          
   3796            /* Generate Stop */
   3797            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000016   0x600A             STR      R2,[R1, #+0]
   3798          
   3799            /* Disable Last DMA */
   3800            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x684A             LDR      R2,[R1, #+4]
   \   0000001C   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000020   0x604A             STR      R2,[R1, #+4]
   3801          
   3802            /* Disable DMA Request */
   3803            CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x684A             LDR      R2,[R1, #+4]
   \   00000026   0xF422 0x6200      BIC      R2,R2,#0x800
   \   0000002A   0x604A             STR      R2,[R1, #+4]
   3804          
   3805            hi2c->XferCount = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x8541             STRH     R1,[R0, #+42]
   3806          
   3807            hi2c->State = HAL_I2C_STATE_READY;
   \   00000030   0x2120             MOVS     R1,#+32
   \   00000032   0xF880 0x1035      STRB     R1,[R0, #+53]
   3808            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF880 0x1036      STRB     R1,[R0, #+54]
   3809          
   3810            /* Check if Errors has been detected during transfer */
   3811            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000003C   0x6B81             LDR      R1,[R0, #+56]
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD002             BEQ.N    ??I2C_DMAMemReceiveCplt_0
   3812            {
   3813              HAL_I2C_ErrorCallback(hi2c);
   \   00000042   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000046   0xBD01             POP      {R0,PC}
   3814            }
   3815            else
   3816            {
   3817              HAL_I2C_MemRxCpltCallback(hi2c);
   \                     ??I2C_DMAMemReceiveCplt_0: (+1)
   \   00000048   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   3818            }
   3819          }
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return
   3820          
   3821          /**
   3822            * @brief  I2C Configuration Speed function
   3823            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3824            *                the configuration information for the specified I2C.
   3825            * @param  I2CClkSrcFreq: PCLK frequency from RCC.
   3826            * @retval CCR Speed: Speed to set in I2C CCR Register
   3827            */

   \                                 In section .text, align 2, keep-with-next
   3828          static uint32_t I2C_Configure_Speed(I2C_HandleTypeDef *hi2c, uint32_t I2CClkSrcFreq)
   3829          {
   3830            uint32_t tmp1 = 0;
   3831            
   3832            /* Clock Standard Mode */
   3833            if(hi2c->Init.ClockSpeed <= I2C_STANDARD_MODE_MAX_CLK)
   \                     I2C_Configure_Speed: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0x....             LDR.N    R3,??DataTable26_3  ;; 0x186a1
   \   00000004   0x429A             CMP      R2,R3
   \   00000006   0xD208             BCS.N    ??I2C_Configure_Speed_0
   3834            {
   3835              /* Calculate Value to be set in CCR register */
   3836              tmp1 = (I2CClkSrcFreq/(hi2c->Init.ClockSpeed << 1));
   \   00000008   0x0050             LSLS     R0,R2,#+1
   \   0000000A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   3837              
   3838              /* The minimum allowed value set in CCR register is 0x04 for Standard Mode */
   3839              if( (tmp1 & I2C_CCR_CCR) < 4 )
   \   0000000E   0x0501             LSLS     R1,R0,#+20
   \   00000010   0x0D09             LSRS     R1,R1,#+20
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD214             BCS.N    ??I2C_Configure_Speed_1
   3840              {
   3841                return 4;
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x4770             BX       LR
   3842              }
   3843              else
   3844              {
   3845                return tmp1;
   3846              }
   3847            }
   3848            else
   3849            {
   3850              /* Clock Fast Mode */
   3851              tmp1 = I2C_CCR_FS;
   3852              
   3853              /* Duty Cylce tLow/tHigh = 2 */
   3854              if(hi2c->Init.DutyCycle == I2C_DUTYCYCLE_2)
   \                     ??I2C_Configure_Speed_0: (+1)
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD106             BNE.N    ??I2C_Configure_Speed_2
   3855              {
   3856                tmp1 |= (I2CClkSrcFreq/(hi2c->Init.ClockSpeed * 3)) | I2C_DUTYCYCLE_2; 
   \   00000020   0xEB02 0x0042      ADD      R0,R2,R2, LSL #+1
   \   00000024   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000028   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   0000002C   0xE005             B.N      ??I2C_Configure_Speed_3
   3857              }
   3858              else /* Duty Cylce tLow/tHigh = 16/9 */
   3859              {
   3860                tmp1 |= (I2CClkSrcFreq/(hi2c->Init.ClockSpeed * 25)) | I2C_DUTYCYCLE_16_9;
   \                     ??I2C_Configure_Speed_2: (+1)
   \   0000002E   0x2019             MOVS     R0,#+25
   \   00000030   0x4350             MULS     R0,R0,R2
   \   00000032   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000036   0xF440 0x4040      ORR      R0,R0,#0xC000
   3861              }
   3862          
   3863              /* The minimum allowed value set in CCR register is 0x01 for Fast Mode */
   3864              if( (tmp1 & I2C_CCR_CCR) < 1 )
   \                     ??I2C_Configure_Speed_3: (+1)
   \   0000003A   0x0501             LSLS     R1,R0,#+20
   \   0000003C   0xD100             BNE.N    ??I2C_Configure_Speed_1
   3865              {
   3866                return 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   3867              }
   3868              else
   3869              {
   3870                return tmp1;
   \                     ??I2C_Configure_Speed_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   3871              }
   3872            }
   3873          }
   3874          
   3875          /**
   3876            * @brief  DMA I2C communication error callback.
   3877            * @param  hdma: DMA handle
   3878            * @retval None
   3879            */

   \                                 In section .text, align 4, keep-with-next
   3880          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   3881          {
   \                     I2C_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3882            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   3883          
   3884            /* Disable Acknowledge */
   3885            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   3886          
   3887            hi2c->XferCount = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8541             STRH     R1,[R0, #+42]
   3888          
   3889            hi2c->State = HAL_I2C_STATE_READY;
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0xF880 0x1035      STRB     R1,[R0, #+53]
   3890            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xF880 0x1036      STRB     R1,[R0, #+54]
   3891          
   3892            hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \   0000001E   0x6B81             LDR      R1,[R0, #+56]
   \   00000020   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000024   0x6381             STR      R1,[R0, #+56]
   3893          
   3894            HAL_I2C_ErrorCallback(hi2c);
   \   00000026   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3895          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
   3896          
   3897          /**
   3898            * @brief  This function handles I2C Communication Timeout.
   3899            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3900            *                the configuration information for the specified I2C.
   3901            * @param  Flag: specifies the I2C flag to check.
   3902            * @param  Status: The new Flag status (SET or RESET).
   3903            * @param  Timeout Timeout duration
   3904            * @retval HAL status
   3905            */

   \                                 In section .text, align 2, keep-with-next
   3906          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   3907          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x461E             MOV      R6,R3
   3908            uint32_t tickstart = 0;
   3909          
   3910            /* Get tick */
   3911            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xEA4F 0x4815      LSR      R8,R5,#+16
   \   00000016   0xFA5F 0xF888      UXTB     R8,R8
   \   0000001A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001E   0xD123             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   3912          
   3913            /* Wait until flag is set */
   3914            if(Status == RESET)
   3915            {
   3916              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000026   0xD109             BNE.N    ??I2C_WaitOnFlagUntilTimeout_2
   \   00000028   0x6940             LDR      R0,[R0, #+20]
   \   0000002A   0x4028             ANDS     R0,R5,R0
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0xB2A9             UXTH     R1,R5
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_3
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE00A             B.N      ??I2C_WaitOnFlagUntilTimeout_4
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE008             B.N      ??I2C_WaitOnFlagUntilTimeout_4
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x4028             ANDS     R0,R5,R0
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0xB2A9             UXTH     R1,R5
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_5
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_4
   \                     ??I2C_WaitOnFlagUntilTimeout_5: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_4: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD135             BNE.N    ??I2C_WaitOnFlagUntilTimeout_6
   3917              {
   3918                /* Check for the Timeout */
   3919                if(Timeout != HAL_MAX_DELAY)
   \   00000052   0xF116 0x0F01      CMN      R6,#+1
   \   00000056   0xD0E3             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_1
   3920                {
   3921                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD028             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_7
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x1BC0             SUBS     R0,R0,R7
   \   00000062   0x4286             CMP      R6,R0
   \   00000064   0xD2DC             BCS.N    ??I2C_WaitOnFlagUntilTimeout_1
   \   00000066   0xE022             B.N      ??I2C_WaitOnFlagUntilTimeout_7
   3922                  {
   3923                    hi2c->State= HAL_I2C_STATE_READY;
   3924          
   3925                    /* Process Unlocked */
   3926                    __HAL_UNLOCK(hi2c);
   3927          
   3928                    return HAL_TIMEOUT;
   3929                  }
   3930                }
   3931              }
   3932            }
   3933            else
   3934            {
   3935              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000006E   0xD109             BNE.N    ??I2C_WaitOnFlagUntilTimeout_8
   \   00000070   0x6940             LDR      R0,[R0, #+20]
   \   00000072   0x4028             ANDS     R0,R5,R0
   \   00000074   0xB280             UXTH     R0,R0
   \   00000076   0xB2A9             UXTH     R1,R5
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_9
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE00A             B.N      ??I2C_WaitOnFlagUntilTimeout_10
   \                     ??I2C_WaitOnFlagUntilTimeout_9: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE008             B.N      ??I2C_WaitOnFlagUntilTimeout_10
   \                     ??I2C_WaitOnFlagUntilTimeout_8: (+1)
   \   00000084   0x6980             LDR      R0,[R0, #+24]
   \   00000086   0x4028             ANDS     R0,R5,R0
   \   00000088   0xB280             UXTH     R0,R0
   \   0000008A   0xB2A9             UXTH     R1,R5
   \   0000008C   0x4288             CMP      R0,R1
   \   0000008E   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_11
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_10
   \                     ??I2C_WaitOnFlagUntilTimeout_11: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_10: (+1)
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD011             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_6
   3936              {
   3937                /* Check for the Timeout */
   3938                if(Timeout != HAL_MAX_DELAY)
   \   0000009A   0xF116 0x0F01      CMN      R6,#+1
   \   0000009E   0xD0E3             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   3939                {
   3940                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   000000A0   0x2E00             CMP      R6,#+0
   \   000000A2   0xD004             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_7
   \   000000A4   0x.... 0x....      BL       HAL_GetTick
   \   000000A8   0x1BC0             SUBS     R0,R0,R7
   \   000000AA   0x4286             CMP      R6,R0
   \   000000AC   0xD2DC             BCS.N    ??I2C_WaitOnFlagUntilTimeout_0
   3941                  {
   3942                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_WaitOnFlagUntilTimeout_7: (+1)
   \   000000AE   0x2020             MOVS     R0,#+32
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3943          
   3944                    /* Process Unlocked */
   3945                    __HAL_UNLOCK(hi2c);
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF884 0x0034      STRB     R0,[R4, #+52]
   3946          
   3947                    return HAL_TIMEOUT;
   \   000000BA   0x2003             MOVS     R0,#+3
   \   000000BC   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_12
   3948                  }
   3949                }
   3950              }
   3951            }
   3952            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_6: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_12: (+1)
   \   000000C0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   3953          }
   3954          
   3955          /**
   3956            * @brief  This function handles I2C Communication Timeout for Master addressing phase.
   3957            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3958            *                the configuration information for the specified I2C.
   3959            * @param  Flag: specifies the I2C flag to check.
   3960            * @param  Timeout Timeout duration
   3961            * @retval HAL status
   3962            */

   \                                 In section .text, align 2, keep-with-next
   3963          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout)
   3964          {
   \                     I2C_WaitOnMasterAddressFlagUntilTimeout: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   3965            uint32_t tickstart = 0;
   3966          
   3967            /* Get tick */
   3968            tickstart = HAL_GetTick();
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x4607             MOV      R7,R0
   3969          
   3970            while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x0C29             LSRS     R1,R5,#+16
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD109             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_1
   \   00000018   0x6941             LDR      R1,[R0, #+20]
   \   0000001A   0x4029             ANDS     R1,R5,R1
   \   0000001C   0xB289             UXTH     R1,R1
   \   0000001E   0xB2AA             UXTH     R2,R5
   \   00000020   0x4291             CMP      R1,R2
   \   00000022   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_2
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xE00A             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_2: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xE008             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_1: (+1)
   \   0000002C   0x6981             LDR      R1,[R0, #+24]
   \   0000002E   0x4029             ANDS     R1,R5,R1
   \   00000030   0xB289             UXTH     R1,R1
   \   00000032   0xB2AA             UXTH     R2,R5
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_4
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xE000             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_4: (+1)
   \   0000003C   0x2100             MOVS     R1,#+0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_3: (+1)
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD127             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_5
   3971            {
   3972              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   00000042   0x6941             LDR      R1,[R0, #+20]
   \   00000044   0x0549             LSLS     R1,R1,#+21
   \   00000046   0xD512             BPL.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_6
   3973              {
   3974                /* Generate Stop */
   3975                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   3976          
   3977                /* Clear AF Flag */
   3978                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6941             LDR      R1,[R0, #+20]
   \   00000054   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000058   0x6141             STR      R1,[R0, #+20]
   3979          
   3980                hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x63A0             STR      R0,[R4, #+56]
   3981                hi2c->State= HAL_I2C_STATE_READY;
   \   0000005E   0x2020             MOVS     R0,#+32
   \   00000060   0xF884 0x0035      STRB     R0,[R4, #+53]
   3982          
   3983                /* Process Unlocked */
   3984                __HAL_UNLOCK(hi2c);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x0034      STRB     R0,[R4, #+52]
   3985          
   3986                return HAL_ERROR;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}
   3987              }
   3988          
   3989              /* Check for the Timeout */
   3990              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_6: (+1)
   \   0000006E   0xF116 0x0F01      CMN      R6,#+1
   \   00000072   0xD0CC             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   3991              {
   3992                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD004             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_7
   \   00000078   0x.... 0x....      BL       HAL_GetTick
   \   0000007C   0x1BC0             SUBS     R0,R0,R7
   \   0000007E   0x4286             CMP      R6,R0
   \   00000080   0xD2C5             BCS.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   3993                {
   3994                  hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_7: (+1)
   \   00000082   0x2020             MOVS     R0,#+32
   \   00000084   0xF884 0x0035      STRB     R0,[R4, #+53]
   3995          
   3996                  /* Process Unlocked */
   3997                  __HAL_UNLOCK(hi2c);
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0034      STRB     R0,[R4, #+52]
   3998          
   3999                  return HAL_TIMEOUT;
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}
   4000                }
   4001              }
   4002            }
   4003            return HAL_OK;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_5: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4004          }
   4005          
   4006          /**
   4007            * @brief  This function handles I2C Communication Timeout for specific usage of TXE flag.
   4008            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4009            *                the configuration information for the specified I2C.
   4010            * @param  Timeout Timeout duration
   4011            * @retval HAL status
   4012            */

   \                                 In section .text, align 2, keep-with-next
   4013          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
   4014          {  
   \                     I2C_WaitOnTXEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4015            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4016            
   4017            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
   \   00000010   0x0600             LSLS     R0,R0,#+24
   \   00000012   0xD41C             BMI.N    ??I2C_WaitOnTXEFlagUntilTimeout_1
   4018            {
   4019              /* Check if a NACK is detected */
   4020              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_2
   4021              {
   4022                return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
   4023              }
   4024          		
   4025              /* Check for the Timeout */
   4026              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_2: (+1)
   \   00000022   0xF115 0x0F01      CMN      R5,#+1
   \   00000026   0xD0F1             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   4027              {
   4028                if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD004             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_3
   \   0000002C   0x.... 0x....      BL       HAL_GetTick
   \   00000030   0x1B80             SUBS     R0,R0,R6
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD2EA             BCS.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   4029                {
   4030                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_3: (+1)
   \   00000036   0x6BA0             LDR      R0,[R4, #+56]
   \   00000038   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000003C   0x63A0             STR      R0,[R4, #+56]
   4031                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   4032          
   4033                  /* Process Unlocked */
   4034                  __HAL_UNLOCK(hi2c);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
   4035          
   4036                  return HAL_TIMEOUT;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   4037                }
   4038              }
   4039            }
   4040            return HAL_OK;      
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   4041          }
   4042          
   4043          /**
   4044            * @brief  This function handles I2C Communication Timeout for specific usage of BTF flag.
   4045            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4046            *                the configuration information for the specified I2C.
   4047            * @param  Timeout Timeout duration
   4048            * @retval HAL status
   4049            */

   \                                 In section .text, align 2, keep-with-next
   4050          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
   4051          {  
   \                     I2C_WaitOnBTFFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4052            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4053            
   4054            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
   \   00000010   0x0740             LSLS     R0,R0,#+29
   \   00000012   0xD41C             BMI.N    ??I2C_WaitOnBTFFlagUntilTimeout_1
   4055            {
   4056              /* Check if a NACK is detected */
   4057              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_2
   4058              {
   4059                return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
   4060              }
   4061          		
   4062              /* Check for the Timeout */
   4063              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_2: (+1)
   \   00000022   0xF115 0x0F01      CMN      R5,#+1
   \   00000026   0xD0F1             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   4064              {
   4065                if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD004             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_3
   \   0000002C   0x.... 0x....      BL       HAL_GetTick
   \   00000030   0x1B80             SUBS     R0,R0,R6
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD2EA             BCS.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   4066                {
   4067                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_3: (+1)
   \   00000036   0x6BA0             LDR      R0,[R4, #+56]
   \   00000038   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000003C   0x63A0             STR      R0,[R4, #+56]
   4068                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
   4069          
   4070                  /* Process Unlocked */
   4071                  __HAL_UNLOCK(hi2c);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x0034      STRB     R0,[R4, #+52]
   4072          
   4073                  return HAL_TIMEOUT;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   4074                }
   4075              }
   4076            }
   4077            return HAL_OK;      
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   4078          }
   4079          
   4080          /**
   4081            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   4082            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4083            *                the configuration information for the specified I2C.
   4084            * @param  Timeout Timeout duration
   4085            * @retval HAL status
   4086            */

   \                                 In section .text, align 2, keep-with-next
   4087          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4088          {  
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4089            uint32_t tickstart = 0x00;
   4090            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4091            
   4092            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
   \   00000010   0x06C0             LSLS     R0,R0,#+27
   \   00000012   0xD419             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   4093            {
   4094              /* Check if a NACK is detected */
   4095              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_2
   4096              {
   4097                return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
   4098              }
   4099          		
   4100              /* Check for the Timeout */
   4101              if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD004             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_3
   \   00000026   0x.... 0x....      BL       HAL_GetTick
   \   0000002A   0x1B80             SUBS     R0,R0,R6
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD2ED             BCS.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   4102              {
   4103                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_3: (+1)
   \   00000030   0x6BA0             LDR      R0,[R4, #+56]
   \   00000032   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000036   0x63A0             STR      R0,[R4, #+56]
   4104                hi2c->State= HAL_I2C_STATE_READY;
   \   00000038   0x2020             MOVS     R0,#+32
   \   0000003A   0xF884 0x0035      STRB     R0,[R4, #+53]
   4105          
   4106                /* Process Unlocked */
   4107                __HAL_UNLOCK(hi2c);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF884 0x0034      STRB     R0,[R4, #+52]
   4108          
   4109                return HAL_TIMEOUT;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xBD70             POP      {R4-R6,PC}
   4110              }
   4111            }
   4112            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   4113          }
   4114          
   4115          /**
   4116            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   4117            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4118            *                the configuration information for the specified I2C.
   4119            * @param  Timeout Timeout duration
   4120            * @retval HAL status
   4121            */

   \                                 In section .text, align 2, keep-with-next
   4122          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4123          {  
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4124            uint32_t tickstart = 0x00;
   4125            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4126            
   4127            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6941             LDR      R1,[R0, #+20]
   \   00000010   0x0649             LSLS     R1,R1,#+25
   \   00000012   0xD423             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   4128            {
   4129              /* Check if a STOPF is detected */
   4130              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD50D             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_2
   4131              {
   4132                /* Clear STOP Flag */
   4133                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   0000001A   0x6941             LDR      R1,[R0, #+20]
   \   0000001C   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000020   0x6141             STR      R1,[R0, #+20]
   4134          
   4135                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x63A0             STR      R0,[R4, #+56]
   4136                hi2c->State= HAL_I2C_STATE_READY;
   \   00000026   0x2020             MOVS     R0,#+32
   \   00000028   0xF884 0x0035      STRB     R0,[R4, #+53]
   4137          
   4138                /* Process Unlocked */
   4139                __HAL_UNLOCK(hi2c);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
   4140          
   4141                return HAL_ERROR;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD70             POP      {R4-R6,PC}
   4142              }
   4143          		
   4144              /* Check for the Timeout */
   4145              if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD004             BEQ.N    ??I2C_WaitOnRXNEFlagUntilTimeout_3
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x1B80             SUBS     R0,R0,R6
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD2E3             BCS.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   4146              {
   4147                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \   00000044   0x6BA0             LDR      R0,[R4, #+56]
   \   00000046   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000004A   0x63A0             STR      R0,[R4, #+56]
   4148                hi2c->State= HAL_I2C_STATE_READY;
   \   0000004C   0x2020             MOVS     R0,#+32
   \   0000004E   0xF884 0x0035      STRB     R0,[R4, #+53]
   4149          
   4150                /* Process Unlocked */
   4151                __HAL_UNLOCK(hi2c);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF884 0x0034      STRB     R0,[R4, #+52]
   4152          
   4153                return HAL_TIMEOUT;
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xBD70             POP      {R4-R6,PC}
   4154              }
   4155            }
   4156            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   4157          }
   4158          
   4159          /**
   4160            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   4161            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4162            *                the configuration information for the specified I2C.
   4163            * @retval HAL status
   4164            */

   \                                 In section .text, align 2, keep-with-next
   4165          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
   4166          {
   4167            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     I2C_IsAcknowledgeFailed: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x694A             LDR      R2,[R1, #+20]
   \   00000004   0x0552             LSLS     R2,R2,#+21
   \   00000006   0xD50D             BPL.N    ??I2C_IsAcknowledgeFailed_0
   4168            {
   4169              /* Clear NACKF Flag */
   4170              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000008   0x694A             LDR      R2,[R1, #+20]
   \   0000000A   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000000E   0x614A             STR      R2,[R1, #+20]
   4171          
   4172              hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6381             STR      R1,[R0, #+56]
   4173              hi2c->State= HAL_I2C_STATE_READY;
   \   00000014   0x2120             MOVS     R1,#+32
   \   00000016   0xF880 0x1035      STRB     R1,[R0, #+53]
   4174          
   4175              /* Process Unlocked */
   4176              __HAL_UNLOCK(hi2c);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF880 0x1034      STRB     R1,[R0, #+52]
   4177          
   4178              return HAL_ERROR;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4770             BX       LR
   4179            }
   4180            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
   4181          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x00100002         DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x00010004         DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x00100002         DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x00010008         DC32     0x10008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x00010004         DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x000186A1         DC32     0x186a1
   4182          /**
   4183            * @}
   4184            */
   4185          
   4186          #endif /* HAL_I2C_MODULE_ENABLED */
   4187          
   4188          /**
   4189            * @}
   4190            */
   4191          
   4192          /**
   4193            * @}
   4194            */
   4195          
   4196          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       8   HAL_I2C_ER_IRQHandler
         8   -> HAL_I2C_ErrorCallback
         8   -> I2C_Slave_AF
      16   HAL_I2C_EV_IRQHandler
         0   -> I2C_MasterReceive_BTF
         0   -> I2C_MasterReceive_RXNE
         0   -> I2C_MasterTransmit_BTF
         0   -> I2C_MasterTransmit_TXE
         0   -> I2C_SlaveReceive_BTF
         0   -> I2C_SlaveReceive_RXNE
         0   -> I2C_SlaveTransmit_BTF
         0   -> I2C_SlaveTransmit_TXE
         0   -> I2C_Slave_ADDR
         0   -> I2C_Slave_STOPF
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetState
       8   HAL_I2C_Init
         8   -> HAL_I2C_MspInit
         8   -> HAL_RCC_GetPCLK1Freq
         8   -> I2C_Configure_Speed
      40   HAL_I2C_IsDeviceReady
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      32   HAL_I2C_Master_Receive
        32   -> I2C_MasterRequestRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
      24   HAL_I2C_Master_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_MasterRequestRead
        24   -> I2C_WaitOnFlagUntilTimeout
      24   HAL_I2C_Master_Receive_IT
        24   -> I2C_MasterRequestRead
        24   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Master_Transmit
        32   -> I2C_MasterRequestWrite
        32   -> I2C_WaitOnBTFFlagUntilTimeout
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      24   HAL_I2C_Master_Transmit_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_MasterRequestWrite
        24   -> I2C_WaitOnFlagUntilTimeout
      24   HAL_I2C_Master_Transmit_IT
        24   -> I2C_MasterRequestWrite
        24   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnRXNEFlagUntilTimeout
      32   HAL_I2C_Mem_Read_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_RequestMemoryRead
        32   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Mem_Read_IT
        32   -> I2C_RequestMemoryRead
        32   -> I2C_WaitOnFlagUntilTimeout
      40   HAL_I2C_Mem_Write
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      32   HAL_I2C_Mem_Write_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Mem_Write_IT
        32   -> I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Slave_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_WaitOnFlagUntilTimeout
      16   HAL_I2C_Slave_Receive_IT
        16   -> I2C_WaitOnFlagUntilTimeout
      32   HAL_I2C_Slave_Transmit
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      24   HAL_I2C_Slave_Transmit_DMA
        24   -> HAL_DMA_Start_IT
        24   -> I2C_WaitOnFlagUntilTimeout
      16   HAL_I2C_Slave_Transmit_IT
        16   -> I2C_WaitOnFlagUntilTimeout
       0   I2C_Configure_Speed
       8   I2C_DMAError
         8   -> HAL_I2C_ErrorCallback
       8   I2C_DMAMasterReceiveCplt
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_MasterRxCpltCallback
       8   I2C_DMAMasterTransmitCplt
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_MasterTxCpltCallback
         8   -> I2C_WaitOnFlagUntilTimeout
       8   I2C_DMAMemReceiveCplt
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_MemRxCpltCallback
       8   I2C_DMAMemTransmitCplt
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_MemTxCpltCallback
         8   -> I2C_WaitOnFlagUntilTimeout
      16   I2C_DMASlaveReceiveCplt
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> I2C_WaitOnSTOPFlagUntilTimeout
       8   I2C_DMASlaveTransmitCplt
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveTxCpltCallback
         8   -> I2C_WaitOnFlagUntilTimeout
       0   I2C_IsAcknowledgeFailed
       8   I2C_MasterReceive_BTF
         8   -> HAL_I2C_MasterRxCpltCallback
         8   -> HAL_I2C_MemRxCpltCallback
       8   I2C_MasterReceive_RXNE
         8   -> HAL_I2C_MasterRxCpltCallback
         8   -> HAL_I2C_MemRxCpltCallback
      24   I2C_MasterRequestRead
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnMasterAddressFlagUntilTimeout
      16   I2C_MasterRequestWrite
        16   -> I2C_WaitOnFlagUntilTimeout
        16   -> I2C_WaitOnMasterAddressFlagUntilTimeout
       8   I2C_MasterTransmit_BTF
         8   -> HAL_I2C_MasterTxCpltCallback
         8   -> HAL_I2C_MemTxCpltCallback
       0   I2C_MasterTransmit_TXE
      32   I2C_RequestMemoryRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
       0   I2C_SlaveReceive_BTF
       0   I2C_SlaveReceive_RXNE
       0   I2C_SlaveTransmit_BTF
       0   I2C_SlaveTransmit_TXE
       4   I2C_Slave_ADDR
       8   I2C_Slave_AF
         8   -> HAL_I2C_SlaveTxCpltCallback
       8   I2C_Slave_STOPF
         8   -> HAL_I2C_SlaveRxCpltCallback
      16   I2C_WaitOnBTFFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      32   I2C_WaitOnFlagUntilTimeout
        32   -> HAL_GetTick
      24   I2C_WaitOnMasterAddressFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnTXEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable21
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
      50  HAL_I2C_DeInit
     260  HAL_I2C_ER_IRQHandler
     328  HAL_I2C_EV_IRQHandler
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetState
     166  HAL_I2C_Init
     338  HAL_I2C_IsDeviceReady
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
     524  HAL_I2C_Master_Receive
     224  HAL_I2C_Master_Receive_DMA
     252  HAL_I2C_Master_Receive_IT
     288  HAL_I2C_Master_Transmit
     202  HAL_I2C_Master_Transmit_DMA
     172  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     532  HAL_I2C_Mem_Read
     246  HAL_I2C_Mem_Read_DMA
     272  HAL_I2C_Mem_Read_IT
     288  HAL_I2C_Mem_Write
     210  HAL_I2C_Mem_Write_DMA
     180  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     308  HAL_I2C_Slave_Receive
     192  HAL_I2C_Slave_Receive_DMA
     136  HAL_I2C_Slave_Receive_IT
     334  HAL_I2C_Slave_Transmit
     230  HAL_I2C_Slave_Transmit_DMA
     136  HAL_I2C_Slave_Transmit_IT
      66  I2C_Configure_Speed
      44  I2C_DMAError
      78  I2C_DMAMasterReceiveCplt
      84  I2C_DMAMasterTransmitCplt
      78  I2C_DMAMemReceiveCplt
      84  I2C_DMAMemTransmitCplt
     114  I2C_DMASlaveReceiveCplt
      96  I2C_DMASlaveTransmitCplt
      40  I2C_IsAcknowledgeFailed
     154  I2C_MasterReceive_BTF
     110  I2C_MasterReceive_RXNE
     232  I2C_MasterRequestRead
     140  I2C_MasterRequestWrite
      82  I2C_MasterTransmit_BTF
      40  I2C_MasterTransmit_TXE
     310  I2C_RequestMemoryRead
     192  I2C_RequestMemoryWrite
      28  I2C_SlaveReceive_BTF
      28  I2C_SlaveReceive_RXNE
      28  I2C_SlaveTransmit_BTF
      28  I2C_SlaveTransmit_TXE
      20  I2C_Slave_ADDR
      46  I2C_Slave_AF
      54  I2C_Slave_STOPF
      82  I2C_WaitOnBTFFlagUntilTimeout
     196  I2C_WaitOnFlagUntilTimeout
     150  I2C_WaitOnMasterAddressFlagUntilTimeout
      96  I2C_WaitOnRXNEFlagUntilTimeout
      76  I2C_WaitOnSTOPFlagUntilTimeout
      82  I2C_WaitOnTXEFlagUntilTimeout

 
 8 814 bytes in section .text
 
 8 814 bytes of CODE memory

Errors: none
Warnings: none
