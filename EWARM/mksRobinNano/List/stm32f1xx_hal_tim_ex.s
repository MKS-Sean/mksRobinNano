///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       14/Feb/2020  17:06:09
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c
//    Command line =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
//        -lA
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
//        --diag_suppress Pa050 -o
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
//        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\stm32f1xx_hal_tim_ex.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN HAL_DMA_Start_IT
        EXTERN TIM_Base_SetConfig
        EXTERN TIM_CCxChannelCmd
        EXTERN TIM_DMACaptureCplt
        EXTERN TIM_DMADelayPulseCplt
        EXTERN TIM_DMAError
        EXTERN TIM_OC2_SetConfig
        EXTERN TIM_TI1_SetConfig

        PUBWEAK HAL_TIMEx_BreakCallback
        PUBWEAK HAL_TIMEx_CommutationCallback
        PUBLIC HAL_TIMEx_ConfigBreakDeadTime
        PUBLIC HAL_TIMEx_ConfigCommutationEvent
        PUBLIC HAL_TIMEx_ConfigCommutationEvent_DMA
        PUBLIC HAL_TIMEx_ConfigCommutationEvent_IT
        PUBLIC HAL_TIMEx_HallSensor_DeInit
        PUBLIC HAL_TIMEx_HallSensor_GetState
        PUBLIC HAL_TIMEx_HallSensor_Init
        PUBWEAK HAL_TIMEx_HallSensor_MspDeInit
        PUBWEAK HAL_TIMEx_HallSensor_MspInit
        PUBLIC HAL_TIMEx_HallSensor_Start
        PUBLIC HAL_TIMEx_HallSensor_Start_DMA
        PUBLIC HAL_TIMEx_HallSensor_Start_IT
        PUBLIC HAL_TIMEx_HallSensor_Stop
        PUBLIC HAL_TIMEx_HallSensor_Stop_DMA
        PUBLIC HAL_TIMEx_HallSensor_Stop_IT
        PUBLIC HAL_TIMEx_MasterConfigSynchronization
        PUBLIC HAL_TIMEx_OCN_Start
        PUBLIC HAL_TIMEx_OCN_Start_DMA
        PUBLIC HAL_TIMEx_OCN_Start_IT
        PUBLIC HAL_TIMEx_OCN_Stop
        PUBLIC HAL_TIMEx_OCN_Stop_DMA
        PUBLIC HAL_TIMEx_OCN_Stop_IT
        PUBLIC HAL_TIMEx_OnePulseN_Start
        PUBLIC HAL_TIMEx_OnePulseN_Start_IT
        PUBLIC HAL_TIMEx_OnePulseN_Stop
        PUBLIC HAL_TIMEx_OnePulseN_Stop_IT
        PUBLIC HAL_TIMEx_PWMN_Start
        PUBLIC HAL_TIMEx_PWMN_Start_DMA
        PUBLIC HAL_TIMEx_PWMN_Start_IT
        PUBLIC HAL_TIMEx_PWMN_Stop
        PUBLIC HAL_TIMEx_PWMN_Stop_DMA
        PUBLIC HAL_TIMEx_PWMN_Stop_IT
        PUBLIC TIMEx_DMACommutationCplt
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    stm32f1xx_hal_tim_ex.c
//    4   * @author  MCD Application Team
//    5   * @version V1.0.4
//    6   * @date    29-April-2016
//    7   * @brief   TIM HAL module driver.
//    8   *          This file provides firmware functions to manage the following
//    9   *          functionalities of the Timer Extended peripheral:
//   10   *           + Time Hall Sensor Interface Initialization
//   11   *           + Time Hall Sensor Interface Start
//   12   *           + Time Complementary signal bread and dead time configuration
//   13   *           + Time Master and Slave synchronization configuration
//   14   *           + Timer remapping capabilities configuration
//   15   @verbatim
//   16   ==============================================================================
//   17                       ##### TIMER Extended features #####
//   18   ==============================================================================
//   19   [..]
//   20     The Timer Extended features include:
//   21     (#) Complementary outputs with programmable dead-time for :
//   22         (++) Output Compare
//   23         (++) PWM generation (Edge and Center-aligned Mode)
//   24         (++) One-pulse mode output
//   25     (#) Synchronization circuit to control the timer with external signals and to
//   26         interconnect several timers together.
//   27     (#) Break input to put the timer output signals in reset state or in a known state.
//   28     (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
//   29         positioning purposes
//   30 
//   31             ##### How to use this driver #####
//   32   ==============================================================================
//   33     [..]
//   34      (#) Initialize the TIM low level resources by implementing the following functions
//   35          depending from feature used :
//   36            (++) Complementary Output Compare : HAL_TIM_OC_MspInit()
//   37            (++) Complementary PWM generation : HAL_TIM_PWM_MspInit()
//   38            (++) Complementary One-pulse mode output : HAL_TIM_OnePulse_MspInit()
//   39            (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()
//   40 
//   41      (#) Initialize the TIM low level resources :
//   42         (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
//   43         (##) TIM pins configuration
//   44             (+++) Enable the clock for the TIM GPIOs using the following function:
//   45               __HAL_RCC_GPIOx_CLK_ENABLE();
//   46             (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
//   47 
//   48      (#) The external Clock can be configured, if needed (the default clock is the
//   49          internal clock from the APBx), using the following function:
//   50          HAL_TIM_ConfigClockSource, the clock configuration should be done before
//   51          any start function.
//   52 
//   53      (#) Configure the TIM in the desired functioning mode using one of the
//   54          initialization function of this driver:
//   55           (++) HAL_TIMEx_HallSensor_Init and HAL_TIMEx_ConfigCommutationEvent: to use the
//   56               Timer Hall Sensor Interface and the commutation event with the corresponding
//   57               Interrupt and DMA request if needed (Note that One Timer is used to interface
//   58              with the Hall sensor Interface and another Timer should be used to use
//   59              the commutation event).
//   60 
//   61      (#) Activate the TIM peripheral using one of the start functions:
//   62            (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()
//   63            (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
//   64            (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
//   65            (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
//   66 
//   67 
//   68   @endverbatim
//   69   ******************************************************************************
//   70   * @attention
//   71   *
//   72   * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
//   73   *
//   74   * Redistribution and use in source and binary forms, with or without modification,
//   75   * are permitted provided that the following conditions are met:
//   76   *   1. Redistributions of source code must retain the above copyright notice,
//   77   *      this list of conditions and the following disclaimer.
//   78   *   2. Redistributions in binary form must reproduce the above copyright notice,
//   79   *      this list of conditions and the following disclaimer in the documentation
//   80   *      and/or other materials provided with the distribution.
//   81   *   3. Neither the name of STMicroelectronics nor the names of its contributors
//   82   *      may be used to endorse or promote products derived from this software
//   83   *      without specific prior written permission.
//   84   *
//   85   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   86   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   87   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   88   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   89   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   90   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   91   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   92   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   93   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   94   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   95   *
//   96   ******************************************************************************
//   97 */
//   98 
//   99 /* Includes ------------------------------------------------------------------*/
//  100 #include "stm32f1xx_hal.h"
//  101 
//  102 /** @addtogroup STM32F1xx_HAL_Driver
//  103   * @{
//  104   */
//  105 
//  106 /** @defgroup TIMEx TIMEx
//  107   * @brief TIM Extended HAL module driver
//  108   * @{
//  109   */
//  110 
//  111 #ifdef HAL_TIM_MODULE_ENABLED
//  112 
//  113 /* Private typedef -----------------------------------------------------------*/
//  114 /* Private define ------------------------------------------------------------*/
//  115 /* Private macro -------------------------------------------------------------*/
//  116 /* Private variables ---------------------------------------------------------*/
//  117 /* Private function prototypes -----------------------------------------------*/
//  118 
//  119 #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \ 
//  120     defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \ 
//  121     defined (STM32F105xC) || defined (STM32F107xC)
//  122 /** @defgroup TIMEx_Private_Functions TIMEx Private Functions
//  123   * @{
//  124   */
//  125 static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState);
//  126 /**
//  127   * @}
//  128   */
//  129 #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
//  130        /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
//  131        /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
//  132 
//  133 /* Exported functions ---------------------------------------------------------*/
//  134 
//  135 /** @defgroup TIMEx_Exported_Functions TIMEx Exported Functions
//  136   * @{
//  137   */
//  138 
//  139 
//  140 /** @defgroup TIMEx_Exported_Functions_Group1 Timer Hall Sensor functions
//  141  *  @brief    Timer Hall Sensor functions
//  142  *
//  143 @verbatim
//  144   ==============================================================================
//  145                       ##### Timer Hall Sensor functions #####
//  146   ==============================================================================
//  147   [..]
//  148     This section provides functions allowing to:
//  149     (+) Initialize and configure TIM HAL Sensor.
//  150     (+) De-initialize TIM HAL Sensor.
//  151     (+) Start the Hall Sensor Interface.
//  152     (+) Stop the Hall Sensor Interface.
//  153     (+) Start the Hall Sensor Interface and enable interrupts.
//  154     (+) Stop the Hall Sensor Interface and disable interrupts.
//  155     (+) Start the Hall Sensor Interface and enable DMA transfers.
//  156     (+) Stop the Hall Sensor Interface and disable DMA transfers.
//  157 
//  158 @endverbatim
//  159   * @{
//  160   */
//  161 /**
//  162   * @brief  Initializes the TIM Hall Sensor Interface and create the associated handle.
//  163   * @param  htim : TIM Encoder Interface handle
//  164   * @param  sConfig : TIM Hall Sensor configuration structure
//  165   * @retval HAL status
//  166   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Init
        THUMB
//  167 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
//  168 {
HAL_TIMEx_HallSensor_Init:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+28
          CFI CFA R13+40
        MOV      R4,R0
        MOV      R5,R1
//  169   TIM_OC_InitTypeDef OC_Config;
//  170 
//  171   /* Check the TIM handle allocation */
//  172   if(htim == NULL)
        CMP      R4,#+0
        BNE.N    ??HAL_TIMEx_HallSensor_Init_0
//  173   {
//  174     return HAL_ERROR;
        MOVS     R0,#+1
        B.N      ??HAL_TIMEx_HallSensor_Init_1
//  175   }
//  176 
//  177   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  178   assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
//  179   assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
//  180   assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
//  181   assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
//  182   assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
//  183 
//  184   if(htim->State == HAL_TIM_STATE_RESET)
??HAL_TIMEx_HallSensor_Init_0:
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+0
        BNE.N    ??HAL_TIMEx_HallSensor_Init_2
//  185   {
//  186     /* Allocate lock resource and initialize it */
//  187     htim->Lock = HAL_UNLOCKED;
        MOVS     R0,#+0
        STRB     R0,[R4, #+56]
//  188     
//  189     /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
//  190     HAL_TIMEx_HallSensor_MspInit(htim);
        MOV      R0,R4
          CFI FunCall HAL_TIMEx_HallSensor_MspInit
        BL       HAL_TIMEx_HallSensor_MspInit
//  191   }
//  192 
//  193   /* Set the TIM state */
//  194   htim->State= HAL_TIM_STATE_BUSY;
??HAL_TIMEx_HallSensor_Init_2:
        MOVS     R0,#+2
        STRB     R0,[R4, #+57]
//  195 
//  196   /* Configure the Time base in the Encoder Mode */
//  197   TIM_Base_SetConfig(htim->Instance, &htim->Init);
        ADDS     R1,R4,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_Base_SetConfig
        BL       TIM_Base_SetConfig
//  198 
//  199   /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
//  200   TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
        LDR      R3,[R5, #+8]
        MOVS     R2,#+3
        LDR      R1,[R5, #+0]
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_TI1_SetConfig
        BL       TIM_TI1_SetConfig
//  201 
//  202   /* Reset the IC1PSC Bits */
//  203   htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+24]
        BIC      R1,R1,#0xC
        STR      R1,[R0, #+24]
//  204   /* Set the IC1PSC value */
//  205   htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+24]
        LDR      R2,[R5, #+4]
        ORRS     R1,R2,R1
        STR      R1,[R0, #+24]
//  206 
//  207   /* Enable the Hall sensor interface (XOR function of the three inputs) */
//  208   htim->Instance->CR2 |= TIM_CR2_TI1S;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+4]
        ORR      R1,R1,#0x80
        STR      R1,[R0, #+4]
//  209 
//  210   /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
//  211   htim->Instance->SMCR &= ~TIM_SMCR_TS;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+8]
        BIC      R1,R1,#0x70
        STR      R1,[R0, #+8]
//  212   htim->Instance->SMCR |= TIM_TS_TI1F_ED;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+8]
        ORR      R1,R1,#0x40
        STR      R1,[R0, #+8]
//  213 
//  214   /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
//  215   htim->Instance->SMCR &= ~TIM_SMCR_SMS;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+8]
        LSRS     R1,R1,#+3
        LSLS     R1,R1,#+3
        STR      R1,[R0, #+8]
//  216   htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+8]
        ORR      R1,R1,#0x4
        STR      R1,[R0, #+8]
//  217 
//  218   /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
//  219   OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
        MOVS     R0,#+0
        STR      R0,[SP, #+16]
//  220   OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
        STR      R0,[SP, #+20]
//  221   OC_Config.OCMode = TIM_OCMODE_PWM2;
        MOVS     R0,#+112
        STR      R0,[SP, #+0]
//  222   OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
        MOVS     R0,#+0
        STR      R0,[SP, #+24]
//  223   OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
        STR      R0,[SP, #+12]
//  224   OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
        STR      R0,[SP, #+8]
//  225   OC_Config.Pulse = sConfig->Commutation_Delay;
        LDR      R0,[R5, #+12]
        STR      R0,[SP, #+4]
//  226 
//  227   TIM_OC2_SetConfig(htim->Instance, &OC_Config);
        ADD      R1,SP,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_OC2_SetConfig
        BL       TIM_OC2_SetConfig
//  228 
//  229   /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
//  230     register to 101 */
//  231   htim->Instance->CR2 &= ~TIM_CR2_MMS;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+4]
        BIC      R1,R1,#0x70
        STR      R1,[R0, #+4]
//  232   htim->Instance->CR2 |= TIM_TRGO_OC2REF;
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+4]
        ORR      R1,R1,#0x50
        STR      R1,[R0, #+4]
//  233 
//  234   /* Initialize the TIM state*/
//  235   htim->State= HAL_TIM_STATE_READY;
        MOVS     R0,#+1
        STRB     R0,[R4, #+57]
//  236 
//  237   return HAL_OK;
        MOVS     R0,#+0
??HAL_TIMEx_HallSensor_Init_1:
        ADD      SP,SP,#+28
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock0
//  238 }
//  239 
//  240 /**
//  241   * @brief  DeInitializes the TIM Hall Sensor interface
//  242   * @param  htim : TIM Hall Sensor handle
//  243   * @retval HAL status
//  244   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_DeInit
        THUMB
//  245 HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
//  246 {
HAL_TIMEx_HallSensor_DeInit:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  247   /* Check the parameters */
//  248   assert_param(IS_TIM_INSTANCE(htim->Instance));
//  249 
//  250   htim->State = HAL_TIM_STATE_BUSY;
        MOVS     R0,#+2
        STRB     R0,[R4, #+57]
//  251 
//  252   /* Disable the TIM Peripheral Clock */
//  253   __HAL_TIM_DISABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+32]
        MOVW     R2,#+4369
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  254 
//  255   /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
//  256   HAL_TIMEx_HallSensor_MspDeInit(htim);
??HAL_TIMEx_HallSensor_DeInit_0:
        MOV      R0,R4
          CFI FunCall HAL_TIMEx_HallSensor_MspDeInit
        BL       HAL_TIMEx_HallSensor_MspDeInit
//  257 
//  258   /* Change TIM state */
//  259   htim->State = HAL_TIM_STATE_RESET;
        MOVS     R0,#+0
        STRB     R0,[R4, #+57]
//  260 
//  261   /* Release Lock */
//  262   __HAL_UNLOCK(htim);
        STRB     R0,[R4, #+56]
//  263 
//  264   return HAL_OK;
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock1
//  265 }
//  266 
//  267 /**
//  268   * @brief  Initializes the TIM Hall Sensor MSP.
//  269   * @param  htim : TIM handle
//  270   * @retval None
//  271   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_MspInit
          CFI NoCalls
        THUMB
//  272 __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
//  273 {
//  274   /* Prevent unused argument(s) compilation warning */
//  275   UNUSED(htim);
//  276   /* NOTE : This function Should not be modified, when the callback is needed,
//  277             the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
//  278    */
//  279 }
HAL_TIMEx_HallSensor_MspInit:
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//  280 
//  281 /**
//  282   * @brief  DeInitializes TIM Hall Sensor MSP.
//  283   * @param  htim : TIM handle
//  284   * @retval None
//  285   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_MspDeInit
          CFI NoCalls
        THUMB
//  286 __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
//  287 {
//  288   /* Prevent unused argument(s) compilation warning */
//  289   UNUSED(htim);
//  290   /* NOTE : This function Should not be modified, when the callback is needed,
//  291             the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
//  292    */
//  293 }
HAL_TIMEx_HallSensor_MspDeInit:
        BX       LR               ;; return
          CFI EndBlock cfiBlock3
//  294 
//  295 /**
//  296   * @brief  Starts the TIM Hall Sensor Interface.
//  297   * @param  htim : TIM Hall Sensor handle
//  298   * @retval HAL status
//  299   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Start
        THUMB
//  300 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
//  301 {
HAL_TIMEx_HallSensor_Start:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  302   /* Check the parameters */
//  303   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  304 
//  305   /* Enable the Input Capture channel 1
//  306     (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
//  307   TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
        MOVS     R2,#+1
        MOVS     R1,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxChannelCmd
        BL       TIM_CCxChannelCmd
//  308 
//  309   /* Enable the Peripheral */
//  310   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  311 
//  312   /* Return function status */
//  313   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock4
//  314 }
//  315 
//  316 /**
//  317   * @brief  Stops the TIM Hall sensor Interface.
//  318   * @param  htim : TIM Hall Sensor handle
//  319   * @retval HAL status
//  320   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Stop
        THUMB
//  321 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
//  322 {
HAL_TIMEx_HallSensor_Stop:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  323   /* Check the parameters */
//  324   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  325 
//  326   /* Disable the Input Capture channel 1
//  327     (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
//  328   TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
        MOVS     R2,#+0
        MOV      R1,R2
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxChannelCmd
        BL       TIM_CCxChannelCmd
//  329 
//  330   /* Disable the Peripheral */
//  331   __HAL_TIM_DISABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+32]
        MOVW     R2,#+4369
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  332 
//  333   /* Return function status */
//  334   return HAL_OK;
??HAL_TIMEx_HallSensor_Stop_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock5
//  335 }
//  336 
//  337 /**
//  338   * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
//  339   * @param  htim : TIM Hall Sensor handle
//  340   * @retval HAL status
//  341   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Start_IT
        THUMB
//  342 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
//  343 {
HAL_TIMEx_HallSensor_Start_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  344   /* Check the parameters */
//  345   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  346 
//  347   /* Enable the capture compare Interrupts 1 event */
//  348   __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x2
        STR      R1,[R0, #+12]
//  349 
//  350   /* Enable the Input Capture channel 1
//  351     (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
//  352   TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
        MOVS     R2,#+1
        MOVS     R1,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxChannelCmd
        BL       TIM_CCxChannelCmd
//  353 
//  354   /* Enable the Peripheral */
//  355   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  356 
//  357   /* Return function status */
//  358   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock6
//  359 }
//  360 
//  361 /**
//  362   * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
//  363   * @param  htim : TIM handle
//  364   * @retval HAL status
//  365   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Stop_IT
        THUMB
//  366 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
//  367 {
HAL_TIMEx_HallSensor_Stop_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  368   /* Check the parameters */
//  369   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  370 
//  371   /* Disable the Input Capture channel 1
//  372     (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
//  373   TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
        MOVS     R2,#+0
        MOV      R1,R2
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxChannelCmd
        BL       TIM_CCxChannelCmd
//  374 
//  375   /* Disable the capture compare Interrupts event */
//  376   __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        BIC      R1,R1,#0x2
        STR      R1,[R0, #+12]
//  377 
//  378   /* Disable the Peripheral */
//  379   __HAL_TIM_DISABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+32]
        MOVW     R2,#+4369
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  380 
//  381   /* Return function status */
//  382   return HAL_OK;
??HAL_TIMEx_HallSensor_Stop_IT_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock7
//  383 }
//  384 
//  385 /**
//  386   * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
//  387   * @param  htim : TIM Hall Sensor handle
//  388   * @param  pData : The destination Buffer address.
//  389   * @param  Length : The length of data to be transferred from TIM peripheral to memory.
//  390   * @retval HAL status
//  391   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Start_DMA
        THUMB
//  392 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
//  393 {
HAL_TIMEx_HallSensor_Start_DMA:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R6,R1
        MOV      R5,R2
//  394   /* Check the parameters */
//  395   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  396 
//  397    if((htim->State == HAL_TIM_STATE_BUSY))
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+2
        BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_0
//  398   {
//  399      return HAL_BUSY;
        MOVS     R0,#+2
        POP      {R4-R6,PC}
//  400   }
//  401   else if((htim->State == HAL_TIM_STATE_READY))
??HAL_TIMEx_HallSensor_Start_DMA_0:
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+1
        BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_1
//  402   {
//  403     if(((uint32_t)pData == 0 ) && (Length > 0))
        CMP      R6,#+0
        BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
        CMP      R5,#+0
        BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
//  404     {
//  405       return HAL_ERROR;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
//  406     }
//  407     else
//  408     {
//  409       htim->State = HAL_TIM_STATE_BUSY;
??HAL_TIMEx_HallSensor_Start_DMA_2:
        MOVS     R0,#+2
        STRB     R0,[R4, #+57]
//  410     }
//  411   }
//  412   /* Enable the Input Capture channel 1
//  413     (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
//  414   TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
??HAL_TIMEx_HallSensor_Start_DMA_1:
        MOVS     R2,#+1
        MOVS     R1,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxChannelCmd
        BL       TIM_CCxChannelCmd
//  415 
//  416   /* Set the DMA Input Capture 1 Callback */
//  417   htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
        LDR.W    R0,??DataTable3
        LDR      R1,[R4, #+32]
        STR      R0,[R1, #+40]
//  418   /* Set the DMA error callback */
//  419   htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
        LDR.W    R0,??DataTable3_1
        LDR      R1,[R4, #+32]
        STR      R0,[R1, #+48]
//  420 
//  421   /* Enable the DMA channel for Capture 1*/
//  422   HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
        MOV      R3,R5
        MOV      R2,R6
        LDR      R0,[R4, #+0]
        ADD      R1,R0,#+52
        LDR      R0,[R4, #+32]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
//  423 
//  424   /* Enable the capture compare 1 Interrupt */
//  425   __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x200
        STR      R1,[R0, #+12]
//  426 
//  427   /* Enable the Peripheral */
//  428   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  429 
//  430   /* Return function status */
//  431   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock8
//  432 }
//  433 
//  434 /**
//  435   * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
//  436   * @param  htim : TIM handle
//  437   * @retval HAL status
//  438   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_Stop_DMA
        THUMB
//  439 HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
//  440 {
HAL_TIMEx_HallSensor_Stop_DMA:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  441   /* Check the parameters */
//  442   assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
//  443 
//  444   /* Disable the Input Capture channel 1
//  445     (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
//  446   TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
        MOVS     R2,#+0
        MOV      R1,R2
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxChannelCmd
        BL       TIM_CCxChannelCmd
//  447 
//  448 
//  449   /* Disable the capture compare Interrupts 1 event */
//  450   __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        BIC      R1,R1,#0x200
        STR      R1,[R0, #+12]
//  451 
//  452   /* Disable the Peripheral */
//  453   __HAL_TIM_DISABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+32]
        MOVW     R2,#+4369
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  454 
//  455   /* Return function status */
//  456   return HAL_OK;
??HAL_TIMEx_HallSensor_Stop_DMA_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock9
//  457 }
//  458 
//  459 /**
//  460   * @}
//  461   */
//  462 
//  463 #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \ 
//  464     defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \ 
//  465     defined (STM32F105xC) || defined (STM32F107xC)
//  466 
//  467 /** @defgroup TIMEx_Exported_Functions_Group2 Timer Complementary Output Compare functions
//  468  *  @brief    Timer Complementary Output Compare functions
//  469  *
//  470 @verbatim
//  471   ==============================================================================
//  472               ##### Timer Complementary Output Compare functions #####
//  473   ==============================================================================
//  474   [..]
//  475     This section provides functions allowing to:
//  476     (+) Start the Complementary Output Compare/PWM.
//  477     (+) Stop the Complementary Output Compare/PWM.
//  478     (+) Start the Complementary Output Compare/PWM and enable interrupts.
//  479     (+) Stop the Complementary Output Compare/PWM and disable interrupts.
//  480     (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
//  481     (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
//  482 
//  483 @endverbatim
//  484   * @{
//  485   */
//  486 
//  487 /**
//  488   * @brief  Starts the TIM Output Compare signal generation on the complementary
//  489   *         output.
//  490   * @param  htim : TIM Output Compare handle
//  491   * @param  Channel : TIM Channel to be enabled
//  492   *          This parameter can be one of the following values:
//  493   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  494   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  495   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  496   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  497   * @retval HAL status
//  498   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function HAL_TIMEx_OCN_Start
        THUMB
//  499 HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
//  500 {
HAL_TIMEx_OCN_Start:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  501   /* Check the parameters */
//  502   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  503 
//  504   /* Enable the Capture compare channel N */
//  505   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
        MOVS     R2,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  506 
//  507   /* Enable the Main Ouput */
//  508   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
//  509 
//  510   /* Enable the Peripheral */
//  511   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  512 
//  513   /* Return function status */
//  514   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock10
//  515 }
//  516 
//  517 /**
//  518   * @brief  Stops the TIM Output Compare signal generation on the complementary
//  519   *         output.
//  520   * @param  htim : TIM handle
//  521   * @param  Channel : TIM Channel to be disabled
//  522   *          This parameter can be one of the following values:
//  523   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  524   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  525   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  526   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  527   * @retval HAL status
//  528   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function HAL_TIMEx_OCN_Stop
        THUMB
//  529 HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
//  530 {
HAL_TIMEx_OCN_Stop:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  531   /* Check the parameters */
//  532   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  533 
//  534   /* Disable the Capture compare channel N */
//  535   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  536 
//  537   /* Disable the Main Ouput */
//  538   __HAL_TIM_MOE_DISABLE(htim);
        LDR      R0,[R4, #+0]
        MOVW     R1,#+4369
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OCN_Stop_0
        LDR      R2,[R0, #+32]
        MOVW     R3,#+1092
        TST      R2,R3
        BNE.N    ??HAL_TIMEx_OCN_Stop_0
        LDR      R2,[R0, #+68]
        BIC      R2,R2,#0x8000
        STR      R2,[R0, #+68]
//  539 
//  540   /* Disable the Peripheral */
//  541   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_OCN_Stop_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OCN_Stop_1
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_OCN_Stop_1
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  542 
//  543   /* Return function status */
//  544   return HAL_OK;
??HAL_TIMEx_OCN_Stop_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock11
//  545 }
//  546 
//  547 /**
//  548   * @brief  Starts the TIM Output Compare signal generation in interrupt mode
//  549   *         on the complementary output.
//  550   * @param  htim : TIM OC handle
//  551   * @param  Channel : TIM Channel to be enabled
//  552   *          This parameter can be one of the following values:
//  553   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  554   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  555   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  556   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  557   * @retval HAL status
//  558   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function HAL_TIMEx_OCN_Start_IT
        THUMB
//  559 HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
//  560 {
HAL_TIMEx_OCN_Start_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  561   /* Check the parameters */
//  562   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  563 
//  564   switch (Channel)
        MOVS     R0,R1
        BEQ.N    ??HAL_TIMEx_OCN_Start_IT_0
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_OCN_Start_IT_1
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_OCN_Start_IT_2
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_OCN_Start_IT_3
        B.N      ??HAL_TIMEx_OCN_Start_IT_4
//  565   {
//  566     case TIM_CHANNEL_1:
//  567     {
//  568       /* Enable the TIM Output Compare interrupt */
//  569       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
??HAL_TIMEx_OCN_Start_IT_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x2
        STR      R2,[R0, #+12]
//  570     }
//  571     break;
        B.N      ??HAL_TIMEx_OCN_Start_IT_4
//  572 
//  573     case TIM_CHANNEL_2:
//  574     {
//  575       /* Enable the TIM Output Compare interrupt */
//  576       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
??HAL_TIMEx_OCN_Start_IT_1:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x4
        STR      R2,[R0, #+12]
//  577     }
//  578     break;
        B.N      ??HAL_TIMEx_OCN_Start_IT_4
//  579 
//  580     case TIM_CHANNEL_3:
//  581     {
//  582       /* Enable the TIM Output Compare interrupt */
//  583       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
??HAL_TIMEx_OCN_Start_IT_2:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x8
        STR      R2,[R0, #+12]
//  584     }
//  585     break;
        B.N      ??HAL_TIMEx_OCN_Start_IT_4
//  586 
//  587     case TIM_CHANNEL_4:
//  588     {
//  589       /* Enable the TIM Output Compare interrupt */
//  590       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
??HAL_TIMEx_OCN_Start_IT_3:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x10
        STR      R2,[R0, #+12]
//  591     }
//  592     break;
//  593 
//  594     default:
//  595     break;
//  596   }
//  597 
//  598   /* Enable the TIM Break interrupt */
//  599   __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
??HAL_TIMEx_OCN_Start_IT_4:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x80
        STR      R2,[R0, #+12]
//  600 
//  601   /* Enable the Capture compare channel N */
//  602   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
        MOVS     R2,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  603 
//  604   /* Enable the Main Ouput */
//  605   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
//  606 
//  607   /* Enable the Peripheral */
//  608   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  609 
//  610   /* Return function status */
//  611   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock12
//  612 }
//  613 
//  614 /**
//  615   * @brief  Stops the TIM Output Compare signal generation in interrupt mode
//  616   *         on the complementary output.
//  617   * @param  htim : TIM Output Compare handle
//  618   * @param  Channel : TIM Channel to be disabled
//  619   *          This parameter can be one of the following values:
//  620   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  621   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  622   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  623   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  624   * @retval HAL status
//  625   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function HAL_TIMEx_OCN_Stop_IT
        THUMB
//  626 HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
//  627 {
HAL_TIMEx_OCN_Stop_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  628   uint32_t tmpccer = 0;
//  629 
//  630   /* Check the parameters */
//  631   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  632 
//  633   switch (Channel)
        MOVS     R0,R1
        BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_0
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_1
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_2
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_3
        B.N      ??HAL_TIMEx_OCN_Stop_IT_4
//  634   {
//  635     case TIM_CHANNEL_1:
//  636     {
//  637       /* Disable the TIM Output Compare interrupt */
//  638       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
??HAL_TIMEx_OCN_Stop_IT_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x2
        STR      R2,[R0, #+12]
//  639     }
//  640     break;
        B.N      ??HAL_TIMEx_OCN_Stop_IT_4
//  641 
//  642     case TIM_CHANNEL_2:
//  643     {
//  644       /* Disable the TIM Output Compare interrupt */
//  645       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
??HAL_TIMEx_OCN_Stop_IT_1:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x4
        STR      R2,[R0, #+12]
//  646     }
//  647     break;
        B.N      ??HAL_TIMEx_OCN_Stop_IT_4
//  648 
//  649     case TIM_CHANNEL_3:
//  650     {
//  651       /* Disable the TIM Output Compare interrupt */
//  652       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
??HAL_TIMEx_OCN_Stop_IT_2:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x8
        STR      R2,[R0, #+12]
//  653     }
//  654     break;
        B.N      ??HAL_TIMEx_OCN_Stop_IT_4
//  655 
//  656     case TIM_CHANNEL_4:
//  657     {
//  658       /* Disable the TIM Output Compare interrupt */
//  659       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
??HAL_TIMEx_OCN_Stop_IT_3:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x10
        STR      R2,[R0, #+12]
//  660     }
//  661     break;
//  662 
//  663     default:
//  664     break;
//  665   }
//  666 
//  667   /* Disable the Capture compare channel N */
//  668   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
??HAL_TIMEx_OCN_Stop_IT_4:
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  669 
//  670   /* Disable the TIM Break interrupt (only if no more channel is active) */
//  671   tmpccer = htim->Instance->CCER;
        LDR      R1,[R4, #+0]
        LDR      R2,[R1, #+32]
//  672   if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
        MOVW     R0,#+1092
        TST      R2,R0
        BNE.N    ??HAL_TIMEx_OCN_Stop_IT_5
//  673   {
//  674     __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
        LDR      R2,[R1, #+12]
        BIC      R2,R2,#0x80
        STR      R2,[R1, #+12]
//  675   }
//  676 
//  677   /* Disable the Main Ouput */
//  678   __HAL_TIM_MOE_DISABLE(htim);
??HAL_TIMEx_OCN_Stop_IT_5:
        LDR      R1,[R4, #+0]
        MOVW     R2,#+4369
        LDR      R3,[R1, #+32]
        TST      R3,R2
        BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
        LDR      R3,[R1, #+32]
        TST      R3,R0
        BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
        LDR      R3,[R1, #+68]
        BIC      R3,R3,#0x8000
        STR      R3,[R1, #+68]
//  679 
//  680   /* Disable the Peripheral */
//  681   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_OCN_Stop_IT_6:
        LDR      R1,[R4, #+0]
        LDR      R3,[R1, #+32]
        TST      R3,R2
        BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
        LDR      R2,[R1, #+32]
        TST      R2,R0
        BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
        LDR      R0,[R1, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        STR      R0,[R1, #+0]
//  682 
//  683   /* Return function status */
//  684   return HAL_OK;
??HAL_TIMEx_OCN_Stop_IT_7:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock13
//  685 }
//  686 
//  687 /**
//  688   * @brief  Starts the TIM Output Compare signal generation in DMA mode
//  689   *         on the complementary output.
//  690   * @param  htim : TIM Output Compare handle
//  691   * @param  Channel : TIM Channel to be enabled
//  692   *          This parameter can be one of the following values:
//  693   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  694   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  695   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  696   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  697   * @param  pData : The source Buffer address.
//  698   * @param  Length : The length of data to be transferred from memory to TIM peripheral
//  699   * @retval HAL status
//  700   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function HAL_TIMEx_OCN_Start_DMA
        THUMB
//  701 HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
//  702 {
HAL_TIMEx_OCN_Start_DMA:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R1,R2
//  703   /* Check the parameters */
//  704   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  705 
//  706   if((htim->State == HAL_TIM_STATE_BUSY))
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+2
        BNE.N    ??HAL_TIMEx_OCN_Start_DMA_0
//  707   {
//  708      return HAL_BUSY;
        MOVS     R0,#+2
        POP      {R1,R4,R5,PC}
//  709   }
//  710   else if((htim->State == HAL_TIM_STATE_READY))
??HAL_TIMEx_OCN_Start_DMA_0:
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+1
        BNE.N    ??HAL_TIMEx_OCN_Start_DMA_1
//  711   {
//  712     if(((uint32_t)pData == 0 ) && (Length > 0))
        CMP      R1,#+0
        BNE.N    ??HAL_TIMEx_OCN_Start_DMA_2
        CMP      R3,#+0
        BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_2
//  713     {
//  714       return HAL_ERROR;
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}
//  715     }
//  716     else
//  717     {
//  718       htim->State = HAL_TIM_STATE_BUSY;
??HAL_TIMEx_OCN_Start_DMA_2:
        MOVS     R0,#+2
        STRB     R0,[R4, #+57]
//  719     }
//  720   }
//  721   switch (Channel)
??HAL_TIMEx_OCN_Start_DMA_1:
        MOVS     R0,R5
        BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_3
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_4
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_5
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_6
        B.N      ??HAL_TIMEx_OCN_Start_DMA_7
//  722   {
//  723     case TIM_CHANNEL_1:
//  724     {
//  725       /* Set the DMA Period elapsed callback */
//  726       htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_OCN_Start_DMA_3:
        LDR.W    R0,??DataTable3_2
        LDR      R2,[R4, #+32]
        STR      R0,[R2, #+40]
//  727 
//  728       /* Set the DMA error callback */
//  729       htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
        LDR.W    R0,??DataTable3_1
        LDR      R2,[R4, #+32]
        STR      R0,[R2, #+48]
//  730 
//  731       /* Enable the DMA channel */
//  732       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+52
        LDR      R0,[R4, #+32]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
//  733 
//  734       /* Enable the TIM Output Compare DMA request */
//  735       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x200
        STR      R1,[R0, #+12]
//  736     }
//  737     break;
        B.N      ??HAL_TIMEx_OCN_Start_DMA_7
//  738 
//  739     case TIM_CHANNEL_2:
//  740     {
//  741       /* Set the DMA Period elapsed callback */
//  742       htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_OCN_Start_DMA_4:
        LDR.W    R0,??DataTable3_2
        LDR      R2,[R4, #+36]
        STR      R0,[R2, #+40]
//  743 
//  744       /* Set the DMA error callback */
//  745       htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
        LDR.W    R0,??DataTable3_1
        LDR      R2,[R4, #+36]
        STR      R0,[R2, #+48]
//  746 
//  747       /* Enable the DMA channel */
//  748       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+56
        LDR      R0,[R4, #+36]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
//  749 
//  750       /* Enable the TIM Output Compare DMA request */
//  751       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x400
        STR      R1,[R0, #+12]
//  752     }
//  753     break;
        B.N      ??HAL_TIMEx_OCN_Start_DMA_7
//  754 
//  755     case TIM_CHANNEL_3:
//  756 {
//  757       /* Set the DMA Period elapsed callback */
//  758       htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_OCN_Start_DMA_5:
        LDR.W    R0,??DataTable3_2
        LDR      R2,[R4, #+40]
        STR      R0,[R2, #+40]
//  759 
//  760       /* Set the DMA error callback */
//  761       htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
        LDR.W    R0,??DataTable3_1
        LDR      R2,[R4, #+40]
        STR      R0,[R2, #+48]
//  762 
//  763       /* Enable the DMA channel */
//  764       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+60
        LDR      R0,[R4, #+40]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
//  765 
//  766       /* Enable the TIM Output Compare DMA request */
//  767       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x800
        STR      R1,[R0, #+12]
//  768     }
//  769     break;
        B.N      ??HAL_TIMEx_OCN_Start_DMA_7
//  770 
//  771     case TIM_CHANNEL_4:
//  772     {
//  773      /* Set the DMA Period elapsed callback */
//  774       htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_OCN_Start_DMA_6:
        LDR.W    R0,??DataTable3_2
        LDR      R2,[R4, #+44]
        STR      R0,[R2, #+40]
//  775 
//  776       /* Set the DMA error callback */
//  777       htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
        LDR.W    R0,??DataTable3_1
        LDR      R2,[R4, #+44]
        STR      R0,[R2, #+48]
//  778 
//  779       /* Enable the DMA channel */
//  780       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+64
        LDR      R0,[R4, #+44]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
//  781 
//  782       /* Enable the TIM Output Compare DMA request */
//  783       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x1000
        STR      R1,[R0, #+12]
//  784     }
//  785     break;
//  786 
//  787     default:
//  788     break;
//  789   }
//  790 
//  791   /* Enable the Capture compare channel N */
//  792   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
??HAL_TIMEx_OCN_Start_DMA_7:
        MOVS     R2,#+4
        MOV      R1,R5
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  793 
//  794   /* Enable the Main Ouput */
//  795   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
//  796 
//  797   /* Enable the Peripheral */
//  798   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  799 
//  800   /* Return function status */
//  801   return HAL_OK;
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock14
//  802 }
//  803 
//  804 /**
//  805   * @brief  Stops the TIM Output Compare signal generation in DMA mode
//  806   *         on the complementary output.
//  807   * @param  htim : TIM Output Compare handle
//  808   * @param  Channel : TIM Channel to be disabled
//  809   *          This parameter can be one of the following values:
//  810   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  811   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  812   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  813   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  814   * @retval HAL status
//  815   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function HAL_TIMEx_OCN_Stop_DMA
        THUMB
//  816 HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
//  817 {
HAL_TIMEx_OCN_Stop_DMA:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  818   /* Check the parameters */
//  819   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  820 
//  821   switch (Channel)
        MOVS     R0,R1
        BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_0
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_1
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_2
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_3
        B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
//  822   {
//  823     case TIM_CHANNEL_1:
//  824     {
//  825       /* Disable the TIM Output Compare DMA request */
//  826       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
??HAL_TIMEx_OCN_Stop_DMA_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x200
        STR      R2,[R0, #+12]
//  827     }
//  828     break;
        B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
//  829 
//  830     case TIM_CHANNEL_2:
//  831     {
//  832       /* Disable the TIM Output Compare DMA request */
//  833       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
??HAL_TIMEx_OCN_Stop_DMA_1:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x400
        STR      R2,[R0, #+12]
//  834     }
//  835     break;
        B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
//  836 
//  837     case TIM_CHANNEL_3:
//  838     {
//  839       /* Disable the TIM Output Compare DMA request */
//  840       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
??HAL_TIMEx_OCN_Stop_DMA_2:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x800
        STR      R2,[R0, #+12]
//  841     }
//  842     break;
        B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
//  843 
//  844     case TIM_CHANNEL_4:
//  845     {
//  846       /* Disable the TIM Output Compare interrupt */
//  847       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
??HAL_TIMEx_OCN_Stop_DMA_3:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x1000
        STR      R2,[R0, #+12]
//  848     }
//  849     break;
//  850 
//  851     default:
//  852     break;
//  853   }
//  854 
//  855   /* Disable the Capture compare channel N */
//  856   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
??HAL_TIMEx_OCN_Stop_DMA_4:
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  857 
//  858   /* Disable the Main Ouput */
//  859   __HAL_TIM_MOE_DISABLE(htim);
        LDR      R0,[R4, #+0]
        MOVW     R1,#+4369
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
        LDR      R2,[R0, #+32]
        MOVW     R3,#+1092
        TST      R2,R3
        BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
        LDR      R2,[R0, #+68]
        BIC      R2,R2,#0x8000
        STR      R2,[R0, #+68]
//  860 
//  861   /* Disable the Peripheral */
//  862   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_OCN_Stop_DMA_5:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  863 
//  864   /* Change the htim state */
//  865   htim->State = HAL_TIM_STATE_READY;
??HAL_TIMEx_OCN_Stop_DMA_6:
        MOVS     R0,#+1
        STRB     R0,[R4, #+57]
//  866 
//  867   /* Return function status */
//  868   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock15
//  869 }
//  870 
//  871 /**
//  872   * @}
//  873   */
//  874 
//  875 /** @defgroup TIMEx_Exported_Functions_Group3 Timer Complementary PWM functions
//  876  *  @brief    Timer Complementary PWM functions
//  877  *
//  878 @verbatim
//  879   ==============================================================================
//  880                  ##### Timer Complementary PWM functions #####
//  881   ==============================================================================
//  882   [..]
//  883     This section provides functions allowing to:
//  884     (+) Start the Complementary PWM.
//  885     (+) Stop the Complementary PWM.
//  886     (+) Start the Complementary PWM and enable interrupts.
//  887     (+) Stop the Complementary PWM and disable interrupts.
//  888     (+) Start the Complementary PWM and enable DMA transfers.
//  889     (+) Stop the Complementary PWM and disable DMA transfers.
//  890     (+) Start the Complementary Input Capture measurement.
//  891     (+) Stop the Complementary Input Capture.
//  892     (+) Start the Complementary Input Capture and enable interrupts.
//  893     (+) Stop the Complementary Input Capture and disable interrupts.
//  894     (+) Start the Complementary Input Capture and enable DMA transfers.
//  895     (+) Stop the Complementary Input Capture and disable DMA transfers.
//  896     (+) Start the Complementary One Pulse generation.
//  897     (+) Stop the Complementary One Pulse.
//  898     (+) Start the Complementary One Pulse and enable interrupts.
//  899     (+) Stop the Complementary One Pulse and disable interrupts.
//  900 
//  901 @endverbatim
//  902   * @{
//  903   */
//  904 
//  905 /**
//  906   * @brief  Starts the PWM signal generation on the complementary output.
//  907   * @param  htim : TIM handle
//  908   * @param  Channel : TIM Channel to be enabled
//  909   *          This parameter can be one of the following values:
//  910   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  911   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  912   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  913   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  914   * @retval HAL status
//  915   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function HAL_TIMEx_PWMN_Start
        THUMB
//  916 HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
//  917 {
HAL_TIMEx_PWMN_Start:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  918   /* Check the parameters */
//  919   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  920 
//  921   /* Enable the complementary PWM output  */
//  922   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
        MOVS     R2,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  923 
//  924   /* Enable the Main Ouput */
//  925   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
//  926 
//  927   /* Enable the Peripheral */
//  928   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
//  929 
//  930   /* Return function status */
//  931   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock16
//  932 }
//  933 
//  934 /**
//  935   * @brief  Stops the PWM signal generation on the complementary output.
//  936   * @param  htim : TIM handle
//  937   * @param  Channel : TIM Channel to be disabled
//  938   *          This parameter can be one of the following values:
//  939   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  940   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  941   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  942   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  943   * @retval HAL status
//  944   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function HAL_TIMEx_PWMN_Stop
        THUMB
//  945 HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
//  946 {
HAL_TIMEx_PWMN_Stop:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  947   /* Check the parameters */
//  948   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  949 
//  950   /* Disable the complementary PWM output  */
//  951   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
//  952 
//  953   /* Disable the Main Ouput */
//  954   __HAL_TIM_MOE_DISABLE(htim);
        LDR      R0,[R4, #+0]
        MOVW     R1,#+4369
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_PWMN_Stop_0
        LDR      R2,[R0, #+32]
        MOVW     R3,#+1092
        TST      R2,R3
        BNE.N    ??HAL_TIMEx_PWMN_Stop_0
        LDR      R2,[R0, #+68]
        BIC      R2,R2,#0x8000
        STR      R2,[R0, #+68]
//  955 
//  956   /* Disable the Peripheral */
//  957   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_PWMN_Stop_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_PWMN_Stop_1
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_PWMN_Stop_1
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  958 
//  959   /* Return function status */
//  960   return HAL_OK;
??HAL_TIMEx_PWMN_Stop_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock17
//  961 }
//  962 
//  963 /**
//  964   * @brief  Starts the PWM signal generation in interrupt mode on the
//  965   *         complementary output.
//  966   * @param  htim : TIM handle
//  967   * @param  Channel : TIM Channel to be disabled
//  968   *          This parameter can be one of the following values:
//  969   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
//  970   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
//  971   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
//  972   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
//  973   * @retval HAL status
//  974   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function HAL_TIMEx_PWMN_Start_IT
        THUMB
//  975 HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
//  976 {
HAL_TIMEx_PWMN_Start_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  977   /* Check the parameters */
//  978   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
//  979 
//  980   switch (Channel)
        MOVS     R0,R1
        BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_0
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_1
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_2
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_3
        B.N      ??HAL_TIMEx_PWMN_Start_IT_4
//  981   {
//  982     case TIM_CHANNEL_1:
//  983     {
//  984       /* Enable the TIM Capture/Compare 1 interrupt */
//  985       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
??HAL_TIMEx_PWMN_Start_IT_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x2
        STR      R2,[R0, #+12]
//  986     }
//  987     break;
        B.N      ??HAL_TIMEx_PWMN_Start_IT_4
//  988 
//  989     case TIM_CHANNEL_2:
//  990     {
//  991       /* Enable the TIM Capture/Compare 2 interrupt */
//  992       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
??HAL_TIMEx_PWMN_Start_IT_1:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x4
        STR      R2,[R0, #+12]
//  993     }
//  994     break;
        B.N      ??HAL_TIMEx_PWMN_Start_IT_4
//  995 
//  996     case TIM_CHANNEL_3:
//  997     {
//  998       /* Enable the TIM Capture/Compare 3 interrupt */
//  999       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
??HAL_TIMEx_PWMN_Start_IT_2:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x8
        STR      R2,[R0, #+12]
// 1000     }
// 1001     break;
        B.N      ??HAL_TIMEx_PWMN_Start_IT_4
// 1002 
// 1003     case TIM_CHANNEL_4:
// 1004     {
// 1005       /* Enable the TIM Capture/Compare 4 interrupt */
// 1006       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
??HAL_TIMEx_PWMN_Start_IT_3:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x10
        STR      R2,[R0, #+12]
// 1007     }
// 1008     break;
// 1009 
// 1010     default:
// 1011     break;
// 1012   }
// 1013 
// 1014   /* Enable the TIM Break interrupt */
// 1015   __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
??HAL_TIMEx_PWMN_Start_IT_4:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x80
        STR      R2,[R0, #+12]
// 1016 
// 1017   /* Enable the complementary PWM output  */
// 1018   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
        MOVS     R2,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1019 
// 1020   /* Enable the Main Ouput */
// 1021   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
// 1022 
// 1023   /* Enable the Peripheral */
// 1024   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
// 1025 
// 1026   /* Return function status */
// 1027   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock18
// 1028 }
// 1029 
// 1030 /**
// 1031   * @brief  Stops the PWM signal generation in interrupt mode on the
// 1032   *         complementary output.
// 1033   * @param  htim : TIM handle
// 1034   * @param  Channel : TIM Channel to be disabled
// 1035   *          This parameter can be one of the following values:
// 1036   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1037   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1038   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
// 1039   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
// 1040   * @retval HAL status
// 1041   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function HAL_TIMEx_PWMN_Stop_IT
        THUMB
// 1042 HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
// 1043 {
HAL_TIMEx_PWMN_Stop_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1044   uint32_t tmpccer = 0;
// 1045 
// 1046   /* Check the parameters */
// 1047   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
// 1048 
// 1049   switch (Channel)
        MOVS     R0,R1
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_0
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_1
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_2
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_3
        B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
// 1050   {
// 1051     case TIM_CHANNEL_1:
// 1052     {
// 1053       /* Disable the TIM Capture/Compare 1 interrupt */
// 1054       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
??HAL_TIMEx_PWMN_Stop_IT_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x2
        STR      R2,[R0, #+12]
// 1055     }
// 1056     break;
        B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
// 1057 
// 1058     case TIM_CHANNEL_2:
// 1059     {
// 1060       /* Disable the TIM Capture/Compare 2 interrupt */
// 1061       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
??HAL_TIMEx_PWMN_Stop_IT_1:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x4
        STR      R2,[R0, #+12]
// 1062     }
// 1063     break;
        B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
// 1064 
// 1065     case TIM_CHANNEL_3:
// 1066     {
// 1067       /* Disable the TIM Capture/Compare 3 interrupt */
// 1068       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
??HAL_TIMEx_PWMN_Stop_IT_2:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x8
        STR      R2,[R0, #+12]
// 1069     }
// 1070     break;
        B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
// 1071 
// 1072     case TIM_CHANNEL_4:
// 1073     {
// 1074       /* Disable the TIM Capture/Compare 3 interrupt */
// 1075       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
??HAL_TIMEx_PWMN_Stop_IT_3:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x10
        STR      R2,[R0, #+12]
// 1076     }
// 1077     break;
// 1078 
// 1079     default:
// 1080     break;
// 1081   }
// 1082 
// 1083   /* Disable the complementary PWM output  */
// 1084   TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
??HAL_TIMEx_PWMN_Stop_IT_4:
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1085 
// 1086   /* Disable the TIM Break interrupt (only if no more channel is active) */
// 1087   tmpccer = htim->Instance->CCER;
        LDR      R1,[R4, #+0]
        LDR      R2,[R1, #+32]
// 1088   if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
        MOVW     R0,#+1092
        TST      R2,R0
        BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_5
// 1089   {
// 1090     __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
        LDR      R2,[R1, #+12]
        BIC      R2,R2,#0x80
        STR      R2,[R1, #+12]
// 1091   }
// 1092 
// 1093   /* Disable the Main Ouput */
// 1094   __HAL_TIM_MOE_DISABLE(htim);
??HAL_TIMEx_PWMN_Stop_IT_5:
        LDR      R1,[R4, #+0]
        MOVW     R2,#+4369
        LDR      R3,[R1, #+32]
        TST      R3,R2
        BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
        LDR      R3,[R1, #+32]
        TST      R3,R0
        BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
        LDR      R3,[R1, #+68]
        BIC      R3,R3,#0x8000
        STR      R3,[R1, #+68]
// 1095 
// 1096   /* Disable the Peripheral */
// 1097   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_PWMN_Stop_IT_6:
        LDR      R1,[R4, #+0]
        LDR      R3,[R1, #+32]
        TST      R3,R2
        BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
        LDR      R2,[R1, #+32]
        TST      R2,R0
        BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
        LDR      R0,[R1, #+0]
        LSRS     R0,R0,#+1
        LSLS     R0,R0,#+1
        STR      R0,[R1, #+0]
// 1098 
// 1099   /* Return function status */
// 1100   return HAL_OK;
??HAL_TIMEx_PWMN_Stop_IT_7:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock19
// 1101 }
// 1102 
// 1103 /**
// 1104   * @brief  Starts the TIM PWM signal generation in DMA mode on the
// 1105   *         complementary output
// 1106   * @param  htim : TIM handle
// 1107   * @param  Channel : TIM Channel to be enabled
// 1108   *          This parameter can be one of the following values:
// 1109   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1110   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1111   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
// 1112   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
// 1113   * @param  pData : The source Buffer address.
// 1114   * @param  Length : The length of data to be transferred from memory to TIM peripheral
// 1115   * @retval HAL status
// 1116   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function HAL_TIMEx_PWMN_Start_DMA
        THUMB
// 1117 HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
// 1118 {
HAL_TIMEx_PWMN_Start_DMA:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R1,R2
// 1119   /* Check the parameters */
// 1120   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
// 1121 
// 1122   if((htim->State == HAL_TIM_STATE_BUSY))
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+2
        BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_0
// 1123   {
// 1124      return HAL_BUSY;
        MOVS     R0,#+2
        POP      {R1,R4,R5,PC}
// 1125   }
// 1126   else if((htim->State == HAL_TIM_STATE_READY))
??HAL_TIMEx_PWMN_Start_DMA_0:
        LDRSB    R0,[R4, #+57]
        CMP      R0,#+1
        BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_1
// 1127   {
// 1128     if(((uint32_t)pData == 0 ) && (Length > 0))
        CMP      R1,#+0
        BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_2
        CMP      R3,#+0
        BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_2
// 1129     {
// 1130       return HAL_ERROR;
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}
// 1131     }
// 1132     else
// 1133     {
// 1134       htim->State = HAL_TIM_STATE_BUSY;
??HAL_TIMEx_PWMN_Start_DMA_2:
        MOVS     R0,#+2
        STRB     R0,[R4, #+57]
// 1135     }
// 1136   }
// 1137   switch (Channel)
??HAL_TIMEx_PWMN_Start_DMA_1:
        MOVS     R0,R5
        BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_3
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_4
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_5
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_6
        B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
// 1138   {
// 1139     case TIM_CHANNEL_1:
// 1140     {
// 1141       /* Set the DMA Period elapsed callback */
// 1142       htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_PWMN_Start_DMA_3:
        LDR.N    R0,??DataTable3_2
        LDR      R2,[R4, #+32]
        STR      R0,[R2, #+40]
// 1143 
// 1144       /* Set the DMA error callback */
// 1145       htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
        LDR.N    R0,??DataTable3_1
        LDR      R2,[R4, #+32]
        STR      R0,[R2, #+48]
// 1146 
// 1147       /* Enable the DMA channel */
// 1148       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+52
        LDR      R0,[R4, #+32]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
// 1149 
// 1150       /* Enable the TIM Capture/Compare 1 DMA request */
// 1151       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x200
        STR      R1,[R0, #+12]
// 1152     }
// 1153     break;
        B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
// 1154 
// 1155     case TIM_CHANNEL_2:
// 1156     {
// 1157       /* Set the DMA Period elapsed callback */
// 1158       htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_PWMN_Start_DMA_4:
        LDR.N    R0,??DataTable3_2
        LDR      R2,[R4, #+36]
        STR      R0,[R2, #+40]
// 1159 
// 1160       /* Set the DMA error callback */
// 1161       htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
        LDR.N    R0,??DataTable3_1
        LDR      R2,[R4, #+36]
        STR      R0,[R2, #+48]
// 1162 
// 1163       /* Enable the DMA channel */
// 1164       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+56
        LDR      R0,[R4, #+36]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
// 1165 
// 1166       /* Enable the TIM Capture/Compare 2 DMA request */
// 1167       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x400
        STR      R1,[R0, #+12]
// 1168     }
// 1169     break;
        B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
// 1170 
// 1171     case TIM_CHANNEL_3:
// 1172     {
// 1173       /* Set the DMA Period elapsed callback */
// 1174       htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_PWMN_Start_DMA_5:
        LDR.N    R0,??DataTable3_2
        LDR      R2,[R4, #+40]
        STR      R0,[R2, #+40]
// 1175 
// 1176       /* Set the DMA error callback */
// 1177       htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
        LDR.N    R0,??DataTable3_1
        LDR      R2,[R4, #+40]
        STR      R0,[R2, #+48]
// 1178 
// 1179       /* Enable the DMA channel */
// 1180       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+60
        LDR      R0,[R4, #+40]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
// 1181 
// 1182       /* Enable the TIM Capture/Compare 3 DMA request */
// 1183       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x800
        STR      R1,[R0, #+12]
// 1184     }
// 1185     break;
        B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
// 1186 
// 1187     case TIM_CHANNEL_4:
// 1188     {
// 1189      /* Set the DMA Period elapsed callback */
// 1190       htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
??HAL_TIMEx_PWMN_Start_DMA_6:
        LDR.N    R0,??DataTable3_2
        LDR      R2,[R4, #+44]
        STR      R0,[R2, #+40]
// 1191 
// 1192       /* Set the DMA error callback */
// 1193       htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
        LDR.N    R0,??DataTable3_1
        LDR      R2,[R4, #+44]
        STR      R0,[R2, #+48]
// 1194 
// 1195       /* Enable the DMA channel */
// 1196       HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
        LDR      R0,[R4, #+0]
        ADD      R2,R0,#+64
        LDR      R0,[R4, #+44]
          CFI FunCall HAL_DMA_Start_IT
        BL       HAL_DMA_Start_IT
// 1197 
// 1198       /* Enable the TIM Capture/Compare 4 DMA request */
// 1199       __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+12]
        ORR      R1,R1,#0x1000
        STR      R1,[R0, #+12]
// 1200     }
// 1201     break;
// 1202 
// 1203     default:
// 1204     break;
// 1205   }
// 1206 
// 1207   /* Enable the complementary PWM output  */
// 1208      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
??HAL_TIMEx_PWMN_Start_DMA_7:
        MOVS     R2,#+4
        MOV      R1,R5
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1209 
// 1210   /* Enable the Main Ouput */
// 1211     __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
// 1212 
// 1213   /* Enable the Peripheral */
// 1214   __HAL_TIM_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+0]
        ORR      R1,R1,#0x1
        STR      R1,[R0, #+0]
// 1215 
// 1216   /* Return function status */
// 1217   return HAL_OK;
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock20
// 1218 }
// 1219 
// 1220 /**
// 1221   * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
// 1222   *         output
// 1223   * @param  htim : TIM handle
// 1224   * @param  Channel : TIM Channel to be disabled
// 1225   *          This parameter can be one of the following values:
// 1226   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1227   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1228   *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
// 1229   *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
// 1230   * @retval HAL status
// 1231   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function HAL_TIMEx_PWMN_Stop_DMA
        THUMB
// 1232 HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
// 1233 {
HAL_TIMEx_PWMN_Stop_DMA:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1234   /* Check the parameters */
// 1235   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
// 1236 
// 1237   switch (Channel)
        MOVS     R0,R1
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_0
        CMP      R0,#+4
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_1
        CMP      R0,#+8
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_2
        CMP      R0,#+12
        BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_3
        B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
// 1238   {
// 1239     case TIM_CHANNEL_1:
// 1240     {
// 1241       /* Disable the TIM Capture/Compare 1 DMA request */
// 1242       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
??HAL_TIMEx_PWMN_Stop_DMA_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x200
        STR      R2,[R0, #+12]
// 1243     }
// 1244     break;
        B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
// 1245 
// 1246     case TIM_CHANNEL_2:
// 1247     {
// 1248       /* Disable the TIM Capture/Compare 2 DMA request */
// 1249       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
??HAL_TIMEx_PWMN_Stop_DMA_1:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x400
        STR      R2,[R0, #+12]
// 1250     }
// 1251     break;
        B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
// 1252 
// 1253     case TIM_CHANNEL_3:
// 1254     {
// 1255       /* Disable the TIM Capture/Compare 3 DMA request */
// 1256       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
??HAL_TIMEx_PWMN_Stop_DMA_2:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x800
        STR      R2,[R0, #+12]
// 1257     }
// 1258     break;
        B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
// 1259 
// 1260     case TIM_CHANNEL_4:
// 1261     {
// 1262       /* Disable the TIM Capture/Compare 4 DMA request */
// 1263       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
??HAL_TIMEx_PWMN_Stop_DMA_3:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x1000
        STR      R2,[R0, #+12]
// 1264     }
// 1265     break;
// 1266 
// 1267     default:
// 1268     break;
// 1269   }
// 1270 
// 1271   /* Disable the complementary PWM output */
// 1272     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
??HAL_TIMEx_PWMN_Stop_DMA_4:
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1273 
// 1274   /* Disable the Main Ouput */
// 1275     __HAL_TIM_MOE_DISABLE(htim);
        LDR      R0,[R4, #+0]
        MOVW     R1,#+4369
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
        LDR      R2,[R0, #+32]
        MOVW     R3,#+1092
        TST      R2,R3
        BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
        LDR      R2,[R0, #+68]
        BIC      R2,R2,#0x8000
        STR      R2,[R0, #+68]
// 1276 
// 1277   /* Disable the Peripheral */
// 1278   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_PWMN_Stop_DMA_5:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 1279 
// 1280   /* Change the htim state */
// 1281   htim->State = HAL_TIM_STATE_READY;
??HAL_TIMEx_PWMN_Stop_DMA_6:
        MOVS     R0,#+1
        STRB     R0,[R4, #+57]
// 1282 
// 1283   /* Return function status */
// 1284   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock21
// 1285 }
// 1286 
// 1287 /**
// 1288   * @}
// 1289   */
// 1290 
// 1291 /** @defgroup TIMEx_Exported_Functions_Group4 Timer Complementary One Pulse functions
// 1292  *  @brief    Timer Complementary One Pulse functions
// 1293  *
// 1294 @verbatim
// 1295   ==============================================================================
// 1296                 ##### Timer Complementary One Pulse functions #####
// 1297   ==============================================================================
// 1298   [..]
// 1299     This section provides functions allowing to:
// 1300     (+) Start the Complementary One Pulse generation.
// 1301     (+) Stop the Complementary One Pulse.
// 1302     (+) Start the Complementary One Pulse and enable interrupts.
// 1303     (+) Stop the Complementary One Pulse and disable interrupts.
// 1304 
// 1305 @endverbatim
// 1306   * @{
// 1307   */
// 1308 
// 1309 /**
// 1310   * @brief  Starts the TIM One Pulse signal generation on the complemetary
// 1311   *         output.
// 1312   * @param  htim : TIM One Pulse handle
// 1313   * @param  OutputChannel : TIM Channel to be enabled
// 1314   *          This parameter can be one of the following values:
// 1315   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1316   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1317   * @retval HAL status
// 1318   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function HAL_TIMEx_OnePulseN_Start
        THUMB
// 1319 HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
// 1320   {
HAL_TIMEx_OnePulseN_Start:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1321   /* Check the parameters */
// 1322   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
// 1323 
// 1324   /* Enable the complementary One Pulse output */
// 1325   TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
        MOVS     R2,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1326 
// 1327   /* Enable the Main Ouput */
// 1328   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
// 1329 
// 1330   /* Return function status */
// 1331   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock22
// 1332 }
// 1333 
// 1334 /**
// 1335   * @brief  Stops the TIM One Pulse signal generation on the complementary
// 1336   *         output.
// 1337   * @param  htim : TIM One Pulse handle
// 1338   * @param  OutputChannel : TIM Channel to be disabled
// 1339   *          This parameter can be one of the following values:
// 1340   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1341   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1342   * @retval HAL status
// 1343   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function HAL_TIMEx_OnePulseN_Stop
        THUMB
// 1344 HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
// 1345 {
HAL_TIMEx_OnePulseN_Stop:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1346 
// 1347   /* Check the parameters */
// 1348   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
// 1349 
// 1350   /* Disable the complementary One Pulse output */
// 1351   TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1352 
// 1353   /* Disable the Main Ouput */
// 1354   __HAL_TIM_MOE_DISABLE(htim);
        LDR      R0,[R4, #+0]
        MOVW     R1,#+4369
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
        LDR      R2,[R0, #+32]
        MOVW     R3,#+1092
        TST      R2,R3
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
        LDR      R2,[R0, #+68]
        BIC      R2,R2,#0x8000
        STR      R2,[R0, #+68]
// 1355 
// 1356   /* Disable the Peripheral */
// 1357   __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_OnePulseN_Stop_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 1358 
// 1359   /* Return function status */
// 1360   return HAL_OK;
??HAL_TIMEx_OnePulseN_Stop_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock23
// 1361 }
// 1362 
// 1363 /**
// 1364   * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
// 1365   *         complementary channel.
// 1366   * @param  htim : TIM One Pulse handle
// 1367   * @param  OutputChannel : TIM Channel to be enabled
// 1368   *          This parameter can be one of the following values:
// 1369   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1370   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1371   * @retval HAL status
// 1372   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function HAL_TIMEx_OnePulseN_Start_IT
        THUMB
// 1373 HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
// 1374 {
HAL_TIMEx_OnePulseN_Start_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1375   /* Check the parameters */
// 1376   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
// 1377 
// 1378   /* Enable the TIM Capture/Compare 1 interrupt */
// 1379   __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x2
        STR      R2,[R0, #+12]
// 1380 
// 1381   /* Enable the TIM Capture/Compare 2 interrupt */
// 1382   __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        ORR      R2,R2,#0x4
        STR      R2,[R0, #+12]
// 1383 
// 1384   /* Enable the complementary One Pulse output */
// 1385   TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
        MOVS     R2,#+4
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1386 
// 1387   /* Enable the Main Ouput */
// 1388   __HAL_TIM_MOE_ENABLE(htim);
        LDR      R0,[R4, #+0]
        LDR      R1,[R0, #+68]
        ORR      R1,R1,#0x8000
        STR      R1,[R0, #+68]
// 1389 
// 1390   /* Return function status */
// 1391   return HAL_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock24
// 1392   }
// 1393 
// 1394 /**
// 1395   * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
// 1396   *         complementary channel.
// 1397   * @param  htim : TIM One Pulse handle
// 1398   * @param  OutputChannel : TIM Channel to be disabled
// 1399   *          This parameter can be one of the following values:
// 1400   *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
// 1401   *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
// 1402   * @retval HAL status
// 1403   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function HAL_TIMEx_OnePulseN_Stop_IT
        THUMB
// 1404 HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
// 1405 {
HAL_TIMEx_OnePulseN_Stop_IT:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1406   /* Check the parameters */
// 1407   assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
// 1408 
// 1409   /* Disable the TIM Capture/Compare 1 interrupt */
// 1410   __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x2
        STR      R2,[R0, #+12]
// 1411 
// 1412   /* Disable the TIM Capture/Compare 2 interrupt */
// 1413   __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+12]
        BIC      R2,R2,#0x4
        STR      R2,[R0, #+12]
// 1414 
// 1415   /* Disable the complementary One Pulse output */
// 1416   TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
        MOVS     R2,#+0
        LDR      R0,[R4, #+0]
          CFI FunCall TIM_CCxNChannelCmd
        BL       TIM_CCxNChannelCmd
// 1417 
// 1418   /* Disable the Main Ouput */
// 1419   __HAL_TIM_MOE_DISABLE(htim);
        LDR      R0,[R4, #+0]
        MOVW     R1,#+4369
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
        LDR      R2,[R0, #+32]
        MOVW     R3,#+1092
        TST      R2,R3
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
        LDR      R2,[R0, #+68]
        BIC      R2,R2,#0x8000
        STR      R2,[R0, #+68]
// 1420 
// 1421   /* Disable the Peripheral */
// 1422    __HAL_TIM_DISABLE(htim);
??HAL_TIMEx_OnePulseN_Stop_IT_0:
        LDR      R0,[R4, #+0]
        LDR      R2,[R0, #+32]
        TST      R2,R1
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
        LDR      R1,[R0, #+32]
        MOVW     R2,#+1092
        TST      R1,R2
        BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
        LDR      R1,[R0, #+0]
        LSRS     R1,R1,#+1
        LSLS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 1423 
// 1424   /* Return function status */
// 1425   return HAL_OK;
??HAL_TIMEx_OnePulseN_Stop_IT_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock25
// 1426 }
// 1427 
// 1428 /**
// 1429   * @}
// 1430   */
// 1431 
// 1432 #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
// 1433        /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
// 1434        /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
// 1435 
// 1436 /** @defgroup TIMEx_Exported_Functions_Group5 Peripheral Control functions
// 1437  *  @brief   	Peripheral Control functions
// 1438  *
// 1439 @verbatim
// 1440   ==============================================================================
// 1441                     ##### Peripheral Control functions #####
// 1442   ==============================================================================
// 1443   [..]
// 1444     This section provides functions allowing to:
// 1445     (+) Configure the commutation event in case of use of the Hall sensor interface.
// 1446       (+) Configure Complementary channels, break features and dead time.
// 1447       (+) Configure Master synchronization.
// 1448 
// 1449 @endverbatim
// 1450   * @{
// 1451   */
// 1452 
// 1453 #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \ 
// 1454     defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \ 
// 1455     defined (STM32F105xC) || defined (STM32F107xC)
// 1456 
// 1457 /**
// 1458   * @brief  Configure the TIM commutation event sequence.
// 1459   * @note: this function is mandatory to use the commutation event in order to
// 1460   *        update the configuration at each commutation detection on the TRGI input of the Timer,
// 1461   *        the typical use of this feature is with the use of another Timer(interface Timer)
// 1462   *        configured in Hall sensor interface, this interface Timer will generate the
// 1463   *        commutation at its TRGO output (connected to Timer used in this function) each time
// 1464   *        the TI1 of the Interface Timer detect a commutation at its input TI1.
// 1465   * @param  htim : TIM handle
// 1466   * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
// 1467   *          This parameter can be one of the following values:
// 1468   *            @arg TIM_TS_ITR0: Internal trigger 0 selected
// 1469   *            @arg TIM_TS_ITR1: Internal trigger 1 selected
// 1470   *            @arg TIM_TS_ITR2: Internal trigger 2 selected
// 1471   *            @arg TIM_TS_ITR3: Internal trigger 3 selected
// 1472   *            @arg TIM_TS_NONE: No trigger is needed
// 1473   * @param  CommutationSource : the Commutation Event source
// 1474   *          This parameter can be one of the following values:
// 1475   *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
// 1476   *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
// 1477   * @retval HAL status
// 1478   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function HAL_TIMEx_ConfigCommutationEvent
          CFI NoCalls
        THUMB
// 1479 HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
// 1480 {
HAL_TIMEx_ConfigCommutationEvent:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
// 1481   /* Check the parameters */
// 1482   assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
// 1483   assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
// 1484 
// 1485   __HAL_LOCK(htim);
        LDRSB    R3,[R0, #+56]
        CMP      R3,#+1
        BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_0
        MOVS     R0,#+2
        B.N      ??HAL_TIMEx_ConfigCommutationEvent_1
??HAL_TIMEx_ConfigCommutationEvent_0:
        MOVS     R3,#+1
        STRB     R3,[R0, #+56]
// 1486 
// 1487   if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
// 1488       (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
        CMP      R1,#+0
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
        CMP      R1,#+16
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
        CMP      R1,#+32
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
        CMP      R1,#+48
        BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_3
// 1489   {
// 1490     /* Select the Input trigger */
// 1491     htim->Instance->SMCR &= ~TIM_SMCR_TS;
??HAL_TIMEx_ConfigCommutationEvent_2:
        LDR      R3,[R0, #+0]
        LDR      R4,[R3, #+8]
        BIC      R4,R4,#0x70
        STR      R4,[R3, #+8]
// 1492     htim->Instance->SMCR |= InputTrigger;
        LDR      R3,[R0, #+0]
        LDR      R4,[R3, #+8]
        ORRS     R1,R1,R4
        STR      R1,[R3, #+8]
// 1493   }
// 1494 
// 1495   /* Select the Capture Compare preload feature */
// 1496   htim->Instance->CR2 |= TIM_CR2_CCPC;
??HAL_TIMEx_ConfigCommutationEvent_3:
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        ORR      R3,R3,#0x1
        STR      R3,[R1, #+4]
// 1497   /* Select the Commutation event source */
// 1498   htim->Instance->CR2 &= ~TIM_CR2_CCUS;
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        BIC      R3,R3,#0x4
        STR      R3,[R1, #+4]
// 1499   htim->Instance->CR2 |= CommutationSource;
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        ORRS     R2,R2,R3
        STR      R2,[R1, #+4]
// 1500 
// 1501   __HAL_UNLOCK(htim);
        MOVS     R1,#+0
        STRB     R1,[R0, #+56]
// 1502 
// 1503   return HAL_OK;
        MOV      R0,R1
??HAL_TIMEx_ConfigCommutationEvent_1:
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock26
// 1504 }
// 1505 
// 1506 /**
// 1507   * @brief  Configure the TIM commutation event sequence with interrupt.
// 1508   * @note: this function is mandatory to use the commutation event in order to
// 1509   *        update the configuration at each commutation detection on the TRGI input of the Timer,
// 1510   *        the typical use of this feature is with the use of another Timer(interface Timer)
// 1511   *        configured in Hall sensor interface, this interface Timer will generate the
// 1512   *        commutation at its TRGO output (connected to Timer used in this function) each time
// 1513   *        the TI1 of the Interface Timer detect a commutation at its input TI1.
// 1514   * @param  htim : TIM handle
// 1515   * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
// 1516   *          This parameter can be one of the following values:
// 1517   *            @arg TIM_TS_ITR0: Internal trigger 0 selected
// 1518   *            @arg TIM_TS_ITR1: Internal trigger 1 selected
// 1519   *            @arg TIM_TS_ITR2: Internal trigger 2 selected
// 1520   *            @arg TIM_TS_ITR3: Internal trigger 3 selected
// 1521   *            @arg TIM_TS_NONE: No trigger is needed
// 1522   * @param  CommutationSource : the Commutation Event source
// 1523   *          This parameter can be one of the following values:
// 1524   *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
// 1525   *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
// 1526   * @retval HAL status
// 1527   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function HAL_TIMEx_ConfigCommutationEvent_IT
          CFI NoCalls
        THUMB
// 1528 HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
// 1529 {
HAL_TIMEx_ConfigCommutationEvent_IT:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
// 1530   /* Check the parameters */
// 1531   assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
// 1532   assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
// 1533 
// 1534   __HAL_LOCK(htim);
        LDRSB    R3,[R0, #+56]
        CMP      R3,#+1
        BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
        MOVS     R0,#+2
        B.N      ??HAL_TIMEx_ConfigCommutationEvent_IT_1
??HAL_TIMEx_ConfigCommutationEvent_IT_0:
        MOVS     R3,#+1
        STRB     R3,[R0, #+56]
// 1535 
// 1536   if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
// 1537       (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
        CMP      R1,#+0
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
        CMP      R1,#+16
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
        CMP      R1,#+32
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
        CMP      R1,#+48
        BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_3
// 1538   {
// 1539     /* Select the Input trigger */
// 1540     htim->Instance->SMCR &= ~TIM_SMCR_TS;
??HAL_TIMEx_ConfigCommutationEvent_IT_2:
        LDR      R3,[R0, #+0]
        LDR      R4,[R3, #+8]
        BIC      R4,R4,#0x70
        STR      R4,[R3, #+8]
// 1541     htim->Instance->SMCR |= InputTrigger;
        LDR      R3,[R0, #+0]
        LDR      R4,[R3, #+8]
        ORRS     R1,R1,R4
        STR      R1,[R3, #+8]
// 1542   }
// 1543 
// 1544   /* Select the Capture Compare preload feature */
// 1545   htim->Instance->CR2 |= TIM_CR2_CCPC;
??HAL_TIMEx_ConfigCommutationEvent_IT_3:
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        ORR      R3,R3,#0x1
        STR      R3,[R1, #+4]
// 1546   /* Select the Commutation event source */
// 1547   htim->Instance->CR2 &= ~TIM_CR2_CCUS;
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        BIC      R3,R3,#0x4
        STR      R3,[R1, #+4]
// 1548   htim->Instance->CR2 |= CommutationSource;
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        ORRS     R2,R2,R3
        STR      R2,[R1, #+4]
// 1549 
// 1550   /* Enable the Commutation Interrupt Request */
// 1551   __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
        LDR      R1,[R0, #+0]
        LDR      R2,[R1, #+12]
        ORR      R2,R2,#0x20
        STR      R2,[R1, #+12]
// 1552 
// 1553   __HAL_UNLOCK(htim);
        MOVS     R1,#+0
        STRB     R1,[R0, #+56]
// 1554 
// 1555   return HAL_OK;
        MOV      R0,R1
??HAL_TIMEx_ConfigCommutationEvent_IT_1:
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock27
// 1556 }
// 1557 
// 1558 /**
// 1559   * @brief  Configure the TIM commutation event sequence with DMA.
// 1560   * @note: this function is mandatory to use the commutation event in order to
// 1561   *        update the configuration at each commutation detection on the TRGI input of the Timer,
// 1562   *        the typical use of this feature is with the use of another Timer(interface Timer)
// 1563   *        configured in Hall sensor interface, this interface Timer will generate the
// 1564   *        commutation at its TRGO output (connected to Timer used in this function) each time
// 1565   *        the TI1 of the Interface Timer detect a commutation at its input TI1.
// 1566   * @note: The user should configure the DMA in his own software, in This function only the COMDE bit is set
// 1567   * @param  htim : TIM handle
// 1568   * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
// 1569   *          This parameter can be one of the following values:
// 1570   *            @arg TIM_TS_ITR0: Internal trigger 0 selected
// 1571   *            @arg TIM_TS_ITR1: Internal trigger 1 selected
// 1572   *            @arg TIM_TS_ITR2: Internal trigger 2 selected
// 1573   *            @arg TIM_TS_ITR3: Internal trigger 3 selected
// 1574   *            @arg TIM_TS_NONE: No trigger is needed
// 1575   * @param  CommutationSource : the Commutation Event source
// 1576   *          This parameter can be one of the following values:
// 1577   *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
// 1578   *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
// 1579   * @retval HAL status
// 1580   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function HAL_TIMEx_ConfigCommutationEvent_DMA
          CFI NoCalls
        THUMB
// 1581 HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
// 1582 {
HAL_TIMEx_ConfigCommutationEvent_DMA:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
// 1583   /* Check the parameters */
// 1584   assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
// 1585   assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
// 1586 
// 1587   __HAL_LOCK(htim);
        LDRSB    R3,[R0, #+56]
        CMP      R3,#+1
        BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
        MOVS     R0,#+2
        B.N      ??HAL_TIMEx_ConfigCommutationEvent_DMA_1
??HAL_TIMEx_ConfigCommutationEvent_DMA_0:
        MOVS     R3,#+1
        STRB     R3,[R0, #+56]
// 1588 
// 1589   if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
// 1590       (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
        CMP      R1,#+0
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
        CMP      R1,#+16
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
        CMP      R1,#+32
        BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
        CMP      R1,#+48
        BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_3
// 1591   {
// 1592     /* Select the Input trigger */
// 1593     htim->Instance->SMCR &= ~TIM_SMCR_TS;
??HAL_TIMEx_ConfigCommutationEvent_DMA_2:
        LDR      R3,[R0, #+0]
        LDR      R4,[R3, #+8]
        BIC      R4,R4,#0x70
        STR      R4,[R3, #+8]
// 1594     htim->Instance->SMCR |= InputTrigger;
        LDR      R3,[R0, #+0]
        LDR      R4,[R3, #+8]
        ORRS     R1,R1,R4
        STR      R1,[R3, #+8]
// 1595   }
// 1596 
// 1597   /* Select the Capture Compare preload feature */
// 1598   htim->Instance->CR2 |= TIM_CR2_CCPC;
??HAL_TIMEx_ConfigCommutationEvent_DMA_3:
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        ORR      R3,R3,#0x1
        STR      R3,[R1, #+4]
// 1599   /* Select the Commutation event source */
// 1600   htim->Instance->CR2 &= ~TIM_CR2_CCUS;
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        BIC      R3,R3,#0x4
        STR      R3,[R1, #+4]
// 1601   htim->Instance->CR2 |= CommutationSource;
        LDR      R1,[R0, #+0]
        LDR      R3,[R1, #+4]
        ORRS     R2,R2,R3
        STR      R2,[R1, #+4]
// 1602 
// 1603   /* Enable the Commutation DMA Request */
// 1604   /* Set the DMA Commutation Callback */
// 1605   htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
        ADR.W    R1,TIMEx_DMACommutationCplt
        LDR      R2,[R0, #+48]
        STR      R1,[R2, #+40]
// 1606   /* Set the DMA error callback */
// 1607   htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
        LDR.N    R1,??DataTable3_1
        LDR      R2,[R0, #+48]
        STR      R1,[R2, #+48]
// 1608 
// 1609   /* Enable the Commutation DMA Request */
// 1610   __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
        LDR      R1,[R0, #+0]
        LDR      R2,[R1, #+12]
        ORR      R2,R2,#0x2000
        STR      R2,[R1, #+12]
// 1611 
// 1612   __HAL_UNLOCK(htim);
        MOVS     R1,#+0
        STRB     R1,[R0, #+56]
// 1613 
// 1614   return HAL_OK;
        MOV      R0,R1
??HAL_TIMEx_ConfigCommutationEvent_DMA_1:
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock28
// 1615 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3:
        DC32     TIM_DMACaptureCplt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_1:
        DC32     TIM_DMAError

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable3_2:
        DC32     TIM_DMADelayPulseCplt
// 1616 
// 1617 /**
// 1618   * @brief   Configures the Break feature, dead time, Lock level, OSSI/OSSR State
// 1619   *          and the AOE(automatic output enable).
// 1620   * @param  htim : TIM handle
// 1621   * @param  sBreakDeadTimeConfig : pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
// 1622   *         contains the BDTR Register configuration  information for the TIM peripheral.
// 1623   * @retval HAL status
// 1624   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function HAL_TIMEx_ConfigBreakDeadTime
          CFI NoCalls
        THUMB
// 1625 HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
// 1626                                                 TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
// 1627 {
// 1628   /* Check the parameters */
// 1629   assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
// 1630   assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
// 1631   assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
// 1632   assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
// 1633   assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
// 1634   assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
// 1635   assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
// 1636   assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
// 1637 
// 1638   /* Process Locked */
// 1639   __HAL_LOCK(htim);
HAL_TIMEx_ConfigBreakDeadTime:
        LDRSB    R2,[R0, #+56]
        CMP      R2,#+1
        BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_0
        MOVS     R0,#+2
        BX       LR
??HAL_TIMEx_ConfigBreakDeadTime_0:
        MOVS     R2,#+1
        STRB     R2,[R0, #+56]
// 1640 
// 1641   htim->State = HAL_TIM_STATE_BUSY;
        MOVS     R2,#+2
        STRB     R2,[R0, #+57]
// 1642 
// 1643   /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
// 1644      the OSSI State, the dead time value and the Automatic Output Enable Bit */
// 1645   htim->Instance->BDTR = (uint32_t)sBreakDeadTimeConfig->OffStateRunMode  |
// 1646                                    sBreakDeadTimeConfig->OffStateIDLEMode |
// 1647                                    sBreakDeadTimeConfig->LockLevel        |
// 1648                                    sBreakDeadTimeConfig->DeadTime         |
// 1649                                    sBreakDeadTimeConfig->BreakState       |
// 1650                                    sBreakDeadTimeConfig->BreakPolarity    |
// 1651                                    sBreakDeadTimeConfig->AutomaticOutput;
        LDR      R2,[R1, #+0]
        LDR      R3,[R1, #+4]
        ORRS     R2,R3,R2
        LDR      R3,[R1, #+8]
        ORRS     R2,R3,R2
        LDR      R3,[R1, #+12]
        ORRS     R2,R3,R2
        LDR      R3,[R1, #+16]
        ORRS     R2,R3,R2
        LDR      R3,[R1, #+20]
        ORRS     R2,R3,R2
        LDR      R1,[R1, #+24]
        ORRS     R1,R1,R2
        LDR      R2,[R0, #+0]
        STR      R1,[R2, #+68]
// 1652 
// 1653 
// 1654   htim->State = HAL_TIM_STATE_READY;
        MOVS     R1,#+1
        STRB     R1,[R0, #+57]
// 1655 
// 1656   __HAL_UNLOCK(htim);
        MOVS     R1,#+0
        STRB     R1,[R0, #+56]
// 1657 
// 1658   return HAL_OK;
        MOV      R0,R1
        BX       LR               ;; return
          CFI EndBlock cfiBlock29
// 1659 }
// 1660 
// 1661 #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
// 1662        /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
// 1663        /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
// 1664 
// 1665 /**
// 1666   * @brief  Configures the TIM in master mode.
// 1667   * @param  htim : TIM handle.
// 1668   * @param  sMasterConfig : pointer to a TIM_MasterConfigTypeDef structure that
// 1669   *         contains the selected trigger output (TRGO) and the Master/Slave
// 1670   *         mode.
// 1671   * @retval HAL status
// 1672   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function HAL_TIMEx_MasterConfigSynchronization
          CFI NoCalls
        THUMB
// 1673 HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
// 1674 {
HAL_TIMEx_MasterConfigSynchronization:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
// 1675   /* Check the parameters */
// 1676   assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
// 1677   assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
// 1678   assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
// 1679 
// 1680   __HAL_LOCK(htim);
        LDRSB    R2,[R0, #+56]
        CMP      R2,#+1
        BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_0
        MOVS     R0,#+2
        B.N      ??HAL_TIMEx_MasterConfigSynchronization_1
??HAL_TIMEx_MasterConfigSynchronization_0:
        MOVS     R2,#+1
        STRB     R2,[R0, #+56]
// 1681 
// 1682   htim->State = HAL_TIM_STATE_BUSY;
        MOVS     R2,#+2
        STRB     R2,[R0, #+57]
// 1683 
// 1684   /* Reset the MMS Bits */
// 1685   htim->Instance->CR2 &= ~TIM_CR2_MMS;
        LDR      R2,[R0, #+0]
        LDR      R3,[R2, #+4]
        BIC      R3,R3,#0x70
        STR      R3,[R2, #+4]
// 1686   /* Select the TRGO source */
// 1687   htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
        LDR      R2,[R0, #+0]
        LDR      R3,[R2, #+4]
        LDR      R4,[R1, #+0]
        ORRS     R3,R4,R3
        STR      R3,[R2, #+4]
// 1688 
// 1689   /* Reset the MSM Bit */
// 1690   htim->Instance->SMCR &= ~TIM_SMCR_MSM;
        LDR      R2,[R0, #+0]
        LDR      R3,[R2, #+8]
        BIC      R3,R3,#0x80
        STR      R3,[R2, #+8]
// 1691   /* Set or Reset the MSM Bit */
// 1692   htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
        LDR      R2,[R0, #+0]
        LDR      R3,[R2, #+8]
        LDR      R1,[R1, #+4]
        ORRS     R1,R1,R3
        STR      R1,[R2, #+8]
// 1693 
// 1694   htim->State = HAL_TIM_STATE_READY;
        MOVS     R1,#+1
        STRB     R1,[R0, #+57]
// 1695 
// 1696   __HAL_UNLOCK(htim);
        MOVS     R1,#+0
        STRB     R1,[R0, #+56]
// 1697 
// 1698   return HAL_OK;
        MOV      R0,R1
??HAL_TIMEx_MasterConfigSynchronization_1:
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock30
// 1699 }
// 1700 
// 1701 /**
// 1702   * @}
// 1703   */
// 1704 
// 1705 /** @defgroup TIMEx_Exported_Functions_Group6 Extension Callbacks functions
// 1706  *  @brief   Extension Callbacks functions
// 1707  *
// 1708 @verbatim
// 1709   ==============================================================================
// 1710                     ##### Extension Callbacks functions #####
// 1711   ==============================================================================
// 1712   [..]
// 1713     This section provides Extension TIM callback functions:
// 1714     (+) Timer Commutation callback
// 1715     (+) Timer Break callback
// 1716 
// 1717 @endverbatim
// 1718   * @{
// 1719   */
// 1720 
// 1721 /**
// 1722   * @brief  Hall commutation changed callback in non blocking mode
// 1723   * @param  htim : TIM handle
// 1724   * @retval None
// 1725   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function HAL_TIMEx_CommutationCallback
          CFI NoCalls
        THUMB
// 1726 __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
// 1727 {
// 1728   /* Prevent unused argument(s) compilation warning */
// 1729   UNUSED(htim);
// 1730   /* NOTE : This function Should not be modified, when the callback is needed,
// 1731             the HAL_TIMEx_CommutationCallback could be implemented in the user file
// 1732    */
// 1733 }
HAL_TIMEx_CommutationCallback:
        BX       LR               ;; return
          CFI EndBlock cfiBlock31
// 1734 
// 1735 /**
// 1736   * @brief  Hall Break detection callback in non blocking mode
// 1737   * @param  htim : TIM handle
// 1738   * @retval None
// 1739   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function HAL_TIMEx_BreakCallback
          CFI NoCalls
        THUMB
// 1740 __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
// 1741 {
// 1742   /* Prevent unused argument(s) compilation warning */
// 1743   UNUSED(htim);
// 1744   /* NOTE : This function Should not be modified, when the callback is needed,
// 1745             the HAL_TIMEx_BreakCallback could be implemented in the user file
// 1746    */
// 1747 }
HAL_TIMEx_BreakCallback:
        BX       LR               ;; return
          CFI EndBlock cfiBlock32
// 1748 
// 1749 /**
// 1750   * @brief  TIM DMA Commutation callback.
// 1751   * @param  hdma : pointer to DMA handle.
// 1752   * @retval None
// 1753   */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function TIMEx_DMACommutationCplt
        THUMB
// 1754 void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
// 1755 {
TIMEx_DMACommutationCplt:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1756   TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
        LDR      R0,[R0, #+36]
// 1757 
// 1758   htim->State= HAL_TIM_STATE_READY;
        MOVS     R1,#+1
        STRB     R1,[R0, #+57]
// 1759 
// 1760   HAL_TIMEx_CommutationCallback(htim);
          CFI FunCall HAL_TIMEx_CommutationCallback
        BL       HAL_TIMEx_CommutationCallback
// 1761 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock33
// 1762 
// 1763 /**
// 1764   * @}
// 1765   */
// 1766 
// 1767 #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \ 
// 1768     defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \ 
// 1769     defined (STM32F105xC) || defined (STM32F107xC)
// 1770 
// 1771 /** @defgroup TIMEx_Exported_Functions_Group7 Extension Peripheral State functions
// 1772  *  @brief   Extension Peripheral State functions
// 1773  *
// 1774 @verbatim
// 1775   ==============================================================================
// 1776                 ##### Extension Peripheral State functions #####
// 1777   ==============================================================================
// 1778   [..]
// 1779     This subsection permit to get in run-time the status of the peripheral
// 1780     and the data flow.
// 1781 
// 1782 @endverbatim
// 1783   * @{
// 1784   */
// 1785 
// 1786 /**
// 1787   * @brief  Return the TIM Hall Sensor interface state
// 1788   * @param  htim : TIM Hall Sensor handle
// 1789   * @retval HAL state
// 1790   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function HAL_TIMEx_HallSensor_GetState
          CFI NoCalls
        THUMB
// 1791 HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
// 1792 {
// 1793   return htim->State;
HAL_TIMEx_HallSensor_GetState:
        LDRSB    R0,[R0, #+57]
        BX       LR               ;; return
          CFI EndBlock cfiBlock34
// 1794 }
// 1795 
// 1796 /**
// 1797   * @}
// 1798   */
// 1799 #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
// 1800        /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
// 1801        /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
// 1802 
// 1803 /**
// 1804   * @}
// 1805   */
// 1806 
// 1807 #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \ 
// 1808     defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \ 
// 1809     defined (STM32F105xC) || defined (STM32F107xC)
// 1810 
// 1811 /** @addtogroup TIMEx_Private_Functions
// 1812   * @{
// 1813   */
// 1814 
// 1815 /**
// 1816   * @brief  Enables or disables the TIM Capture Compare Channel xN.
// 1817   * @param  TIMx  to select the TIM peripheral
// 1818   * @param  Channel : specifies the TIM Channel
// 1819   *          This parameter can be one of the following values:
// 1820   *            @arg TIM_Channel_1: TIM Channel 1
// 1821   *            @arg TIM_Channel_2: TIM Channel 2
// 1822   *            @arg TIM_Channel_3: TIM Channel 3
// 1823   * @param  ChannelNState : specifies the TIM Channel CCxNE bit new state.
// 1824   *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
// 1825   * @retval None
// 1826   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function TIM_CCxNChannelCmd
          CFI NoCalls
        THUMB
// 1827 static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
// 1828 {
TIM_CCxNChannelCmd:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
// 1829   uint32_t tmp = 0;
// 1830 
// 1831   tmp = TIM_CCER_CC1NE << Channel;
// 1832 
// 1833   /* Reset the CCxNE Bit */
// 1834   TIMx->CCER &=  ~tmp;
        LDR      R3,[R0, #+32]
        MOVS     R4,#+4
        LSLS     R4,R4,R1
        BICS     R3,R3,R4
        STR      R3,[R0, #+32]
// 1835 
// 1836   /* Set or reset the CCxNE Bit */
// 1837   TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
        LDR      R3,[R0, #+32]
        LSL      R1,R2,R1
        ORRS     R1,R1,R3
        STR      R1,[R0, #+32]
// 1838 }
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock35

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 1839 
// 1840 /**
// 1841   * @}
// 1842   */
// 1843 
// 1844 #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
// 1845        /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
// 1846        /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
// 1847 
// 1848 #endif /* HAL_TIM_MODULE_ENABLED */
// 1849 /**
// 1850   * @}
// 1851   */
// 1852 
// 1853 /**
// 1854   * @}
// 1855   */
// 1856 
// 1857 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
// 2 880 bytes in section .text
// 
// 2 880 bytes of CODE memory
//
//Errors: none
//Warnings: none
